#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."

namespace SDKGenerator
{

    public partial class nsxt_policyClient 
    {
        private string _baseUrl = "https://nsxmanager.your.domain/policy/api/v1";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;
    
        public nsxt_policyClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient; 
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(() => 
            {
                var settings = new Newtonsoft.Json.JsonSerializerSettings();
                UpdateJsonSerializerSettings(settings);
                return settings;
            });
        }
    
        public string BaseUrl 
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }
    
        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }
    
        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);
    
        /// <summary>Resolves the error</summary>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ErrorAsync(ErrorResolverMetadataList errorResolverMetadataList)
        {
            return ErrorAsync(errorResolverMetadataList, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Resolves the error</summary>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task ErrorAsync(ErrorResolverMetadataList errorResolverMetadataList, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/error-resolver?action=resolve_error");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(errorResolverMetadataList, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "404") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ApiError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<ApiError>("Not Found", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ApiError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<ApiError>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "412") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ApiError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<ApiError>("Precondition Failed", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ApiError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<ApiError>("Bad Request", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ApiError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<ApiError>("Service Unavailable", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ApiError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<ApiError>("Internal Server Error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }
    
            public T Object { get; }
    
            public string Text { get; }
        }
    
        public bool ReadResponseAsString { get; set; }
        
        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }
        
            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }
    
        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool) {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }
        
            return System.Convert.ToString(value, cultureInfo);
        }
    }

    /// <summary>Abstract base type for Weekly or Interval Backup Schedule</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("IntervalBackupSchedule", typeof(IntervalBackupSchedule))]
    [JsonInheritanceAttribute("WeeklyBackupSchedule", typeof(WeeklyBackupSchedule))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BackupSchedule 
    {
    
    }
    
    /// <summary>IPFIX L2 data will be collected on collectors.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPFIXL2CollectorProfile : PolicyConfigResource
    {
        /// <summary>It accepts Multiple Collector objects.</summary>
        [Newtonsoft.Json.JsonProperty("ipfix_l2_collectors", Required = Newtonsoft.Json.Required.AllowNull)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(4)]
        public System.Collections.Generic.ICollection<IPFIXL2Collector> Ipfix_l2_collectors { get; set; } = new System.Collections.ObjectModel.Collection<IPFIXL2Collector>();
    
    
    }
    
    /// <summary>Root of the api result set for forming rows.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RowListField 
    {
        /// <summary>Short name or alias of row list field, if any. If unspecified, the row list field can be referenced by its index in the array of row list fields as $&lt;index&gt; (for example, $0).</summary>
        [Newtonsoft.Json.JsonProperty("alias", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string Alias { get; set; }
    
        /// <summary>JSON path to the root of the api result set for forming rows.</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Path { get; set; }
    
    
    }
    
    /// <summary>Policy resource reference.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyResourceReference : ResourceReference
    {
        /// <summary>Absolute path of this object.</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
    
    }
    
    /// <summary>The passive type of LBMonitorProfile.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBPassiveMonitorProfile : LBMonitorProfile
    {
        /// <summary>When the consecutive failures reach this value, then the member is
        /// considered temporarily unavailable for a configurable period
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_fails", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long? Max_fails { get; set; } = 5L;
    
        /// <summary>After this timeout period, the member is tried again for a new
        /// connection to see if it is available.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long? Timeout { get; set; } = 5L;
    
    
    }
    
    /// <summary>Results from probing all LDAP servers in an LDAP identity source configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LdapIdentitySourceProbeResults : Resource
    {
        /// <summary>Probe results for all probed LDAP servers.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IdentitySourceLdapServerProbeResult> Results { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for PolicyMulticastConfig used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyMulticastConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains actual PolicyMulticastConfig.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyMulticastConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyMulticastConfig PolicyMulticastConfig { get; set; }
    
    
    }
    
    /// <summary>Active healthchecks are disabled by default and can be enabled for a
    /// server pool by binding a health monitor to the Group through the PolicyLbRule
    /// object. This represents active health monitoring over HTTP.
    /// Active healthchecks are initiated periodically, at a configurable
    /// interval, to each member of the Group. Only if a healthcheck fails
    /// consecutively for a specified number of times (fall_count) to a member will
    /// the member status be marked DOWN. Once a member is DOWN, a specified
    /// number of consecutive successful healthchecks (rise_count) will bring the
    /// member back to UP state. After a healthcheck is initiated, if it does not
    /// complete within a certain period, then also the healthcheck is considered
    /// to be unsuccessful.
    /// Completing a healthcheck within timeout means establishing a connection
    /// (TCP or SSL), if applicable, sending the request and receiving the
    /// response, all within the configured timeout.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class HttpPolicyLbMonitorProfile : PolicyLbMonitorProfile
    {
        /// <summary>For HTTP active healthchecks, the HTTP request url sent can be
        /// customized and can include query parameters.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; } = "/";
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyBgpNeighborStatus 
    {
        /// <summary>Current state of the BGP session.</summary>
        [Newtonsoft.Json.JsonProperty("connection_state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyBgpNeighborStatusConnection_state? Connection_state { get; set; }
    
        /// <summary>Count of messages received from the neighbor</summary>
        [Newtonsoft.Json.JsonProperty("messages_received", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Messages_received { get; set; }
    
        /// <summary>Time in ms to wait for HELLO packet from BGP peer</summary>
        [Newtonsoft.Json.JsonProperty("keep_alive_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Keep_alive_interval { get; set; }
    
        /// <summary>Policy path to Tier0</summary>
        [Newtonsoft.Json.JsonProperty("tier0_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tier0_path { get; set; }
    
        /// <summary>Router ID of the BGP neighbor.</summary>
        [Newtonsoft.Json.JsonProperty("neighbor_router_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Neighbor_router_id { get; set; }
    
        /// <summary>Sum of out prefixes counts across all address families.</summary>
        [Newtonsoft.Json.JsonProperty("total_out_prefix_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total_out_prefix_count { get; set; }
    
        /// <summary>AS number of the BGP neighbor</summary>
        [Newtonsoft.Json.JsonProperty("remote_as_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Remote_as_number { get; set; }
    
        /// <summary>Count of messages sent to the neighbor</summary>
        [Newtonsoft.Json.JsonProperty("messages_sent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Messages_sent { get; set; }
    
        /// <summary>Time(in seconds) since connection was established.</summary>
        [Newtonsoft.Json.JsonProperty("time_since_established", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Time_since_established { get; set; }
    
        /// <summary>If a HELLO packet is not seen from BGP Peer withing hold_time
        /// then BGP neighbor will be marked as down.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hold_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Hold_time { get; set; }
    
        /// <summary>Count of connections established</summary>
        [Newtonsoft.Json.JsonProperty("established_connection_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Established_connection_count { get; set; }
    
        /// <summary>Current state of graceful restart of BGP neighbor. Possible
        /// values are -
        /// 1. GR_AND_HELPER - Graceful restart with Helper
        /// 2. HELPER_ONLY - Helper only
        /// 3. DISABLE - Disabled
        /// </summary>
        [Newtonsoft.Json.JsonProperty("graceful_restart_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Graceful_restart_mode { get; set; }
    
        /// <summary>Count of connection drop</summary>
        [Newtonsoft.Json.JsonProperty("connection_drop_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Connection_drop_count { get; set; }
    
        /// <summary>TCP port number of remote BGP Connection</summary>
        [Newtonsoft.Json.JsonProperty("remote_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long? Remote_port { get; set; }
    
        /// <summary>Timestamp when the data was last updated, unset if data source has never updated the data.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>The Ip address of logical port</summary>
        [Newtonsoft.Json.JsonProperty("source_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source_address { get; set; }
    
        /// <summary>Sum of in prefixes counts across all address families.</summary>
        [Newtonsoft.Json.JsonProperty("total_in_prefix_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total_in_prefix_count { get; set; }
    
        /// <summary>Remote site details.</summary>
        [Newtonsoft.Json.JsonProperty("remote_site", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceReference Remote_site { get; set; }
    
        /// <summary>Transport node policy path</summary>
        [Newtonsoft.Json.JsonProperty("edge_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Edge_path { get; set; }
    
        /// <summary>TCP port number of Local BGP connection</summary>
        [Newtonsoft.Json.JsonProperty("local_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long? Local_port { get; set; }
    
        /// <summary>BGP capabilities sent to BGP neighbor.</summary>
        [Newtonsoft.Json.JsonProperty("announced_capabilities", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Announced_capabilities { get; set; }
    
        /// <summary>BGP capabilities negotiated with BGP neighbor.</summary>
        [Newtonsoft.Json.JsonProperty("negotiated_capability", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Negotiated_capability { get; set; }
    
        /// <summary>Address families of BGP neighbor</summary>
        [Newtonsoft.Json.JsonProperty("address_families", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<BgpAddressFamily> Address_families { get; set; }
    
        /// <summary>BGP neighbor type</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyBgpNeighborStatusType? Type { get; set; }
    
        /// <summary>The IP of the BGP neighbor</summary>
        [Newtonsoft.Json.JsonProperty("neighbor_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Neighbor_address { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SIDataCounter 
    {
        /// <summary>The total packets or bytes</summary>
        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Always)]
        public long Total { get; set; }
    
        /// <summary>The multicast and broadcast packets or bytes</summary>
        [Newtonsoft.Json.JsonProperty("multicast_broadcast", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Multicast_broadcast { get; set; }
    
        /// <summary>The dropped packets or bytes</summary>
        [Newtonsoft.Json.JsonProperty("dropped", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dropped { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer WafPolicyPSMGroup object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWafPolicyPSMGroup : PolicyConfigResource
    {
        /// <summary>Enable or disable this WAF rule group.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable { get; set; } = true;
    
        /// <summary>This field indicates that this group is used for learning.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_learning_group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_learning_group { get; set; } = false;
    
        /// <summary>Positive Security Model locations.
        /// These are used to partition the application name space.
        /// Maximum of 16384 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("locations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBWafPSMLocation> Locations { get; set; }
    
        /// <summary>If a rule in this group does not match the match_value
        /// pattern, this action will be executed.
        /// Allowed actions are WAF_ACTION_NO_OP and WAF_ACTION_BLOCK.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as WAF_ACTION_NO_OP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("miss_action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBWafPolicyPSMGroupMiss_action? Miss_action { get; set; } = SDKGenerator.ALBWafPolicyPSMGroupMiss_action.WAF_ACTION_NO_OP;
    
        /// <summary>If a rule in this group matches the match_value pattern,
        /// this action will be executed.
        /// Allowed actions are WAF_ACTION_NO_OP and
        /// WAF_ACTION_ALLOW_PARAMETER.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as WAF_ACTION_ALLOW_PARAMETER.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hit_action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBWafPolicyPSMGroupHit_action? Hit_action { get; set; } = SDKGenerator.ALBWafPolicyPSMGroupHit_action.WAF_ACTION_ALLOW_PARAMETER;
    
    
    }
    
    /// <summary>WafPolicyApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWafPolicyApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of WafPolicy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBWafPolicy> Results { get; set; }
    
    
    }
    
    /// <summary>Paged collection of Firewall Flood Protection Profile Binding Maps</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyFirewallFloodProtectionProfileBindingMapListResult : ListResult
    {
        /// <summary>Firewall Flood Protection Profile Binding Map list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyFirewallFloodProtectionProfileBindingMap> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyFirewallFloodProtectionProfileBindingMap>();
    
    
    }
    
    /// <summary>Virtual Hybrid Cloud is a construct that provides network isolation for all
    /// its contents out of the box. It can be considered to be an equivalent of a
    /// tenant in the networking world, where the compute and networking elements
    /// within are isolated from other VHCs. The VHC will also be used to provide
    /// hybridity across on-prem datacenters and the cloud, thus providing a means
    /// of building private clouds with elements both on-prem and in the cloud.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Vhc : PolicyConfigResource
    {
        /// <summary>Information related to sites applicable for given VHC.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("site_infos", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(4)]
        public System.Collections.Generic.ICollection<SiteInfo> Site_infos { get; set; } = new System.Collections.ObjectModel.Collection<SiteInfo>();
    
        /// <summary>This is set of IP addresses that will be used for Public Application tiers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("public_ip_addresses", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Public_ip_addresses { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>This is set of IP addresses that will be used for Shared and Private Application tiers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("private_ip_addresses", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Private_ip_addresses { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Type of Services to be made available for the applications defined under VHC.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("capabilities", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Capabilities> Capabilities { get; set; }
    
        /// <summary>The tier 0 has to be pre-created before VHC is created. The tier 0 typically provides connectivity to external world.
        /// List of sites for VHC has to be subset of sites where the tier 0 spans.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tier_0s", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Tier_0s { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>Enforcement point is the endpoint where policy configurations are applied.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EnforcementPoint : PolicyConfigResource
    {
        /// <summary>Connection Info of the Enforcement Point.</summary>
        [Newtonsoft.Json.JsonProperty("connection_info", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public EnforcementPointConnectionInfo Connection_info { get; set; } = new EnforcementPointConnectionInfo();
    
        /// <summary>Version of the Enforcement point.</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }
    
        /// <summary>Auto enforce flag suggests whether the policy objects shall be automatically
        /// enforced on this enforcement point or not. When this flag is set to true,
        /// all policy objects will be automatically enforced on this enforcement
        /// point. If this flag is set to false, user shall rely on the usual means
        /// of realization, i.e., deployment maps.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("auto_enforce", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Auto_enforce { get; set; } = true;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GatewayGeneralSecurityProfile : GeneralSecurityProfile
    {
        /// <summary>The flag to indicate double flow check is enabled or not. This option applies only to EDGE components.</summary>
        [Newtonsoft.Json.JsonProperty("enable_double_flow", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_double_flow { get; set; } = false;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TunnelInterfaceIPSubnet 
    {
        /// <summary>IPv4 Addresses</summary>
        [Newtonsoft.Json.JsonProperty("ip_addresses", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Ip_addresses { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Subnet Prefix Length</summary>
        [Newtonsoft.Json.JsonProperty("prefix_length", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1D, 31D)]
        public long Prefix_length { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of L2BridgeEndpointProfile</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2BridgeEndpointProfileListResult : ListResult
    {
        /// <summary>L2BridgeEndpointProfile list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<L2BridgeEndpointProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<L2BridgeEndpointProfile>();
    
    
    }
    
    /// <summary>Wrapper object for PolicySIExcludeList</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicySIExcludeList : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual policy exclude list object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicySIExcludeList", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicySIExcludeList PolicySIExcludeList { get; set; }
    
    
    }
    
    /// <summary>Defining access of a Group from a LBVirtualServer and binding to
    /// LBMonitorProfile.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBPool : PolicyConfigResource
    {
        /// <summary>In case of active healthchecks, load balancer itself initiates new
        /// connections (or sends ICMP ping) to the servers periodically to check
        /// their health, completely independent of any data traffic. Active
        /// healthchecks are disabled by default and can be enabled for a server
        /// pool by binding a health monitor to the pool. If multiple active
        /// monitors are configured, the pool member status is UP only when the
        /// health check status for all the monitors are UP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("active_monitor_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Active_monitor_paths { get; set; }
    
        /// <summary>TCP multiplexing allows the same TCP connection between load balancer
        /// and the backend server to be used for sending multiple client requests
        /// from different client TCP connections.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tcp_multiplexing_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Tcp_multiplexing_enabled { get; set; } = false;
    
        /// <summary>Depending on the topology, Source NAT (SNAT) may be required to ensure
        /// traffic from the server destined to the client is received by the load
        /// balancer. SNAT can be enabled per pool. If SNAT is not enabled for a
        /// pool, then load balancer uses the client IP and port (spoofing) while
        /// establishing connections to the servers. This is referred to as no-SNAT
        /// or TRANSPARENT mode.  By default Source NAT is enabled as LBSnatAutoMap.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("snat_translation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LBSnatTranslation Snat_translation { get; set; }
    
        /// <summary>Load balancer pool support grouping object as dynamic pool members.
        /// When member group is defined, members setting should not be specified.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("member_group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LBPoolMemberGroup Member_group { get; set; }
    
        /// <summary>Load Balancing algorithm chooses a server for each new connection by going
        /// through the list of servers in the pool. Currently, following load balancing
        /// algorithms are supported with ROUND_ROBIN as the default.
        /// ROUND_ROBIN means that a server is selected in a round-robin fashion. The
        /// weight would be ignored even if it is configured.
        /// WEIGHTED_ROUND_ROBIN means that a server is selected in a weighted
        /// round-robin fashion. Default weight of 1 is used if weight is not configured.
        /// LEAST_CONNECTION means that a server is selected when it has the least
        /// number of connections. The weight would be ignored even if it is configured.
        /// Slow start would be enabled by default.
        /// WEIGHTED_LEAST_CONNECTION means that a server is selected in a weighted
        /// least connection fashion. Default weight of 1 is used if weight is not
        /// configured. Slow start would be enabled by default.
        /// IP_HASH means that consistent hash is performed on the source IP address of
        /// the incoming connection. This ensures that the same client IP address will
        /// always reach the same server as long as no server goes down or up. It may
        /// be used on the Internet to provide a best-effort stickiness to clients
        /// which refuse session cookies.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("algorithm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBPoolAlgorithm? Algorithm { get; set; } = SDKGenerator.LBPoolAlgorithm.ROUND_ROBIN;
    
        /// <summary>The maximum number of TCP connections per pool that are idly kept alive
        /// for sending future client requests.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tcp_multiplexing_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 2147483647D)]
        public long? Tcp_multiplexing_number { get; set; } = 6L;
    
        /// <summary>Server pool consists of one or more pool members. Each pool member
        /// is identified, typically, by an IP address and a port.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("members", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBPoolMember> Members { get; set; }
    
        /// <summary>Passive healthchecks are disabled by default and can be enabled by
        /// attaching a passive health monitor to a server pool.
        /// Each time a client connection to a pool member fails, its failed count
        /// is incremented. For pools bound to L7 virtual servers, a connection is
        /// considered to be failed and failed count is incremented if any TCP
        /// connection errors (e.g. TCP RST or failure to send data) or SSL
        /// handshake failures occur. For pools bound to L4 virtual servers, if no
        /// response is received to a TCP SYN sent to the pool member or if a TCP
        /// RST is received in response to a TCP SYN, then the pool member is
        /// considered to have failed and the failed count is incremented.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("passive_monitor_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Passive_monitor_path { get; set; }
    
        /// <summary>A pool is considered active if there are at least certain
        /// minimum number of members.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("min_active_members", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long? Min_active_members { get; set; } = 1L;
    
    
    }
    
    /// <summary>A rule indicates the action to be performed for various types of traffic flowing between workload groups.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BaseRule : PolicyConfigResource
    {
        /// <summary>Flag to disable the rule. Default is enabled.</summary>
        [Newtonsoft.Json.JsonProperty("disabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Disabled { get; set; } = false;
    
        /// <summary>Define direction of traffic.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("direction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BaseRuleDirection? Direction { get; set; } = SDKGenerator.BaseRuleDirection.IN_OUT;
    
        /// <summary>Type of IP packet that should be matched while enforcing the rule.
        /// The value is set to IPV4_IPV6 for Layer3 rule if not specified.
        /// For Layer2/Ether rule the value must be null.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip_protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BaseRuleIp_protocol? Ip_protocol { get; set; }
    
        /// <summary>Text for additional notes on changes.</summary>
        [Newtonsoft.Json.JsonProperty("notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(2048)]
        public string Notes { get; set; }
    
        /// <summary>Flag to enable packet logging. Default is disabled.</summary>
        [Newtonsoft.Json.JsonProperty("logged", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Logged { get; set; } = false;
    
        /// <summary>Holds the list of layer 7 service profile paths. These profiles accept
        /// attributes and sub-attributes of various network services
        /// (e.g. L4 AppId, encryption algorithm, domain name, etc) as key value
        /// pairs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("profiles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<string> Profiles { get; set; }
    
        /// <summary>This is a unique 4 byte positive number that is assigned by the system. 
        /// This rule id is passed all the way down to the data path. The first 1GB
        /// (1000 to 2^30) will be shared by GM and LM with zebra style striped
        /// number space. For E.g 1000 to (1Million -1) by LM, (1M - 2M-1) by GM
        /// and so on.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rule_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Rule_id { get; set; }
    
        /// <summary>A flag to indicate whether rule is a default rule.</summary>
        [Newtonsoft.Json.JsonProperty("is_default", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_default { get; set; }
    
        /// <summary>User level field which will be printed in CLI and packet logs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tag { get; set; }
    
        /// <summary>We need paths as duplicate names may exist for groups under different
        /// domains. Along with paths we support IP Address of type IPv4 and IPv6.
        /// IP Address can be in one of the format(CIDR, IP Address, Range of IP Address).
        /// In order to specify all groups, use the constant "ANY". This
        /// is case insensitive. If "ANY" is used, it should be the ONLY element
        /// in the group array. Error will be thrown if ANY is used in conjunction
        /// with other values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<string> Source_groups { get; set; }
    
        /// <summary>We need paths as duplicate names may exist for groups under different
        /// domains. Along with paths we support IP Address of type IPv4 and IPv6.
        /// IP Address can be in one of the format(CIDR, IP Address, Range of IP Address).
        /// In order to specify all groups, use the constant "ANY". This
        /// is case insensitive. If "ANY" is used, it should be the ONLY element
        /// in the group array. Error will be thrown if ANY is used in conjunction
        /// with other values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destination_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<string> Destination_groups { get; set; }
    
        /// <summary>In order to specify all services, use the constant "ANY".
        /// This is case insensitive. If "ANY" is used, it should
        /// be the ONLY element in the services array. Error will be thrown
        /// if ANY is used in conjunction with other values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("services", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<string> Services { get; set; }
    
        /// <summary>The list of policy paths where the rule is applied
        /// LR/Edge/T0/T1/LRP etc. Note that a given rule can be applied
        /// on multiple LRs/LRPs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<string> Scope { get; set; }
    
        /// <summary>In order to specify raw services this can be used,
        /// along with services which contains path to services.
        /// This can be empty or null.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service_entries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<ServiceEntry> Service_entries { get; set; }
    
        /// <summary>If set to true, the rule gets applied on all the groups that are
        /// NOT part of the destination groups. If false, the rule applies to the
        /// destination groups
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinations_excluded", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Destinations_excluded { get; set; } = false;
    
        /// <summary>This field is used to resolve conflicts between multiple
        /// Rules under Security or Gateway Policy for a Domain
        /// If no sequence number is specified in the payload, a value of 0 is
        /// assigned by default. If there are multiple rules with the same
        /// sequence number then their order is not deterministic. If a specific
        /// order of rules is desired, then one has to specify unique sequence
        /// numbers or use the POST request on the rule entity with
        /// a query parameter action=revise to let the framework assign a
        /// sequence number
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sequence_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, int.MaxValue)]
        public long? Sequence_number { get; set; }
    
        /// <summary>If set to true, the rule gets applied on all the groups that are
        /// NOT part of the source groups. If false, the rule applies to the
        /// source groups
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sources_excluded", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Sources_excluded { get; set; } = false;
    
    
    }
    
    /// <summary>Vidm Info</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VidmInfo 
    {
        /// <summary>User's Full Name Or User Group's Display Name</summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Display_name { get; set; }
    
        /// <summary>Type</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public VidmInfoType? Type { get; set; }
    
        /// <summary>Username Or Groupname</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer Pool object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBPool : PolicyConfigResource
    {
        /// <summary>The load balancing algorithm will pick a server within the
        /// pool's list of available servers.
        /// Values LB_ALGORITHM_NEAREST_SERVER and
        /// LB_ALGORITHM_TOPOLOGY are only allowed for GSLB pool.
        /// Enum options - LB_ALGORITHM_LEAST_CONNECTIONS,
        /// LB_ALGORITHM_ROUND_ROBIN, LB_ALGORITHM_FASTEST_RESPONSE,
        /// LB_ALGORITHM_CONSISTENT_HASH, LB_ALGORITHM_LEAST_LOAD,
        /// LB_ALGORITHM_FEWEST_SERVERS, LB_ALGORITHM_RANDOM,
        /// LB_ALGORITHM_FEWEST_TASKS, LB_ALGORITHM_NEAREST_SERVER,
        /// LB_ALGORITHM_CORE_AFFINITY, LB_ALGORITHM_TOPOLOGY.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// LB_ALGORITHM_LEAST_CONNECTIONS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lb_algorithm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBPoolLb_algorithm? Lb_algorithm { get; set; } = SDKGenerator.ALBPoolLb_algorithm.LB_ALGORITHM_LEAST_CONNECTIONS;
    
        /// <summary>Do not translate the client's destination port when sending
        /// the connection to the server.
        /// The pool or servers specified service port will still be
        /// used for health monitoring.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("use_service_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Use_service_port { get; set; } = false;
    
        /// <summary>Rewrite incoming Host Header to server name of the server
        /// to which the request is proxied.
        /// Enabling this feature rewrites Host Header for requests to
        /// all servers in the pool.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rewrite_host_header_to_server_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Rewrite_host_header_to_server_name { get; set; } = false;
    
        /// <summary>Enable common name check for server certificate.
        /// If enabled and no explicit domain name is specified, Avi
        /// will use the incoming host header to do the match.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("host_check_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Host_check_enabled { get; set; } = false;
    
        /// <summary>Connnection pool properties.</summary>
        [Newtonsoft.Json.JsonProperty("conn_pool_properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBConnPoolProperties Conn_pool_properties { get; set; }
    
        /// <summary>If SNI server name is specified, rewrite incoming host
        /// header to the SNI server name.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rewrite_host_header_to_sni", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Rewrite_host_header_to_sni { get; set; } = false;
    
        /// <summary>Indicates whether existing IPs are disabled(false) or
        /// deleted(true) on dns hostname refreshDetail -- On a dns
        /// refresh, some IPs set on pool may no longer be returned by
        /// the resolver.
        /// These IPs are deleted from the pool when this knob is set
        /// to true.
        /// They are disabled, if the knob is set to false.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("delete_server_on_dns_refresh", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Delete_server_on_dns_refresh { get; set; } = true;
    
        /// <summary>Inline estimation of capacity of servers.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("capacity_estimation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Capacity_estimation { get; set; } = false;
    
        /// <summary>Rate Limit connections to each server.</summary>
        [Newtonsoft.Json.JsonProperty("max_conn_rate_per_server", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBRateProfile Max_conn_rate_per_server { get; set; }
    
        /// <summary>The pool directs load balanced traffic to this list of
        /// destination servers.
        /// The servers can be configured by IP address, name, network
        /// or via IP Address Group.
        /// Maximum of 5000 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("servers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBServer> Servers { get; set; }
    
        /// <summary>Periodicity of feedback for fewest tasks server selection
        /// algorithm.
        /// Allowed values are 1-300.
        /// Unit is SEC.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 10.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fewest_tasks_feedback_delay", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 300D)]
        public long? Fewest_tasks_feedback_delay { get; set; } = 10L;
    
        /// <summary>Use list of servers from Ip Address Group.
        /// It is a reference to an object of type IpAddrGroup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipaddrgroup_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ipaddrgroup_path { get; set; }
    
        /// <summary>Creator name.</summary>
        [Newtonsoft.Json.JsonProperty("created_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_by { get; set; }
    
        /// <summary>The maximum time-to-first-byte of a server.
        /// Allowed values are 1-5000.
        /// Special values are 0 - 'Automatic'.
        /// Unit is MILLISECONDS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("capacity_estimation_ttfb_thresh", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 5000D)]
        public long? Capacity_estimation_ttfb_thresh { get; set; } = 0L;
    
        /// <summary>Minimum number of servers in UP state for marking the pool
        /// UP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("min_servers_up", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Min_servers_up { get; set; }
    
        /// <summary>Enable an action - Close Connection, HTTP Redirect or Local
        /// HTTP Response - when a pool failure happens.
        /// By default, a connection will be closed, in case the pool
        /// experiences a failure.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fail_action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBFailAction Fail_action { get; set; }
    
        /// <summary>Allow server lookup by name.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lookup_server_by_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Lookup_server_by_name { get; set; } = false;
    
        /// <summary>(internal-use) Networks designated as containing servers
        /// for this pool.
        /// The servers may be further narrowed down by a filter.
        /// This field is used internally by Avi, not editable by the
        /// user.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("networks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBNetworkFilter> Networks { get; set; }
    
        /// <summary>Criteria used as a key for determining the hash between the
        /// client and  server.
        /// Enum options -
        /// LB_ALGORITHM_CONSISTENT_HASH_SOURCE_IP_ADDRESS,
        /// LB_ALGORITHM_CONSISTENT_HASH_SOURCE_IP_ADDRESS_AND_PORT,
        /// LB_ALGORITHM_CONSISTENT_HASH_URI,
        /// LB_ALGORITHM_CONSISTENT_HASH_CUSTOM_HEADER,
        /// LB_ALGORITHM_CONSISTENT_HASH_CUSTOM_STRING,
        /// LB_ALGORITHM_CONSISTENT_HASH_CALLID.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// LB_ALGORITHM_CONSISTENT_HASH_SOURCE_IP_ADDRESS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lb_algorithm_hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBPoolLb_algorithm_hash? Lb_algorithm_hash { get; set; } = SDKGenerator.ALBPoolLb_algorithm_hash.LB_ALGORITHM_CONSISTENT_HASH_SOURCE_IP_ADDRESS;
    
        /// <summary>Metadata pertaining to the service provided by this Pool.
        /// In Openshift/Kubernetes environments, app metadata info is
        /// stored.
        /// Any user input to this field will be overwritten by Avi
        /// Vantage.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service_metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Service_metadata { get; set; }
    
        /// <summary>Enable TLS SNI for server connections.
        /// If disabled, Avi will not send the SNI extension as part of
        /// the handshake.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sni_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Sni_enabled { get; set; } = true;
    
        /// <summary>Fully qualified DNS hostname which will be used in the TLS
        /// SNI extension in server connections if SNI is enabled.
        /// If no value is specified, Avi will use the incoming host
        /// header instead.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Server_name { get; set; }
    
        /// <summary>This tier1_lr field should be set same as VirtualService
        /// associated for NSX-T.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tier1_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tier1_path { get; set; }
    
        /// <summary>Comma separated list of domain names which will be used to
        /// verify the common names or subject alternative names
        /// presented by server certificates.
        /// It is performed only when common name check
        /// host_check_enabled is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("domain_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Domain_name { get; set; }
    
        /// <summary>Enable HTTP/2 for traffic from VirtualService to all
        /// backend servers in this pool.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_http2", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_http2 { get; set; } = false;
    
        /// <summary>Synchronize Cisco APIC EPG members with pool servers.</summary>
        [Newtonsoft.Json.JsonProperty("apic_epg_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Apic_epg_name { get; set; }
    
        /// <summary>Server reselect configuration for HTTP requests.</summary>
        [Newtonsoft.Json.JsonProperty("server_reselect", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPServerReselect Server_reselect { get; set; }
    
        /// <summary>If configured then Avi will trigger orchestration of pool
        /// server creation and deletion.
        /// It is a reference to an object of type
        /// AutoScaleLaunchConfig.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoscale_launch_config_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Autoscale_launch_config_path { get; set; }
    
        /// <summary>Minimum number of health monitors in UP state to mark
        /// server UP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("min_health_monitors_up", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Min_health_monitors_up { get; set; }
    
        /// <summary>Degree of non-affinity for core affinity based server
        /// selection.
        /// Allowed values are 1-65535.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 2.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lb_algorithm_core_nonaffinity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long? Lb_algorithm_core_nonaffinity { get; set; } = 2L;
    
        /// <summary>Inherited config from VirtualService.</summary>
        [Newtonsoft.Json.JsonProperty("east_west", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? East_west { get; set; }
    
        /// <summary>The Passive monitor will monitor client to server
        /// connections and requests and adjust traffic load to servers
        /// based on successful responses.
        /// This may alter the expected behavior of the LB method, such
        /// as Round Robin.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inline_health_monitor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Inline_health_monitor { get; set; } = true;
    
        /// <summary>Traffic sent to servers will use this destination server
        /// port unless overridden by the server's specific port
        /// attribute.
        /// The SSL checkbox enables Avi to server encryption.
        /// Allowed values are 1-65535.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 80.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("default_server_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long? Default_server_port { get; set; } = 80L;
    
        /// <summary>Minimum number of requests to be queued when pool is full.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 128.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("request_queue_depth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Request_queue_depth { get; set; } = 128L;
    
        /// <summary>Used to gracefully disable a server.
        /// Virtual service waits for the specified time before
        /// terminating the existing connections  to the servers that
        /// are disabled.
        /// Allowed values are 1-7200.
        /// Special values are 0 - 'Immediate', -1 - 'Infinite'.
        /// Unit is MIN.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("graceful_disable_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(-1D, 7200D)]
        public long? Graceful_disable_timeout { get; set; } = 1L;
    
        /// <summary>Enable to do routing when this pool is selected to send
        /// traffic.
        /// No servers present in routing pool.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("routing_pool", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Routing_pool { get; set; } = false;
    
        /// <summary>When enabled, Avi re-encrypts traffic to the backend
        /// servers.
        /// The specific SSL profile defines which ciphers and SSL
        /// versions will be supported.
        /// It is a reference to an object of type SSLProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ssl_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ssl_profile_path { get; set; }
    
        /// <summary>Verify server health by applying one or more health
        /// monitors.
        /// Active monitors generate synthetic traffic from each
        /// Service Engine and mark a server up or down based on the
        /// response.
        /// The Passive monitor listens only to client to server
        /// communication.
        /// It raises or lowers the ratio of traffic destined to a
        /// server based on successful responses.
        /// It is a reference to an object of type HealthMonitor.
        /// Maximum of 50 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("health_monitor_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Health_monitor_paths { get; set; }
    
        /// <summary>Specifies settings related to analytics.
        /// It is a reference to an object of type AnalyticsProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("analytics_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Analytics_profile_path { get; set; }
    
        /// <summary>Server timeout value specifies the time within which a
        /// server connection needs to be established and a
        /// request-response exchange completes between AVI and the
        /// server.
        /// Value of 0 results in using default timeout of 60 minutes.
        /// Allowed values are 0-3600000.
        /// Unit is MILLISECONDS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 3600000D)]
        public long? Server_timeout { get; set; } = 0L;
    
        /// <summary>Enable request queue when pool is full.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("request_queue_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Request_queue_enabled { get; set; } = false;
    
        /// <summary>Reference to Server Autoscale Policy.
        /// It is a reference to an object of type
        /// ServerAutoScalePolicy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoscale_policy_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Autoscale_policy_path { get; set; }
    
        /// <summary>The maximum number of concurrent connections allowed to
        /// each server within the pool.
        /// NOTE  applied value will be no less than the number of
        /// service engines that the pool is placed on.
        /// If set to 0, no limit is applied.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_concurrent_connections_per_server", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Max_concurrent_connections_per_server { get; set; } = 0L;
    
        /// <summary>Avi will validate the SSL certificate present by a server
        /// against the selected PKI Profile.
        /// It is a reference to an object of type PKIProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pki_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pki_profile_path { get; set; }
    
        /// <summary>A list of NSX Groups where the Servers for the Pool are
        /// created .
        /// </summary>
        [Newtonsoft.Json.JsonProperty("group_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Group_paths { get; set; }
    
        /// <summary>Enable or disable the pool.
        /// Disabling will terminate all open connections and pause
        /// health monitors.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
        /// <summary>Network Ids for the launch configuration.</summary>
        [Newtonsoft.Json.JsonProperty("autoscale_networks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Autoscale_networks { get; set; }
    
        /// <summary>HTTP header name to be used for the hash key.</summary>
        [Newtonsoft.Json.JsonProperty("lb_algorithm_consistent_hash_hdr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lb_algorithm_consistent_hash_hdr { get; set; }
    
        /// <summary>Duration for which new connections will be gradually ramped
        /// up to a server recently brought online.
        /// Useful for LB algorithms that are least connection based.
        /// Allowed values are 1-300.
        /// Special values are 0 - 'Immediate'.
        /// Unit is MIN.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 10.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("connection_ramp_duration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 300D)]
        public long? Connection_ramp_duration { get; set; } = 10L;
    
        /// <summary>Checksum of cloud configuration for Pool.
        /// Internally set by cloud connector.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cloud_config_cksum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cloud_config_cksum { get; set; }
    
        /// <summary>Determines analytics settings for the pool.</summary>
        [Newtonsoft.Json.JsonProperty("analytics_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBPoolAnalyticsPolicy Analytics_policy { get; set; }
    
        /// <summary>Names of external auto-scale groups for pool servers.
        /// Currently available only for AWS and Azure.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("external_autoscale_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> External_autoscale_groups { get; set; }
    
        /// <summary>Persistence will ensure the same user sticks to the same
        /// server for a desired duration of time.
        /// It is a reference to an object of type
        /// ApplicationPersistenceProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("application_persistence_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Application_persistence_profile_path { get; set; }
    
        /// <summary>Ignore the server port in building the load balancing
        /// state.Applicable only for consistent hash load balancing
        /// algorithm or Disable Port translation (use_service_port) use
        /// cases.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ignore_server_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Ignore_server_port { get; set; } = false;
    
        /// <summary>Manually select the networks and subnets used to provide
        /// reachability to the pool's servers.
        /// Specify the Subnet using the following syntax  10-1-1-0/24.
        /// Use static routes in VRF configuration when pool servers
        /// are not directly connected but routable from the service
        /// engine.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("placement_networks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBPlacementNetwork> Placement_networks { get; set; }
    
        /// <summary>Service Engines will present a client SSL certificate to
        /// the server.
        /// It is a reference to an object of type
        /// SSLKeyAndCertificate.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ssl_key_and_certificate_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ssl_key_and_certificate_path { get; set; }
    
        /// <summary>Indicates if the pool is a site-persistence pool.</summary>
        [Newtonsoft.Json.JsonProperty("gslb_sp_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Gslb_sp_enabled { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBL4PolicySet, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBL4PolicySet : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBL4PolicySet object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBL4PolicySet", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBL4PolicySet ALBL4PolicySet { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HTTPResponseRule object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPResponseRule 
    {
        /// <summary>Location header rewrite action.</summary>
        [Newtonsoft.Json.JsonProperty("loc_hdr_action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPRewriteLocHdrAction Loc_hdr_action { get; set; }
    
        /// <summary>Index of the rule.</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public long Index { get; set; }
    
        /// <summary>Enable or disable the rule.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable", Required = Newtonsoft.Json.Required.Always)]
        public bool Enable { get; set; } = true;
    
        /// <summary>Log HTTP request upon rule match.</summary>
        [Newtonsoft.Json.JsonProperty("log", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Log { get; set; }
    
        /// <summary>Name of the rule.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>Log all HTTP headers upon rule match.</summary>
        [Newtonsoft.Json.JsonProperty("all_headers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? All_headers { get; set; }
    
        /// <summary>Add match criteria to the rule.</summary>
        [Newtonsoft.Json.JsonProperty("match", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBResponseMatchTarget Match { get; set; }
    
        /// <summary>HTTP header rewrite action.</summary>
        [Newtonsoft.Json.JsonProperty("hdr_action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBHTTPHdrAction> Hdr_action { get; set; }
    
    
    }
    
    /// <summary>Paged collection of Segment Discovery Profile Binding Maps</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentDiscoveryProfileBindingMapListResult : ListResult
    {
        /// <summary>Segment Discovery Profile Binding Map list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SegmentDiscoveryProfileBindingMap> Results { get; set; } = new System.Collections.ObjectModel.Collection<SegmentDiscoveryProfileBindingMap>();
    
    
    }
    
    /// <summary>Details of Container Ingress Policy.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ContainerIngressPolicy : DiscoveredResource
    {
        /// <summary>Network status of container ingress.</summary>
        [Newtonsoft.Json.JsonProperty("network_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ContainerIngressPolicyNetwork_status? Network_status { get; set; }
    
        /// <summary>Identifier of the container cluster this ingress policy belongs to.</summary>
        [Newtonsoft.Json.JsonProperty("container_cluster_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Container_cluster_id { get; set; }
    
        /// <summary>List of identifiers of the container application , on which ingress policy
        /// is applied. e.g. IDs of all services on which the ingress is applied in
        /// kubernetes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("container_application_ids", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Container_application_ids { get; set; }
    
        /// <summary>Array of additional specific properties of container ingress
        /// in key-value format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("origin_properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyValuePair> Origin_properties { get; set; }
    
        /// <summary>Identifier of the container ingress policy.</summary>
        [Newtonsoft.Json.JsonProperty("external_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string External_id { get; set; }
    
        /// <summary>Identifier of the project which this container ingress belongs to.</summary>
        [Newtonsoft.Json.JsonProperty("container_project_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Container_project_id { get; set; }
    
        /// <summary>List of network errors related to container ingress.</summary>
        [Newtonsoft.Json.JsonProperty("network_errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<NetworkError> Network_errors { get; set; }
    
        /// <summary>Container ingress policy specification.</summary>
        [Newtonsoft.Json.JsonProperty("spec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Spec { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for VirtualEndpoint used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildVirtualEndpoint : ChildPolicyConfigResource
    {
        /// <summary>Contains reference to actual VirtualEndpoint.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("VirtualEndpoint", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public VirtualEndpoint VirtualEndpoint { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of flood protection profiles</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FloodProtectionProfileListResult : ListResult
    {
        /// <summary>Flood protection profile list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FloodProtectionProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<FloodProtectionProfile>();
    
    
    }
    
    /// <summary>Child wrapper object for IpAddressBlock, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIpAddressBlock : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual IpAddressBlock object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IpAddressBlock", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IpAddressBlock IpAddressBlock { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for StaticRouteBfdPeer, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildStaticRouteBfdPeer : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual StaticRouteBfdPeer object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("BfdPeer", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public StaticRouteBfdPeer BfdPeer { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBTrafficCloneProfile, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBTrafficCloneProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBTrafficCloneProfile object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBTrafficCloneProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBTrafficCloneProfile ALBTrafficCloneProfile { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceflowObservationReplicationLogical : TraceflowObservation
    {
        /// <summary>The label of VTEP</summary>
        [Newtonsoft.Json.JsonProperty("vtep_label", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Vtep_label { get; set; }
    
        /// <summary>This field specifies the type of replication message TX_VTEP - Transmit replication to all VTEPs TX_MTEP - Transmit replication to all MTEPs RX - Receive replication</summary>
        [Newtonsoft.Json.JsonProperty("replication_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TraceflowObservationReplicationLogicalReplication_type? Replication_type { get; set; }
    
        /// <summary>Local IP address of the component that replicates the packet.</summary>
        [Newtonsoft.Json.JsonProperty("local_ip_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Local_ip_address { get; set; }
    
        /// <summary>The name of uplink</summary>
        [Newtonsoft.Json.JsonProperty("uplink_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uplink_name { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsSrvRdata object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsSrvRdata 
    {
        /// <summary>Priority of the target hosting the service, low value
        /// implies higher priority for this service record.
        /// Allowed values are 0-65535.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Priority { get; set; } = 0L;
    
        /// <summary>Service port.
        /// Allowed values are 0-65535.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long Port { get; set; }
    
        /// <summary>Relative weight for service records with same priority,
        /// high value implies higher preference for this service
        /// record.
        /// Allowed values are 0-65535.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("weight", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Weight { get; set; } = 0L;
    
        /// <summary>Canonical hostname, of the machine hosting the service,
        /// with no trailing period.
        /// 'default.host' is valid but not 'default.host.'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as default.host.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Target { get; set; } = "default.host";
    
    
    }
    
    /// <summary>Server SSL profile binding.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBServerSslProfileBinding 
    {
        /// <summary>If server auth type is REQUIRED, server certificate must be signed by
        /// one of the trusted Certificate Authorities (CAs), also referred to as
        /// root CAs, whose self signed certificates are specified.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server_auth_ca_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Server_auth_ca_paths { get; set; }
    
        /// <summary>To support client authentication (load balancer acting as a client
        /// authenticating to the backend server), client certificate can be
        /// specified in the server-side SSL profile binding
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_certificate_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Client_certificate_path { get; set; }
    
        /// <summary>Server authentication mode.</summary>
        [Newtonsoft.Json.JsonProperty("server_auth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBServerSslProfileBindingServer_auth? Server_auth { get; set; } = SDKGenerator.LBServerSslProfileBindingServer_auth.AUTO_APPLY;
    
        /// <summary>Authentication depth is used to set the verification depth in the server
        /// certificates chain.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("certificate_chain_depth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long? Certificate_chain_depth { get; set; } = 3L;
    
        /// <summary>A Certificate Revocation List (CRL) can be specified in the server-side
        /// SSL profile binding to disallow compromised server certificates.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server_auth_crl_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Server_auth_crl_paths { get; set; }
    
        /// <summary>Server SSL profile defines reusable, application-independent server side
        /// SSL properties.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ssl_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ssl_profile_path { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyTraceflowObservationRelayedLogical : TraceflowObservationRelayedLogical
    {
        /// <summary>This field specifies the logical component that relay service located on.</summary>
        [Newtonsoft.Json.JsonProperty("logical_component_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Logical_component_path { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for StaticRoutes, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildStaticRoutes : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual StaticRoutes object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("StaticRoutes", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public StaticRoutes StaticRoutes { get; set; }
    
    
    }
    
    /// <summary>LBServiceStatus on specific Enforcement Point</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("LBServiceStatus", typeof(LBServiceStatus))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBServiceStatusPerEP : PolicyRuntimeInfoPerEP
    {
    
    }
    
    /// <summary>Directory domain synchronization statistics</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DirectoryDomainSyncStats 
    {
        /// <summary>Directory domain previous sync status. It could be one of the following two states.</summary>
        [Newtonsoft.Json.JsonProperty("prev_sync_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DirectoryDomainSyncStatsPrev_sync_status? Prev_sync_status { get; set; }
    
        /// <summary>All the historical full sync are counted in calculating the average full sync time in milliseconds.</summary>
        [Newtonsoft.Json.JsonProperty("avg_full_sync_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Avg_full_sync_time { get; set; }
    
        /// <summary>Directory domain previous sync type. It could be one of the following five states. Right after the directory domain is configured, this field is set to IDLE.</summary>
        [Newtonsoft.Json.JsonProperty("prev_sync_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DirectoryDomainSyncStatsPrev_sync_type? Prev_sync_type { get; set; }
    
        /// <summary>number of successful historical full sync initiated either by system or by API request.</summary>
        [Newtonsoft.Json.JsonProperty("num_full_sync", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Num_full_sync { get; set; }
    
        /// <summary>Since what time the current state has begun. The time is expressed in millisecond epoch time.</summary>
        [Newtonsoft.Json.JsonProperty("current_state_begin_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Current_state_begin_time { get; set; }
    
        /// <summary>All the historical delta sync are counted in calculating the average delta sync time in milliseconds.</summary>
        [Newtonsoft.Json.JsonProperty("avg_delta_sync_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Avg_delta_sync_time { get; set; }
    
        /// <summary>Directory domain previous sync status error if last status was failure.</summary>
        [Newtonsoft.Json.JsonProperty("prev_sync_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Prev_sync_error { get; set; }
    
        /// <summary>Current running state of the directory domain in synchronization life cycle. It could be one of the following five states. SELECTIVE_FULL_SYNC and SELECTIVE_DELTA_SYNC are sync states for selective sync.</summary>
        [Newtonsoft.Json.JsonProperty("current_state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DirectoryDomainSyncStatsCurrent_state? Current_state { get; set; }
    
        /// <summary>number of successful historical delta sync initiated either by system or by API request.</summary>
        [Newtonsoft.Json.JsonProperty("num_delta_sync", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Num_delta_sync { get; set; }
    
        /// <summary>Directory domain previous sync ending time expressed in millisecond epoch time.</summary>
        [Newtonsoft.Json.JsonProperty("prev_sync_end_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Prev_sync_end_time { get; set; }
    
    
    }
    
    /// <summary>Represents configuration for dropdown filter widget.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DropdownFilterWidgetConfiguration : FilterWidgetConfiguration
    {
        /// <summary>Expression to specify default value of filter.</summary>
        [Newtonsoft.Json.JsonProperty("default_value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Default_value { get; set; }
    
        /// <summary>Additional static items to be added in dropdown filter. Example can be 'ALL'.</summary>
        [Newtonsoft.Json.JsonProperty("static_filters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<StaticFilter> Static_filters { get; set; }
    
        /// <summary>Defines the item of a dropdown.</summary>
        [Newtonsoft.Json.JsonProperty("dropdown_item", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public DropdownItem Dropdown_item { get; set; } = new DropdownItem();
    
        /// <summary>If the condition is met then the static filter will be added. If no condition is provided, then the static filters will be applied unconditionally.</summary>
        [Newtonsoft.Json.JsonProperty("static_filter_condition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Static_filter_condition { get; set; }
    
        /// <summary>Placeholder message to be displayed in dropdown filter.</summary>
        [Newtonsoft.Json.JsonProperty("placeholder_msg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Placeholder_msg { get; set; }
    
    
    }
    
    /// <summary>Tier-0 vrf configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier0VrfConfig 
    {
        /// <summary>Route targets.</summary>
        [Newtonsoft.Json.JsonProperty("route_targets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<VrfRouteTargets> Route_targets { get; set; }
    
        /// <summary>L3 VNI associated with the VRF for overlay traffic of ethernet virtual
        /// private network (EVPN). It must be unique and available from the VNI
        /// pool defined for EVPN service. It is required for VRF to participate
        /// in the EVPN service in INLINE mode.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("evpn_transit_vni", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Evpn_transit_vni { get; set; }
    
        /// <summary>Default tier0 path. Cannot be modified after realization.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tier0_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Tier0_path { get; set; }
    
        /// <summary>Route distinguisher with format in IPAddress:&lt;number&gt; or ASN:&lt;number&gt;.</summary>
        [Newtonsoft.Json.JsonProperty("route_distinguisher", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Route_distinguisher { get; set; }
    
        /// <summary>It is required for VRF to participate in the EVPN service in ROUTE_SERVER
        /// mode.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("evpn_l2_vni_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public VrfEvpnL2VniConfig Evpn_l2_vni_config { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IcmpEchoRequestHeader 
    {
        /// <summary>ICMP id</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Id { get; set; } = 0L;
    
        /// <summary>ICMP sequence number</summary>
        [Newtonsoft.Json.JsonProperty("sequence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Sequence { get; set; } = 0L;
    
    
    }
    
    /// <summary>Consolidated Status of an intent object. Status Consolidation of an intent happens at
    /// multiple levels:
    /// - Per Enforcement Point: calculation of the consolidated status is performed using all
    /// realized entities that the intent objet maps to on a specific enforcement point.
    /// - Across Enforcement Points: calculation of the consolidated status is performend
    /// aggregating the consolidated status from each enforcement point.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConsolidatedStatus 
    {
        /// <summary>Consolidated Realized Status of an intent object.</summary>
        [Newtonsoft.Json.JsonProperty("consolidated_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConsolidatedStatusConsolidated_status? Consolidated_status { get; set; }
    
    
    }
    
    /// <summary>Remote file server</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RemoteFileServer 
    {
        /// <summary>Remote server directory to copy bundle files to</summary>
        [Newtonsoft.Json.JsonProperty("directory_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Directory_path { get; set; }
    
        /// <summary>Protocol to use to copy file</summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public FileTransferProtocol Protocol { get; set; } = new FileTransferProtocol();
    
        /// <summary>Server port</summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long? Port { get; set; } = 22L;
    
        /// <summary>Remote server hostname or IP address</summary>
        [Newtonsoft.Json.JsonProperty("server", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Server { get; set; }
    
    
    }
    
    /// <summary>Nested expressions is a list of condition expressions that must follow the
    /// below criteria:
    /// 0. Only allowed expressions in a NestedExpression are Condition and
    /// ConjunctionOperator.
    /// 1. A non-empty expression list, must be of odd size. In a list, with
    /// indices starting from 0, all condition expressions must be at even indices,
    /// separated by the conjunction expressions AND at odd indices.
    /// 2. There may be at most 5 condition expressions inside a list.
    /// 3. NestedExpressions are homogeneous in nature, i.e, all expressions inside
    /// a nested expression must have the same member type.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class NestedExpression : Expression
    {
        /// <summary>Expression.</summary>
        [Newtonsoft.Json.JsonProperty("expressions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<Expression> Expressions { get; set; } = new System.Collections.ObjectModel.Collection<Expression>();
    
    
    }
    
    /// <summary>Advanced load balancer ResponseMatchTarget object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBResponseMatchTarget 
    {
        /// <summary>Configure the HTTP status code(s).</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPStatusMatch Status { get; set; }
    
        /// <summary>Configure client ip addresses.</summary>
        [Newtonsoft.Json.JsonProperty("client_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddrMatch Client_ip { get; set; }
    
        /// <summary>Configure the type of HTTP protocol.</summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBProtocolMatch Protocol { get; set; }
    
        /// <summary>Configure HTTP headers.</summary>
        [Newtonsoft.Json.JsonProperty("hdrs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBHdrMatch> Hdrs { get; set; }
    
        /// <summary>Configure the location header.</summary>
        [Newtonsoft.Json.JsonProperty("loc_hdr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBLocationHdrMatch Loc_hdr { get; set; }
    
        /// <summary>Configure the host header.</summary>
        [Newtonsoft.Json.JsonProperty("host_hdr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHostHdrMatch Host_hdr { get; set; }
    
        /// <summary>Configure virtual service ports.</summary>
        [Newtonsoft.Json.JsonProperty("vs_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBPortMatch Vs_port { get; set; }
    
        /// <summary>Configure the HTTP headers in response.</summary>
        [Newtonsoft.Json.JsonProperty("rsp_hdrs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBHdrMatch> Rsp_hdrs { get; set; }
    
        /// <summary>Configure HTTP cookie(s).</summary>
        [Newtonsoft.Json.JsonProperty("cookie", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBCookieMatch Cookie { get; set; }
    
        /// <summary>Configure versions of the HTTP protocol.</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPVersionMatch Version { get; set; }
    
        /// <summary>Configure request query.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBQueryMatch Query { get; set; }
    
        /// <summary>Configure request paths.</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBPathMatch Path { get; set; }
    
        /// <summary>Configure HTTP methods.</summary>
        [Newtonsoft.Json.JsonProperty("method", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBMethodMatch Method { get; set; }
    
    
    }
    
    /// <summary>Group.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Group : PolicyConfigResource
    {
        /// <summary>Realization state of this group</summary>
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public GroupState? State { get; set; }
    
        /// <summary>Extended Expression allows additional higher level context to be
        /// specified for grouping criteria. (e.g. user AD group)
        /// This field allow users to specified user context as the source of a
        /// firewall rule for IDFW feature.
        /// Current version only support a single IdentityGroupExpression. In the
        /// future, this might expand to support other conjunction and non-conjunction
        /// expression.
        /// 
        /// The extended expression list must follow below criteria:
        /// 1. Contains a single IdentityGroupExpression. No conjunction expression is
        /// supported.
        /// 2. No other non-conjunction expression is supported, except for
        /// IdentityGroupExpression.
        /// 3. Each expression must be a valid Expression. See the definition of
        /// the Expression type for more information.
        /// 4. Extended expression are implicitly AND with expression.
        /// 5. No nesting can be supported if this value is used.
        /// 6. If a Group is using extended expression, this group must be the only
        /// member in the source field of an communication map.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("extended_expression", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<Expression> Extended_expression { get; set; }
    
        /// <summary>The expression list must follow below criteria:
        ///   1. A non-empty expression list, must be of odd size. In a list, with
        ///   indices starting from 0, all non-conjunction expressions must be at
        ///   even indices, separated by a conjunction expression at odd
        ///   indices.
        ///   2. The total of ConditionExpression and NestedExpression in a list
        ///   should not exceed 5.
        ///   3. The total of IPAddressExpression, MACAddressExpression, external
        ///   IDs in an ExternalIDExpression and paths in a PathExpression must not exceed
        ///   500.
        ///   4. Each expression must be a valid Expression. See the definition of
        ///   the Expression type for more information.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expression", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Expression> Expression { get; set; }
    
        /// <summary>If true, indicates that this is a remote reference group. Such group will have
        /// span different from the its parent domain. Default value is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Reference { get; set; } = false;
    
    
    }
    
    /// <summary>LBAccessListControl is used to define how IP access list control can filter
    /// the connections from clients.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBAccessListControl 
    {
        /// <summary>ALLOW means connections matching grouping object IP list are allowed
        /// and requests not matching grouping object IP list are dropped.
        /// DROP means connections matching grouping object IP list are dropped
        /// and requests not matching grouping object IP list are allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBAccessListControlAction Action { get; set; }
    
        /// <summary>The path of grouping object which defines the IP addresses or
        /// ranges to match the client IP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("group_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Group_path { get; set; }
    
        /// <summary>The enabled flag indicates whether to enable access list control option.
        /// It is false by default.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = false;
    
    
    }
    
    /// <summary>Aggregate of IPSec VPN Session Statistics across Enforcement Points.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregateIPSecVpnSessionStatistics : AggregatePolicyRuntimeInfo
    {
        /// <summary>List of IPSec VPN Session Statistics per Enforcement Point.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IPSecVpnSessionStatisticsPerEP> Results { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer SSLRating object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSSLRating 
    {
        /// <summary>Enum options - SSL_SCORE_NOT_SECURE, SSL_SCORE_VERY_BAD,
        /// SSL_SCORE_BAD, SSL_SCORE_AVERAGE, SSL_SCORE_GOOD,
        /// SSL_SCORE_EXCELLENT.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("performance_rating", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBSSLRatingPerformance_rating? Performance_rating { get; set; }
    
        /// <summary>security_score of SSLRating.</summary>
        [Newtonsoft.Json.JsonProperty("security_score", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Security_score { get; set; }
    
        /// <summary>Enum options - SSL_SCORE_NOT_SECURE, SSL_SCORE_VERY_BAD,
        /// SSL_SCORE_BAD, SSL_SCORE_AVERAGE, SSL_SCORE_GOOD,
        /// SSL_SCORE_EXCELLENT.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("compatibility_rating", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBSSLRatingCompatibility_rating? Compatibility_rating { get; set; }
    
    
    }
    
    /// <summary>This object holds the information of the task.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyTask : TaskProperties
    {
        /// <summary>This property holds the reason of the task failure, if any.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("failure_msg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Failure_msg { get; set; }
    
    
    }
    
    /// <summary>The server will populate this field when returing the resource. Ignored on PUT and POST.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SelfResourceLink : ResourceLink
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyTraceflowObservationDelivered : TraceflowObservationDelivered
    {
        /// <summary>The path of the segment port or router port into which the traceflow packet was delivered</summary>
        [Newtonsoft.Json.JsonProperty("segment_port_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Segment_port_path { get; set; }
    
    
    }
    
    /// <summary>Session cookie time.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBSessionCookieTime : LBCookieTime
    {
        /// <summary>Instead of using HTTP Cookie max-age and relying on client to expire
        /// the cookie, max idle time and/or max lifetime of the cookie can be used.
        /// Max idle time, if configured, specifies the maximum interval the cookie
        /// is valid for from the last time it was seen in a request.
        /// It is available for insert mode.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cookie_max_idle", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long? Cookie_max_idle { get; set; }
    
        /// <summary>Max life time, if configured, specifies the maximum interval the cookie
        /// is valid for from the first time the cookie was seen in a request.
        /// It is available for insert mode.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cookie_max_life", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long? Cookie_max_life { get; set; }
    
    
    }
    
    /// <summary>IPSec VPN tunnel profile is a reusable profile that captures phase two negotiation parameters and IPSec tunnel properties. Any changes affects all IPSec VPN sessions consuming this profile.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnTunnelProfile : PolicyConfigResource
    {
        /// <summary>Collection of type specific properties. As of now, to hold
        /// encapsulation mode and transform protocol.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("extended_attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AttributeVal> Extended_attributes { get; set; }
    
        /// <summary>Algorithm to be used for message digest. Default digest algorithm is implicitly covered by default encryption algorithm "AES_GCM_128".</summary>
        [Newtonsoft.Json.JsonProperty("digest_algorithms", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Digest_algorithms> Digest_algorithms { get; set; }
    
        /// <summary>Encryption algorithm to encrypt/decrypt the messages exchanged between IPSec VPN initiator and responder during tunnel negotiation. Default is AES_GCM_128.</summary>
        [Newtonsoft.Json.JsonProperty("encryption_algorithms", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Encryption_algorithms> Encryption_algorithms { get; set; }
    
        /// <summary>If true, perfect forward secrecy (PFS) is enabled.</summary>
        [Newtonsoft.Json.JsonProperty("enable_perfect_forward_secrecy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_perfect_forward_secrecy { get; set; } = true;
    
        /// <summary>Diffie-Hellman group to be used if PFS is enabled. Default is GROUP14.</summary>
        [Newtonsoft.Json.JsonProperty("dh_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Dh_groups> Dh_groups { get; set; }
    
        /// <summary>Defragmentation policy helps to handle defragmentation bit present in the inner packet. COPY copies the defragmentation bit from the inner IP packet into the outer packet. CLEAR ignores the defragmentation bit present in the inner packet.</summary>
        [Newtonsoft.Json.JsonProperty("df_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPSecVpnTunnelProfileDf_policy? Df_policy { get; set; } = SDKGenerator.IPSecVpnTunnelProfileDf_policy.COPY;
    
        /// <summary>SA life time specifies the expiry time of security association. Default is 3600 seconds.</summary>
        [Newtonsoft.Json.JsonProperty("sa_life_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(900D, 31536000D)]
        public long? Sa_life_time { get; set; } = 3600L;
    
    
    }
    
    /// <summary>Paged collection of port security profile binding maps</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PortSecurityProfileBindingMapListResult : ListResult
    {
        /// <summary>Port security profile binding map list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PortSecurityProfileBindingMap> Results { get; set; } = new System.Collections.ObjectModel.Collection<PortSecurityProfileBindingMap>();
    
    
    }
    
    /// <summary>Represents a label-value pair.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PropertyItem 
    {
        /// <summary>Represents field value of the property.</summary>
        [Newtonsoft.Json.JsonProperty("field", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Field { get; set; }
    
        /// <summary>If true, separates this property in a widget.</summary>
        [Newtonsoft.Json.JsonProperty("separator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Separator { get; set; } = false;
    
        /// <summary>Hyperlink of the specified UI page that provides details. This will be linked with value of the property.</summary>
        [Newtonsoft.Json.JsonProperty("navigation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Navigation { get; set; }
    
        /// <summary>Render configuration to be applied, if any.</summary>
        [Newtonsoft.Json.JsonProperty("render_configuration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RenderConfiguration> Render_configuration { get; set; }
    
        /// <summary>Data type of the field.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PropertyItemType Type { get; set; } = SDKGenerator.PropertyItemType.String;
    
        /// <summary>Set to true if the field is a heading. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("heading", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Heading { get; set; } = false;
    
        /// <summary>If the condition is met then the property will be displayed. Examples of expression syntax are provided under 'example_request' section of 'CreateWidgetConfiguration' API.</summary>
        [Newtonsoft.Json.JsonProperty("condition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Condition { get; set; }
    
        /// <summary>If a field represents a heading, then label is not needed</summary>
        [Newtonsoft.Json.JsonProperty("label", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Label Label { get; set; }
    
    
    }
    
    /// <summary>Render configuration to be applied to the widget.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RenderConfiguration 
    {
        /// <summary>The color to use when rendering an entity. For example, set color as 'RED' to render a portion of donut in red.</summary>
        [Newtonsoft.Json.JsonProperty("color", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RenderConfigurationColor? Color { get; set; }
    
        /// <summary>If the condition is met then the rendering specified for the condition will be applied. Examples of expression syntax are provided under 'example_request' section of 'CreateWidgetConfiguration' API.</summary>
        [Newtonsoft.Json.JsonProperty("condition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Condition { get; set; }
    
        /// <summary>If specified, overrides the field value. This can be used to display a meaningful value in situations where field value is not available or not configured.</summary>
        [Newtonsoft.Json.JsonProperty("display_value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string Display_value { get; set; }
    
        /// <summary>Multi-line text to be shown on tooltip while hovering over the UI element if the condition is met.</summary>
        [Newtonsoft.Json.JsonProperty("tooltip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Tooltip> Tooltip { get; set; }
    
        /// <summary>Icons to be applied at dashboard for widgets and UI elements.</summary>
        [Newtonsoft.Json.JsonProperty("icons", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Icon> Icons { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class InterfaceArpTableInCsvFormat : CsvListResult
    {
        /// <summary>Timestamp when the data was last updated; unset if data source has never updated the data.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InterfaceArpCsvRecord> Results { get; set; }
    
    
    }
    
    /// <summary>OSPF Routes.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OspfRoutesListResult : ListResult
    {
        /// <summary>Policy path to Tier0 gateway.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gateway_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Gateway_path { get; set; }
    
        /// <summary>Timestamp when the data was last updated, unset if data source has never updated the data.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OspfRoutes> Results { get; set; }
    
    
    }
    
    /// <summary>Represents which federated global resources have been overrriden on
    /// a specific Site.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverriddenResource : PolicyConfigResource
    {
        /// <summary>Site path to the specific site that has overridden the global resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("site_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Site_path { get; set; }
    
        /// <summary>Policy resource path of the overridden resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("intent_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Intent_path { get; set; }
    
    
    }
    
    /// <summary>A rule indicates the action to be performed for various types of traffic flowing between workload groups.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Rule : BaseRule
    {
        /// <summary>The action to be applied to all the services
        /// The JUMP_TO_APPLICATION action is only supported for rules created in the
        /// Environment category. Once a match is hit then the rule processing
        /// will jump to the rules present in the Application category, skipping
        /// all further rules in the Environment category. If no rules match in
        /// the Application category then the default application rule will be hit.
        /// This is applicable only for DFW.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RuleAction? Action { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer CompressionFilter object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBCompressionFilter 
    {
        /// <summary>It is a reference to an object of type IpAddrGroup.</summary>
        [Newtonsoft.Json.JsonProperty("ip_addrs_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ip_addrs_path { get; set; }
    
        /// <summary>Placeholder for description of property ip_addr_ranges of
        /// obj type CompressionFilter field type str  type array.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip_addr_ranges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBIpAddrRange> Ip_addr_ranges { get; set; }
    
        /// <summary>It is a reference to an object of type StringGroup.</summary>
        [Newtonsoft.Json.JsonProperty("devices_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Devices_path { get; set; }
    
        /// <summary>Name of the object.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>Number of index.</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public long Index { get; set; }
    
        /// <summary>Placeholder for description of property ip_addr_prefixes of
        /// obj type CompressionFilter field type str  type array.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip_addr_prefixes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBIpAddrPrefix> Ip_addr_prefixes { get; set; }
    
        /// <summary>Enum options - AGGRESSIVE_COMPRESSION, NORMAL_COMPRESSION,
        /// NO_COMPRESSION.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as NORMAL_COMPRESSION.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("level", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBCompressionFilterLevel Level { get; set; } = SDKGenerator.ALBCompressionFilterLevel.NORMAL_COMPRESSION;
    
        /// <summary>Placeholder for description of property ip_addrs of obj
        /// type CompressionFilter field type str  type array.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip_addrs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBIpAddr> Ip_addrs { get; set; }
    
        /// <summary>Whether to apply Filter when group criteria is matched or
        /// not.
        /// Enum options - IS_IN, IS_NOT_IN.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as IS_IN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBCompressionFilterMatch? Match { get; set; } = SDKGenerator.ALBCompressionFilterMatch.IS_IN;
    
        /// <summary>Placeholder for description of property user_agent of obj
        /// type CompressionFilter field type str  type array.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("user_agent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> User_agent { get; set; }
    
    
    }
    
    /// <summary>Local endpoint represents a tier-0/tier-1 on which tunnel needs to be terminated.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnLocalEndpoint : PolicyConfigResource
    {
        /// <summary>IPV4 Address of local endpoint.</summary>
        [Newtonsoft.Json.JsonProperty("local_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Local_address { get; set; }
    
        /// <summary>List of policy paths referencing certificate authority (CA) to verify peer certificates.</summary>
        [Newtonsoft.Json.JsonProperty("trust_ca_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Trust_ca_paths { get; set; }
    
        /// <summary>Local identifier.</summary>
        [Newtonsoft.Json.JsonProperty("local_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Local_id { get; set; }
    
        /// <summary>List of policy paths referencing certificate revocation list (CRL) to peer certificates.</summary>
        [Newtonsoft.Json.JsonProperty("trust_crl_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Trust_crl_paths { get; set; }
    
        /// <summary>Policy path referencing site certificate.</summary>
        [Newtonsoft.Json.JsonProperty("certificate_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Certificate_path { get; set; }
    
    
    }
    
    /// <summary>A ServiceEntry that represents nesting service</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class NestedServiceServiceEntry : ServiceEntry
    {
        /// <summary>path of nested service</summary>
        [Newtonsoft.Json.JsonProperty("nested_service_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Nested_service_path { get; set; }
    
    
    }
    
    /// <summary>Directory Domain</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("DirectoryAdDomain", typeof(DirectoryAdDomain))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DirectoryDomain : ManagedResource
    {
        /// <summary>Directory domain LDAP servers' information including host, name, port, protocol and so on.</summary>
        [Newtonsoft.Json.JsonProperty("ldap_servers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(50)]
        public System.Collections.Generic.ICollection<DirectoryLdapServer> Ldap_servers { get; set; } = new System.Collections.ObjectModel.Collection<DirectoryLdapServer>();
    
        /// <summary>Directory domain name which best describes the domain. It could be unique fqdn name or it could also be descriptive. There is no unique contraint for domain name among different domains.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
    
    }
    
    /// <summary>PriorityLabelsApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBPriorityLabelsApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of PriorityLabels
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBPriorityLabels> Results { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBErrorPageProfile, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBErrorPageProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBErrorPageProfile object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBErrorPageProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBErrorPageProfile ALBErrorPageProfile { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentCrossSiteTrafficStats 
    {
        /// <summary>Total sent data counters.</summary>
        [Newtonsoft.Json.JsonProperty("tx_stats", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public InterSitePortCounters Tx_stats { get; set; }
    
        /// <summary>Timestamp when the l2 forwarder statistics was last updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>Total received data counters.</summary>
        [Newtonsoft.Json.JsonProperty("rx_stats", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public InterSitePortCounters Rx_stats { get; set; }
    
        /// <summary>Policy path of Segment to attach interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("segment_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Segment_path { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for SecurityZoneRule, used in hierarchical API This type is deprecated. Use the type ChildRule instead.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildSecurityZoneRule : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual SecurityZoneRule object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("SecurityZoneRule", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SecurityZoneRule SecurityZoneRule { get; set; }
    
    
    }
    
    /// <summary>Header of a widget that provides additional information. This will be shown at the container level. It includes details as label value pairs.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Header 
    {
        /// <summary>Alignment of header labels.</summary>
        [Newtonsoft.Json.JsonProperty("content_alignment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public HeaderContent_alignment? Content_alignment { get; set; } = SDKGenerator.HeaderContent_alignment.RIGHT;
    
        /// <summary>If the condition is met then the header will be applied. Examples of expression syntax are provided under 'example_request' section of 'CreateWidgetConfiguration' API.</summary>
        [Newtonsoft.Json.JsonProperty("condition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Condition { get; set; }
    
        /// <summary>An array of label-value properties.</summary>
        [Newtonsoft.Json.JsonProperty("sub_headers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PropertyItem> Sub_headers { get; set; }
    
    
    }
    
    /// <summary>Routing table entry.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RoutingEntry 
    {
        /// <summary>Logical router component(Service Router/Distributed Router) id</summary>
        [Newtonsoft.Json.JsonProperty("lr_component_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lr_component_id { get; set; }
    
        /// <summary>Next hop address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("next_hop", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Next_hop { get; set; }
    
        /// <summary>Logical router component(Service Router/Distributed Router) type</summary>
        [Newtonsoft.Json.JsonProperty("lr_component_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lr_component_type { get; set; }
    
        /// <summary>Network CIDR.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("network", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Network { get; set; }
    
        /// <summary>Route type in routing table.
        /// t0c - Tier-0 Connected
        /// t0s - Tier-0 Static
        /// b - BGP
        /// t0n - Tier-0 NAT
        /// t1s - Tier-1 Static
        /// t1c - Tier-1 Connected
        /// t1n: Tier-1 NAT
        /// t1l: Tier-1 LB VIP
        /// t1ls: Tier-1 LB SNAT
        /// t1d: Tier-1 DNS FORWARDER
        /// t1ipsec: Tier-1 IPSec
        /// isr: Inter-SR
        /// </summary>
        [Newtonsoft.Json.JsonProperty("route_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Route_type { get; set; }
    
        /// <summary>The policy path of the interface which is used as the next hop</summary>
        [Newtonsoft.Json.JsonProperty("interface", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Interface { get; set; }
    
        /// <summary>Admin distance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("admin_distance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Admin_distance { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer L4Rule object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBL4Rule 
    {
        /// <summary>Action to be performed upon successful rule match.</summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBL4RuleAction Action { get; set; }
    
        /// <summary>Index of the rule.</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public long Index { get; set; }
    
        /// <summary>Enable or disable the rule.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable { get; set; } = true;
    
        /// <summary>Name of the rule.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>Match criteria of the rule.</summary>
        [Newtonsoft.Json.JsonProperty("match", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBL4RuleMatchTarget Match { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer AuthProfileHTTPClientParams object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAuthProfileHTTPClientParams 
    {
        /// <summary>The max allowed length of time a clients authentication is
        /// cached.
        /// Allowed values are 1-30.
        /// Unit is SEC.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 5.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cache_expiration_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 30D)]
        public long? Cache_expiration_time { get; set; } = 5L;
    
        /// <summary>A user should be a member of these groups.
        /// Each group is defined by the DN.
        /// For example,
        /// CN=testgroup,OU=groups,dc=example,dc=avinetworks,DC=com.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("require_user_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Require_user_groups { get; set; }
    
        /// <summary>Insert an HTTP header.
        /// This field is used to define the header name.
        /// The value of the header is set to the client's HTTP Auth
        /// user ID.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("request_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Request_header { get; set; }
    
    
    }
    
    /// <summary>Gives the Statistics of a NAT rule.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyNatRuleStatisticsPerTransportNode : PolicyNATRuleCounters
    {
        /// <summary>Timestamp when the data was last updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>Policy path of the Edge Node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transport_node_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_node_path { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VrfL2VniConfig 
    {
        /// <summary>L2 VNI associated with the VRF. It must be unique and available from the VNI
        /// pool defined for EVPN service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("l2_vni", Required = Newtonsoft.Json.Required.Always)]
        public long L2_vni { get; set; }
    
        /// <summary>Route targets.</summary>
        [Newtonsoft.Json.JsonProperty("route_targets", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<VrfRouteTargets> Route_targets { get; set; } = new System.Collections.ObjectModel.Collection<VrfRouteTargets>();
    
        /// <summary>This is a 64 bit number which disambiguates overlapping logical networks, with
        /// format in IPAddress:&lt;number&gt; or ASN:&lt;number&gt;.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("route_distinguisher", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Route_distinguisher { get; set; }
    
    
    }
    
    /// <summary>Collection of OSPF area configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OspfAreaConfigListResult : ListResult
    {
        /// <summary>OSPF area configuration list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<OspfAreaConfig> Results { get; set; } = new System.Collections.ObjectModel.Collection<OspfAreaConfig>();
    
    
    }
    
    /// <summary>Vlan-Vni mapping pair resource in EvpnTenantConfig for ROUTE-SERVER Evpn mode</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VlanVniRangePair 
    {
        /// <summary>List of VNI ids and VNI ranges (specified with '-'). The vni id is used for VXLAN transmission for a given tenant Vlan ID in ROUTE-SERVER Evpn.</summary>
        [Newtonsoft.Json.JsonProperty("vnis", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Vnis { get; set; }
    
        /// <summary>List of VLAN ids and VLAN ranges (specified with '-').</summary>
        [Newtonsoft.Json.JsonProperty("vlans", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Vlans { get; set; }
    
    
    }
    
    /// <summary>Duplicate address binding information</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DuplicateAddressBindingEntry : AddressBindingEntry
    {
        /// <summary>Provides the ID of the port on which the same address bidning exists
        /// </summary>
        [Newtonsoft.Json.JsonProperty("conflicting_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Conflicting_port { get; set; }
    
    
    }
    
    /// <summary>Contains IPv6 related discovery options.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPv6DiscoveryOptions 
    {
        /// <summary>Indicates ND snooping options</summary>
        [Newtonsoft.Json.JsonProperty("nd_snooping_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NdSnoopingConfig Nd_snooping_config { get; set; }
    
        /// <summary>Enable this method will snoop the DHCPv6 message transaction
        /// which a VM makes with a DHCPv6 server. From the transaction, we
        /// learn the IPv6 addresses assigned by the DHCPv6 server to this VM
        /// along with its lease time.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dhcp_snooping_v6_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Dhcp_snooping_v6_enabled { get; set; } = false;
    
        /// <summary>Enable this method will learn the IPv6 addresses which are
        /// configured on interfaces of a VM with the help of the VMTools software.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vmtools_v6_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Vmtools_v6_enabled { get; set; } = false;
    
    
    }
    
    /// <summary>A CRL is a time-stamped list identifying revoked certificates.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class X509Crl 
    {
        /// <summary>Next update time for the CRL.</summary>
        [Newtonsoft.Json.JsonProperty("next_update", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Next_update { get; set; }
    
        /// <summary>CRL's version number either 1 or 2.</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }
    
        /// <summary>List of X509CrlEntry.</summary>
        [Newtonsoft.Json.JsonProperty("crl_entries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<X509CrlEntry> Crl_entries { get; set; }
    
        /// <summary>Issuer's distinguished name. (DN)</summary>
        [Newtonsoft.Json.JsonProperty("issuer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Issuer { get; set; }
    
    
    }
    
    /// <summary>Collection of IP Addresses.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPAddressList 
    {
        /// <summary>The array contains IP addresses.</summary>
        [Newtonsoft.Json.JsonProperty("ip_addresses", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(4000)]
        public System.Collections.Generic.ICollection<string> Ip_addresses { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Ipv6NdraProfile : PolicyConfigResource
    {
        /// <summary>RA Mode</summary>
        [Newtonsoft.Json.JsonProperty("ra_mode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Ipv6NdraProfileRa_mode Ra_mode { get; set; } = SDKGenerator.Ipv6NdraProfileRa_mode.SLAAC_DNS_THROUGH_RA;
    
        /// <summary>RA Configuration</summary>
        [Newtonsoft.Json.JsonProperty("ra_config", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public RAConfig Ra_config { get; set; } = new RAConfig();
    
        /// <summary>The time, in milliseconds, between retransmitted neighbour
        /// solicitation messages. A value of 0 means unspecified.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("retransmit_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? Retransmit_interval { get; set; } = 1000L;
    
        /// <summary>DNS Configurations</summary>
        [Newtonsoft.Json.JsonProperty("dns_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RaDNSConfig Dns_config { get; set; }
    
        /// <summary>Neighbour reachable time duration in milliseconds.
        /// A value of 0 means unspecified.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reachable_timer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 3600000D)]
        public long? Reachable_timer { get; set; } = 0L;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MulticastRouteCsvRecord : CsvRecord
    {
        /// <summary>Transport node uuid or policy path.</summary>
        [Newtonsoft.Json.JsonProperty("transport_node", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_node { get; set; }
    
        /// <summary>Time for which multicast route entry is active.</summary>
        [Newtonsoft.Json.JsonProperty("uptime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uptime { get; set; }
    
        /// <summary>Multicast group address.</summary>
        [Newtonsoft.Json.JsonProperty("group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group { get; set; }
    
        /// <summary>Time-to-live value for multicast packets.</summary>
        [Newtonsoft.Json.JsonProperty("ttl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Ttl { get; set; }
    
        /// <summary>Ingress interface on which multicast traffic is learned.</summary>
        [Newtonsoft.Json.JsonProperty("input_interface", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Input_interface { get; set; }
    
        /// <summary>Multicast source address.</summary>
        [Newtonsoft.Json.JsonProperty("source_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source_address { get; set; }
    
        /// <summary>Egress interface on which multicast traffic is forwarded.</summary>
        [Newtonsoft.Json.JsonProperty("output_interface", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Output_interface { get; set; }
    
    
    }
    
    /// <summary>Realized NSService</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedNSService : RealizedService
    {
        /// <summary>Realized nsservice type</summary>
        [Newtonsoft.Json.JsonProperty("service_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RealizedNSServiceService_type? Service_type { get; set; }
    
    
    }
    
    /// <summary>Segment configuration to attach workloads.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Segment : PolicyConfigResource
    {
        /// <summary>Subnet configuration. Max 1 subnet</summary>
        [Newtonsoft.Json.JsonProperty("subnets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SegmentSubnet> Subnets { get; set; }
    
        /// <summary>Policy path to the connecting Tier-0 or Tier-1.
        /// Valid only for segments created under Infra.
        /// This field can only be used for overlay segments.
        /// VLAN backed segments cannot have connectivity path set.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("connectivity_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Connectivity_path { get; set; }
    
        /// <summary>This property could be used for vendor specific configuration in key value
        /// string pairs, the setting in extra_configs will be automatically inheritted
        /// by segment ports in the Segment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("extra_configs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SegmentExtraConfig> Extra_configs { get; set; }
    
        /// <summary>Advanced configuration for Segment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("advanced_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SegmentAdvancedConfig Advanced_config { get; set; }
    
        /// <summary>Static address binding used for the Segment. This field is deprecated and will be removed in a future release. Please use address_bindings in SegmentPort to configure static bindings.</summary>
        [Newtonsoft.Json.JsonProperty("address_bindings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(512)]
        public System.Collections.Generic.ICollection<PortAddressBindingEntry> Address_bindings { get; set; }
    
        /// <summary>Additional config for federation.</summary>
        [Newtonsoft.Json.JsonProperty("federation_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FederationConnectivityConfig Federation_config { get; set; }
    
        /// <summary>Policy path to the EvpnTenantConfig resource. Supported only for Route-Server Evpn Mode.
        /// Supported only for Overlay Segments. This will be populated for both Parent and Child segments
        /// participating in Evpn Route-Server Mode.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("evpn_tenant_config_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Evpn_tenant_config_path { get; set; }
    
        /// <summary>Mac pool id that associated with a Segment.</summary>
        [Newtonsoft.Json.JsonProperty("mac_pool_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Mac_pool_id { get; set; }
    
        /// <summary>Multiple distinct L2 bridge profiles can be configured.</summary>
        [Newtonsoft.Json.JsonProperty("bridge_profiles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<BridgeProfileConfig> Bridge_profiles { get; set; }
    
        /// <summary>VLAN ids for a VLAN backed Segment.
        /// Can be a VLAN id or a range of VLAN ids specified with '-' in between.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vlan_ids", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Vlan_ids { get; set; }
    
        /// <summary>DNS domain name</summary>
        [Newtonsoft.Json.JsonProperty("domain_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Domain_name { get; set; }
    
        /// <summary>Used for overlay connectivity of segments. The overlay_id
        /// should be allocated from the pool as definied by enforcement-point.
        /// If not provided, it is auto-allocated from the default pool on the
        /// enforcement-point.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overlay_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 2147483647D)]
        public long? Overlay_id { get; set; }
    
        /// <summary>Policy path to DHCP server or relay configuration to use for all
        /// IPv4 &amp; IPv6 subnets configured on this segment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dhcp_config_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dhcp_config_path { get; set; }
    
        /// <summary>This property is deprecated. The property will continue to work as
        /// expected for existing segments. The segments that are newly created
        /// with ls_id will be ignored.
        /// Sepcify pre-creted logical switch id for Segment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ls_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ls_id { get; set; }
    
        /// <summary>Flag to indicate if the Segment is a Child-Segment of type EVPN.</summary>
        [Newtonsoft.Json.JsonProperty("evpn_segment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Evpn_segment { get; set; }
    
        /// <summary>Represents Desired state of the Segment</summary>
        [Newtonsoft.Json.JsonProperty("admin_state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SegmentAdmin_state? Admin_state { get; set; } = SDKGenerator.SegmentAdmin_state.UP;
    
        /// <summary>Policy path to metadata proxy configuration. Multiple distinct MD proxies can be configured.</summary>
        [Newtonsoft.Json.JsonProperty("metadata_proxy_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Metadata_proxy_paths { get; set; }
    
        /// <summary>Segment type based on configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SegmentType? Type { get; set; }
    
        /// <summary>Configuration for extending Segment through L2 VPN</summary>
        [Newtonsoft.Json.JsonProperty("l2_extension", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public L2Extension L2_extension { get; set; }
    
        /// <summary>Policy path to the transport zone. Supported for VLAN backed segments
        /// as well as Overlay Segments.
        /// - This field is required for VLAN backed Segments.
        /// - For overlay Segments, it is auto assigned if only one transport zone
        ///   exists in the enforcement point. Default transport zone is auto
        ///   assigned for  overlay segments if none specified.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transport_zone_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_zone_path { get; set; }
    
        /// <summary>If this field is not set for overlay segment, then the default of MTEP
        /// will be used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("replication_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SegmentReplication_mode? Replication_mode { get; set; } = SDKGenerator.SegmentReplication_mode.MTEP;
    
    
    }
    
    /// <summary>Consolidated Realized Status of an intent object across enforcement points.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConsolidatedRealizedStatus : AggregatePolicyRuntimeInfo
    {
        /// <summary>Represent highest intent version across all realized objects</summary>
        [Newtonsoft.Json.JsonProperty("intent_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Intent_version { get; set; }
    
        /// <summary>Aggregated Realization state of this object</summary>
        [Newtonsoft.Json.JsonProperty("publish_status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConsolidatedRealizedStatusPublish_status Publish_status { get; set; }
    
        /// <summary>Consolidated Realized Status across enforcement points.</summary>
        [Newtonsoft.Json.JsonProperty("consolidated_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConsolidatedStatus Consolidated_status { get; set; }
    
        /// <summary>List of Consolidated Realized Status per enforcement point.</summary>
        [Newtonsoft.Json.JsonProperty("consolidated_status_per_enforcement_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ConsolidatedStatusPerEnforcementPoint> Consolidated_status_per_enforcement_point { get; set; }
    
    
    }
    
    /// <summary>Forwarding rule that determine how to forward traffic from a VM.
    /// Traffic from VM can either be routed via Overlay or Underlay when VM is on hybrid port.
    /// Additionally NAT can be performed for VM or container on overlay to route traffic to/from underlay
    /// ROUTE_TO_UNDERLAY - Access a service on underlay space from a VM connected to hybrid port. Eg access to AWS S3 on AWS underlay
    /// ROUTE_TO_OVERLAY -  Access a service on overlay space from a VM connected to hybrid port.
    /// ROUTE_FROM_UNDERLAY - Access a service hosted on a VM (that is connected to hybrid port) from underlay space. Eg access from AWS ELB to VM
    /// ROUTE_FROM_OVERLAY - Access a  service hosted on a VM (that is connected to hybrid port) from overlay space
    /// NAT_FROM_UNDERLAY - Access a service on overlay VM/container from underlay space using DNAT from underlay IP to overlay IP
    /// NAT_TO_UNDERLAY - Access an underlay service from a VM/container on overlay space using SNAT from overlay IP to underlay IP
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ForwardingRule : BaseRule
    {
        /// <summary>The action to be applied to all the services
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ForwardingRuleAction? Action { get; set; }
    
    
    }
    
    /// <summary>Service Reference List</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServiceReferenceListResult : ListResult
    {
        /// <summary>Service Reference list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ServiceReference> Results { get; set; } = new System.Collections.ObjectModel.Collection<ServiceReference>();
    
    
    }
    
    /// <summary>Related attribute on the target resource for conditional constraints based
    /// on related attribute value.
    /// Example - destinationGroups/service/action is related attribute of
    ///   sourceGroups in communcation entry.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RelatedAttribute 
    {
        /// <summary>Related attribute name on the target entity.</summary>
        [Newtonsoft.Json.JsonProperty("attribute", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Attribute { get; set; }
    
    
    }
    
    /// <summary>Network error related to container objects.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class NetworkError 
    {
        /// <summary>Detailed message of network related error.</summary>
        [Newtonsoft.Json.JsonProperty("error_message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error_message { get; set; }
    
        /// <summary>Error code of network related error.</summary>
        [Newtonsoft.Json.JsonProperty("error_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error_code { get; set; }
    
        /// <summary>Additional error information in json format.</summary>
        [Newtonsoft.Json.JsonProperty("spec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Spec { get; set; }
    
    
    }
    
    /// <summary>This entity will be used to establish association between qos profile
    /// and Segment. Using this entity, you can specify intent for applying
    /// qos profile to particular segment.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentQoSProfileBindingMap : QoSProfileBindingMap
    {
        /// <summary>PolicyPath of associated  QoS Profile</summary>
        [Newtonsoft.Json.JsonProperty("qos_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Qos_profile_path { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RuntimeInterfaceStatistics : SIAggregatedDataCounterEx
    {
        /// <summary>Timestamp when the data was last updated; unset if data source has never updated the data.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>Index of the interface</summary>
        [Newtonsoft.Json.JsonProperty("interface_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Interface_index { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FeaturePermissionArray 
    {
        /// <summary>Array of FeaturePermission</summary>
        [Newtonsoft.Json.JsonProperty("feature_permissions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FeaturePermission> Feature_permissions { get; set; } = new System.Collections.ObjectModel.Collection<FeaturePermission>();
    
    
    }
    
    /// <summary>DistributedVirtualSwitch on a VC</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DistributedVirtualSwitch : VirtualSwitch
    {
        /// <summary>Array of discovered nodes connected to this switch.</summary>
        [Newtonsoft.Json.JsonProperty("discovered_nodes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<DiscoveredNode> Discovered_nodes { get; set; }
    
        /// <summary>Uplink portgroup of distributed virtual switch</summary>
        [Newtonsoft.Json.JsonProperty("uplink_portgroup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DistributedVirtualPortgroup Uplink_portgroup { get; set; }
    
        /// <summary>UUID of the switch</summary>
        [Newtonsoft.Json.JsonProperty("uuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uuid { get; set; }
    
        /// <summary>Key-Value map of additional properties of switch</summary>
        [Newtonsoft.Json.JsonProperty("origin_properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyValuePair> Origin_properties { get; set; }
    
        /// <summary>It contains information about VMware specific multiple dynamic
        /// LACP groups.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lacp_group_configs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LacpGroupConfigInfo> Lacp_group_configs { get; set; }
    
        /// <summary>The uniform name of uplink ports on each host.</summary>
        [Newtonsoft.Json.JsonProperty("uplink_port_names", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Uplink_port_names { get; set; }
    
    
    }
    
    /// <summary>Answer of dns nslookup</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class NsxTDnsAnswer : PolicyDnsAnswerPerEnforcementPoint
    {
        /// <summary>Authoritative answers</summary>
        [Newtonsoft.Json.JsonProperty("authoritative_answers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(256)]
        public System.Collections.Generic.ICollection<NsxTDnsQueryAnswer> Authoritative_answers { get; set; }
    
        /// <summary>ID of the edge node that performed the query.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_node_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Edge_node_id { get; set; }
    
        /// <summary>Dns server ip address and port, format is "ip address#port".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dns_server", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Dns_server { get; set; }
    
        /// <summary>Non authoritative answers</summary>
        [Newtonsoft.Json.JsonProperty("non_authoritative_answers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(256)]
        public System.Collections.Generic.ICollection<NsxTDnsQueryAnswer> Non_authoritative_answers { get; set; }
    
        /// <summary>It can be NXDOMAIN or error message which is not consisted of
        /// authoritative_answer or non_authoritative_answer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("raw_answer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Raw_answer { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for ServiceSegment, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildServiceSegment : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ServiceSegment objects
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ServiceSegment", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ServiceSegment ServiceSegment { get; set; }
    
    
    }
    
    /// <summary>Represents an entity or portion to be plotted on a donut or stats chart.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DonutPart 
    {
        /// <summary>A numerical value that represents the portion or entity of the donut or stats chart.</summary>
        [Newtonsoft.Json.JsonProperty("field", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Field { get; set; }
    
        /// <summary>If true, legend will be shown only if the data for the part is available. This is applicable only if legends are specified in widget configuration.</summary>
        [Newtonsoft.Json.JsonProperty("hide_empty_legend", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Hide_empty_legend { get; set; } = false;
    
        /// <summary>If the condition is met then the part will be displayed. Examples of expression syntax are provided under 'example_request' section of 'CreateWidgetConfiguration' API.</summary>
        [Newtonsoft.Json.JsonProperty("condition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Condition { get; set; }
    
        /// <summary>Id of drilldown widget, if any. Id should be a valid id of an existing widget. A widget is considered as drilldown widget when it is associated with any other widget and provides more detailed information about any data item from the parent widget.</summary>
        [Newtonsoft.Json.JsonProperty("drilldown_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Drilldown_id { get; set; }
    
        /// <summary>If a section 'template' holds this donut or stats part, then the label is auto-generated from the fetched field values after applying the template.</summary>
        [Newtonsoft.Json.JsonProperty("label", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Label Label { get; set; }
    
        /// <summary>Hyperlink of the specified UI page that provides details. If drilldown_id is provided, then navigation cannot be used.</summary>
        [Newtonsoft.Json.JsonProperty("navigation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Navigation { get; set; }
    
        /// <summary>Multi-line text to be shown on tooltip while hovering over the portion.</summary>
        [Newtonsoft.Json.JsonProperty("tooltip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Tooltip> Tooltip { get; set; }
    
        /// <summary>Additional rendering or conditional evaluation of the field values to be performed, if any.</summary>
        [Newtonsoft.Json.JsonProperty("render_configuration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RenderConfiguration> Render_configuration { get; set; }
    
    
    }
    
    /// <summary>Snat auto map.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBSnatAutoMap : LBSnatTranslation
    {
    
    }
    
    /// <summary>This condition is used to match URI arguments aka query string of Http
    /// request messages, for example, in URI http://exaple.com?foo=1&amp;bar=2, the
    /// "foo=1&amp;bar=2" is the query string containing URI arguments. In an URI
    /// scheme, query string is indicated by the first question mark ("?")
    /// character and terminated by a number sign ("#") character or by the end of
    /// the URI.
    /// The uri_arguments field can be specified as a regular expression(Set
    /// match_type to REGEX). For example, "foo=(?&amp;lt;x&amp;gt;\d+)". It matches HTTP
    /// requests whose URI arguments containing "foo", the value of foo contains
    /// only digits. And the value of foo is captured as $x which can be used in
    /// LBRuleAction fields which support variables.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBHttpRequestUriArgumentsCondition : LBRuleCondition
    {
        /// <summary>URI arguments, aka query string of URI.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uri_arguments", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Uri_arguments { get; set; }
    
        /// <summary>Match type of URI arguments</summary>
        [Newtonsoft.Json.JsonProperty("match_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBHttpRequestUriArgumentsConditionMatch_type? Match_type { get; set; } = SDKGenerator.LBHttpRequestUriArgumentsConditionMatch_type.REGEX;
    
        /// <summary>If true, case is significant when comparing URI arguments.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("case_sensitive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Case_sensitive { get; set; } = true;
    
    
    }
    
    /// <summary>Returns the certificate and thumbprint of a remote TLS listener, if the
    /// listener is running and accepting requests. If the certificate cannot be
    /// retrieved, the result property describes the problem.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TlsListenerCertificate 
    {
        /// <summary>Result of get certificate operation.</summary>
        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TlsListenerCertificateResult? Result { get; set; }
    
        /// <summary>The certificate of the TLS listener.</summary>
        [Newtonsoft.Json.JsonProperty("certificate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public X509Certificate Certificate { get; set; }
    
        /// <summary>The SHA-256 thumbprint of the TLS listener.</summary>
        [Newtonsoft.Json.JsonProperty("thumbprint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Thumbprint { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of L2VPNServices</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VPNServiceListResult : ListResult
    {
        /// <summary>L2VPNService list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<L2VPNService> Results { get; set; } = new System.Collections.ObjectModel.Collection<L2VPNService>();
    
    
    }
    
    /// <summary>Advanced load balancer DnsServiceApplicationProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsServiceApplicationProfile 
    {
        /// <summary>Enable DNS query/response over TCP.
        /// This enables analytics for pass-through queries as well.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dns_over_tcp_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Dns_over_tcp_enabled { get; set; } = true;
    
        /// <summary>Specifies the IP address prefix length to use in the EDNS
        /// client subnet (ECS) option.
        /// When the incoming request does not have any ECS option and
        /// the prefix length is specified, an ECS option is inserted in
        /// the request passed to upstream server.
        /// If the incoming request already has an ECS option, the
        /// prefix length (and correspondingly the address) in the ECS
        /// option is updated, with the minimum of the prefix length
        /// present in the incoming and the configured prefix length,
        /// before passing the request to upstream server.
        /// Allowed values are 1-32.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edns_client_subnet_prefix_len", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 32D)]
        public long? Edns_client_subnet_prefix_len { get; set; }
    
        /// <summary>The &lt;domain-name&gt;  of the name server that was the original
        /// or primary source of data for this zone.
        /// This field is used in SOA records (mname) pertaining to all
        /// domain names specified as authoritative domain names.
        /// If not configured, domain name is used as name server in
        /// SOA response.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name_server", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name_server { get; set; }
    
        /// <summary>Enable stripping of EDNS client subnet (ecs) option towards
        /// client if DNS service inserts ecs option in the DNS query
        /// towards upstream servers.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ecs_stripping_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Ecs_stripping_enabled { get; set; } = true;
    
        /// <summary>Subdomain names serviced by this Virtual Service.
        /// These are configured as Ends-With semantics.
        /// Maximum of 100 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("domain_names", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Domain_names { get; set; }
    
        /// <summary>Specifies the TTL value (in seconds) for SOA (Start of
        /// Authority) (corresponding to a authoritative domain owned by
        /// this DNS Virtual Service) record's minimum TTL served by the
        /// DNS Virtual Service.
        /// Allowed values are 0-86400.
        /// Unit is SEC.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 30.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("negative_caching_ttl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 86400D)]
        public long? Negative_caching_ttl { get; set; } = 30L;
    
        /// <summary>Respond to AAAA queries with empty response when there are
        /// only IPV4 records.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("aaaa_empty_response", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Aaaa_empty_response { get; set; } = true;
    
        /// <summary>Specifies the number of IP addresses returned by the DNS
        /// Service.
        /// Enter 0 to return all IP addresses.
        /// Allowed values are 1-20.
        /// Special values are 0- 'Return all IP addresses'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("num_dns_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 20D)]
        public long? Num_dns_ip { get; set; } = 1L;
    
        /// <summary>Drop or respond to client when the DNS service encounters
        /// an error processing a client query.
        /// By default, such a request is dropped without any response,
        /// or passed through to a passthrough pool, if configured.
        /// When set to respond, an appropriate response is sent to
        /// client, e.g.
        /// NXDOMAIN response for non-existent records, empty NOERROR
        /// response for unsupported queries, etc.
        /// Enum options - DNS_ERROR_RESPONSE_ERROR,
        /// DNS_ERROR_RESPONSE_NONE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as DNS_ERROR_RESPONSE_NONE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("error_response", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBDnsServiceApplicationProfileError_response? Error_response { get; set; } = SDKGenerator.ALBDnsServiceApplicationProfileError_response.DNS_ERROR_RESPONSE_NONE;
    
        /// <summary>Specifies the TTL value (in seconds) for records served by
        /// DNS Service.
        /// Allowed values are 0-86400.
        /// Unit is SEC.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 30.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ttl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 86400D)]
        public long? Ttl { get; set; } = 30L;
    
        /// <summary>Enable DNS service to be aware of EDNS (Extension mechanism
        /// for DNS).
        /// EDNS extensions are parsed and shown in logs.
        /// For GSLB services, the EDNS client subnet option can be
        /// used to influence Load Balancing.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edns", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Edns { get; set; } = true;
    
        /// <summary>Email address of the administrator responsible for this
        /// zone.
        /// This field is used in SOA records (rname) pertaining to all
        /// domain names specified as authoritative domain names.
        /// If not configured, the default value 'hostmaster' is used
        /// in SOA responses.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as hostmaster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("admin_email", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Admin_email { get; set; } = "hostmaster";
    
        /// <summary>DNS zones hosted on this Virtual Service.
        /// Maximum of 100 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dns_zones", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDnsZone> Dns_zones { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer SSLCertificate object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSSLCertificate 
    {
        /// <summary>subjectAltName that provides additional subject identities.</summary>
        [Newtonsoft.Json.JsonProperty("subject_alt_names", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Subject_alt_names { get; set; }
    
        /// <summary>public_key of SSLCertificate.</summary>
        [Newtonsoft.Json.JsonProperty("public_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Public_key { get; set; }
    
        /// <summary>Placeholder for description of property self_signed of obj
        /// type SSLCertificate field type str  type boolean.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("self_signed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Self_signed { get; set; }
    
        /// <summary>certificate of SSLCertificate.</summary>
        [Newtonsoft.Json.JsonProperty("certificate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Certificate { get; set; }
    
        /// <summary>Placeholder for description of property issuer of obj type
        /// SSLCertificate field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("issuer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBSSLCertificateDescription Issuer { get; set; }
    
        /// <summary>certificate_signing_request of SSLCertificate.</summary>
        [Newtonsoft.Json.JsonProperty("certificate_signing_request", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Certificate_signing_request { get; set; }
    
        /// <summary>not_after of SSLCertificate.</summary>
        [Newtonsoft.Json.JsonProperty("not_after", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Not_after { get; set; }
    
        /// <summary>signature_algorithm of SSLCertificate.</summary>
        [Newtonsoft.Json.JsonProperty("signature_algorithm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Signature_algorithm { get; set; }
    
        /// <summary>Enum options - SSL_CERTIFICATE_GOOD,
        /// SSL_CERTIFICATE_EXPIRY_WARNING, SSL_CERTIFICATE_EXPIRED.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as SSL_CERTIFICATE_GOOD.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expiry_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBSSLCertificateExpiry_status? Expiry_status { get; set; } = SDKGenerator.ALBSSLCertificateExpiry_status.SSL_CERTIFICATE_GOOD;
    
        /// <summary>Placeholder for description of property chain_verified of
        /// obj type SSLCertificate field type str  type boolean.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("chain_verified", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Chain_verified { get; set; }
    
        /// <summary>version of SSLCertificate.</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }
    
        /// <summary>text of SSLCertificate.</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Text { get; set; }
    
        /// <summary>fingerprint of SSLCertificate.</summary>
        [Newtonsoft.Json.JsonProperty("fingerprint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fingerprint { get; set; }
    
        /// <summary>Placeholder for description of property key_params of obj
        /// type SSLCertificate field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key_params", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBSSLKeyParams Key_params { get; set; }
    
        /// <summary>serial_number of SSLCertificate.</summary>
        [Newtonsoft.Json.JsonProperty("serial_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Serial_number { get; set; }
    
        /// <summary>Number of days_until_expire.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 365.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("days_until_expire", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Days_until_expire { get; set; } = 365L;
    
        /// <summary>signature of SSLCertificate.</summary>
        [Newtonsoft.Json.JsonProperty("signature", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Signature { get; set; }
    
        /// <summary>not_before of SSLCertificate.</summary>
        [Newtonsoft.Json.JsonProperty("not_before", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Not_before { get; set; }
    
        /// <summary>Placeholder for description of property subject of obj type
        /// SSLCertificate field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subject", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBSSLCertificateDescription Subject { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for PolicyFirewallSessionTimerProfile,
    /// used in hierarchical API
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyFirewallSessionTimerProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyFirewallSessionTimerProfile object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyFirewallSessionTimerProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyFirewallSessionTimerProfile PolicyFirewallSessionTimerProfile { get; set; }
    
    
    }
    
    /// <summary>This entity will be used to establish association between Firewall Timer session
    /// profile and Group. Using this entity, user can specify intent for applying
    /// Firewall Timer session profile to particular Group.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyFirewallSessionTimerProfileBindingMap : PolicyConfigResource
    {
        /// <summary>Sequence number is used to resolve conflicts when two profiles get applied
        /// to a single port. Lower value gets higher precedence. Two binding maps
        /// having the same profile path should have the same sequence number.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sequence_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Sequence_number { get; set; }
    
        /// <summary>PolicyPath of associated Firewall Timer Session Profile</summary>
        [Newtonsoft.Json.JsonProperty("firewall_session_timer_profile_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Firewall_session_timer_profile_path { get; set; }
    
    
    }
    
    /// <summary>Multicast forwarding interface details.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MulticastForwardingInterface 
    {
        /// <summary>Interface id.</summary>
        [Newtonsoft.Json.JsonProperty("ifuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ifuid { get; set; }
    
    
    }
    
    /// <summary>Active Directory Domain</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DirectoryAdDomain : DirectoryDomain
    {
        /// <summary>Each active directory domain has a domain naming context (NC), which contains domain-specific data. The root of this naming context is represented by a domain's distinguished name (DN) and is typically referred to as the NC head.</summary>
        [Newtonsoft.Json.JsonProperty("base_distinguished_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Base_distinguished_name { get; set; }
    
        /// <summary>Each domain sync settings can be changed using this object. It is not required since there are default values used if there is no specification for this object.</summary>
        [Newtonsoft.Json.JsonProperty("sync_settings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DirectoryDomainSyncSettings Sync_settings { get; set; }
    
        /// <summary>NetBIOS names can contain all alphanumeric characters except for the certain disallowed characters. Names can contain a period, but names cannot start with a period. NetBIOS is similar to DNS in that it can serve as a directory service, but more limited as it has no provisions for a name hierarchy and names are limited to 15 characters. The netbios name is case insensitive and is stored in upper case regardless of input case.</summary>
        [Newtonsoft.Json.JsonProperty("netbios_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Netbios_name { get; set; }
    
        /// <summary>SelectiveSync settings toggle the SelectiveSync feature and
        /// selected OrgUnits. If this is not specified, SelectiveSync is
        /// disabled by default.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selective_sync_settings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SelectiveSyncSettings Selective_sync_settings { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of Sites.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SiteListResult : ListResult
    {
        /// <summary>Site list result.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Site> Results { get; set; } = new System.Collections.ObjectModel.Collection<Site>();
    
    
    }
    
    /// <summary>Endpoint Rule comes from user configuration. User configures Endpoint Rule to specify what services are applied on the groups.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EndpointRule : PolicyConfigResource
    {
        /// <summary>The policy paths of service profiles are listed here. It pecifies what
        /// services are applied on the group. Currently only one is allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service_profiles", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Service_profiles { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>We need paths as duplicate names may exist for groups under different
        /// domains. In order to specify all groups, use the constant "ANY". This
        /// is case insensitive. If "ANY" is used, it should be the ONLY element
        /// in the group array. Error will be thrown if ANY is used in conjunction
        /// with other values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("groups", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(50)]
        public System.Collections.Generic.ICollection<string> Groups { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>This field is used to resolve conflicts between multiple
        /// entries under EndpointPolicy. It will be system default value when not specified
        /// by user.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sequence_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 499D)]
        public long? Sequence_number { get; set; } = 0L;
    
    
    }
    
    /// <summary>A Policy Based VPN requires to define protect rules that match local and peer subnets. IPSec security associations is negotiated for each pair of local and peer subnet.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyBasedIPSecVpnSession : IPSecVpnSession
    {
        /// <summary>Rules</summary>
        [Newtonsoft.Json.JsonProperty("rules", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<IPSecVpnRule> Rules { get; set; } = new System.Collections.ObjectModel.Collection<IPSecVpnRule>();
    
    
    }
    
    /// <summary>Child wrapper object for SecurityZone, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildSecurityZone : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual SecurityZone object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("SecurityZone", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SecurityZone SecurityZone { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of ForwardingRules</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ForwardingRuleListResult : BaseRuleListResult
    {
        /// <summary>Rule list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ForwardingRule> Results { get; set; } = new System.Collections.ObjectModel.Collection<ForwardingRule>();
    
    
    }
    
    /// <summary>Defining access of a Group from a PolicyLbVirtualServer and binding to
    /// PolicyLbMonitorProfile.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyLbPoolAccess : PolicyConfigResource
    {
        /// <summary>Port for LoadBalancer to send connections to the PolicyLbPoolAccess's
        /// Group. Pool_port could be optional, if it is not specified, LB will use
        /// PolicyLbVirtualServer port to connect to backend servers. If the
        /// PolicyLbMonitorProfile is configured in PolicyLbPoolAccess and active
        /// monitor IP protocol is TCP/UDP(which requires TCP or UDP port number),
        /// monitor_port should be specified if pool_port is unset.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Pool_port { get; set; }
    
        /// <summary>IP Port list for applications within the Group to allow
        /// for non-uniform port usage by applications
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip_port_list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IPAddressPortPair> Ip_port_list { get; set; }
    
        /// <summary>Depending on the topology, Source NAT (SNAT) may be required to ensure
        /// traffic from the server destined to the client is received by the load
        /// balancer. SNAT can be enabled per pool. If SNAT is not enabled for a
        /// pool, then load balancer uses the client IP and port (spoofing) while
        /// establishing connections to the servers. This is referred to as no-SNAT
        /// or TRANSPARENT mode.  SNAT is enabled by default and will use the
        /// load balancer interface IP and an ephemeral port as the source IP and
        /// port of the server side connection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source_nat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyLbPoolAccessSource_nat? Source_nat { get; set; } = SDKGenerator.PolicyLbPoolAccessSource_nat.ENABLED;
    
        /// <summary>Load balanding algorithm controls how the incoming
        /// connections are distributed among the members.
        /// - ROUND_ROBIN - requests to the application servers are distributed
        /// in a round-robin fashion,
        /// - LEAST_CONNECTION - next request is assigned to the server with the
        /// least number of active connections
        /// </summary>
        [Newtonsoft.Json.JsonProperty("algorithm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyLbPoolAccessAlgorithm? Algorithm { get; set; } = SDKGenerator.PolicyLbPoolAccessAlgorithm.ROUND_ROBIN;
    
        /// <summary>Path of the PolicyLbMonitorProfile to actively monitor the
        /// PolicyLbPoolAccess's Group
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lb_monitor_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lb_monitor_profile { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer URIParamToken object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBURIParamToken 
    {
        /// <summary>Constant string to use as a token.</summary>
        [Newtonsoft.Json.JsonProperty("str_value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Str_value { get; set; }
    
        /// <summary>Token type for constructing the URI.
        /// Enum options - URI_TOKEN_TYPE_HOST, URI_TOKEN_TYPE_PATH,
        /// URI_TOKEN_TYPE_STRING, URI_TOKEN_TYPE_STRING_GROUP,
        /// URI_TOKEN_TYPE_REGEX.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBURIParamTokenType Type { get; set; }
    
        /// <summary>Index of the starting token in the incoming URI.</summary>
        [Newtonsoft.Json.JsonProperty("start_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Start_index { get; set; }
    
        /// <summary>Index of the ending token in the incoming URI.
        /// Allowed values are 0-65534.
        /// Special values are 65535 - 'end of string'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("end_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? End_index { get; set; }
    
    
    }
    
    /// <summary>Match condition for client certficate subject DN.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBClientCertificateSubjectDnCondition 
    {
        /// <summary>If true, case is significant when comparing subject DN value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("case_sensitive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Case_sensitive { get; set; } = true;
    
        /// <summary>Match type of subject DN.</summary>
        [Newtonsoft.Json.JsonProperty("match_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBClientCertificateSubjectDnConditionMatch_type? Match_type { get; set; } = SDKGenerator.LBClientCertificateSubjectDnConditionMatch_type.REGEX;
    
        /// <summary>Value of subject DN.</summary>
        [Newtonsoft.Json.JsonProperty("subject_dn", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Subject_dn { get; set; }
    
    
    }
    
    /// <summary>Mac Discovery Profile</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MacDiscoveryProfile : PolicyConfigResource
    {
        /// <summary>Indicates how long learned MAC address remain.</summary>
        [Newtonsoft.Json.JsonProperty("mac_learning_aging_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Mac_learning_aging_time { get; set; } = 600L;
    
        /// <summary>Allowing source MAC address learning</summary>
        [Newtonsoft.Json.JsonProperty("mac_learning_enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Mac_learning_enabled { get; set; }
    
        /// <summary>The policy after MAC Limit is exceeded</summary>
        [Newtonsoft.Json.JsonProperty("mac_limit_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public MacDiscoveryProfileMac_limit_policy? Mac_limit_policy { get; set; } = SDKGenerator.MacDiscoveryProfileMac_limit_policy.ALLOW;
    
        /// <summary>This property specifies the limit on the maximum number of MACs
        /// learned for a remote virtual machine's MAC to VTEP binding per
        /// overlay logical switch.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remote_overlay_mac_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(2048D, 8192D)]
        public long? Remote_overlay_mac_limit { get; set; } = 2048L;
    
        /// <summary>The maximum number of MAC addresses that can be learned on this port</summary>
        [Newtonsoft.Json.JsonProperty("mac_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4096D)]
        public long? Mac_limit { get; set; } = 4096L;
    
        /// <summary>Allowing source MAC address change</summary>
        [Newtonsoft.Json.JsonProperty("mac_change_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Mac_change_enabled { get; set; } = false;
    
        /// <summary>Allowing flooding for unlearned MAC for ingress traffic</summary>
        [Newtonsoft.Json.JsonProperty("unknown_unicast_flooding_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Unknown_unicast_flooding_enabled { get; set; } = true;
    
    
    }
    
    /// <summary>Advanced load balancer L4Policies object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBL4Policies 
    {
        /// <summary>ID of the virtual service L4 policy set.
        /// It is a reference to an object of type L4PolicySet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("l4_policy_set_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string L4_policy_set_path { get; set; }
    
        /// <summary>Index of the virtual service L4 policy set.</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public long Index { get; set; }
    
    
    }
    
    /// <summary>This entity will be used to establish association between monitoring profile
    /// and Segment. Using this entity, you can specify intent for applying
    /// monitoring profile to particular segment.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentMonitoringProfileBindingMap : MonitoringProfileBindingMap
    {
        /// <summary>PolicyPath of associated IPFIX L2 Profile</summary>
        [Newtonsoft.Json.JsonProperty("ipfix_l2_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ipfix_l2_profile_path { get; set; }
    
        /// <summary>PolicyPath of associated Port Mirroring Profile</summary>
        [Newtonsoft.Json.JsonProperty("port_mirroring_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Port_mirroring_profile_path { get; set; }
    
    
    }
    
    /// <summary>IPSec VPN session status summary, gives total, failed, degraded and established IPSec VPN sessions.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPsecVPNIKESessionSummary 
    {
        /// <summary>Number of established sessions.</summary>
        [Newtonsoft.Json.JsonProperty("established_sessions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Established_sessions { get; set; }
    
        /// <summary>Total sessions configured.</summary>
        [Newtonsoft.Json.JsonProperty("total_sessions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total_sessions { get; set; }
    
        /// <summary>Number of failed sessions.</summary>
        [Newtonsoft.Json.JsonProperty("failed_sessions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Failed_sessions { get; set; }
    
        /// <summary>Number of degraded sessions.</summary>
        [Newtonsoft.Json.JsonProperty("degraded_sessions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Degraded_sessions { get; set; }
    
    
    }
    
    /// <summary>Search response</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SearchResponse : ListResult
    {
        /// <summary>List of records matching the search query.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<object> Results { get; set; }
    
    
    }
    
    /// <summary>ServiceProfileGroups contains list of Groups referenced in Service Insertion Rules.To be considered, Service profile must be part of a Service chain and that Service chain must be used in a Rule.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServiceProfileGroups : ManagedResource
    {
        /// <summary>List of Groups Used in ServiceInsertion Rules.</summary>
        [Newtonsoft.Json.JsonProperty("groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<GroupInfo> Groups { get; set; }
    
    
    }
    
    /// <summary>All the filtering criteria objects extend from this abstract class.
    /// This is present for extensibility.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("IdsProfileConjunctionOperator", typeof(IdsProfileConjunctionOperator))]
    [JsonInheritanceAttribute("IdsProfileFilterCriteria", typeof(IdsProfileFilterCriteria))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsProfileCriteria 
    {
    
    }
    
    /// <summary>Collection of resource info objects</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ResourceInfoListResult : ListResult
    {
        /// <summary>Resource info list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyFineTuningResourceInfo> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyFineTuningResourceInfo>();
    
    
    }
    
    /// <summary>Advanced load balancer WafPSMLocationMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWafPSMLocationMatch 
    {
        /// <summary>Apply the rules only to requests that match the specified
        /// URI.
        /// If this is not set, the path will not be checked.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBPathMatch Path { get; set; }
    
        /// <summary>Apply the rules only to requests that match the specified
        /// Host header.
        /// If this is not set, the host header will not be checked.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("host", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHostHdrMatch Host { get; set; }
    
        /// <summary>Apply the rules only to requests that have the specified
        /// methods.
        /// If this is not set, the method will not be checked.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("methods", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBMethodMatch Methods { get; set; }
    
    
    }
    
    /// <summary>Detailed Realized Status Per Transport Node.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EnforcedStatusPerTransportNode 
    {
        /// <summary>Realized Status of an Intent object on this Transport Node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enforced_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EnforcedStatusNsxT Enforced_status { get; set; }
    
        /// <summary>Policy Path referencing the transport node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>UUID identifying uniquely the Transport Node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nsx_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Nsx_id { get; set; }
    
        /// <summary>Display name of the transport node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Display_name { get; set; }
    
    
    }
    
    /// <summary>A profile holding TCP, UDP and ICMP session timeout configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyFirewallSessionTimerProfile : PolicyConfigResource
    {
        /// <summary>The timeout value of connection in seconds after one endpoint sends an RST. The default value for Edges (i.e, Gateway, or Logical Router) may be different than Distributed Firewall hosts.</summary>
        [Newtonsoft.Json.JsonProperty("tcp_closed", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(10D, 4320000D)]
        public long Tcp_closed { get; set; } = 20L;
    
        /// <summary>The timeout value of connection in seconds after a second packet has been transferred. The default value for Edges (i.e, Gateway, or Logical Router) may be different than Distributed Firewall hosts.</summary>
        [Newtonsoft.Json.JsonProperty("tcp_opening", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(10D, 4320000D)]
        public long Tcp_opening { get; set; } = 30L;
    
        /// <summary>The timeout value of connection in seconds if the source host sends more than one packet but the destination host has never sent one back. The default value for Edges (i.e, Gateway, or Logical Router) may be different than Distributed Firewall hosts.</summary>
        [Newtonsoft.Json.JsonProperty("udp_single", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(10D, 4320000D)]
        public long Udp_single { get; set; } = 30L;
    
        /// <summary>The timeout value of connection in seconds after both FINs have been exchanged and connection is closed. The default value for Edges (i.e, Gateway, or Logical Router) may be different than Distributed Firewall hosts.</summary>
        [Newtonsoft.Json.JsonProperty("tcp_finwait", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(10D, 4320000D)]
        public long Tcp_finwait { get; set; } = 45L;
    
        /// <summary>The timeout value of connection in seconds after the first packet has been sent. The default value for Edges (i.e, Gateway, or Logical Router) may be different than Distributed Firewall hosts.</summary>
        [Newtonsoft.Json.JsonProperty("tcp_first_packet", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(10D, 4320000D)]
        public long Tcp_first_packet { get; set; } = 120L;
    
        /// <summary>The timeout value of connection in seconds after the first FIN has been sent. The default value for Edges (i.e, Gateway, or Logical Router) may be different than Distributed Firewall hosts.</summary>
        [Newtonsoft.Json.JsonProperty("tcp_closing", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(10D, 4320000D)]
        public long Tcp_closing { get; set; } = 120L;
    
        /// <summary>The timeout value of connection in seconds once the connection has become fully established. The default value for Edges (i.e, Gateway,or Logical Router) may be different than Distributed Firewall hosts.</summary>
        [Newtonsoft.Json.JsonProperty("tcp_established", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(120D, 4320000D)]
        public long Tcp_established { get; set; } = 43200L;
    
        /// <summary>The timeout value of connection in seconds if both hosts have sent packets. The default value for Edges (i.e, Gateway, or Logical Router) may be different than Distributed Firewall hosts.</summary>
        [Newtonsoft.Json.JsonProperty("udp_multiple", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(10D, 4320000D)]
        public long Udp_multiple { get; set; } = 60L;
    
        /// <summary>The timeout value for the connection after an ICMP error came back in response to an ICMP packet. The default value for Edges (i.e, Gateway, or Logical Router) may be different than Distributed Firewall hosts.</summary>
        [Newtonsoft.Json.JsonProperty("icmp_error_reply", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(10D, 4320000D)]
        public long Icmp_error_reply { get; set; } = 10L;
    
        /// <summary>The timeout value of connection in seconds after the first packet. This will be the initial timeout for the new UDP flow. The default value for Edges (i.e, Gateway, or Logical Router) may be different than Distributed Firewall hosts.</summary>
        [Newtonsoft.Json.JsonProperty("udp_first_packet", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(10D, 4320000D)]
        public long Udp_first_packet { get; set; } = 60L;
    
        /// <summary>The timeout value of connection in seconds after the first packet. This will be the initial timeout for the new ICMP flow. The default value for Edges (i.e, Gateway, or Logical Router) may be different than Distributed Firewall hosts.</summary>
        [Newtonsoft.Json.JsonProperty("icmp_first_packet", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(10D, 4320000D)]
        public long Icmp_first_packet { get; set; } = 20L;
    
    
    }
    
    /// <summary>All the types of the expression extend from this abstract class.
    /// This is present for extensibility.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("EntityInstanceCountConstraintExpression", typeof(EntityInstanceCountConstraintExpression))]
    [JsonInheritanceAttribute("ValueConstraintExpression", typeof(ValueConstraintExpression))]
    [JsonInheritanceAttribute("RelatedAttributeConditionalExpression", typeof(RelatedAttributeConditionalExpression))]
    [JsonInheritanceAttribute("FieldSanityConstraintExpression", typeof(FieldSanityConstraintExpression))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConstraintExpression : ManagedResource
    {
    
    }
    
    /// <summary>Advanced load balancer PriorityLabels object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBPriorityLabels : PolicyConfigResource
    {
        /// <summary>Equivalent priority labels in descending order.</summary>
        [Newtonsoft.Json.JsonProperty("equivalent_labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBEquivalentLabels> Equivalent_labels { get; set; }
    
    
    }
    
    /// <summary>Traffic statistics for a segment.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VpnPerSegmentTrafficStatistics 
    {
        /// <summary>Total number of outgoing packets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_out { get; set; }
    
        /// <summary>Total number of incoming packets dropped.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_receive_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_receive_error { get; set; }
    
        /// <summary>Total number of incoming bytes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bytes_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_in { get; set; }
    
        /// <summary>Total number of incoming Broadcast, Unknown unicast and Multicast (BUM) packets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bum_packets_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bum_packets_in { get; set; }
    
        /// <summary>Policy path referencing the segment on which stats are gathered.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("segment_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Segment_path { get; set; }
    
        /// <summary>Total number of outgoing Broadcast, Unknown unicast and Multicast (BUM) bytes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bum_bytes_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bum_bytes_out { get; set; }
    
        /// <summary>Total number of outgoing bytes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bytes_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_out { get; set; }
    
        /// <summary>Total number of packets dropped while sending for any reason.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_sent_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_sent_error { get; set; }
    
        /// <summary>Total number of outgoing Broadcast, Unknown unicast and Multicast (BUM) packets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bum_packets_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bum_packets_out { get; set; }
    
        /// <summary>Total number of incoming packets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_in { get; set; }
    
        /// <summary>Total number of incoming Broadcast, Unknown unicast and Multicast (BUM) bytes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bum_bytes_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bum_bytes_in { get; set; }
    
    
    }
    
    /// <summary>SSL protocol</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LbSslProtocolInfo 
    {
        /// <summary>Default SSL protocol flag</summary>
        [Newtonsoft.Json.JsonProperty("is_default", Required = Newtonsoft.Json.Required.Always)]
        public bool Is_default { get; set; }
    
        /// <summary>Secure/insecure SSL protocol flag</summary>
        [Newtonsoft.Json.JsonProperty("is_secure", Required = Newtonsoft.Json.Required.Always)]
        public bool Is_secure { get; set; }
    
        /// <summary>SSL protocol</summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LbSslProtocolInfoProtocol Protocol { get; set; }
    
    
    }
    
    /// <summary>Status of the Identity Firewall compute collection's VM.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdfwVirtualMachineCondition 
    {
        /// <summary>VM IDFW Status.</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IdfwVirtualMachineConditionStatus Status { get; set; }
    
        /// <summary>IDFW compute collection's VM condition.</summary>
        [Newtonsoft.Json.JsonProperty("status_detail", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Status_detail { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LdapIdentitySourceSearchResultItem 
    {
        /// <summary>Distinguished name (DN) of the entry.</summary>
        [Newtonsoft.Json.JsonProperty("dn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dn { get; set; }
    
        /// <summary>The Common Name (CN) of the entry, if available.</summary>
        [Newtonsoft.Json.JsonProperty("common_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Common_name { get; set; }
    
        /// <summary>For Active Directory (AD) users, this will be the user principal name (UPN), in the format user@domain. For non-AD users, this will be the user's uid property, followed by "@" and the domain of the directory. For groups, this will be the group's common name, followed by "@" and the domain of the directory.</summary>
        [Newtonsoft.Json.JsonProperty("principal_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Principal_name { get; set; }
    
        /// <summary>Describes the type of the entry</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LdapIdentitySourceSearchResultItemType? Type { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SIAggregatedDataCounterEx : SIAggregatedDataCounter
    {
        [Newtonsoft.Json.JsonProperty("mac_learning", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SIMacLearningCounters Mac_learning { get; set; }
    
        [Newtonsoft.Json.JsonProperty("dropped_by_security_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SIPacketsDroppedBySecurity Dropped_by_security_packets { get; set; }
    
    
    }
    
    /// <summary>Parameters to let the admin specify a relative position of a security
    /// policy or rule w.r.t to another one.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyInsertParameters 
    {
        /// <summary>The security policy/rule path if operation is 'insert_after' or
        /// 'insert_before'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("anchor_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Anchor_path { get; set; }
    
        /// <summary>Operation</summary>
        [Newtonsoft.Json.JsonProperty("operation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyInsertParametersOperation? Operation { get; set; } = SDKGenerator.PolicyInsertParametersOperation.Insert_top;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyEdgeClusterInterSiteBgpSummary 
    {
        /// <summary>Edge cluster path whose status is being reported.</summary>
        [Newtonsoft.Json.JsonProperty("edge_cluster_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Edge_cluster_path { get; set; }
    
        /// <summary>Status of all edge nodes within cluster.</summary>
        [Newtonsoft.Json.JsonProperty("edge_nodes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyEdgeNodeInterSiteBgpSummary> Edge_nodes { get; set; }
    
    
    }
    
    /// <summary>Paged collection of Tier-0 Interfaces</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier0InterfaceListResult : ListResult
    {
        /// <summary>Tier-0 Interface list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Tier0Interface> Results { get; set; } = new System.Collections.ObjectModel.Collection<Tier0Interface>();
    
    
    }
    
    /// <summary>Credential info to connect to a node in the federated remote site.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SiteNodeConnectionInfo 
    {
        /// <summary>Username to connect to Site's Local Manager.</summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Username { get; set; }
    
        /// <summary>Password to connect to Site's Local Manager.</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Password { get; set; }
    
        /// <summary>Please specify the fqdn of the Management Node of your site.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fqdn", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Fqdn { get; set; }
    
        /// <summary>Thumbprint of Site's Local Manager in the form of a SHA-256 hash represented in lower case HEX.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thumbprint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Thumbprint { get; set; }
    
    
    }
    
    /// <summary>Error along with its metadata</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ErrorResolverMetadata 
    {
        /// <summary>The error id as reported by the entity where the error occurred.</summary>
        [Newtonsoft.Json.JsonProperty("error_id", Required = Newtonsoft.Json.Required.Always)]
        public long Error_id { get; set; }
    
        /// <summary>This can come from some external system like syslog collector</summary>
        [Newtonsoft.Json.JsonProperty("system_metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ErrorResolverSystemMetadata System_metadata { get; set; }
    
        /// <summary>The entity/node UUID where the error has occurred.</summary>
        [Newtonsoft.Json.JsonProperty("entity_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Entity_id { get; set; }
    
        /// <summary>User supplied metadata that might be required by the resolver</summary>
        [Newtonsoft.Json.JsonProperty("user_metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ErrorResolverUserMetadata User_metadata { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer StringGroup object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBStringGroup : PolicyConfigResource
    {
        /// <summary>Enable the longest match, default is the shortest match.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("longest_match", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Longest_match { get; set; } = false;
    
        /// <summary>Type of StringGroup.
        /// Enum options - SG_TYPE_STRING, SG_TYPE_KEYVAL.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as SG_TYPE_STRING.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBStringGroupType Type { get; set; } = SDKGenerator.ALBStringGroupType.SG_TYPE_STRING;
    
        /// <summary>Configure Key Value in the string group.</summary>
        [Newtonsoft.Json.JsonProperty("kv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBKeyValue> Kv { get; set; }
    
    
    }
    
    /// <summary>Realized Virtual Machine</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedVirtualMachine : PolicyRealizedResource
    {
        /// <summary>Id of the host on which the vm exists.</summary>
        [Newtonsoft.Json.JsonProperty("host_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Host_id { get; set; }
    
        /// <summary>Id of the vm unique within the host.</summary>
        [Newtonsoft.Json.JsonProperty("local_id_on_host", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Local_id_on_host { get; set; }
    
        /// <summary>Current power state of this virtual machine in the system.</summary>
        [Newtonsoft.Json.JsonProperty("power_state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RealizedVirtualMachinePower_state? Power_state { get; set; }
    
        /// <summary>List of external compute ids of the virtual machine in the format 'id-type-key:value' , list of external compute ids ['uuid:xxxx-xxxx-xxxx-xxxx', 'moIdOnHost:moref-11', 'instanceUuid:xxxx-xxxx-xxxx-xxxx']</summary>
        [Newtonsoft.Json.JsonProperty("compute_ids", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Compute_ids { get; set; }
    
    
    }
    
    /// <summary>LDAP server of directory domain</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DirectoryLdapServer : ManagedResource
    {
        /// <summary>Directory LDAP server connection user name.</summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Username { get; set; }
    
        /// <summary>Directory LDAP server DNS host name or ip address which is reachable by NSX manager to be connected and do object synchronization.</summary>
        [Newtonsoft.Json.JsonProperty("host", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Host { get; set; }
    
        /// <summary>Directory LDAP server connection protocol which is either LDAP or LDAPS.</summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DirectoryLdapServerProtocol? Protocol { get; set; } = SDKGenerator.DirectoryLdapServerProtocol.LDAP;
    
        /// <summary>Directory LDAP server certificate thumbprint used in secure LDAPS connection.</summary>
        [Newtonsoft.Json.JsonProperty("thumbprint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Thumbprint { get; set; }
    
        /// <summary>Directory LDAP server connection password.</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Password { get; set; }
    
        /// <summary>Directory domain name which best describes the domain. It could be unique fqdn name or it could also be descriptive. There is no unique contraint for domain name among different domains.</summary>
        [Newtonsoft.Json.JsonProperty("domain_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Domain_name { get; set; }
    
        /// <summary>Directory LDAP server connection TCP/UDP port.</summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Port { get; set; } = 389L;
    
    
    }
    
    /// <summary>Advanced load balancer SSLCertificateDescription object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSSLCertificateDescription 
    {
        /// <summary>common_name of SSLCertificateDescription.</summary>
        [Newtonsoft.Json.JsonProperty("common_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Common_name { get; set; }
    
        /// <summary>state of SSLCertificateDescription.</summary>
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string State { get; set; }
    
        /// <summary>organization of SSLCertificateDescription.</summary>
        [Newtonsoft.Json.JsonProperty("organization", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Organization { get; set; }
    
        /// <summary>locality of SSLCertificateDescription.</summary>
        [Newtonsoft.Json.JsonProperty("locality", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Locality { get; set; }
    
        /// <summary>distinguished_name of SSLCertificateDescription.</summary>
        [Newtonsoft.Json.JsonProperty("distinguished_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Distinguished_name { get; set; }
    
        /// <summary>country of SSLCertificateDescription.</summary>
        [Newtonsoft.Json.JsonProperty("country", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Country { get; set; }
    
        /// <summary>organization_unit of SSLCertificateDescription.</summary>
        [Newtonsoft.Json.JsonProperty("organization_unit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Organization_unit { get; set; }
    
        /// <summary>email_address of SSLCertificateDescription.</summary>
        [Newtonsoft.Json.JsonProperty("email_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Email_address { get; set; }
    
    
    }
    
    /// <summary>GroupInfo contains information about a particular Group used in Redirection Rules. It also contains information about policy path, if the group is created from Policy.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GroupInfo 
    {
        /// <summary>Group Data.</summary>
        [Newtonsoft.Json.JsonProperty("group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceReference Group { get; set; }
    
        /// <summary>Policy path of a particular Group.</summary>
        [Newtonsoft.Json.JsonProperty("group_policy_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group_policy_path { get; set; }
    
    
    }
    
    /// <summary>Allocation parameters for the IP address (e.g. specific IP address) can be specified. Tags, display_name and description attributes are not supported in this release.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IpAddressAllocation : PolicyConfigResource
    {
        /// <summary>Address that is allocated from pool</summary>
        [Newtonsoft.Json.JsonProperty("allocation_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Allocation_ip { get; set; }
    
    
    }
    
    /// <summary>Represents MAC address expressions in the form of an array, to support addition of MAC addresses in a group. Avoid creating groups with multiple MACAddressExpression. In future releases, group will be restricted to contain a single MACAddressExpression. To group MAC addresses, use nested groups instead of multiple MACAddressExpression.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MACAddressExpression : Expression
    {
        /// <summary>This array can consist of one or more MAC addresses.</summary>
        [Newtonsoft.Json.JsonProperty("mac_addresses", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(4000)]
        public System.Collections.Generic.ICollection<string> Mac_addresses { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BgpNeighborRoutesListResult : ListResult
    {
        /// <summary>Paged Collection of Bgp neighbor routes.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<BgpNeighborRoutes> Results { get; set; }
    
    
    }
    
    /// <summary>DHCP configuration of IPv4 subnet in a segment</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentDhcpV4Config : SegmentDhcpConfig
    {
        /// <summary>IPv4 DHCP options for segment subnet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("options", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DhcpV4Options Options { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of IPSecVpnDpdProfile.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnDpdProfileListResult : ListResult
    {
        /// <summary>IPSecVpnDpdProfile list results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IPSecVpnDpdProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<IPSecVpnDpdProfile>();
    
    
    }
    
    /// <summary>This entity will be used to establish association between Session Timer
    /// profile and Logical Routers.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SessionTimerProfileBindingMap : ProfileBindingMap
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Dhcpv6Header 
    {
        /// <summary>This is used to specify the DHCP v6 message. To request the assignment of one or more IPv6 addresses, a client first locates a DHCP server and then requests the assignment of addresses and other configuration information from the server. The client sends a Solicit message to the All_DHCP_Relay_Agents_and_Servers address to find available DHCP servers. Any server that can meet the client's requirements responds with an Advertise message. The client then chooses one of the servers and sends a Request message to the server asking for confirmed assignment of addresses and other configuration information. The server responds with a Reply message that contains the confirmed addresses and configuration. SOLICIT - A client sends a Solicit message to locate servers. ADVERTISE - A server sends and Advertise message to indicate that it is available. REQUEST - A client sends a Request message to request configuration parameters. REPLY - A server sends a Reply message containing assigned addresses and configuration parameters.</summary>
        [Newtonsoft.Json.JsonProperty("msg_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Dhcpv6HeaderMsg_type? Msg_type { get; set; } = SDKGenerator.Dhcpv6HeaderMsg_type.SOLICIT;
    
    
    }
    
    /// <summary>A ServiceEntry that represents an ethertype protocol</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EtherTypeServiceEntry : ServiceEntry
    {
        /// <summary>Type of the encapsulated protocol</summary>
        [Newtonsoft.Json.JsonProperty("ether_type", Required = Newtonsoft.Json.Required.Always)]
        public long Ether_type { get; set; }
    
    
    }
    
    /// <summary>L2VPN Service defines if service running as server or client. It also
    /// defines all the common properties for the multiple L2VPN Sessions
    /// associated with this service.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VPNService : PolicyConfigResource
    {
        /// <summary>IP Pool to allocate local and peer endpoint IPs for
        /// L2VpnSession logical tap.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("encap_ip_pool", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Encap_ip_pool { get; set; }
    
        /// <summary>Specify an L2VPN service mode as SERVER or CLIENT.</summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public L2VPNServiceMode? Mode { get; set; } = SDKGenerator.L2VPNServiceMode.SERVER;
    
        /// <summary>This property applies only in SERVER mode. If set to true,
        /// traffic from any client will be replicated to all other clients.
        /// If set to false, traffic received from clients is only replicated
        /// to the local VPN endpoint.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_hub", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_hub { get; set; } = false;
    
    
    }
    
    /// <summary>List of routes to be aggregated</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RouteAggregationEntry 
    {
        /// <summary>Send only summarized route.
        /// Summarization reduces number of routes advertised by representing
        /// multiple related routes with prefix property.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("summary_only", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Summary_only { get; set; } = true;
    
        /// <summary>CIDR of aggregate address</summary>
        [Newtonsoft.Json.JsonProperty("prefix", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Prefix { get; set; }
    
    
    }
    
    /// <summary>IPSec VPN tunnel traffic statistics.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnTunnelTrafficStatistics 
    {
        /// <summary>Total number of packets dropped while sending for any reason.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_sent_other_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_sent_other_error { get; set; }
    
        /// <summary>Total number of outgoing packets on outbound Security association.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_out { get; set; }
    
        /// <summary>Total number of outgoing packets dropped on outbound security association.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dropped_packets_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dropped_packets_out { get; set; }
    
        /// <summary>Total number of packets dropped due to integrity failures.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("integrity_failures", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Integrity_failures { get; set; }
    
        /// <summary>Number of packets dropped because of no matching policy is available.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nomatching_policy_errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Nomatching_policy_errors { get; set; }
    
        /// <summary>Totoal number of security association mismatch errors on incoming packets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sa_mismatch_errors_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Sa_mismatch_errors_in { get; set; }
    
        /// <summary>Total number of incoming packets dropped on inbound Security association.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_received_other_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_received_other_error { get; set; }
    
        /// <summary>Total number of packets dropped due to replay check on that Security association.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("replay_errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Replay_errors { get; set; }
    
        /// <summary>Total number of outgoing bytes on outbound Security association.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bytes_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_out { get; set; }
    
        /// <summary>Local subnet to which a tunnel belongs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("local_subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Local_subnet { get; set; }
    
        /// <summary>Total number of incoming packets dropped on inbound security association.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dropped_packets_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dropped_packets_in { get; set; }
    
        /// <summary>Total number of packets dropped because of failure in encryption.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("encryption_failures", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Encryption_failures { get; set; }
    
        /// <summary>Totoal number of security association mismatch errors on outgoing packets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sa_mismatch_errors_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Sa_mismatch_errors_out { get; set; }
    
        /// <summary>Gives the detailed reason about the tunnel when it is down. If tunnel
        /// is UP tunnel down reason will be empty.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tunnel_down_reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tunnel_down_reason { get; set; }
    
        /// <summary>Total number of incoming bytes on inbound Security association.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bytes_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_in { get; set; }
    
        /// <summary>Total number of packets dropped due to decryption failures.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("decryption_failures", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Decryption_failures { get; set; }
    
        /// <summary>Total number of packets dropped while sending due to overflow in sequence number.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("seq_number_overflow_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Seq_number_overflow_error { get; set; }
    
        /// <summary>Peer subnet to which a tunnel belongs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remote_subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Remote_subnet { get; set; }
    
        /// <summary>Total number of incoming packets on inbound Security association.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_in { get; set; }
    
        /// <summary>Specifies the status of tunnel, if it is UP/DOWN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tunnel_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPSecVpnTunnelTrafficStatisticsTunnel_status? Tunnel_status { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PktcapActionConfig 
    {
        /// <summary>Sample argument for packet capture</summary>
        [Newtonsoft.Json.JsonProperty("sampling_argument", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SamplingArgument Sampling_argument { get; set; }
    
        /// <summary>Action argument for packet capture</summary>
        [Newtonsoft.Json.JsonProperty("action_argument", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PktcapActionArgument Action_argument { get; set; }
    
    
    }
    
    /// <summary>Paged collection of IDS profiles</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsProfileListResult : ListResult
    {
        /// <summary>IDS profile list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IdsProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<IdsProfile>();
    
    
    }
    
    /// <summary>Advanced load balancer DnsQueryTypeMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsQueryTypeMatch 
    {
        /// <summary>DNS query types in the request query.
        /// Enum options - DNS_RECORD_OTHER, DNS_RECORD_A,
        /// DNS_RECORD_NS, DNS_RECORD_CNAME, DNS_RECORD_SOA,
        /// DNS_RECORD_PTR, DNS_RECORD_HINFO, DNS_RECORD_MX,
        /// DNS_RECORD_TXT, DNS_RECORD_RP, DNS_RECORD_DNSKEY,
        /// DNS_RECORD_AAAA, DNS_RECORD_SRV, DNS_RECORD_OPT,
        /// DNS_RECORD_RRSIG, DNS_RECORD_AXFR, DNS_RECORD_ANY.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("query_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Query_type> Query_type { get; set; }
    
        /// <summary>Criterion to use for matching the DNS query typein the
        /// question section.
        /// Enum options - IS_IN, IS_NOT_IN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBDnsQueryTypeMatchMatch_criteria Match_criteria { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of Deployment Zones.
    /// This is a deprecated type. DeploymentZone has been renamed to Site.
    /// Use SiteListResult.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DeploymentZoneListResult : ListResult
    {
        /// <summary>Deployment Zones</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<DeploymentZone> Results { get; set; } = new System.Collections.ObjectModel.Collection<DeploymentZone>();
    
    
    }
    
    /// <summary>Advanced load balancer LdapAuthSettings object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBLdapAuthSettings 
    {
        /// <summary>LDAP anonymous bind configuration.</summary>
        [Newtonsoft.Json.JsonProperty("user_bind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBLdapUserBindSettings User_bind { get; set; }
    
        /// <summary>LDAP connection security mode.
        /// Enum options - AUTH_LDAP_SECURE_NONE,
        /// AUTH_LDAP_SECURE_USE_LDAPS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("security_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBLdapAuthSettingsSecurity_mode? Security_mode { get; set; }
    
        /// <summary>LDAP attribute that refers to user's full name.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("full_name_attribute", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Full_name_attribute { get; set; } = "name";
    
        /// <summary>LDAP full directory configuration with administrator
        /// credentials.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBLdapDirectorySettings Settings { get; set; }
    
        /// <summary>The LDAP base DN.
        /// For example, avinetworks.com would be
        /// DC=avinetworks,DC=com.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("base_dn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Base_dn { get; set; }
    
        /// <summary>LDAP attribute that refers to user email.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as email.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("email_attribute", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Email_attribute { get; set; } = "email";
    
        /// <summary>LDAP administrator credentials are used to search for users
        /// and group memberships.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bind_as_administrator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Bind_as_administrator { get; set; } = true;
    
        /// <summary>Query the LDAP servers on this port.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 389.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Port { get; set; } = 389L;
    
        /// <summary>LDAP server IP address or Hostname.
        /// Use IP address if an auth profile is used to configure
        /// Virtual Service.
        /// Minimum of 1 items required.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Server { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>Cookie time.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "type")]
    [JsonInheritanceAttribute("LBSessionCookieTime", typeof(LBSessionCookieTime))]
    [JsonInheritanceAttribute("LBPersistenceCookieTime", typeof(LBPersistenceCookieTime))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBCookieTime 
    {
    
    }
    
    /// <summary>Authenticated User Info</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class UserInfo 
    {
        /// <summary>User Name</summary>
        [Newtonsoft.Json.JsonProperty("user_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User_name { get; set; }
    
        /// <summary>Permissions</summary>
        [Newtonsoft.Json.JsonProperty("roles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<NsxRole> Roles { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PacketTypeAndCounter 
    {
        /// <summary>The number of packets.</summary>
        [Newtonsoft.Json.JsonProperty("counter", Required = Newtonsoft.Json.Required.Always)]
        public long Counter { get; set; }
    
        /// <summary>The type of the packets</summary>
        [Newtonsoft.Json.JsonProperty("packet_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Packet_type { get; set; }
    
    
    }
    
    /// <summary>Represents a reference to a widget that is held by a container or a multi-widget or a View.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class WidgetItem 
    {
        /// <summary>Aligns widget either left or right.</summary>
        [Newtonsoft.Json.JsonProperty("alignment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public WidgetItemAlignment? Alignment { get; set; } = SDKGenerator.WidgetItemAlignment.LEFT;
    
        /// <summary>If true, separates this widget in a container.</summary>
        [Newtonsoft.Json.JsonProperty("separator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Separator { get; set; } = false;
    
        /// <summary>Id of the widget configuration that is held by a multi-widget or a container or a view.</summary>
        [Newtonsoft.Json.JsonProperty("widget_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string Widget_id { get; set; }
    
        /// <summary>Determines placement of widget or container relative to other widgets and containers. The lower the weight, the higher it is in the placement order.</summary>
        [Newtonsoft.Json.JsonProperty("weight", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Weight { get; set; } = 10000L;
    
        /// <summary>Applicable for 'DonutConfiguration' and 'StatsConfiguration' reports only. If label is not specified, then it defaults to the label of the donut or stats report.</summary>
        [Newtonsoft.Json.JsonProperty("label", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Label Label { get; set; }
    
    
    }
    
    /// <summary>This action is used to create a new variable and assign value to it.
    /// One action can be used to create one variable. To create multiple
    /// variables, multiple actions must be defined.
    /// The variables can be used by LBVariableCondition, etc.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBVariableAssignmentAction : LBRuleAction
    {
        /// <summary>Value of variable.</summary>
        [Newtonsoft.Json.JsonProperty("variable_value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Variable_value { get; set; }
    
        /// <summary>Name of the variable to be assigned.</summary>
        [Newtonsoft.Json.JsonProperty("variable_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Variable_name { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceActionArgument 
    {
        /// <summary>Please keep this aligned with pktcap_config, if you
        /// specify reverse_filter at pktcap_config.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reverse_filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LiveTraceFilterData Reverse_filter { get; set; }
    
        /// <summary>Please keep this aligned with pktcap_config, if you
        /// specify dest_lport at pktcap_config.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dest_lport", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dest_lport { get; set; }
    
        /// <summary>Type of trace</summary>
        [Newtonsoft.Json.JsonProperty("trace_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TraceActionArgumentTrace_type? Trace_type { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of TraceflowConfigs</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceflowConfigListResult : ListResult
    {
        /// <summary>TraceflowConfig list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<TraceflowConfig> Results { get; set; } = new System.Collections.ObjectModel.Collection<TraceflowConfig>();
    
    
    }
    
    /// <summary>DHCP options for IPv4 server.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DhcpV4Options 
    {
        /// <summary>DHCP option 121 to define classless static routes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("option121", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DhcpOption121 Option121 { get; set; }
    
        /// <summary>To define DHCP options other than option 121 in generic format.
        /// Please note, only the following options can be defined in generic
        /// format. Those other options will be accepted without validation
        /// but will not take effect.
        /// --------------------------
        ///   Code    Name
        /// --------------------------
        ///     2   Time Offset
        ///     6   Domain Name Server
        ///     13  Boot File Size
        ///     19  Forward On/Off
        ///     26  MTU Interface
        ///     28  Broadcast Address
        ///     35  ARP Timeout
        ///     40  NIS Domain
        ///     41  NIS Servers
        ///     42  NTP Servers
        ///     44  NETBIOS Name Srv
        ///     45  NETBIOS Dist Srv
        ///     46  NETBIOS Node Type
        ///     47  NETBIOS Scope
        ///     58  Renewal Time
        ///     59  Rebinding Time
        ///     64  NIS+-Domain-Name
        ///     65  NIS+-Server-Addr
        ///     66  TFTP Server-Name (used by PXE)
        ///     67  Bootfile-Name (used by PXE)
        ///     93  PXE: Client system architecture
        ///     94  PXE: Client NDI
        ///     97  PXE: UUID/UNDI
        ///     117 Name Service Search
        ///     119 Domain Search
        ///     150 TFTP server address (used by PXE)
        ///     175 Etherboot
        ///     209 PXE Configuration File
        ///     210 PXE Path Prefix
        ///     211 PXE Reboot Time
        /// </summary>
        [Newtonsoft.Json.JsonProperty("others", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(255)]
        public System.Collections.Generic.ICollection<GenericDhcpOption> Others { get; set; }
    
    
    }
    
    /// <summary>Snat disabled.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBSnatDisabled : LBSnatTranslation
    {
    
    }
    
    /// <summary>Aggregate of L2VPN Session Statistics across Enforcement Points.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregateL2VPNSessionStatistics : AggregatePolicyRuntimeInfo
    {
        /// <summary>List of L2VPN Session Statistics per Enforcement Point.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<L2VPNSessionStatisticsPerEP> Results { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of LBVirtualServers</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBVirtualServerListResult : ListResult
    {
        /// <summary>LBVirtualServer list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<LBVirtualServer> Results { get; set; } = new System.Collections.ObjectModel.Collection<LBVirtualServer>();
    
    
    }
    
    /// <summary>Advanced load balancer HSMThalesNetHsm object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHSMThalesNetHsm 
    {
        /// <summary>Priority class of the nethsm in an high availability setup.
        /// 1 is the highest priority and 100 is the lowest priority.
        /// Allowed values are 1-100.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 100.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1D, 100D)]
        public long Priority { get; set; } = 100L;
    
        /// <summary>Hash of the key that netHSM device uses to authenticate
        /// itself.
        /// Use Thales anonkneti utility to find the netHSM keyhash.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keyhash", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Keyhash { get; set; }
    
        /// <summary>Local module id of the netHSM device.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("module_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Module_id { get; set; } = 0L;
    
        /// <summary>Electronic serial number of the netHSM device.
        /// Use Thales anonkneti utility to find the netHSM ESN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("esn", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Esn { get; set; }
    
        /// <summary>Port at which the netHSM device accepts the connection.
        /// Allowed values are 1-65535.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 9004.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remote_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long? Remote_port { get; set; } = 9004L;
    
        /// <summary>IP address of the netHSM device.</summary>
        [Newtonsoft.Json.JsonProperty("remote_ip", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBIpAddr Remote_ip { get; set; } = new ALBIpAddr();
    
    
    }
    
    /// <summary>IPFIX data for the NSX distributed firewall will be sent to the specified
    /// IPFIX collectors.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPFIXDFWCollectorProfile : PolicyConfigResource
    {
        /// <summary>It accepts Multiple Collectors.</summary>
        [Newtonsoft.Json.JsonProperty("ipfix_dfw_collectors", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<IPFIXDFWCollector> Ipfix_dfw_collectors { get; set; } = new System.Collections.ObjectModel.Collection<IPFIXDFWCollector>();
    
    
    }
    
    /// <summary>List SegmentPort objects</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentPortListResult : ListResult
    {
        /// <summary>Place holder for the list result</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SegmentPort> Results { get; set; } = new System.Collections.ObjectModel.Collection<SegmentPort>();
    
    
    }
    
    /// <summary>Advanced load balancer SSLKeyECParams object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSSLKeyECParams 
    {
        /// <summary>Enum options - SSL_KEY_EC_CURVE_SECP256R1,
        /// SSL_KEY_EC_CURVE_SECP384R1, SSL_KEY_EC_CURVE_SECP521R1.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as SSL_KEY_EC_CURVE_SECP256R1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("curve", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBSSLKeyECParamsCurve? Curve { get; set; } = SDKGenerator.ALBSSLKeyECParamsCurve.SSL_KEY_EC_CURVE_SECP256R1;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MetadataProxyConfigListResult : ListResult
    {
        /// <summary>Paginated list of metadata proxy configurations</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<MetadataProxyConfig> Results { get; set; } = new System.Collections.ObjectModel.Collection<MetadataProxyConfig>();
    
    
    }
    
    /// <summary>This condition is used to match the HTTP protocol version of the HTTP
    /// request messages.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBHttpRequestVersionCondition : LBRuleCondition
    {
        /// <summary>HTTP version</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBHttpRequestVersionConditionVersion Version { get; set; }
    
    
    }
    
    /// <summary>PKIProfileApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBPKIProfileApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of PKIProfile
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBPKIProfile> Results { get; set; }
    
    
    }
    
    /// <summary>Describes the configuration of a widget to be displayed on the dashboard. WidgetConfiguration is a base type that provides attributes of a widget in-general.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("DropdownFilterWidgetConfiguration", typeof(DropdownFilterWidgetConfiguration))]
    [JsonInheritanceAttribute("FilterWidgetConfiguration", typeof(FilterWidgetConfiguration))]
    [JsonInheritanceAttribute("ContainerConfiguration", typeof(ContainerConfiguration))]
    [JsonInheritanceAttribute("GridConfiguration", typeof(GridConfiguration))]
    [JsonInheritanceAttribute("MultiWidgetConfiguration", typeof(MultiWidgetConfiguration))]
    [JsonInheritanceAttribute("LabelValueConfiguration", typeof(LabelValueConfiguration))]
    [JsonInheritanceAttribute("DonutConfiguration", typeof(DonutConfiguration))]
    [JsonInheritanceAttribute("GraphConfiguration", typeof(GraphConfiguration))]
    [JsonInheritanceAttribute("StatsConfiguration", typeof(StatsConfiguration))]
    [JsonInheritanceAttribute("CustomWidgetConfiguration", typeof(CustomWidgetConfiguration))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class WidgetConfiguration : ManagedResource
    {
        /// <summary>Features required to view the widget.</summary>
        [Newtonsoft.Json.JsonProperty("feature_set", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FeatureSet Feature_set { get; set; }
    
        /// <summary>Default filter values to be passed to datasources. This will be used when the report is requested without filter values.</summary>
        [Newtonsoft.Json.JsonProperty("default_filter_value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<DefaultFilterValue> Default_filter_value { get; set; }
    
        /// <summary>Title of the widget. If display_name is omitted, the widget will be shown without a title.</summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string Display_name { get; set; }
    
        /// <summary>The 'datasources' represent the sources from which data will be fetched. Currently, only NSX-API is supported as a 'default' datasource. An example of specifying 'default' datasource along with the urls to fetch data from is given at 'example_request' section of 'CreateWidgetConfiguration' API.</summary>
        [Newtonsoft.Json.JsonProperty("datasources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Datasource> Datasources { get; set; }
    
        /// <summary>Specify relavite weight in WidgetItem for placement in a view. Please see WidgetItem for details.</summary>
        [Newtonsoft.Json.JsonProperty("weight", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Weight { get; set; }
    
        [Newtonsoft.Json.JsonProperty("footer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Footer Footer { get; set; }
    
        /// <summary>Flag to indicate that widget will continue to work without filter value. If this flag is set to false then default_filter_value is manadatory.</summary>
        [Newtonsoft.Json.JsonProperty("filter_value_required", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Filter_value_required { get; set; } = true;
    
        /// <summary>Represents the horizontal span of the widget / container.</summary>
        [Newtonsoft.Json.JsonProperty("span", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 12D)]
        public long? Span { get; set; }
    
        /// <summary>Icons to be applied at dashboard for widgets and UI elements.</summary>
        [Newtonsoft.Json.JsonProperty("icons", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Icon> Icons { get; set; }
    
        /// <summary>Set to true if this widget should be used as a drilldown.</summary>
        [Newtonsoft.Json.JsonProperty("is_drilldown", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_drilldown { get; set; } = false;
    
        /// <summary>Id of filter widget for subscription, if any. Id should be a valid id of an existing filter widget. Filter widget should be from the same view. Datasource URLs should have placeholder values equal to filter alias to accept the filter value on filter change.</summary>
        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Filter { get; set; }
    
        /// <summary>Id of drilldown widget, if any. Id should be a valid id of an existing widget. A widget is considered as drilldown widget when it is associated with any other widget and provides more detailed information about any data item from the parent widget.</summary>
        [Newtonsoft.Json.JsonProperty("drilldown_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string Drilldown_id { get; set; }
    
        /// <summary>Please use the property 'shared' of View instead of this. The widgets of a shared view are visible to other users.</summary>
        [Newtonsoft.Json.JsonProperty("shared", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Shared { get; set; }
    
        /// <summary>Legend to be displayed. If legend is not needed, do not include it.</summary>
        [Newtonsoft.Json.JsonProperty("legend", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Legend Legend { get; set; }
    
    
    }
    
    /// <summary>Transport tunnel status.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("IPSecVpnTransportStatus", typeof(IPSecVpnTransportStatus))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VPNSessionTransportTunnelStatus 
    {
        /// <summary>Policy path referencing Transport Tunnel.</summary>
        [Newtonsoft.Json.JsonProperty("transport_tunnel_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_tunnel_path { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VirtualNetworkInterfaceListResult : ListResult
    {
        /// <summary>VirtualNetworkInterface list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<VirtualNetworkInterface> Results { get; set; } = new System.Collections.ObjectModel.Collection<VirtualNetworkInterface>();
    
    
    }
    
    /// <summary>Paged Collection of Domains</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DomainListResult : ListResult
    {
        /// <summary>Domain list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Domain> Results { get; set; } = new System.Collections.ObjectModel.Collection<Domain>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceflowObservationDropped : TraceflowObservation
    {
        /// <summary>The ID of the NAT rule that was applied to forward the traceflow packet</summary>
        [Newtonsoft.Json.JsonProperty("nat_rule_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Nat_rule_id { get; set; }
    
        /// <summary>The reason traceflow packet was dropped</summary>
        [Newtonsoft.Json.JsonProperty("reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TraceflowObservationDroppedReason? Reason { get; set; }
    
        /// <summary>The id of the logical port at which the traceflow packet was dropped</summary>
        [Newtonsoft.Json.JsonProperty("lport_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lport_id { get; set; }
    
        /// <summary>The name of the logical port at which the traceflow packet was dropped</summary>
        [Newtonsoft.Json.JsonProperty("lport_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lport_name { get; set; }
    
        /// <summary>The id of the acl rule that was applied to drop the traceflow packet</summary>
        [Newtonsoft.Json.JsonProperty("acl_rule_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Acl_rule_id { get; set; }
    
        /// <summary>This field specifies the ARP fails reason ARP_TIMEOUT - ARP failure due to query control plane timeout ARP_CPFAIL - ARP failure due post ARP query message to control plane failure ARP_FROMCP - ARP failure due to deleting ARP entry from control plane ARP_PORTDESTROY - ARP failure due to port destruction ARP_TABLEDESTROY - ARP failure due to ARP table destruction ARP_NETDESTROY - ARP failure due to overlay network destruction</summary>
        [Newtonsoft.Json.JsonProperty("arp_fail_reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TraceflowObservationDroppedArp_fail_reason? Arp_fail_reason { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsRuleAction object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsRuleAction 
    {
        /// <summary>Select a pool or pool group for the passthrough DNS query
        /// which cannot be served locally but could be served by
        /// upstream servers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_switching", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDnsRuleActionPoolSwitching Pool_switching { get; set; }
    
        /// <summary>Select a specific GSLB site for the DNS query.
        /// This action should be used only when GSLB services have
        /// been configured for the DNS virtual service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gslb_site_selection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDnsRuleActionGslbSiteSelection Gslb_site_selection { get; set; }
    
        /// <summary>Generate a response for the DNS query.</summary>
        [Newtonsoft.Json.JsonProperty("response", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDnsRuleActionResponse Response { get; set; }
    
        /// <summary>Allow or drop the DNS query.</summary>
        [Newtonsoft.Json.JsonProperty("allow", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDnsRuleActionAllowDrop Allow { get; set; }
    
        /// <summary>Rate limits the DNS requests.</summary>
        [Newtonsoft.Json.JsonProperty("dns_rate_limiter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDnsRateLimiter Dns_rate_limiter { get; set; }
    
    
    }
    
    /// <summary>Ipaddress information of the fabric node.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IpAddressInfo 
    {
        /// <summary>Source of the ipaddress information.</summary>
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IpAddressInfoSource? Source { get; set; }
    
        /// <summary>IP Addresses of the the virtual network interface, as discovered in the source.</summary>
        [Newtonsoft.Json.JsonProperty("ip_addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Ip_addresses { get; set; }
    
    
    }
    
    /// <summary>Restore step info</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RestoreStep 
    {
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PerStepRestoreStatus Status { get; set; }
    
        /// <summary>Restore step number</summary>
        [Newtonsoft.Json.JsonProperty("step_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Step_number { get; set; }
    
        /// <summary>Restore step description</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Restore step value</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }
    
    
    }
    
    /// <summary>LBVirtualServerStatus on specific Enforcement Point</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("LBVirtualServerStatus", typeof(LBVirtualServerStatus))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBVirtualServerStatusPerEP : PolicyRuntimeInfoPerEP
    {
    
    }
    
    /// <summary>Child wrapper object for L2Vpn, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildL2Vpn : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual L2Vpn object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("L2Vpn", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public L2Vpn L2Vpn { get; set; }
    
    
    }
    
    /// <summary>Unary Operation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class UnaryOperation 
    {
        /// <summary>Logical Operator describing the operation to apply to the operand.</summary>
        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public UnaryOperationOperator Operator { get; set; }
    
        /// <summary>Represents an argument of the operation pointing to a specific field value.</summary>
        [Newtonsoft.Json.JsonProperty("operand", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ResourceFieldPointer Operand { get; set; } = new ResourceFieldPointer();
    
    
    }
    
    /// <summary>Paged collection of IDS signatures</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsSignatureListResult : ListResult
    {
        /// <summary>IDS signature list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IdsSignature> Results { get; set; } = new System.Collections.ObjectModel.Collection<IdsSignature>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CapacityThresholdList : ManagedResource
    {
        /// <summary>List of capacity thresholds for NSX Objects</summary>
        [Newtonsoft.Json.JsonProperty("capacity_thresholds", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<CapacityThreshold> Capacity_thresholds { get; set; } = new System.Collections.ObjectModel.Collection<CapacityThreshold>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedFirewallSectionListResult : ListResult
    {
        /// <summary>Paged Collection of firewall sections</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RealizedFirewallSection> Results { get; set; }
    
    
    }
    
    /// <summary>RBAC Objects qualifier</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ObjectRolePermissionGroup : ManagedResource
    {
        /// <summary>Allowed operation</summary>
        [Newtonsoft.Json.JsonProperty("operation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectRolePermissionGroupOperation? Operation { get; set; }
    
        /// <summary>Role name</summary>
        [Newtonsoft.Json.JsonProperty("role_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Role_name { get; set; }
    
        /// <summary>Is rule disabled or not</summary>
        [Newtonsoft.Json.JsonProperty("rule_disabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Rule_disabled { get; set; } = false;
    
        /// <summary>Does children of this object inherit this rule</summary>
        [Newtonsoft.Json.JsonProperty("inheritance_disabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Inheritance_disabled { get; set; } = false;
    
        /// <summary>Path prefix</summary>
        [Newtonsoft.Json.JsonProperty("path_prefix", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Path_prefix { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of LBMonitorProfiles</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBMonitorProfileListResult : ListResult
    {
        /// <summary>LBMonitorProfile list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<LBMonitorProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<LBMonitorProfile>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DhcpStatistics 
    {
        /// <summary>The total number of DHCP errors</summary>
        [Newtonsoft.Json.JsonProperty("errors", Required = Newtonsoft.Json.Required.Always)]
        public long Errors { get; set; }
    
        /// <summary>The total number of DHCP RELEASE packets</summary>
        [Newtonsoft.Json.JsonProperty("releases", Required = Newtonsoft.Json.Required.Always)]
        public long Releases { get; set; }
    
        /// <summary>The total number of DHCP INFORM packets</summary>
        [Newtonsoft.Json.JsonProperty("informs", Required = Newtonsoft.Json.Required.Always)]
        public long Informs { get; set; }
    
        /// <summary>The total number of DHCP DECLINE packets</summary>
        [Newtonsoft.Json.JsonProperty("declines", Required = Newtonsoft.Json.Required.Always)]
        public long Declines { get; set; }
    
        /// <summary>dhcp server uuid</summary>
        [Newtonsoft.Json.JsonProperty("dhcp_server_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Dhcp_server_id { get; set; }
    
        /// <summary>The total number of DHCP NACK packets</summary>
        [Newtonsoft.Json.JsonProperty("nacks", Required = Newtonsoft.Json.Required.Always)]
        public long Nacks { get; set; }
    
        /// <summary>The total number of DHCP OFFER packets</summary>
        [Newtonsoft.Json.JsonProperty("offers", Required = Newtonsoft.Json.Required.Always)]
        public long Offers { get; set; }
    
        /// <summary>The total number of DHCP DISCOVER packets</summary>
        [Newtonsoft.Json.JsonProperty("discovers", Required = Newtonsoft.Json.Required.Always)]
        public long Discovers { get; set; }
    
        /// <summary>The total number of DHCP ACK packets</summary>
        [Newtonsoft.Json.JsonProperty("acks", Required = Newtonsoft.Json.Required.Always)]
        public long Acks { get; set; }
    
        /// <summary>timestamp of the statistics</summary>
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Always)]
        public long Timestamp { get; set; }
    
        /// <summary>The total number of DHCP REQUEST packets</summary>
        [Newtonsoft.Json.JsonProperty("requests", Required = Newtonsoft.Json.Required.Always)]
        public long Requests { get; set; }
    
        /// <summary>The DHCP ip pool usage statistics</summary>
        [Newtonsoft.Json.JsonProperty("ip_pool_stats", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<DhcpIpPoolUsage> Ip_pool_stats { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of IPFIX Switch Collection Instances</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPFIXSwitchCollectionInstanceListResult : ListResult
    {
        /// <summary>IPFIX Switch Collection Instances list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IPFIXSwitchCollectionInstance> Results { get; set; } = new System.Collections.ObjectModel.Collection<IPFIXSwitchCollectionInstance>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregatedDataCounterEx : AggregatedDataCounter
    {
        [Newtonsoft.Json.JsonProperty("mac_learning", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public MacLearningCounters Mac_learning { get; set; }
    
        [Newtonsoft.Json.JsonProperty("dropped_by_security_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PacketsDroppedBySecurity Dropped_by_security_packets { get; set; }
    
    
    }
    
    /// <summary>Local Egress is used on both server and client sites so that the gateway
    /// is used for N-S traffic and overhead on L2VPN tunnel is reduced.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LocalEgress 
    {
        /// <summary>Gateway IP for Local Egress. Local egress is enabled only when this
        /// list is not empty.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("optimized_ips", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Optimized_ips { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of DNS Forwarder Zones</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyDnsForwarderZoneListResult : ListResult
    {
        /// <summary>Dns Forwarder Zone list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyDnsForwarderZone> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyDnsForwarderZone>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DhcpStaticBindingState : ConfigurationState
    {
    
    }
    
    /// <summary>Configuration where backup files are stored for restore</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RestoreConfiguration 
    {
        /// <summary>The server from which backup files will be retrieved for restore.</summary>
        [Newtonsoft.Json.JsonProperty("remote_file_server", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public RemoteFileServer Remote_file_server { get; set; } = new RemoteFileServer();
    
        /// <summary>Passphrase used to encrypt backup files.</summary>
        [Newtonsoft.Json.JsonProperty("passphrase", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Passphrase { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for PolicyFirewallFloodProtectionProfileBindingMap,
    /// used in hierarchical API
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyFirewallFloodProtectionProfileBindingMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyFirewallFloodProtectionProfileBindingMap object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyFirewallFloodProtectionProfileBindingMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyFirewallFloodProtectionProfileBindingMap PolicyFirewallFloodProtectionProfileBindingMap { get; set; }
    
    
    }
    
    /// <summary>WafPolicyPSMGroupApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWafPolicyPSMGroupApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of WafPolicyPSMGroup
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBWafPolicyPSMGroup> Results { get; set; }
    
    
    }
    
    /// <summary>It represents tag operation status for a resource and details of the failure if any.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ResourceTagStatus 
    {
        /// <summary>Status of tag apply or remove operation</summary>
        [Newtonsoft.Json.JsonProperty("tag_status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ResourceTagStatusTag_status Tag_status { get; set; }
    
        /// <summary>Details about the error if any</summary>
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Details { get; set; }
    
        /// <summary>Resource display name</summary>
        [Newtonsoft.Json.JsonProperty("resource_display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Resource_display_name { get; set; }
    
        /// <summary>Resource id</summary>
        [Newtonsoft.Json.JsonProperty("resource_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Resource_id { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for Tier-0, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildTier0 : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual Tier-0 object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Tier0", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Tier0 Tier0 { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for Tier-1 , used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildTier1 : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual Tier-1 object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Tier1", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Tier1 Tier1 { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for IPSecVpnTunnelProfile, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIPSecVpnTunnelProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual IPSecVpnTunnelProfile object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IPSecVpnTunnelProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IPSecVpnTunnelProfile IPSecVpnTunnelProfile { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer WafProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWafProfile : PolicyConfigResource
    {
        /// <summary>List of Data Files Used for WAF Rules.
        /// Maximum of 64 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("files", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBWafDataFile> Files { get; set; }
    
        /// <summary>Config params for WAF.</summary>
        [Newtonsoft.Json.JsonProperty("config", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBWafConfig Config { get; set; } = new ALBWafConfig();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceflowObservationForwarded : TraceflowObservation
    {
        /// <summary>The name of the uplink the traceflow packet is forwarded on</summary>
        [Newtonsoft.Json.JsonProperty("uplink_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uplink_name { get; set; }
    
        /// <summary>The virtual tunnel endpoint label</summary>
        [Newtonsoft.Json.JsonProperty("vtep_label", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Vtep_label { get; set; }
    
        /// <summary>IP address of the destination end of the tunnel</summary>
        [Newtonsoft.Json.JsonProperty("remote_ip_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Remote_ip_address { get; set; }
    
        /// <summary>The 64bit tunnel context carried on the wire</summary>
        [Newtonsoft.Json.JsonProperty("context", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Context { get; set; }
    
        /// <summary>IP address of the source end of the tunnel</summary>
        [Newtonsoft.Json.JsonProperty("local_ip_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Local_ip_address { get; set; }
    
        /// <summary>This field will not be always available. Use remote_ip_address when this field is not set.</summary>
        [Newtonsoft.Json.JsonProperty("dst_transport_node_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dst_transport_node_id { get; set; }
    
        /// <summary>The name of the transport node to which the traceflow packet is forwarded</summary>
        [Newtonsoft.Json.JsonProperty("dst_transport_node_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dst_transport_node_name { get; set; }
    
    
    }
    
    /// <summary>Represents IP address expressions in the form of an array, to support addition of IP addresses in a group. Avoid creating groups with multiple IPAddressExpression. In future releases, group will be restricted to contain a single IPAddressExpression. To group IPAddresses, use nested groups instead of multiple IPAddressExpressions.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPAddressExpression : Expression
    {
        /// <summary>This array can consist of a single IP address, IP address range or a subnet. Its type can be of either IPv4 or IPv6. Both IPv4 and IPv6 addresses within one expression is not allowed. Supported list of formats are, "192.168.1.1", "192.168.1.1-192.168.1.100", "192.168.0.0/24", "fe80::250:56ff:fe83:318c", "fe80::250:56ff:fe83:3181-fe80::250:56ff:fe83:318c", "fe80::250:56ff:fe83:318c/64".</summary>
        [Newtonsoft.Json.JsonProperty("ip_addresses", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(4000)]
        public System.Collections.Generic.ICollection<string> Ip_addresses { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>Advanced load balancer MatchTarget object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBMatchTarget 
    {
        /// <summary>Configure the host header.</summary>
        [Newtonsoft.Json.JsonProperty("host_hdr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHostHdrMatch Host_hdr { get; set; }
    
        /// <summary>Configure client ip addresses.</summary>
        [Newtonsoft.Json.JsonProperty("client_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddrMatch Client_ip { get; set; }
    
        /// <summary>Configure versions of the HTTP protocol.</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPVersionMatch Version { get; set; }
    
        /// <summary>Configure the type of HTTP protocol.</summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBProtocolMatch Protocol { get; set; }
    
        /// <summary>Configure HTTP header(s).</summary>
        [Newtonsoft.Json.JsonProperty("hdrs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBHdrMatch> Hdrs { get; set; }
    
        /// <summary>Configure request query.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBQueryMatch Query { get; set; }
    
        /// <summary>Configure HTTP cookie(s).</summary>
        [Newtonsoft.Json.JsonProperty("cookie", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBCookieMatch Cookie { get; set; }
    
        /// <summary>Configure request paths.</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBPathMatch Path { get; set; }
    
        /// <summary>Configure virtual service ports.</summary>
        [Newtonsoft.Json.JsonProperty("vs_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBPortMatch Vs_port { get; set; }
    
        /// <summary>Configure HTTP methods.</summary>
        [Newtonsoft.Json.JsonProperty("method", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBMethodMatch Method { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsNsRdata object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsNsRdata 
    {
        /// <summary>IPv6 address for Name Server.</summary>
        [Newtonsoft.Json.JsonProperty("ip6_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddr Ip6_address { get; set; }
    
        /// <summary>IP address for Name Server.</summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddr Ip_address { get; set; }
    
        /// <summary>Name Server name.</summary>
        [Newtonsoft.Json.JsonProperty("nsname", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Nsname { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer AuthorizationMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAuthorizationMatch 
    {
        /// <summary>Host header value to be matched.</summary>
        [Newtonsoft.Json.JsonProperty("host_hdr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHostHdrMatch Host_hdr { get; set; }
    
        /// <summary>Paths/URLs to be matched.</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBPathMatch Path { get; set; }
    
        /// <summary>HTTP methods to be matched.</summary>
        [Newtonsoft.Json.JsonProperty("method", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBMethodMatch Method { get; set; }
    
        /// <summary>Attributes whose values need to be matched .</summary>
        [Newtonsoft.Json.JsonProperty("attr_matches", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBAuthAttributeMatch> Attr_matches { get; set; }
    
    
    }
    
    /// <summary>It define redirection rule for service insertion</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RedirectionRule : BaseRule
    {
        /// <summary>The action to be applied to all the services
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RedirectionRuleAction? Action { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HTTPCookieData object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPCookieData 
    {
        /// <summary>Cookie name.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Cookie value.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer AutoScaleMesosSettings object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAutoScaleMesosSettings 
    {
        /// <summary>Apply scaleout even when there are deployments inprogress.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("force", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Force { get; set; } = true;
    
    
    }
    
    /// <summary>Child wrapper object for group, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildGroup : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual group objects.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Group", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Group Group { get; set; }
    
    
    }
    
    /// <summary>Binding of Tier-1 to the enforcement point.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier1DeploymentMap : PolicyConfigResource
    {
        /// <summary>Path of enforcement point on which Tier-1 shall be deployed.</summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Enforcement_point { get; set; }
    
    
    }
    
    /// <summary>This holds the request parameters required to invoke export task.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ExportRequestParameter 
    {
        /// <summary>Policy path of a draft which is to be exported.
        /// If not provided, current firewall configuration will then be exported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("draft_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Draft_path { get; set; }
    
        /// <summary>Passphrase to sign exported files.
        /// The passphrase specified must be at least 8 characters in length and
        /// must contain at least one lowercase, one uppercase, one numeric
        /// character and one non-space special character.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("passphrase", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength = 8)]
        public string Passphrase { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyBgpNeighborsStatusListResult : ListResult
    {
        /// <summary>Status of BGP neighbors of the Tier0</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyBgpNeighborStatus> Results { get; set; }
    
    
    }
    
    /// <summary>IDS configuration to enable/disable IDS on cluster level.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsClusterConfig : PolicyConfigResource
    {
        /// <summary>Contains policy resource reference object</summary>
        [Newtonsoft.Json.JsonProperty("cluster", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyResourceReference Cluster { get; set; }
    
        /// <summary>If set to true, IDS is enabled on the respective cluster</summary>
        [Newtonsoft.Json.JsonProperty("ids_enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Ids_enabled { get; set; }
    
    
    }
    
    /// <summary>L2Vpn Context provides meta-data information about the parent Tier-0.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VpnContext : PolicyConfigResource
    {
        /// <summary>If enabled, the tier-0 acts as a Hub and replicates traffic received from
        /// peer to all other peers. If disabled, the tier-0 acts as a Spoke and
        /// replicates only the local.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_hub", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_hub { get; set; } = false;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VrfEvpnL2VniConfig 
    {
        /// <summary>Define L2 VNI and its related route distinguiser and route targets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("l2_vni_configs", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<VrfL2VniConfig> L2_vni_configs { get; set; } = new System.Collections.ObjectModel.Collection<VrfL2VniConfig>();
    
        /// <summary>This is used to enable or disable the creation of vtep groups. Each vtep group
        /// is used to group vteps with the same MAC for L2 ECMP usage.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_vtep_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_vtep_groups { get; set; } = false;
    
    
    }
    
    /// <summary>Layer 2 Auto assigned Route Distinguisher</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2AutoRD 
    {
        /// <summary>Layer 2 Virtual Network Interface</summary>
        [Newtonsoft.Json.JsonProperty("l2_vni", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string L2_vni { get; set; }
    
        /// <summary>Layer 2 auto assigned route distinghusher</summary>
        [Newtonsoft.Json.JsonProperty("l2_auto_rd", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string L2_auto_rd { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Traceflow : ManagedResource
    {
        /// <summary>Represents the traceflow operation state</summary>
        [Newtonsoft.Json.JsonProperty("operation_state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TraceflowOperation_state? Operation_state { get; set; }
    
        /// <summary>counters of observations from logical components</summary>
        [Newtonsoft.Json.JsonProperty("logical_counters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TraceflowObservationCounters Logical_counters { get; set; }
    
        /// <summary>Maximum time (in ms) the management plane will be waiting for this traceflow round.</summary>
        [Newtonsoft.Json.JsonProperty("timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(5000D, 15000D)]
        public long? Timeout { get; set; }
    
        /// <summary>A flag, when set true, indicates some observations were deleted from the result set.</summary>
        [Newtonsoft.Json.JsonProperty("result_overflowed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Result_overflowed { get; set; }
    
        /// <summary>id of the source logical port used for injecting the traceflow packet</summary>
        [Newtonsoft.Json.JsonProperty("lport_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lport_id { get; set; }
    
        /// <summary>observation counters</summary>
        [Newtonsoft.Json.JsonProperty("counters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TraceflowObservationCounters Counters { get; set; }
    
        /// <summary>The status of the traceflow RPC request. SUCCESS - The traceflow request is sent successfully. TIMEOUT - The traceflow request gets timeout. SOURCE_PORT_NOT_FOUND - The source port of the request cannot be found. DATA_PATH_NOT_READY - The datapath component cannot be ready to receive request. CONNECTION_ERROR - There is connection error on datapath component. UNKNOWN - The status of traceflow request cannot be determined.</summary>
        [Newtonsoft.Json.JsonProperty("request_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TraceflowRequest_status? Request_status { get; set; }
    
        /// <summary>Traceflow result analysis notes</summary>
        [Newtonsoft.Json.JsonProperty("analysis", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Analysis { get; set; }
    
        /// <summary>The id of the traceflow round</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
    
    }
    
    /// <summary>Realized group</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("RealizedSecurityGroup", typeof(RealizedSecurityGroup))]
    [JsonInheritanceAttribute("RealizedNSGroup", typeof(RealizedNSGroup))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedGroup : PolicyRealizedResource
    {
    
    }
    
    /// <summary>Child wrapper object for SessionTimerProfileBindingMap,
    /// used in hierarchical API
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildSessionTimerProfileBindingMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual SessionTimerProfileBindingMap object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("SessionTimerProfileBindingMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SessionTimerProfileBindingMap SessionTimerProfileBindingMap { get; set; }
    
    
    }
    
    /// <summary>A list of fields to include in query results</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IncludedFieldsParameters 
    {
        /// <summary>Comma separated list of fields that should be included in query result</summary>
        [Newtonsoft.Json.JsonProperty("included_fields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Included_fields { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FirstNSampling : SamplingArgument
    {
        /// <summary>Number of packets to be sampled</summary>
        [Newtonsoft.Json.JsonProperty("match_number", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1D, 50D)]
        public long Match_number { get; set; }
    
    
    }
    
    /// <summary>Metadata fetched from an external system like Syslog or LogInsight.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ErrorResolverSystemMetadata 
    {
        /// <summary>The value fetched from another system</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }
    
    
    }
    
    /// <summary>IGMP Memberships Per Edge.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IgmpMembershipsPerEdge 
    {
        [Newtonsoft.Json.JsonProperty("igmp_memberships", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IgmpMembership> Igmp_memberships { get; set; }
    
        /// <summary>Policy path to edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Edge_path { get; set; }
    
    
    }
    
    /// <summary>The service count for specific load balancer usage severity.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBServiceCountPerSeverity 
    {
        /// <summary>Service count for specific serverity.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Service_count { get; set; }
    
        /// <summary>The severity calculation is based on current usage percentage
        /// for one load balancer service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("severity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBServiceCountPerSeveritySeverity? Severity { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of IPSecVpnTunnelProfile.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnTunnelProfileListResult : ListResult
    {
        /// <summary>IPSecVpnTunnelProfile list results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IPSecVpnTunnelProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<IPSecVpnTunnelProfile>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VersionList : ManagedResource
    {
        /// <summary>List of component versions</summary>
        [Newtonsoft.Json.JsonProperty("acceptable_versions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Acceptable_versions { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBPoolMemberStatistics 
    {
        /// <summary>Pool member statistics counter.</summary>
        [Newtonsoft.Json.JsonProperty("statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LBStatisticsCounter Statistics { get; set; }
    
        /// <summary>Pool member IP address.</summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ip_address { get; set; }
    
        /// <summary>The port is configured in pool member. For virtual server port range
        /// case, pool member port must be null.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Port { get; set; }
    
    
    }
    
    /// <summary>A Route Based VPN is more flexible, more powerful and recommended over policy based VPN. IP Tunnel port is created and all traffic routed via tunnel port is protected. Routes can be configured statically or can be learned through BGP. A route based VPN is must for establishing redundant VPN session to remote site.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RouteBasedIPSecVpnSession : IPSecVpnSession
    {
        /// <summary>If true the default firewall rule Action is set to DROP, otherwise set to ALLOW.
        /// This filed is deprecated and recommended to change Rule action filed. Note that this
        /// filed is not synchornied with default rule field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("force_whitelisting", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Force_whitelisting { get; set; } = false;
    
        /// <summary>IP Tunnel interfaces.</summary>
        [Newtonsoft.Json.JsonProperty("tunnel_interfaces", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<IPSecVpnTunnelInterface> Tunnel_interfaces { get; set; } = new System.Collections.ObjectModel.Collection<IPSecVpnTunnelInterface>();
    
    
    }
    
    /// <summary>Constant Field Value.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConstantFieldValue : FieldSettingValue
    {
        /// <summary>Constant Value that the field must be set to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("constant", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Constant { get; set; }
    
    
    }
    
    /// <summary>Policy Service Profile List</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyServiceProfileListResult : ListResult
    {
        /// <summary>Service Profile list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyServiceProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyServiceProfile>();
    
    
    }
    
    /// <summary>Child wrapper for ALBNetworkSecurityPolicy, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBNetworkSecurityPolicy : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBNetworkSecurityPolicy object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBNetworkSecurityPolicy", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBNetworkSecurityPolicy ALBNetworkSecurityPolicy { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class InterfaceArpEntry 
    {
        /// <summary>The IP address</summary>
        [Newtonsoft.Json.JsonProperty("ip", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ip { get; set; }
    
        /// <summary>The MAC address</summary>
        [Newtonsoft.Json.JsonProperty("mac_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Mac_address { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyTepListResult : ListResult
    {
        /// <summary>Timestamp when the data was last updated; unset if data source has never updated the data.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyTepTableEntry> Results { get; set; }
    
        /// <summary>Transport node identifier</summary>
        [Newtonsoft.Json.JsonProperty("transport_node_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_node_id { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBWafPolicy, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBWafPolicy : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBWafPolicy object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBWafPolicy", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBWafPolicy ALBWafPolicy { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsGeoLocationMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsGeoLocationMatch 
    {
        /// <summary>Geographical location of the client IP to be used in the
        /// match.
        /// This location is of the format Country/State/City e.g.
        /// US/CA/Santa Clara.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("geolocation_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Geolocation_name { get; set; }
    
        /// <summary>Use the IP address from the EDNS client subnet option, if
        /// available, to derive geo location of the DNS query.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("use_edns_client_subnet_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Use_edns_client_subnet_ip { get; set; } = true;
    
        /// <summary>Geolocation tag for the client IP.
        /// This could be any string value for the client IP, e.g.
        /// client IPs from US East Coast geolocation would be tagged
        /// as 'East Coast'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("geolocation_tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Geolocation_tag { get; set; }
    
        /// <summary>Criterion to use for matching the client IP's geographical
        /// location.
        /// Enum options - IS_IN, IS_NOT_IN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBDnsGeoLocationMatchMatch_criteria Match_criteria { get; set; }
    
    
    }
    
    /// <summary>Aggregate of L3Vpn Statistics across Enforcement Points.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregateL3VpnStatistics 
    {
        /// <summary>List of L3Vpn Statistics per Enforcement Point.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("l3vpn_statistics_per_enforcement_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<L3VpnStatisticsPerEnforcementPoint> L3vpn_statistics_per_enforcement_point { get; set; }
    
        /// <summary>Intent path of object, forward slashes must be escaped using %2F.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("intent_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Intent_path { get; set; }
    
    
    }
    
    /// <summary>This object holds the information of the import task.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ImportTask : PolicyTask
    {
        /// <summary>Policy path of a draft in which the imported configuration gets stored
        /// after completion of import task.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("draft_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Draft_path { get; set; }
    
    
    }
    
    /// <summary>OSPF Neighbor Per Edge.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OspfNeighbor 
    {
        [Newtonsoft.Json.JsonProperty("neighbors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OspfNeighborStatus> Neighbors { get; set; }
    
        /// <summary>Policy path to edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Edge_path { get; set; }
    
        /// <summary>Display name to edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Edge_display_name { get; set; }
    
    
    }
    
    /// <summary>Loadbalancer Service.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBService : PolicyConfigResource
    {
        /// <summary>Flag to enable access log</summary>
        [Newtonsoft.Json.JsonProperty("access_log_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Access_log_enabled { get; set; }
    
        /// <summary>LBS could be instantiated (or created) on the Tier-1, etc.
        /// For now, only the Tier-1 object is supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("connectivity_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Connectivity_path { get; set; }
    
        /// <summary>Load balancer engine writes information about encountered issues of
        /// different severity levels to the error log. This setting is used to
        /// define the severity level of the error log.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("error_log_level", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBServiceError_log_level? Error_log_level { get; set; } = SDKGenerator.LBServiceError_log_level.INFO;
    
        /// <summary>If relax_scale_validation is true, the scale validations for virtual
        /// servers/pools/pool members/rules are relaxed for load balancer service.
        /// When load balancer service is deployed on edge nodes, the scale of
        /// virtual servers/pools/pool members for the load balancer service should
        /// not exceed the scale number of the largest load balancer size which
        /// could be configured on a certain edge form factor. For example, the
        /// largest load balancer size supported on a MEDIUM edge node is MEDIUM.
        /// So one SMALL load balancer deployed on MEDIUM edge nodes can support
        /// the scale number of MEDIUM load balancer. It is not recommended to
        /// enable active monitors if relax_scale_validation is true due to
        /// performance consideration.
        /// If relax_scale_validation is false, scale numbers should be validated
        /// for load balancer service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("relax_scale_validation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Relax_scale_validation { get; set; } = false;
    
        /// <summary>Flag to enable the load balancer service.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
        /// <summary>Load balancer service size.</summary>
        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBServiceSize? Size { get; set; } = SDKGenerator.LBServiceSize.SMALL;
    
    
    }
    
    /// <summary>Child wrapper object for Constraint, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildConstraint : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual Constraint object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Constraint", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Constraint Constraint { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for PolicyDnsForwarderZone, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyDnsForwarderZone : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyDnsForwarderZone object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyDnsForwarderZone", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyDnsForwarderZone PolicyDnsForwarderZone { get; set; }
    
    
    }
    
    /// <summary>Represents the leaf level constraint to restrict the number instances of an entity
    /// type can be created. This is useful in restricting number of CGWs or MGWs or
    /// Providers that can created in a system.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EntityInstanceCountConstraintExpression : ConstraintExpression
    {
        /// <summary>Operations supported '&lt;' and '&lt;='.</summary>
        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Operator { get; set; }
    
        /// <summary>Instance count.</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Always)]
        public long Count { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for IPSecVpnDpdProfile, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIPSecVpnDpdProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual IPSecVpnDpdProfile object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IPSecVpnDpdProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IPSecVpnDpdProfile IPSecVpnDpdProfile { get; set; }
    
    
    }
    
    /// <summary>Aggregate of L2Vpn Statistics across Enforcement Points.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregateL2VpnStatistics 
    {
        /// <summary>List of L2Vpn Statistics per Enforcement Point.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("l2vpn_statistics_per_enforcement_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<L2VpnStatisticsPerEnforcementPoint> L2vpn_statistics_per_enforcement_point { get; set; }
    
        /// <summary>Intent path of object, forward slashes must be escaped using %2F.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("intent_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Intent_path { get; set; }
    
    
    }
    
    /// <summary>IPv6 DAD status</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPv6DADStatus 
    {
        /// <summary>DAD status for IP address on the port.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPv6DADStatusStatus? Status { get; set; }
    
        /// <summary>Array of transport node id on which DAD status is reported for
        /// given IP address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transport_node", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ResourceReference> Transport_node { get; set; }
    
        /// <summary>IP address on the port for which DAD status is reported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ip_address { get; set; }
    
    
    }
    
    /// <summary>VM ID and status of the Identity Firewall Compute collection.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdfwVirtualMachineStatusListResult : ListResult
    {
        /// <summary>List of VM's on Identity Firewall Compute collection.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IdfwVirtualMachineStatus> Results { get; set; } = new System.Collections.ObjectModel.Collection<IdfwVirtualMachineStatus>();
    
    
    }
    
    /// <summary>This condition is used to match SSL SNI in client hello. This condition is
    /// only supported in TRANSPORT phase and HTTP_FORWARDING.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBSslSniCondition : LBRuleCondition
    {
        /// <summary>If true, case is significant when comparing SNI value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("case_sensitive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Case_sensitive { get; set; } = true;
    
        /// <summary>Match type of SNI</summary>
        [Newtonsoft.Json.JsonProperty("match_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBSslSniConditionMatch_type? Match_type { get; set; } = SDKGenerator.LBSslSniConditionMatch_type.REGEX;
    
        /// <summary>The SNI(Server Name indication) in client hello message.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sni", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Sni { get; set; }
    
    
    }
    
    /// <summary>Contains information necessary to configure IPSec VPN.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L3Vpn : PolicyConfigResource
    {
        /// <summary>This field is used to resolve conflicts in case of a remote site being
        /// behind NAT as remote public ip address is not enough. If it is not the
        /// case the remote public address should be provided here. If not provided,
        /// the value of this field is set to remote_public_address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remote_private_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Remote_private_address { get; set; }
    
        /// <summary>Algorithm to be used for message digest during tunnel establishment.
        /// Default algorithm is empty.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tunnel_digest_algorithms", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<Tunnel_digest_algorithms> Tunnel_digest_algorithms { get; set; }
    
        /// <summary>List of IPSec pre-shared keys used for IPSec authentication. If not
        /// specified, the older passphrase values are retained if there are any.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("passphrases", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Passphrases { get; set; }
    
        /// <summary>If true, perfect forward secrecy (PFS) is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_perfect_forward_secrecy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_perfect_forward_secrecy { get; set; } = true;
    
        /// <summary>Algorithm to be used for message digest during Internet Key Exchange(IKE)
        /// negotiation. Default is SHA2_256.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ike_digest_algorithms", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<Ike_digest_algorithms> Ike_digest_algorithms { get; set; }
    
        /// <summary>IKE protocol version to be used. IKE-Flex will initiate IKE-V2 and responds
        /// to both IKE-V1 and IKE-V2.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ike_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public L3VpnIke_version? Ike_version { get; set; } = SDKGenerator.L3VpnIke_version.IKE_V2;
    
        /// <summary>Algorithm to be used during Internet Key Exchange(IKE) negotiation.
        /// Default is AES_128.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ike_encryption_algorithms", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<Ike_encryption_algorithms> Ike_encryption_algorithms { get; set; }
    
        /// <summary>IPv4 address of local gateway</summary>
        [Newtonsoft.Json.JsonProperty("local_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Local_address { get; set; }
    
        /// <summary>L3Vpn Session</summary>
        [Newtonsoft.Json.JsonProperty("l3vpn_session", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public L3VpnSession L3vpn_session { get; set; } = new L3VpnSession();
    
        /// <summary>Diffie-Hellman group to be used if PFS is enabled. Default group is GROUP14.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dh_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<Dh_groups2> Dh_groups { get; set; }
    
        /// <summary>Encryption algorithm to encrypt/decrypt the messages exchanged between
        /// IPSec VPN initiator and responder during tunnel negotiation. Default is
        /// AES_GCM_128.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tunnel_encryption_algorithms", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<Tunnel_encryption_algorithms> Tunnel_encryption_algorithms { get; set; }
    
        /// <summary>Flag to enable L3Vpn. Default is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
        /// <summary>Public IPv4 address of remote gateway</summary>
        [Newtonsoft.Json.JsonProperty("remote_public_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Remote_public_address { get; set; }
    
    
    }
    
    /// <summary>Paginated collection of IP members belonging to a Group.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyGroupIPMembersListResult : ListResult
    {
        /// <summary>Paged Collection of IP addresses that belong to the given Group</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Results { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>IKE Profile is a reusable profile that captures IKE phase one negotiation parameters. Any changes affects all IPSec VPN sessions consuming this profile.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnIkeProfile : PolicyConfigResource
    {
        /// <summary>Algorithm to be used for message digest during Internet Key Exchange(IKE) negotiation. Default is SHA2_256.</summary>
        [Newtonsoft.Json.JsonProperty("digest_algorithms", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Digest_algorithms2> Digest_algorithms { get; set; }
    
        /// <summary>Encryption algorithm is used during Internet Key Exchange(IKE) negotiation. Default is AES_128.</summary>
        [Newtonsoft.Json.JsonProperty("encryption_algorithms", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Encryption_algorithms2> Encryption_algorithms { get; set; }
    
        /// <summary>Diffie-Hellman group to be used if PFS is enabled. Default is GROUP14.</summary>
        [Newtonsoft.Json.JsonProperty("dh_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Dh_groups3> Dh_groups { get; set; }
    
        /// <summary>Life time for security association. Default is 86400 seconds (1 day).</summary>
        [Newtonsoft.Json.JsonProperty("sa_life_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(21600D, 31536000D)]
        public long? Sa_life_time { get; set; } = 86400L;
    
        /// <summary>IKE protocol version to be used. IKE-Flex will initiate IKE-V2 and responds to both IKE-V1 and IKE-V2.</summary>
        [Newtonsoft.Json.JsonProperty("ike_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPSecVpnIkeProfileIke_version? Ike_version { get; set; } = SDKGenerator.IPSecVpnIkeProfileIke_version.IKE_V2;
    
    
    }
    
    /// <summary>Advanced load balancer ServicePoolSelector object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBServicePoolSelector 
    {
        /// <summary>Destination protocol to match for the pool selection.
        /// If not specified, it will match any protocol.
        /// Enum options - PROTOCOL_TYPE_TCP_PROXY,
        /// PROTOCOL_TYPE_TCP_FAST_PATH, PROTOCOL_TYPE_UDP_FAST_PATH,
        /// PROTOCOL_TYPE_UDP_PROXY.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service_protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBServicePoolSelectorService_protocol? Service_protocol { get; set; }
    
        /// <summary>It is a reference to an object of type Pool.</summary>
        [Newtonsoft.Json.JsonProperty("service_pool_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Service_pool_path { get; set; }
    
        /// <summary>The end of the Service port number range.
        /// Allowed values are 1-65535.
        /// Special values are 0- 'single port'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service_port_range_end", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Service_port_range_end { get; set; } = 0L;
    
        /// <summary>It is a reference to an object of type PoolGroup.</summary>
        [Newtonsoft.Json.JsonProperty("service_pool_group_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Service_pool_group_path { get; set; }
    
        /// <summary>Pool based destination port.
        /// Allowed values are 1-65535.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service_port", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long Service_port { get; set; }
    
    
    }
    
    /// <summary>A ServiceEntry that represents IPv4 or IPv6 ICMP protocol</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ICMPTypeServiceEntry : ServiceEntry
    {
        /// <summary>ICMP message code</summary>
        [Newtonsoft.Json.JsonProperty("icmp_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 255D)]
        public long? Icmp_code { get; set; }
    
        /// <summary>ICMP message type</summary>
        [Newtonsoft.Json.JsonProperty("icmp_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 255D)]
        public long? Icmp_type { get; set; }
    
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ICMPTypeServiceEntryProtocol Protocol { get; set; }
    
    
    }
    
    /// <summary>Active healthchecks are disabled by default and can be enabled for a
    /// server pool by binding a health monitor to the Group through the PolicyLbRule
    /// object. This represents active health monitoring over UDP. Active
    /// healthchecks are initiated periodically, at a configurable interval, to
    /// each member of the Group. Only if a healthcheck fails consecutively for a
    /// specified number of times (fall_count) to a member will the member status
    /// be marked DOWN. Once a member is DOWN, a specified number of consecutive
    /// successful healthchecks (rise_count) will bring the member back to UP
    /// state. After a healthcheck is initiated, if it does not complete within a
    /// certain period, then also the healthcheck is considered to be
    /// unsuccessful. Completing a healthcheck within timeout means establishing
    /// a connection (TCP or SSL), if applicable, sending the request and
    /// receiving the response, all within the configured timeout.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class UdpPolicyLbMonitorProfile : PolicyLbMonitorProfile
    {
        /// <summary>Expected data, can be anywhere in the response and it has to be a
        /// string, regular expressions are not supported.
        /// UDP healthcheck is considered failed if there is no server response
        /// within the timeout period.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receive", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Receive { get; set; }
    
        /// <summary>The data to be sent to the monitored server.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("send", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Send { get; set; }
    
    
    }
    
    /// <summary>VM or vmknic entity attached to LogicalPort</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PortAttacher 
    {
        /// <summary>TransportNode on which the attacher resides</summary>
        [Newtonsoft.Json.JsonProperty("host", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Host { get; set; }
    
        /// <summary>This is a vmknic name if the attacher is vmknic. Otherwise, it is
        /// full path of the attached VM's config file
        /// </summary>
        [Newtonsoft.Json.JsonProperty("entity", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Entity { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for PolicyLbVirtualServer, used in hierarchical API
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyLbVirtualServer : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyLbVirtualServer object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyLbVirtualServer", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyLbVirtualServer PolicyLbVirtualServer { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer L4RuleActionSelectPool object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBL4RuleActionSelectPool 
    {
        /// <summary>ID of the pool of servers to serve the request.
        /// It is a reference to an object of type Pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pool_path { get; set; }
    
        /// <summary>Indicates action to take on rule match.
        /// Enum options - L4_RULE_ACTION_SELECT_POOL,
        /// L4_RULE_ACTION_SELECT_POOLGROUP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBL4RuleActionSelectPoolAction_type Action_type { get; set; }
    
        /// <summary>ID of the pool group to serve the request.
        /// It is a reference to an object of type PoolGroup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_group_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pool_group_path { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyTepTableEntry 
    {
        /// <summary>The tunnel endpoint label</summary>
        [Newtonsoft.Json.JsonProperty("tep_label", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Tep_label { get; set; }
    
        /// <summary>The segment Id</summary>
        [Newtonsoft.Json.JsonProperty("segment_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Segment_id { get; set; }
    
        /// <summary>The tunnel endpoint MAC address</summary>
        [Newtonsoft.Json.JsonProperty("tep_mac_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tep_mac_address { get; set; }
    
        /// <summary>The tunnel endpoint IP address</summary>
        [Newtonsoft.Json.JsonProperty("tep_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tep_ip { get; set; }
    
    
    }
    
    /// <summary>This condition is used to match the message body of an HTTP request.
    /// Typically, only HTTP POST, PATCH, or PUT requests have request body.
    /// The match_type field defines how body_value field is used to match the body
    /// of HTTP requests.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBHttpRequestBodyCondition : LBRuleCondition
    {
        /// <summary>HTTP request body</summary>
        [Newtonsoft.Json.JsonProperty("body_value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Body_value { get; set; }
    
        /// <summary>Match type of HTTP body</summary>
        [Newtonsoft.Json.JsonProperty("match_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBHttpRequestBodyConditionMatch_type? Match_type { get; set; } = SDKGenerator.LBHttpRequestBodyConditionMatch_type.REGEX;
    
        /// <summary>If true, case is significant when comparing HTTP body value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("case_sensitive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Case_sensitive { get; set; } = true;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class X509Certificate 
    {
        /// <summary>The order of the middle term(s) of the reduction polynomial in elliptic curve (EC) | characteristic 2 finite field.| Contents of this array are copied to protect against subsequent modification in ECDSA.</summary>
        [Newtonsoft.Json.JsonProperty("ecdsa_ec_field_f2mks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<long> Ecdsa_ec_field_f2mks { get; set; }
    
        /// <summary>Certificate version (default v1).</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }
    
        /// <summary>True if this is a CA certificate.</summary>
        [Newtonsoft.Json.JsonProperty("is_ca", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_ca { get; set; }
    
        /// <summary>The algorithm used by the Certificate Authority to sign the certificate.</summary>
        [Newtonsoft.Json.JsonProperty("signature_algorithm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Signature_algorithm { get; set; }
    
        /// <summary>The first coefficient of this elliptic curve in ECDSA.</summary>
        [Newtonsoft.Json.JsonProperty("ecdsa_public_key_a", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ecdsa_public_key_a { get; set; }
    
        /// <summary>An RSA public key is made up of the modulus and the public exponent. Exponent is a power number.</summary>
        [Newtonsoft.Json.JsonProperty("rsa_public_key_exponent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rsa_public_key_exponent { get; set; }
    
        /// <summary>The first coefficient of this elliptic curve in elliptic curve (EC) | characteristic 2 finite field for ECDSA.</summary>
        [Newtonsoft.Json.JsonProperty("ecdsa_ec_field_f2mm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Ecdsa_ec_field_f2mm { get; set; }
    
        /// <summary>The certificate issuer's common name.</summary>
        [Newtonsoft.Json.JsonProperty("issuer_cn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Issuer_cn { get; set; }
    
        /// <summary>The certificate owner's common name.</summary>
        [Newtonsoft.Json.JsonProperty("subject_cn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Subject_cn { get; set; }
    
        /// <summary>The order of generator G in ECDSA.</summary>
        [Newtonsoft.Json.JsonProperty("ecdsa_public_key_order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ecdsa_public_key_order { get; set; }
    
        /// <summary>The value whose i-th bit corresponds to the i-th coefficient of the reduction polynomial | in elliptic curve (EC) characteristic 2 finite field for ECDSA.</summary>
        [Newtonsoft.Json.JsonProperty("ecdsa_ec_field_f2mrp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ecdsa_ec_field_f2mrp { get; set; }
    
        /// <summary>Size measured in bits of the public/private keys used in a cryptographic algorithm.</summary>
        [Newtonsoft.Json.JsonProperty("public_key_length", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Public_key_length { get; set; }
    
        /// <summary>The time in epoch milliseconds at which the certificate becomes valid.</summary>
        [Newtonsoft.Json.JsonProperty("not_before", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Not_before { get; set; }
    
        /// <summary>The specified prime for the elliptic curve prime finite field in ECDSA.</summary>
        [Newtonsoft.Json.JsonProperty("ecdsa_ec_field_f2pp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ecdsa_ec_field_f2pp { get; set; }
    
        /// <summary>The certificate issuers complete distinguished name.</summary>
        [Newtonsoft.Json.JsonProperty("issuer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Issuer { get; set; }
    
        /// <summary>The second coefficient of this elliptic curve in ECDSA.</summary>
        [Newtonsoft.Json.JsonProperty("ecdsa_public_key_b", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ecdsa_public_key_b { get; set; }
    
        /// <summary>An RSA public key is made up of the modulus and the public exponent. Modulus is wrap around number.</summary>
        [Newtonsoft.Json.JsonProperty("rsa_public_key_modulus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rsa_public_key_modulus { get; set; }
    
        /// <summary>One of the DSA cryptogaphic algorithm's strength parameters.</summary>
        [Newtonsoft.Json.JsonProperty("dsa_public_key_y", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dsa_public_key_y { get; set; }
    
        /// <summary>The co-factor in ECDSA.</summary>
        [Newtonsoft.Json.JsonProperty("ecdsa_public_key_cofactor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Ecdsa_public_key_cofactor { get; set; }
    
        /// <summary>The time in epoch milliseconds at which the certificate becomes invalid.</summary>
        [Newtonsoft.Json.JsonProperty("not_after", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Not_after { get; set; }
    
        /// <summary>One of the DSA cryptogaphic algorithm's strength parameters, sub-prime.</summary>
        [Newtonsoft.Json.JsonProperty("dsa_public_key_q", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dsa_public_key_q { get; set; }
    
        /// <summary>One of the DSA cryptogaphic algorithm's strength parameters, prime.</summary>
        [Newtonsoft.Json.JsonProperty("dsa_public_key_p", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dsa_public_key_p { get; set; }
    
        /// <summary>Y co-ordinate of G (the generator which is also known as the base point) in ECDSA.</summary>
        [Newtonsoft.Json.JsonProperty("ecdsa_public_key_generator_y", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ecdsa_public_key_generator_y { get; set; }
    
        /// <summary>X co-ordinate of G (the generator which is also known as the base point) in ECDSA.</summary>
        [Newtonsoft.Json.JsonProperty("ecdsa_public_key_generator_x", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ecdsa_public_key_generator_x { get; set; }
    
        /// <summary>Cryptographic algorithm used by the public key for data encryption.</summary>
        [Newtonsoft.Json.JsonProperty("public_key_algo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public X509CertificatePublic_key_algo? Public_key_algo { get; set; }
    
        /// <summary>True if this certificate is valid.</summary>
        [Newtonsoft.Json.JsonProperty("is_valid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_valid { get; set; }
    
        /// <summary>The bytes used during curve generation for later validation in ECDSA.| Contents of this array are copied to protect against subsequent modification.</summary>
        [Newtonsoft.Json.JsonProperty("ecdsa_public_key_seed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Ecdsa_public_key_seed { get; set; }
    
        /// <summary>The signature value(the raw signature bits) used for signing and validate the cert.</summary>
        [Newtonsoft.Json.JsonProperty("signature", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Signature { get; set; }
    
        /// <summary>Certificate's serial number.</summary>
        [Newtonsoft.Json.JsonProperty("serial_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Serial_number { get; set; }
    
        /// <summary>One of the DSA cryptogaphic algorithm's strength parameters, base.</summary>
        [Newtonsoft.Json.JsonProperty("dsa_public_key_g", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dsa_public_key_g { get; set; }
    
        /// <summary>The certificate owners complete distinguished name.</summary>
        [Newtonsoft.Json.JsonProperty("subject", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Subject { get; set; }
    
        /// <summary>Represents an elliptic curve (EC) finite field in ECDSA.</summary>
        [Newtonsoft.Json.JsonProperty("ecdsa_ec_field", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public X509CertificateEcdsa_ec_field? Ecdsa_ec_field { get; set; }
    
        /// <summary>The Curve name for the ECDSA certificate.</summary>
        [Newtonsoft.Json.JsonProperty("ecdsa_curve_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ecdsa_curve_name { get; set; }
    
    
    }
    
    /// <summary>Paged collection of IDS security policies</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsSecurityPolicyListResult : PolicyListResult
    {
        /// <summary>IDS security policy list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IdsSecurityPolicy> Results { get; set; } = new System.Collections.ObjectModel.Collection<IdsSecurityPolicy>();
    
    
    }
    
    /// <summary>Paginated collection of members belonging to a Group.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyGroupMembersListResult : ListResult
    {
        /// <summary>Paged Collection of members that belong to the given Group</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyGroupMemberDetails> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyGroupMemberDetails>();
    
    
    }
    
    /// <summary>Advanced load balancer CRL object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBCRL 
    {
        /// <summary>Certificate Revocation list from a given issuer in PEM
        /// format.
        /// This can either be configured directly or via the
        /// server_url.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("body", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Body { get; set; }
    
        /// <summary>Distinguished name of the issuer in the Certificate
        /// Revocation list.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("distinguished_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Distinguished_name { get; set; }
    
        /// <summary>Certificate Revocation list in plain text for readability.</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Text { get; set; }
    
        /// <summary>URL of a server that issues the Certificate Revocation
        /// list.
        /// If this is configured, CRL will be periodically downloaded
        /// either based on the configured update interval or the next
        /// update interval in the CRL.
        /// CRL itself is stored in the body.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server_url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Server_url { get; set; }
    
        /// <summary>The date when this CRL was last issued.</summary>
        [Newtonsoft.Json.JsonProperty("last_update", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_update { get; set; }
    
        /// <summary>Last time CRL was refreshed by the system.
        /// This is an internal field used by the system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("last_refreshed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_refreshed { get; set; }
    
        /// <summary>Cached etag to optimize the download of the CRL.</summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }
    
        /// <summary>Fingerprint of the CRL.
        /// Used to avoid configuring duplicates.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fingerprint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fingerprint { get; set; }
    
        /// <summary>Common name of the issuer in the Certificate Revocation
        /// list.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("common_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Common_name { get; set; }
    
        /// <summary>The date when a newer CRL will be available.
        /// Also conveys the date after which the CRL should be
        /// considered obsolete.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("next_update", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Next_update { get; set; }
    
        /// <summary>Interval in minutes to check for CRL update.
        /// If not specified, interval will be 1 day.
        /// Allowed values are 30-525600.
        /// Unit is MIN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("update_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(30D, 525600D)]
        public long? Update_interval { get; set; }
    
    
    }
    
    /// <summary>The Attached interface is only effective for the segment port on Bare metal server.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AttachedInterfaceEntry 
    {
        /// <summary>Routing rules</summary>
        [Newtonsoft.Json.JsonProperty("routing_table", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Routing_table { get; set; }
    
        /// <summary>IP configuration on migrate_intf will migrate to app_intf_name. It is used for Management and Application sharing the same IP.</summary>
        [Newtonsoft.Json.JsonProperty("migrate_intf", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Migrate_intf { get; set; }
    
        /// <summary>The name of application interface</summary>
        [Newtonsoft.Json.JsonProperty("app_intf_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string App_intf_name { get; set; }
    
        /// <summary>Gateway IP</summary>
        [Newtonsoft.Json.JsonProperty("default_gateway", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Default_gateway { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HTTPResponsePolicy object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPResponsePolicy 
    {
        /// <summary>Add rules to the HTTP response policy.</summary>
        [Newtonsoft.Json.JsonProperty("rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBHTTPResponseRule> Rules { get; set; }
    
    
    }
    
    /// <summary>Ordered list of Rules.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SecurityPolicy : Policy
    {
        /// <summary>Rules that are a part of this SecurityPolicy</summary>
        [Newtonsoft.Json.JsonProperty("rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Rule> Rules { get; set; }
    
        /// <summary>This field indicates the default connectivity policy for the security
        /// policy. Based on the connectivitiy strategy, a default rule for this
        /// security policy will be created. An appropriate action will be set on
        /// the rule based on the value of the connectivity strategy. If NONE is
        /// selected or no connectivity strategy is specified, then no default
        /// rule for the security policy gets created. The default rule that gets
        /// created will be a any-any rule and applied to entities specified in the
        /// scope of the security policy. Specifying the connectivity_strategy
        /// without specifying the scope is not allowed. The scope has to be a
        /// Group and one cannot specify IPAddress directly in the group that is
        /// used as scope. This default rule is only applicable for the Layer3
        /// security policies.
        /// WHITELIST - Adds a default drop rule. Administrator can then use "allow"
        /// rules (aka whitelist) to allow traffic between groups
        /// BLACKLIST - Adds a default allow rule. Admin can then use "drop" rules
        /// (aka blacklist) to block traffic between groups
        /// WHITELIST_ENABLE_LOGGING - Whitelising with logging enabled
        /// BLACKLIST_ENABLE_LOGGING - Blacklisting with logging enabled
        /// NONE - No default rule is created.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("connectivity_strategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SecurityPolicyConnectivity_strategy? Connectivity_strategy { get; set; }
    
        /// <summary>This field indicates the application connectivity policy for the security
        /// policy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("application_connectivity_strategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(2)]
        public System.Collections.Generic.ICollection<ApplicationConnectivityStrategy> Application_connectivity_strategy { get; set; }
    
        /// <summary>Flag to enable logging for all the rules in the security policy.
        /// If the value is true then logging will be enabled for all the rules
        /// in the security policy. If the value is false, then the rule level
        /// logging value will be honored.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("logging_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Logging_enabled { get; set; } = false;
    
        /// <summary>Based on the value of the connectivity strategy, a default rule is
        /// created for the security policy. The rule id is internally assigned
        /// by the system for this default rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("default_rule_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Default_rule_id { get; set; }
    
    
    }
    
    /// <summary>Aggregate of L2VPN Session Status across Enforcement Points.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregateL2VPNSessionStatus : AggregatePolicyRuntimeInfo
    {
        /// <summary>List of L2VPN Session Status per Enforcement Point.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<L2VPNSessionStatusPerEP> Results { get; set; }
    
    
    }
    
    /// <summary>Allows more granular policies for application workloads
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ApplicationConnectivityStrategy 
    {
        /// <summary>Flag to enable packet logging. Default is disabled.</summary>
        [Newtonsoft.Json.JsonProperty("logging_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Logging_enabled { get; set; } = false;
    
        /// <summary>Based on the value of the app connectivity strategy, a default rule is
        /// created for the security policy. The rule id is internally assigned
        /// by the system for this default rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("default_application_rule_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Default_application_rule_id { get; set; }
    
        /// <summary>App connectivity strategies
        /// </summary>
        [Newtonsoft.Json.JsonProperty("application_connectivity_strategy", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ApplicationConnectivityStrategyApplication_connectivity_strategy Application_connectivity_strategy { get; set; }
    
    
    }
    
    /// <summary>LBVirtualServerStatistics on specific Enforcement Point</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("LBVirtualServerStatistics", typeof(LBVirtualServerStatistics))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBVirtualServerStatisticsPerEP : PolicyRuntimeInfoPerEP
    {
    
    }
    
    /// <summary>Child wrapper object for SpoofGuardProfile, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildSpoofGuardProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual SpoofGuardProfile object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("SpoofGuardProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SpoofGuardProfile SpoofGuardProfile { get; set; }
    
    
    }
    
    /// <summary>Realized Security Group member evaluation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedSecurityGroupMemberEvaluation : PolicyRealizedResource
    {
        /// <summary>list of virtual machines</summary>
        [Newtonsoft.Json.JsonProperty("virtual_machines", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RealizedVirtualMachine> Virtual_machines { get; set; }
    
        /// <summary>Count of the members added to this Security Group</summary>
        [Newtonsoft.Json.JsonProperty("member_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Member_count { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PktcapActionArgument 
    {
        /// <summary>Type of packet capture</summary>
        [Newtonsoft.Json.JsonProperty("pktcap_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PktcapActionArgumentPktcap_type? Pktcap_type { get; set; }
    
        /// <summary>Please keep this aligned with trace_config, if you
        /// specify dest_lport at trace_config.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dest_lport", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dest_lport { get; set; }
    
        /// <summary>Please keep this aligned with trace_config, if you
        /// specify dest_lport at trace_config.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reverse_filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LiveTraceFilterData Reverse_filter { get; set; }
    
    
    }
    
    /// <summary>This action is used to drop the connections. There is no extra propery in
    /// this action. If there is no match condition specified, the connection will
    /// be always dropped. This action can be specified at HTTP_ACCESS or
    /// HTTP_FORWARDING pahse.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBConnectionDropAction : LBRuleAction
    {
    
    }
    
    /// <summary>Advanced load balancer SidebandProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSidebandProfile 
    {
        /// <summary>IP Address of the sideband server.</summary>
        [Newtonsoft.Json.JsonProperty("ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBIpAddr> Ip { get; set; }
    
        /// <summary>Maximum size of the request body that will be sent on the
        /// sideband.
        /// Allowed values are 0-16384.
        /// Unit is BYTES.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1024.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sideband_max_request_body_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 16384D)]
        public long? Sideband_max_request_body_size { get; set; } = 1024L;
    
    
    }
    
    /// <summary>Represents a list of views.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ViewList 
    {
        /// <summary>Array of views</summary>
        [Newtonsoft.Json.JsonProperty("views", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<View> Views { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer AuthenticationAction object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAuthenticationAction 
    {
        /// <summary>Authentication Action to be taken for a matched Rule.
        /// Enum options - SKIP_AUTHENTICATION,
        /// USE_DEFAULT_AUTHENTICATION.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as USE_DEFAULT_AUTHENTICATION.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBAuthenticationActionType? Type { get; set; } = SDKGenerator.ALBAuthenticationActionType.USE_DEFAULT_AUTHENTICATION;
    
    
    }
    
    /// <summary>This entity will be used to establish association between DNS security profile and
    /// Group. With this entity, user can specify intent for applying DNS security profile
    /// profile to particular Group.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DnsSecurityProfileBindingMap : ProfileBindingMap
    {
        /// <summary>Sequence number used to resolve conflicts betweeen two profiles applied on
        /// the same group. Lower sequence number takes higher precedence. Two binding
        /// maps applied to the same profile must have the same sequence number.
        /// User defined sequence numbers range from 1 through 100,000.
        /// System defined sequence numbers range from 100,001 through 200,000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sequence_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 100000D)]
        public long? Sequence_number { get; set; }
    
    
    }
    
    /// <summary>It represents the resource information which could identify resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ResourceInfo 
    {
        /// <summary>It will represent resource identifiers. For example, policy objects will be
        /// represented with paths and virtual machine will be represented with external
        /// ids.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resource_ids", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Resource_ids { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>It will represent resource type on which tag bulk operation to be performed.
        /// Supported resource type is VirtualMachine.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resource_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Resource_type { get; set; }
    
    
    }
    
    /// <summary>L2Vpn Statistics Per Enforcement Point.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("L2VpnSessionStatistics", typeof(L2VpnSessionStatistics))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VpnStatisticsPerEnforcementPoint 
    {
        /// <summary>Policy Path referencing the enforcement point wehere the statistics are fetched.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enforcement_point_path { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for TlsCrl, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildTlsCrl : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual TlsCrl object.</summary>
        [Newtonsoft.Json.JsonProperty("TlsCrl", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public TlsCrl TlsCrl { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HSMSafenetLuna object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHSMSafenetLuna 
    {
        /// <summary>Node specific information.</summary>
        [Newtonsoft.Json.JsonProperty("node_info", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBHSMSafenetClientInfo> Node_info { get; set; }
    
        /// <summary>Set to indicate HA across more than one servers.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_ha", Required = Newtonsoft.Json.Required.Always)]
        public bool Is_ha { get; set; } = false;
    
        /// <summary>Generated File - server.pem.</summary>
        [Newtonsoft.Json.JsonProperty("server_pem", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Server_pem { get; set; }
    
        /// <summary>If enabled, dedicated network is used to communicate with
        /// HSM,else, the management network is used.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("use_dedicated_network", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Use_dedicated_network { get; set; } = false;
    
        /// <summary>Group Number of generated HA Group.</summary>
        [Newtonsoft.Json.JsonProperty("ha_group_num", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Ha_group_num { get; set; }
    
        /// <summary>SafeNet/Gemalto HSM Servers used for crypto operations.</summary>
        [Newtonsoft.Json.JsonProperty("server", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBHSMSafenetLunaServer> Server { get; set; }
    
    
    }
    
    /// <summary>List of URL reputation severities.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyUrlReputationSeverityListResult : ListResult
    {
        /// <summary>Reputation Severity list</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyUrlReputationSeverity> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyUrlReputationSeverity>();
    
    
    }
    
    /// <summary>A SecurityZoneRule specifies the security policy that applies to the tiers
    /// associated with the security zones.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SecurityZoneRule : PolicyConfigResource
    {
        /// <summary>Flag to disable the rule. Default is enabled.</summary>
        [Newtonsoft.Json.JsonProperty("disabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Disabled { get; set; } = false;
    
        /// <summary>Source field indicates the source path of the Rule.
        /// It could be;
        ///  - Path of the current/other zone
        ///  - One/more tiers associated with the zone
        ///  - Shared Group
        ///  - ANY (It should be the ONLY element in the services array. Error will be thrown
        ///         if ANY is used in conjunction with other values.)
        /// Note that either Source or Destination has to be associated with the current Zone.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<string> Source { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>User level field which will be printed in CLI and packet logs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(32)]
        public string Tag { get; set; }
    
        /// <summary>ID of the Service that is defined in Infra space. e.g. HTTPS.
        /// In order to specify all services, use the constant "ANY". If "ANY" is used,
        /// it should be the ONLY element in the services array. Error will be thrown
        /// if ANY is used in conjunction with other values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("services", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<string> Services { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Text for additional notes on changes.</summary>
        [Newtonsoft.Json.JsonProperty("notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Notes { get; set; }
    
        /// <summary>Destination field indicates the destination path of the Rule.
        /// It could be;
        ///  - Path of the current/other zone
        ///  - One/more tiers associated with the zone
        ///  - Shared Group
        ///  - ANY (It should be the ONLY element in the services array. Error will be thrown
        ///         if ANY is used in conjunction with other values.)
        /// Note that either Source or Destination has to be associated with the current Zone.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destination", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<string> Destination { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Flag to enable packet logging. Default is disabled.</summary>
        [Newtonsoft.Json.JsonProperty("logged", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Logged { get; set; } = false;
    
        /// <summary>The action to be applied to all the services.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SecurityZoneRuleAction Action { get; set; }
    
        /// <summary>This field is used to resolve conflicts between multiple
        /// SecurityZoneRule under same securityZone
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sequence_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Sequence_number { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer AuthProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAuthProfile : PolicyConfigResource
    {
        /// <summary>HTTP user authentication params.</summary>
        [Newtonsoft.Json.JsonProperty("http", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBAuthProfileHTTPClientParams Http { get; set; }
    
        /// <summary>SAML settings.</summary>
        [Newtonsoft.Json.JsonProperty("saml", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBSamlSettings Saml { get; set; }
    
        /// <summary>Type of the Auth Profile.
        /// Enum options - AUTH_PROFILE_LDAP, AUTH_PROFILE_TACACS_PLUS,
        /// AUTH_PROFILE_SAML, AUTH_PROFILE_PINGACCESS,
        /// AUTH_PROFILE_JWT.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBAuthProfileType Type { get; set; }
    
        /// <summary>TACACS+ settings.</summary>
        [Newtonsoft.Json.JsonProperty("tacacs_plus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBTacacsPlusAuthSettings Tacacs_plus { get; set; }
    
        /// <summary>LDAP server and directory settings.</summary>
        [Newtonsoft.Json.JsonProperty("ldap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBLdapAuthSettings Ldap { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBPoolStatus : LBPoolStatusPerEP
    {
        /// <summary>UP means that all primary members are in UP status.
        /// PARTIALLY_UP means that some(not all) primary members are in UP
        /// status, the number of these active members is larger or equal to
        /// certain number(min_active_members) which is defined in LBPool.
        /// When there are no backup members which are in the UP status, the
        /// number(min_active_members) would be ignored.
        /// PRIMARY_DOWN means that less than certain(min_active_members) primary
        /// members are in UP status but backup members are in UP status,
        /// connections to this pool would be dispatched to backup members.
        /// DOWN means that all primary and backup members are DOWN.
        /// DETACHED means that the pool is not bound to any virtual server.
        /// UNKOWN means that no status reported from transport-nodes. The
        /// associated load balancer service may be working(or not working).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBPoolStatusStatus? Status { get; set; }
    
        /// <summary>Timestamp when the data was last updated.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>Load balancer pool object path.</summary>
        [Newtonsoft.Json.JsonProperty("pool_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pool_path { get; set; }
    
        /// <summary>Status of load balancer pool members.</summary>
        [Newtonsoft.Json.JsonProperty("members", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBPoolMemberStatus> Members { get; set; }
    
    
    }
    
    /// <summary>Detailed information about errors from API call to an enforcement point</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyRelatedApiError 
    {
        /// <summary>The module name where the error occurred</summary>
        [Newtonsoft.Json.JsonProperty("module_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Module_name { get; set; }
    
        /// <summary>A description of the error</summary>
        [Newtonsoft.Json.JsonProperty("error_message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error_message { get; set; }
    
        /// <summary>A numeric error code</summary>
        [Newtonsoft.Json.JsonProperty("error_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Error_code { get; set; }
    
        /// <summary>Further details about the error</summary>
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Details { get; set; }
    
        /// <summary>Additional data about the error</summary>
        [Newtonsoft.Json.JsonProperty("error_data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Error_data { get; set; }
    
    
    }
    
    /// <summary>Ordered list of CommunicationEntries. This object is created by default
    /// along with the Domain.
    /// This type is deprecated. Use the type SecurityPolicy instead.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CommunicationMap : PolicyConfigResource
    {
        /// <summary>CommunicationEntries that are a part of this CommunicationMap</summary>
        [Newtonsoft.Json.JsonProperty("communication_entries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CommunicationEntry> Communication_entries { get; set; }
    
        /// <summary>- Distributed Firewall -
        /// Policy framework for Distributed Firewall provides four pre-defined
        /// categories for classifying a communication map. They are
        /// "Emergency", "Infrastructure", "Environment" and "Application".
        /// Amongst the layer 3 communication maps,there is a pre-determined
        /// order in which the policy framework manages the priority of these
        /// communication maps. Emergency category has the highest priority
        /// followed by Infrastructure, Environment and then Application rules.
        /// Administrator can choose to categorize a communication  map into the
        /// above categories or can choose to leave it empty. If empty it will
        /// have the least precedence w.r.t the above four layer 3 categories.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Category { get; set; }
    
        /// <summary>This field is used to resolve conflicts between communication maps
        /// across domains. In order to change the precedence of a communication
        /// map one can fire a POST request on the communication map entity with
        /// a query parameter action=revise
        /// The precedence field will reflect the value of the computed precedence
        /// upon execution of the above mentioned POST request.
        /// For scenarios where the administrator is using a template to update
        /// several communication maps, the only way to set the precedence is to
        /// explicitly specify the precedence number for each communication map.
        /// If no precedence is specified in the payload, a value of 0 is
        /// assigned by default. If there are multiple communication maps with
        /// the same precedence then their order is not deterministic. If a
        /// specific order of communication map is desired, then one has to
        /// specify a unique precedence or use the POST request on the
        /// communication map entity with a query parameter action=revise to let
        /// the framework assign a precedence
        /// </summary>
        [Newtonsoft.Json.JsonProperty("precedence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Precedence { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsZone object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsZone 
    {
        /// <summary>Email address of the administrator responsible for this
        /// zone.
        /// This field is used in SOA records as rname (RFC 1035).
        /// If not configured, it is inherited from the DNS service
        /// profile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("admin_email", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Admin_email { get; set; }
    
        /// <summary>Domain name authoritatively serviced by this Virtual
        /// Service.
        /// Queries for FQDNs that are sub domains of this domain and
        /// do not have any DNS record in Avi are dropped or NXDomain
        /// response sent.
        /// For domains which are present, SOA parameters are sent in
        /// answer section of response if query type is SOA.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("domain_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Domain_name { get; set; }
    
        /// <summary>The primary name server for this zone.
        /// This field is used in SOA records as mname (RFC 1035).
        /// If not configured, it is inherited from the DNS service
        /// profile.
        /// If even that is not configured, the domain name is used
        /// instead.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name_server", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name_server { get; set; }
    
    
    }
    
    /// <summary>Realized Enforcement Point</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedEnforcementPoint : PolicyRealizedResource
    {
        /// <summary>Root of Realized Firewalls</summary>
        [Newtonsoft.Json.JsonProperty("realized_firewalls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RealizedFirewalls Realized_firewalls { get; set; }
    
        /// <summary>Root of Realized Services</summary>
        [Newtonsoft.Json.JsonProperty("realized_services", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RealizedServices Realized_services { get; set; }
    
        /// <summary>Root of Realized Groups</summary>
        [Newtonsoft.Json.JsonProperty("realized_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RealizedGroups Realized_groups { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer IpAddrMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBIpAddrMatch 
    {
        /// <summary>IP address prefix(es).</summary>
        [Newtonsoft.Json.JsonProperty("prefixes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBIpAddrPrefix> Prefixes { get; set; }
    
        /// <summary>IP address range(s).</summary>
        [Newtonsoft.Json.JsonProperty("ranges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBIpAddrRange> Ranges { get; set; }
    
        /// <summary>path of IP address group(s).
        /// It is a reference to an object of type IpAddrGroup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("group_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Group_paths { get; set; }
    
        /// <summary>IP address(es).</summary>
        [Newtonsoft.Json.JsonProperty("addrs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBIpAddr> Addrs { get; set; }
    
        /// <summary>Criterion to use for IP address matching the HTTP request.
        /// Enum options - IS_IN, IS_NOT_IN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBIpAddrMatchMatch_criteria Match_criteria { get; set; }
    
    
    }
    
    /// <summary>Binding object to bind Security Zone and Application Tier
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SecurityZoneBinding : PolicyConfigResource
    {
        /// <summary>Path of the security zone.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("security_zone_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Security_zone_path { get; set; }
    
    
    }
    
    /// <summary>Subnet specification for interface connectivity</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class InterfaceSubnet 
    {
        /// <summary>IP addresses assigned to interface</summary>
        [Newtonsoft.Json.JsonProperty("ip_addresses", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Ip_addresses { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Subnet prefix length</summary>
        [Newtonsoft.Json.JsonProperty("prefix_len", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1D, 128D)]
        public long Prefix_len { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HTTPSecurityActionRateProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPSecurityActionRateProfile 
    {
        /// <summary>The action to take when the rate limit has been reached.</summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBRateLimiterAction Action { get; set; } = new ALBRateLimiterAction();
    
        /// <summary>The rate limiter used when this action is triggered.</summary>
        [Newtonsoft.Json.JsonProperty("rate_limiter", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBRateLimiter Rate_limiter { get; set; } = new ALBRateLimiter();
    
        /// <summary>Rate limiting should be done on a per request uri path
        /// basis.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("per_uri_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Per_uri_path { get; set; }
    
        /// <summary>Rate limiting should be done on a per client ip basis.</summary>
        [Newtonsoft.Json.JsonProperty("per_client_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Per_client_ip { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for LBAppProfile, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildLBAppProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual LBAppProfile object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("LBAppProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public LBAppProfile LBAppProfile { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBWebhook, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBWebhook : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBWebhook object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBWebhook", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBWebhook ALBWebhook { get; set; }
    
    
    }
    
    /// <summary>Represents an object on the desired state.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyConfigResource : PolicyResource
    {
        /// <summary>subtree for this type within policy tree containing nested elements.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("children", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ChildPolicyConfigResource> Children { get; set; }
    
        /// <summary>Global intent objects cannot be modified by the user.
        /// However, certain global intent objects can be overridden locally by use
        /// of this property. In such cases, the overridden local values take
        /// precedence over the globally defined values for the properties.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overridden", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Overridden { get; set; } = false;
    
        /// <summary>Intent objects are not directly deleted from the system when a delete
        /// is invoked on them. They are marked for deletion and only when all the
        /// realized entities for that intent object gets deleted, the intent object
        /// is deleted. Objects that are marked for deletion are not returned in
        /// GET call. One can use the search API to get these objects.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("marked_for_delete", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Marked_for_delete { get; set; } = false;
    
    
    }
    
    /// <summary>Advanced load balancer IpAddrGroup object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBIpAddrGroup : PolicyConfigResource
    {
        /// <summary>Configure IP address range(s).</summary>
        [Newtonsoft.Json.JsonProperty("ranges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBIpAddrRange> Ranges { get; set; }
    
        /// <summary>Configure IP address prefix(es).</summary>
        [Newtonsoft.Json.JsonProperty("prefixes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBIpAddrPrefix> Prefixes { get; set; }
    
        /// <summary>Populate IP addresses from tasks of this Marathon app.</summary>
        [Newtonsoft.Json.JsonProperty("marathon_app_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Marathon_app_name { get; set; }
    
        /// <summary>Configure IP address(es).</summary>
        [Newtonsoft.Json.JsonProperty("addrs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBIpAddr> Addrs { get; set; }
    
        /// <summary>Populate the IP address ranges from the geo database for
        /// this country.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("country_codes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Country_codes { get; set; }
    
        /// <summary>Task port associated with marathon service port.
        /// If Marathon app has multiple service ports, this is
        /// required.
        /// Else, the first task port is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("marathon_service_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Marathon_service_port { get; set; }
    
        /// <summary>Configure (IP address, port) tuple(s).</summary>
        [Newtonsoft.Json.JsonProperty("ip_ports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBIpAddrPort> Ip_ports { get; set; }
    
        /// <summary>Populate IP addresses from members of this Cisco APIC EPG.</summary>
        [Newtonsoft.Json.JsonProperty("apic_epg_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Apic_epg_name { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HTTPRewriteLocHdrAction object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPRewriteLocHdrAction 
    {
        /// <summary>Keep or drop the query from the server side redirect URI.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keep_query", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Keep_query { get; set; } = true;
    
        /// <summary>Path config.</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBURIParam Path { get; set; }
    
        /// <summary>Host config.</summary>
        [Newtonsoft.Json.JsonProperty("host", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBURIParam Host { get; set; }
    
        /// <summary>HTTP protocol type.
        /// Enum options - HTTP, HTTPS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHTTPRewriteLocHdrActionProtocol Protocol { get; set; }
    
        /// <summary>Port to use in the redirected URI.
        /// Allowed values are 1-65535.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long? Port { get; set; }
    
    
    }
    
    /// <summary>Paged collection of Static Routes</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class StaticRoutesListResult : ListResult
    {
        /// <summary>Static Routes list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<StaticRoutes> Results { get; set; } = new System.Collections.ObjectModel.Collection<StaticRoutes>();
    
    
    }
    
    /// <summary>A communication entry indicates the action to be performed for various types of traffic flowing between workload groups. This type is deprecated. Use the type Rule instead.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CommunicationEntry : PolicyConfigResource
    {
        /// <summary>Define direction of traffic.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("direction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CommunicationEntryDirection? Direction { get; set; } = SDKGenerator.CommunicationEntryDirection.IN_OUT;
    
        /// <summary>Text for additional notes on changes.</summary>
        [Newtonsoft.Json.JsonProperty("notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Notes { get; set; }
    
        /// <summary>Flag to enable packet logging. Default is disabled.</summary>
        [Newtonsoft.Json.JsonProperty("logged", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Logged { get; set; } = false;
    
        /// <summary>Flag to disable the rule. Default is enabled.</summary>
        [Newtonsoft.Json.JsonProperty("disabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Disabled { get; set; } = false;
    
        /// <summary>In order to specify all services, use the constant "ANY".
        /// This is case insensitive. If "ANY" is used, it should
        /// be the ONLY element in the services array. Error will be thrown
        /// if ANY is used in conjunction with other values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("services", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<string> Services { get; set; }
    
        /// <summary>User level field which will be printed in CLI and packet logs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(32)]
        public string Tag { get; set; }
    
        /// <summary>We need paths as duplicate names may exist for groups under different
        /// domains.In order to specify all groups, use the constant "ANY". This
        /// is case insensitive. If "ANY" is used, it should be the ONLY element
        /// in the group array. Error will be thrown if ANY is used in conjunction
        /// with other values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destination_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<string> Destination_groups { get; set; }
    
        /// <summary>The action to be applied to all the services.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CommunicationEntryAction? Action { get; set; }
    
        /// <summary>The list of policy paths where the communication entry is applied
        /// Edge/LR/T0/T1/LRP/CGW/MGW/etc. Note that a given rule can be applied
        /// on multiple LRs/LRPs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<string> Scope { get; set; }
    
        /// <summary>This field is used to resolve conflicts between multiple
        /// CommunicationEntries under CommunicationMap for a Domain
        /// If no sequence number is specified in the payload, a value of 0 is
        /// assigned by default. If there are multiple communication entries with
        /// the same sequence number then their order is not deterministic. If a
        /// specific order of communication entry is desired, then one has to
        /// specify unique sequence numbers or use the POST request on the
        /// communication entry entity with a query parameter action=revise to let
        /// the framework assign a sequence number
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sequence_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Sequence_number { get; set; }
    
        /// <summary>We need paths as duplicate names may exist for groups under different
        /// domains. In order to specify all groups, use the constant "ANY". This
        /// is case insensitive. If "ANY" is used, it should be the ONLY element
        /// in the group array. Error will be thrown if ANY is used in conjunction
        /// with other values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<string> Source_groups { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for EndpointRule used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildEndpointRule : ChildPolicyConfigResource
    {
        /// <summary>Contains actual EndpointRule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("EndpointRule", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public EndpointRule EndpointRule { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBStringGroup, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBStringGroup : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBStringGroup object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBStringGroup", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBStringGroup ALBStringGroup { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer NetworkProfileUnion object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBNetworkProfileUnion 
    {
        /// <summary>Configure one of either proxy or fast path profiles.
        /// Enum options - PROTOCOL_TYPE_TCP_PROXY,
        /// PROTOCOL_TYPE_TCP_FAST_PATH, PROTOCOL_TYPE_UDP_FAST_PATH,
        /// PROTOCOL_TYPE_UDP_PROXY.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as PROTOCOL_TYPE_TCP_PROXY.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBNetworkProfileUnionType Type { get; set; } = SDKGenerator.ALBNetworkProfileUnionType.PROTOCOL_TYPE_TCP_PROXY;
    
        /// <summary>Placeholder for description of property tcp_proxy_profile
        /// of obj type NetworkProfileUnion field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tcp_proxy_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBTCPProxyProfile Tcp_proxy_profile { get; set; }
    
        /// <summary>Placeholder for description of property
        /// tcp_fast_path_profile of obj type NetworkProfileUnion field
        /// type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tcp_fast_path_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBTCPFastPathProfile Tcp_fast_path_profile { get; set; }
    
        /// <summary>Configure UDP Proxy network profile.</summary>
        [Newtonsoft.Json.JsonProperty("udp_proxy_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBUDPProxyProfile Udp_proxy_profile { get; set; }
    
        /// <summary>Placeholder for description of property
        /// udp_fast_path_profile of obj type NetworkProfileUnion field
        /// type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("udp_fast_path_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBUDPFastPathProfile Udp_fast_path_profile { get; set; }
    
    
    }
    
    /// <summary>Paged collection of RBAC Objects</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ObjectRolePermissionGroupListResult : ListResult
    {
        /// <summary>ObjectRolePermissionGroup list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ObjectRolePermissionGroup> Results { get; set; } = new System.Collections.ObjectModel.Collection<ObjectRolePermissionGroup>();
    
    
    }
    
    /// <summary>Wrapper object for PolicySIStatusConfiguration</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildSIStatusConfiguration : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual service insertion status configuration list object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicySIStatusConfiguration", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicySIStatusConfiguration PolicySIStatusConfiguration { get; set; }
    
    
    }
    
    /// <summary>Contains OSPF routing configurations.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OspfRoutingConfig : PolicyConfigResource
    {
        /// <summary>List of summary address configruation to summarize or filter external routes based on the
        /// setting of advertise flag in each OspfSummaryAddressConfig
        /// </summary>
        [Newtonsoft.Json.JsonProperty("summary_addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1000)]
        public System.Collections.Generic.ICollection<OspfSummaryAddressConfig> Summary_addresses { get; set; }
    
        /// <summary>Flag to enable/disable advertisement of default route into OSPF domain.
        /// The default route should be present in the edge only then it redistributes the
        /// same into OSPF domain only if this flag is set to TRUE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("default_originate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Default_originate { get; set; } = false;
    
        /// <summary>Configuration field to hold OSPF Restart mode .</summary>
        [Newtonsoft.Json.JsonProperty("graceful_restart_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OspfRoutingConfigGraceful_restart_mode? Graceful_restart_mode { get; set; } = SDKGenerator.OspfRoutingConfigGraceful_restart_mode.HELPER_ONLY;
    
        /// <summary>Flag to enable OSPF routing protocol. Disabling will stop feature and
        /// OSPF peering.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = false;
    
        /// <summary>Flag to enable ECMP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ecmp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Ecmp { get; set; } = true;
    
    
    }
    
    /// <summary>Label to reference group of policy entities of same type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyLabel : PolicyConfigResource
    {
        /// <summary>Policy entity paths referred by the label instance</summary>
        [Newtonsoft.Json.JsonProperty("refs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Refs { get; set; }
    
        /// <summary>Policy intent entity type from PolicyResourceType</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }
    
    
    }
    
    /// <summary>Multicast Routes Per Edge.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MulticastRoutesPerEdge 
    {
        [Newtonsoft.Json.JsonProperty("mcast_routes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MulticastRoute> Mcast_routes { get; set; }
    
        /// <summary>Policy path to edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Edge_path { get; set; }
    
    
    }
    
    /// <summary>NSX global configs for VRNI global collector</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VrniGlobalCollector : GlobalCollectorConfig
    {
        /// <summary>Report interval for operation data in seconds.</summary>
        [Newtonsoft.Json.JsonProperty("report_interval", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1D, 1800D)]
        public long Report_interval { get; set; } = 30L;
    
    
    }
    
    /// <summary>A weak reference to an NSX resource.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ResourceReference 
    {
        /// <summary>Display name of the NSX resource.</summary>
        [Newtonsoft.Json.JsonProperty("target_display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string Target_display_name { get; set; }
    
        /// <summary>Will be set to false if the referenced NSX resource has been deleted.</summary>
        [Newtonsoft.Json.JsonProperty("is_valid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_valid { get; set; }
    
        /// <summary>Identifier of the NSX resource.</summary>
        [Newtonsoft.Json.JsonProperty("target_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(64)]
        public string Target_id { get; set; }
    
        /// <summary>Type of the NSX resource.</summary>
        [Newtonsoft.Json.JsonProperty("target_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string Target_type { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer AnalyticsPolicy object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAnalyticsPolicy 
    {
        /// <summary>Placeholder for description of property client_log_filters
        /// of obj type AnalyticsPolicy field type str  type array.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_log_filters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBClientLogFilter> Client_log_filters { get; set; }
    
        /// <summary>This setting limits the total number of UDF logs generated
        /// per second for this VS on each SE.
        /// UDF logs are generated due to the configured client log
        /// filters or the rules with logging enabled.
        /// Default is 10 logs per second.
        /// Set it to zero (0) to deactivate throttling.
        /// Unit is PER_SECOND.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 10.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("udf_log_throttle", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Udf_log_throttle { get; set; } = 10L;
    
        /// <summary>Settings to turn on realtime metrics and set duration for
        /// realtime updates.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("metrics_realtime_update", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBMetricsRealTimeUpdate Metrics_realtime_update { get; set; }
    
        /// <summary>This setting limits the number of significant logs
        /// generated per second for this VS on each SE.
        /// Default is 10 logs per second.
        /// Set it to zero (0) to deactivate throttling.
        /// Unit is PER_SECOND.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 10.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("significant_log_throttle", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Significant_log_throttle { get; set; } = 10L;
    
        /// <summary>Gain insights from sampled client to server HTTP requests
        /// and responses.
        /// Enum options - NO_INSIGHTS, PASSIVE, ACTIVE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as NO_INSIGHTS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_insights", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBAnalyticsPolicyClient_insights? Client_insights { get; set; } = SDKGenerator.ALBAnalyticsPolicyClient_insights.NO_INSIGHTS;
    
        /// <summary>Log all headers.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("all_headers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? All_headers { get; set; } = false;
    
        /// <summary>Placeholder for description of property
        /// client_insights_sampling of obj type AnalyticsPolicy field
        /// type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_insights_sampling", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBClientInsightsSampling Client_insights_sampling { get; set; }
    
        /// <summary>Placeholder for description of property full_client_logs of
        /// obj type AnalyticsPolicy field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("full_client_logs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBFullClientLogs Full_client_logs { get; set; }
    
    
    }
    
    /// <summary>Some applications maintain state and require all relevant connections
    /// to be sent to the same server as the application state is not
    /// synchronized among servers. Persistence is enabled on a
    /// LBVirtualServer by binding a persistence profile to it.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBCookiePersistenceProfile : LBPersistenceProfile
    {
        /// <summary>If garble is set to true, cookie value (server IP and port) would be
        /// encrypted.
        /// If garble is set to false, cookie value would be plain text.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cookie_garble", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Cookie_garble { get; set; } = true;
    
        /// <summary>If cookie secure flag is true, it prevents the browser from sending a
        /// cookie over http. The cookie is sent only over https. Only available
        /// for insert mode.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cookie_secure", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Cookie_secure { get; set; } = false;
    
        /// <summary>If fallback is true, once the cookie points to a server that is down
        /// (i.e. admin state DISABLED or healthcheck state is DOWN), then a new
        /// server is selected by default to handle that request.
        /// If fallback is false, it will cause the request to be rejected if
        /// cookie points to a server.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cookie_fallback", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Cookie_fallback { get; set; } = true;
    
        /// <summary>Cookie persistence mode.</summary>
        [Newtonsoft.Json.JsonProperty("cookie_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBCookiePersistenceProfileCookie_mode? Cookie_mode { get; set; } = SDKGenerator.LBCookiePersistenceProfileCookie_mode.INSERT;
    
        /// <summary>HTTP cookie domain could be configured, only available for insert mode.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cookie_domain", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cookie_domain { get; set; }
    
        /// <summary>If cookie httponly flag is true, it prevents a script running in the
        /// browser from accessing the cookie. Only available for insert mode.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cookie_httponly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Cookie_httponly { get; set; } = false;
    
        /// <summary>Cookie name.</summary>
        [Newtonsoft.Json.JsonProperty("cookie_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cookie_name { get; set; } = "NSXLB";
    
        /// <summary>Both session cookie and persistence cookie are supported, if not
        /// specified, it's a session cookie. It expires when the browser is
        /// closed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cookie_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LBCookieTime Cookie_time { get; set; }
    
        /// <summary>HTTP cookie path could be set, only available for insert mode.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cookie_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cookie_path { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for PortMirroringProfile, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPortMirroringProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PortMirroringProfile object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PortMirroringProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PortMirroringProfile PortMirroringProfile { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsRuleMatchTarget object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsRuleMatchTarget 
    {
        /// <summary>DNS query types to match against request query type.</summary>
        [Newtonsoft.Json.JsonProperty("query_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDnsQueryTypeMatch Query_type { get; set; }
    
        /// <summary>Geographical location attribute to match against that of
        /// the client IP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("geo_location", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDnsGeoLocationMatch Geo_location { get; set; }
    
        /// <summary>Domain names to match against query name.</summary>
        [Newtonsoft.Json.JsonProperty("query_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDnsQueryNameMatch Query_name { get; set; }
    
        /// <summary>DNS transport protocol match.</summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDnsTransportProtocolMatch Protocol { get; set; }
    
        /// <summary>IP addresses to match against client IP or the EDNS client
        /// subnet IP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_ip_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDnsClientIpMatch Client_ip_address { get; set; }
    
    
    }
    
    /// <summary>RouteMap for redistributing routes to BGP and other routing protocols</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier0RouteMap : PolicyConfigResource
    {
        /// <summary>Ordered list of route map entries.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1000)]
        public System.Collections.Generic.ICollection<RouteMapEntry> Entries { get; set; } = new System.Collections.ObjectModel.Collection<RouteMapEntry>();
    
    
    }
    
    /// <summary>Intersite gateway configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IntersiteGatewayConfig 
    {
        /// <summary>IPv4 subnet for inter-site transit segment connecting service routers
        /// across sites for stretched gateway. For IPv6 link local subnet is
        /// auto configured.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("intersite_transit_subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Intersite_transit_subnet { get; set; } = "169.254.32.0/20";
    
        /// <summary>Primary egress site for gateway. T0/T1 gateway in Active/Standby mode
        /// supports stateful services on primary site. In this mode primary site
        /// must be set if gateway is stretched to more than one site. For T0 gateway
        /// in Active/Active primary site is optional field. If set then secondary site
        /// prefers routes learned from primary over locally learned routes. This field
        /// is not applicable for T1 gateway with no services.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("primary_site_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Primary_site_path { get; set; }
    
        /// <summary>Epoch(in seconds) is auto updated based on system current timestamp
        /// when primary locale service is updated. It is used for resolving conflict
        /// during site failover. If system clock not in sync then User can optionally
        /// override this. New value must be higher than the current value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("last_admin_active_epoch", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(int.MinValue, 4294967295D)]
        public long? Last_admin_active_epoch { get; set; }
    
        /// <summary>Fallback site to be used as new primary site on current primary site
        /// failure. Disaster recovery must be initiated via API/UI. Fallback site
        /// configuration is supported only for T0 gateway. T1 gateway will follow
        /// T0 gateway's primary site during disaster recovery.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fallback_sites", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Fallback_sites { get; set; }
    
    
    }
    
    /// <summary>An address binding entry is a combination of the IP-MAC-VLAN binding for
    /// a logical port. The address bindings can be obtained via various methods
    /// like ARP snooping, DHCP snooping etc. or by user configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AddressBindingEntry 
    {
        /// <summary>Source from which the address binding entry was obtained</summary>
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AddressBindingEntrySource? Source { get; set; } = SDKGenerator.AddressBindingEntrySource.UNKNOWN;
    
        /// <summary>Combination of IP-MAC-VLAN binding</summary>
        [Newtonsoft.Json.JsonProperty("binding", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PacketAddressClassifier Binding { get; set; }
    
        /// <summary>Timestamp at which the binding was discovered via snooping or manually
        /// specified by the user
        /// </summary>
        [Newtonsoft.Json.JsonProperty("binding_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Binding_timestamp { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HSMSafenetClientInfo object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHSMSafenetClientInfo 
    {
        /// <summary>Name prepended to client key and certificate filename.</summary>
        [Newtonsoft.Json.JsonProperty("client_ip", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Client_ip { get; set; }
    
        /// <summary>Client Private Key generated by createCert.</summary>
        [Newtonsoft.Json.JsonProperty("client_priv_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Client_priv_key { get; set; }
    
        /// <summary>Minor number of the sesseion.</summary>
        [Newtonsoft.Json.JsonProperty("session_minor_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Session_minor_number { get; set; }
    
        /// <summary>Generated File - Chrystoki.conf .</summary>
        [Newtonsoft.Json.JsonProperty("chrystoki_conf", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Chrystoki_conf { get; set; }
    
        /// <summary>Major number of the sesseion.</summary>
        [Newtonsoft.Json.JsonProperty("session_major_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Session_major_number { get; set; }
    
        /// <summary>Client Certificate generated by createCert.</summary>
        [Newtonsoft.Json.JsonProperty("client_cert", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Client_cert { get; set; }
    
    
    }
    
    /// <summary>IGMP (Internet Group Management Protocol) membership details.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IgmpMembership 
    {
        /// <summary>Multicast group membership active time.</summary>
        [Newtonsoft.Json.JsonProperty("uptime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uptime { get; set; }
    
        /// <summary>Multicast group address.</summary>
        [Newtonsoft.Json.JsonProperty("group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group { get; set; }
    
        /// <summary>Interface on which multicast group membership is learned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("interface", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Interface { get; set; }
    
        /// <summary>Number of multicast sources.</summary>
        [Newtonsoft.Json.JsonProperty("no_of_sources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string No_of_sources { get; set; }
    
        /// <summary>IP address of multicast source.</summary>
        [Newtonsoft.Json.JsonProperty("source_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source_address { get; set; }
    
        /// <summary>IGMP version.</summary>
        [Newtonsoft.Json.JsonProperty("igmp_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Igmp_version { get; set; }
    
    
    }
    
    /// <summary>SSL cipher</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LbSslCipherInfo 
    {
        /// <summary>Default SSL cipher flag</summary>
        [Newtonsoft.Json.JsonProperty("is_default", Required = Newtonsoft.Json.Required.Always)]
        public bool Is_default { get; set; }
    
        /// <summary>Secure/insecure SSL cipher flag</summary>
        [Newtonsoft.Json.JsonProperty("is_secure", Required = Newtonsoft.Json.Required.Always)]
        public bool Is_secure { get; set; }
    
        /// <summary>Several cipher groups might contain the same cipher suite, each cipher
        /// suite could have multiple cipher group labels.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cipher_group_labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Cipher_group_labels> Cipher_group_labels { get; set; }
    
        /// <summary>SSL cipher</summary>
        [Newtonsoft.Json.JsonProperty("cipher", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LbSslCipherInfoCipher Cipher { get; set; }
    
    
    }
    
    /// <summary>Data for a single backup/restore card</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BackupOverview : ClusterBackupInfoListResult
    {
        /// <summary>Backup status decribes type, phase, success/failure and time of a | latest backup execution</summary>
        [Newtonsoft.Json.JsonProperty("current_backup_operation_status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public CurrentBackupOperationStatus Current_backup_operation_status { get; set; } = new CurrentBackupOperationStatus();
    
        /// <summary>Status of the last backup execution per component</summary>
        [Newtonsoft.Json.JsonProperty("backup_operation_history", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BackupOperationHistory Backup_operation_history { get; set; } = new BackupOperationHistory();
    
        /// <summary>Configuration to generate a manual/automated backup</summary>
        [Newtonsoft.Json.JsonProperty("backup_config", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BackupConfiguration Backup_config { get; set; } = new BackupConfiguration();
    
        /// <summary>Status of restore process executing/executed on appliance</summary>
        [Newtonsoft.Json.JsonProperty("restore_status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ClusterRestoreStatus Restore_status { get; set; } = new ClusterRestoreStatus();
    
    
    }
    
    /// <summary>Virtual switch on a compute manager</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VirtualSwitch : DiscoveredResource
    {
        /// <summary>ID of the virtual switch in compute manager</summary>
        [Newtonsoft.Json.JsonProperty("cm_local_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cm_local_id { get; set; }
    
        /// <summary>External id of the virtual switch</summary>
        [Newtonsoft.Json.JsonProperty("external_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string External_id { get; set; }
    
        /// <summary>Switch type like VmwareDistributedVirtualSwitch</summary>
        [Newtonsoft.Json.JsonProperty("origin_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Origin_type { get; set; }
    
        /// <summary>ID of the compute manager where this virtual switch is discovered.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("origin_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Origin_id { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for GeneralSecurityProfile,
    /// used in hierarchical API
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildGeneralSecurityProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual GeneralSecurityProfile object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("GeneralSecurityProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public GeneralSecurityProfile GeneralSecurityProfile { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for Tier0Interface, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildTier0Interface : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual Tier0Interface object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Tier0Interface", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Tier0Interface Tier0Interface { get; set; }
    
    
    }
    
    /// <summary>IpAddressPoolSubnet can either be carved out of a PolicyBlock or statically specified by the user. In the first case where the subnet is carved out of a IpAddressBlock, the user must specify the ID of the block from which this subnet is to be derived. This block must be pre-created. The subnet range is auto populated by the system. In the second case, the user configures the subnet range directly. No IpAddressBlock is required.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("IpAddressPoolBlockSubnet", typeof(IpAddressPoolBlockSubnet))]
    [JsonInheritanceAttribute("IpAddressPoolStaticSubnet", typeof(IpAddressPoolStaticSubnet))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IpAddressPoolSubnet : PolicyConfigResource
    {
    
    }
    
    /// <summary>Mirrors Data from source to destination</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PortMirroringInstance : PolicyConfigResource
    {
        /// <summary>If this property is set, the packet will be truncated to the provided
        /// length. If this property is unset, entire packet will be mirrored.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("snap_length", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(60D, 65535D)]
        public long? Snap_length { get; set; }
    
        /// <summary>Port mirroring instance direction</summary>
        [Newtonsoft.Json.JsonProperty("direction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PortMirroringInstanceDirection? Direction { get; set; }
    
        /// <summary>Data from source group will be copied to members of
        /// destination group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destination_group", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Destination_group { get; set; }
    
    
    }
    
    /// <summary>This entity will be used to establish association between monitoring
    /// profile and Group. Using this entity, you can specify intent for applying
    /// monitoring profile to particular Group. Group with membership criteria vm
    /// only supported as source group. Port mirroring is only supported on group
    /// with five vms.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GroupMonitoringProfileBindingMap : MonitoringProfileBindingMap
    {
        /// <summary>PolicyPath of associated IPFIX L2 Profile</summary>
        [Newtonsoft.Json.JsonProperty("ipfix_l2_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ipfix_l2_profile_path { get; set; }
    
        /// <summary>PolicyPath of associated IPFIX DFW Profile</summary>
        [Newtonsoft.Json.JsonProperty("ipfix_dfw_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ipfix_dfw_profile_path { get; set; }
    
        /// <summary>PolicyPath of associated Port Mirroring Profile</summary>
        [Newtonsoft.Json.JsonProperty("port_mirroring_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Port_mirroring_profile_path { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GatewayFloodProtectionProfile : FloodProtectionProfile
    {
        /// <summary>The maximum limit of active NAT connections. This limit only apply to EDGE components (such as, gateway). If this property is omitted, or set to null, then there is no limit on the specific component. Meanwhile there is an implicit limit which depends on the underlying hardware resource.</summary>
        [Newtonsoft.Json.JsonProperty("nat_active_conn_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 4294967295D)]
        public long? Nat_active_conn_limit { get; set; } = 4294967295L;
    
    
    }
    
    /// <summary>Advanced load balancer ClientLogStreamingFormat object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBClientLogStreamingFormat 
    {
        /// <summary>List of log fields to be streamed, when selective fields
        /// (LOG_STREAMING_FORMAT_JSON_SELECTED) option is chosen.
        /// Only top-level fields in application or connection logs are
        /// supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("included_fields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Included_fields { get; set; }
    
        /// <summary>Format for the streamed logs.
        /// Enum options - LOG_STREAMING_FORMAT_JSON_FULL,
        /// LOG_STREAMING_FORMAT_JSON_SELECTED.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("format", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBClientLogStreamingFormatFormat Format { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer AuthorizationPolicy object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAuthorizationPolicy 
    {
        /// <summary>Authorization Policy Rules.</summary>
        [Newtonsoft.Json.JsonProperty("authz_rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBAuthorizationRule> Authz_rules { get; set; }
    
    
    }
    
    /// <summary>Paged collection of Firewall Session Timer Profile Binding Maps</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyFirewallSessionTimerProfileBindingMapListResult : ListResult
    {
        /// <summary>Firewall Session Timer Profile Binding Map list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyFirewallSessionTimerProfileBindingMap> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyFirewallSessionTimerProfileBindingMap>();
    
    
    }
    
    /// <summary>Aggregate of DNS forwarder status across enforcement points.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregateDNSForwarderStatus 
    {
        /// <summary>List of DNS forwarder status per enforcement point.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status_per_enforcement_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<DNSForwarderStatusPerEnforcementPoint> Status_per_enforcement_point { get; set; }
    
        /// <summary>String path of the DNS forwarder intent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("intent_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Intent_path { get; set; }
    
    
    }
    
    /// <summary>Global IDS signature.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GlobalIdsSignature : PolicyConfigResource
    {
        /// <summary>It denotes the global action of a IDS Signature.
        /// This will take precedence over IDS signature's action.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public GlobalIdsSignatureAction? Action { get; set; }
    
        /// <summary>Represents the Signature's id.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("signature_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Signature_id { get; set; }
    
        /// <summary>Flag through which user can Enable/Disable a Signature at Global Level.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable { get; set; } = true;
    
    
    }
    
    /// <summary>Represents a container to group widgets that belong to a common category or have a common purpose.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ContainerConfiguration : WidgetConfiguration
    {
        /// <summary>If not specified, creates an empty container.</summary>
        [Newtonsoft.Json.JsonProperty("widgets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<WidgetItem> Widgets { get; set; }
    
        /// <summary>Layout of widgets can be either vertical or horizontal. If layout is not specified a default horizontal layout is applied.</summary>
        [Newtonsoft.Json.JsonProperty("layout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Layout Layout { get; set; }
    
        /// <summary>Labels for the container.</summary>
        [Newtonsoft.Json.JsonProperty("labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Label> Labels { get; set; }
    
        /// <summary>Hyperlink of the specified UI page that provides details.</summary>
        [Newtonsoft.Json.JsonProperty("navigation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Navigation { get; set; }
    
        [Newtonsoft.Json.JsonProperty("header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Header Header { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HealthMonitorTcp object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHealthMonitorTcp 
    {
        /// <summary>Request data to send after completing the TCP handshake.</summary>
        [Newtonsoft.Json.JsonProperty("tcp_request", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tcp_request { get; set; }
    
        /// <summary>Match or look for this keyword in the first 2KB of server's
        /// response indicating server maintenance.
        /// A successful match results in the server being marked down.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maintenance_response", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Maintenance_response { get; set; }
    
        /// <summary>Configure TCP health monitor to use half-open TCP
        /// connections to monitor the health of backend servers thereby
        /// avoiding consumption of a full fledged server side
        /// connection and the overhead and logs associated with it.
        /// This method is light-weight as it makes use of listener in
        /// server's kernel layer to measure the health and a child
        /// socket or user thread is not created on the server side.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tcp_half_open", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Tcp_half_open { get; set; } = false;
    
        /// <summary>Match for the desired keyword in the first 2Kb of the
        /// server's TCP response.
        /// If this field is left blank, no server response is
        /// required.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tcp_response", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tcp_response { get; set; }
    
    
    }
    
    /// <summary>Describes status of configuration of an entity</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConfigurationState 
    {
        /// <summary>Gives details of state of desired configuration.
        /// Additional enums with more details on progress/success/error states
        /// are sent for edge node. The success states are NODE_READY and
        /// TRANSPORT_NODE_READY, pending states are {VM_DEPLOYMENT_QUEUED,
        /// VM_DEPLOYMENT_IN_PROGRESS, REGISTRATION_PENDING} and other values
        /// indicate failures.
        /// "in_sync" state indicates that the desired configuration has been
        /// received by the host to which it applies, but is not yet in effect.
        /// When the configuration is actually in effect, the state will
        /// change to "success".
        /// Please note, failed state is deprecated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConfigurationStateState? State { get; set; }
    
        /// <summary>Array of configuration state of various sub systems</summary>
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ConfigurationStateElement> Details { get; set; }
    
        /// <summary>Error code</summary>
        [Newtonsoft.Json.JsonProperty("failure_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Failure_code { get; set; }
    
        /// <summary>Error message in case of failure</summary>
        [Newtonsoft.Json.JsonProperty("failure_message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Failure_message { get; set; }
    
    
    }
    
    /// <summary>Segment specific L2 VPN configuration</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2Extension 
    {
        /// <summary>Policy paths corresponding to the associated L2 VPN sessions
        /// </summary>
        [Newtonsoft.Json.JsonProperty("l2vpn_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> L2vpn_paths { get; set; }
    
        /// <summary>Local Egress.</summary>
        [Newtonsoft.Json.JsonProperty("local_egress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LocalEgress Local_egress { get; set; }
    
        /// <summary>This property has been deprecated. Please use the property l2vpn_paths
        /// for setting the paths of associated L2 VPN session. This property will
        /// continue to work as expected to provide backwards compatibility.
        /// However, when both l2vpn_path and l2vpn_paths properties
        /// are specified, only l2vpn_paths is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("l2vpn_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string L2vpn_path { get; set; }
    
        /// <summary>Tunnel ID</summary>
        [Newtonsoft.Json.JsonProperty("tunnel_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 4093D)]
        public long? Tunnel_id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RuleStatistics : Resource
    {
        /// <summary>Aggregated number of sessions processed by all the rules
        /// This is aggregated statistic which are computed with lower
        /// frequency compared to individual generic rule  statistics.
        /// It may have a computation delay up to 15 minutes in
        /// response to this API.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("total_session_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total_session_count { get; set; }
    
        /// <summary>This is calculated by sessions count divided by age of the rule.</summary>
        [Newtonsoft.Json.JsonProperty("popularity_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Popularity_index { get; set; }
    
        /// <summary>Maximum value of sessions count of all rules of the type.
        /// This is aggregated statistic which are computed with lower
        /// frequency compared to generic rule statistics. It may have
        /// a computation delay up to 15 minutes in response to this API.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_session_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Max_session_count { get; set; }
    
        /// <summary>Aggregated number of bytes processed by the rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("byte_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Byte_count { get; set; }
    
        /// <summary>Maximum value of popularity index of all rules of the type.
        /// This is aggregated statistic which are computed with lower
        /// frequency compared to individual generic rule statistics.
        /// It may have a computation delay up to 15 minutes in response
        /// to this API.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_popularity_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Max_popularity_index { get; set; }
    
        /// <summary>Aggregated number of sessions processed by the rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("session_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Session_count { get; set; }
    
        /// <summary>Path of the rule.</summary>
        [Newtonsoft.Json.JsonProperty("rule", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rule { get; set; }
    
        /// <summary>Aggregated number of packets processed by the rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packet_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packet_count { get; set; }
    
        /// <summary>Realized id of the rule on NSX MP. Policy Manager can create more than
        /// one rule per policy rule, in which case this identifier helps to
        /// distinguish between the multple rules created.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("internal_rule_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Internal_rule_id { get; set; }
    
        /// <summary>Aggregated number of hits received by the rule.</summary>
        [Newtonsoft.Json.JsonProperty("hit_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Hit_count { get; set; }
    
        /// <summary>Path of the LR on which the section is applied in case of Edge FW.</summary>
        [Newtonsoft.Json.JsonProperty("lr_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lr_path { get; set; }
    
    
    }
    
    /// <summary>Aggregate of DNS forwarder statistics across enforcement points.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregateDNSForwarderStatistics 
    {
        /// <summary>List of DNS forwarder statistics per enforcement point.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("statistics_per_enforcement_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<DNSForwarderStatisticsPerEnforcementPoint> Statistics_per_enforcement_point { get; set; }
    
        /// <summary>String path of the DNS forwarder intent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("intent_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Intent_path { get; set; }
    
    
    }
    
    /// <summary>Paged collection of RouteMaps</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier0RouteMapListResult : ListResult
    {
        /// <summary>Tier0RouteMap results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Tier0RouteMap> Results { get; set; } = new System.Collections.ObjectModel.Collection<Tier0RouteMap>();
    
    
    }
    
    /// <summary>BFD configuration for BGP peers</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BgpBfdConfig 
    {
        /// <summary>Declare dead multiple.
        /// Number of times heartbeat packet is missed before BFD declares the
        /// neighbor is down.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("multiple", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(2D, 16D)]
        public long? Multiple { get; set; } = 3L;
    
        /// <summary>Time interval between heartbeat packets in milliseconds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(50D, 60000D)]
        public long? Interval { get; set; } = 500L;
    
        /// <summary>Flag to enable BFD cofiguration.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = false;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DirectoryGroupMemberListResults : ListResult
    {
        /// <summary>Directory group member list</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<DirectoryGroupMember> Results { get; set; } = new System.Collections.ObjectModel.Collection<DirectoryGroupMember>();
    
    
    }
    
    /// <summary>Service List</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServiceInsertionServiceListResult : ListResult
    {
        /// <summary>List of the Service-Insertion Services. The list has to be homogenous.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ServiceDefinition> Results { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer AutoScaleOpenStackSettings object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAutoScaleOpenStackSettings 
    {
        /// <summary>Avi Controller will use this URL to scale upthe pool.
        /// Cloud connector will automatically update the membership.
        /// This is an alpha feature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("heat_scale_up_url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Heat_scale_up_url { get; set; }
    
        /// <summary>Avi Controller will use this URL to scale downthe pool.
        /// Cloud connector will automatically update the membership.
        /// This is an alpha feature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("heat_scale_down_url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Heat_scale_down_url { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer ErrorPage object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBErrorPage 
    {
        /// <summary>Index of the error page.</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Index { get; set; }
    
        /// <summary>Custom error page body used to sent to the client.
        /// It is a reference to an object of type ErrorPageBody.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("error_page_body_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error_page_body_path { get; set; }
    
        /// <summary>Enable or disable the error page.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable { get; set; } = true;
    
        /// <summary>Add match criteria for http status codes to the error page.</summary>
        [Newtonsoft.Json.JsonProperty("match", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPStatusMatch Match { get; set; }
    
        /// <summary>Redirect sent to client when match.</summary>
        [Newtonsoft.Json.JsonProperty("error_redirect", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error_redirect { get; set; }
    
    
    }
    
    /// <summary>An instance of a datasource configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Datasource 
    {
        /// <summary>Name of a datasource instance.</summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string Display_name { get; set; }
    
        /// <summary>Array of urls relative to the datasource configuration. For example, api/v1/fabric/nodes is a relative url of nsx-manager instance.</summary>
        [Newtonsoft.Json.JsonProperty("urls", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<UrlAlias> Urls { get; set; } = new System.Collections.ObjectModel.Collection<UrlAlias>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LogicalRouterPortStatisticsPerNode : AggregatedLogicalRouterPortCounters
    {
        /// <summary>The ID of the TransportNode</summary>
        [Newtonsoft.Json.JsonProperty("transport_node_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_node_id { get; set; }
    
    
    }
    
    /// <summary>A Security Zone establishes the policies that govern the connectivity of
    /// application tiers. While applications run in a self-service mode, the security
    /// zone policies constrain the connectivity based on the security requirements
    /// of that zone.
    /// In Policy Applications, each application tier is associated with a security zone that
    /// should be pre-created by the VHC admin.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SecurityZone : PolicyConfigResource
    {
        /// <summary>PolicyPath of the sites</summary>
        [Newtonsoft.Json.JsonProperty("sites", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(4)]
        public System.Collections.Generic.ICollection<string> Sites { get; set; }
    
    
    }
    
    /// <summary>Configuration of livetrace packet granular action</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LiveTracePacketGranularActionConfig 
    {
        /// <summary>Filter for flows of interest at the reverse direction. It is required only when the trace type is bidirectional.
        /// Multiple bi-directional actions in a livetrace session should have the same filter specified for the reverse
        /// direction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reverse_filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LiveTraceFilterData Reverse_filter { get; set; }
    
        /// <summary>Type of trace</summary>
        [Newtonsoft.Json.JsonProperty("trace_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LiveTracePacketGranularActionConfigTrace_type Trace_type { get; set; }
    
        /// <summary>Policy path of logical port for the reverse direction of a livetrace session. It is required only when the
        /// trace type is bidirectional. Multiple bi-directional actions in a livetrace session should have the same
        /// port specified for the reverse direction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dest_port_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dest_port_path { get; set; }
    
        /// <summary>Sampling parameter for the action. Trace action and packet capture action only support first-N sampling.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sampling", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public LiveTraceSamplingConfig Sampling { get; set; } = new LiveTraceSamplingConfig();
    
    
    }
    
    /// <summary>This type is deprecated. Use the type SecurityPolicyListResult instead.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CommunicationMapListResult : ListResult
    {
        /// <summary>CommunicationMap list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<CommunicationMap> Results { get; set; } = new System.Collections.ObjectModel.Collection<CommunicationMap>();
    
    
    }
    
    /// <summary>IDS Rule Statistics.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsRuleStatistics : RuleStatistics
    {
    
    }
    
    /// <summary>Collection of Evpn Tenant Configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EvpnTenantConfigListResult : ListResult
    {
        /// <summary>Evpn Tenant Config list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<EvpnTenantConfig> Results { get; set; } = new System.Collections.ObjectModel.Collection<EvpnTenantConfig>();
    
    
    }
    
    /// <summary>Application is a collection of Tiers where every tier shares common Security
    /// and networking requirements. Application API exposes self service model of consumption.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Application : PolicyConfigResource
    {
        /// <summary>Path of the sites</summary>
        [Newtonsoft.Json.JsonProperty("sites", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(4)]
        public System.Collections.Generic.ICollection<string> Sites { get; set; }
    
    
    }
    
    /// <summary>An arbitrary key-value pair</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class KeyValuePair 
    {
        /// <summary>Value</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string Value { get; set; }
    
        /// <summary>Key</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string Key { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer SecurityPolicy object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSecurityPolicy : PolicyConfigResource
    {
        /// <summary>Index of the network security policy to use for the
        /// mitigation rules applied to the attacks.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("network_security_policy_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Network_security_policy_index { get; set; } = 0L;
    
        /// <summary>Mode of dealing with the attacks - perform detection only,
        /// or detect and mitigate the attacks.
        /// Enum options - DETECTION, MITIGATION.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as DETECTION.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oper_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBSecurityPolicyOper_mode? Oper_mode { get; set; } = SDKGenerator.ALBSecurityPolicyOper_mode.DETECTION;
    
        /// <summary>Attacks utilizing the DNS protocol operations.</summary>
        [Newtonsoft.Json.JsonProperty("dns_attacks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDnsAttacks Dns_attacks { get; set; }
    
        /// <summary>Index of the dns policy to use for the mitigation rules
        /// applied to the dns attacks.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dns_policy_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dns_policy_index { get; set; } = 0L;
    
    
    }
    
    /// <summary>Global configuration</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FIPSGlobalConfig 
    {
        /// <summary>When this flag is set to true FIPS mode will be set on ssl encryptions of load balancer feature.</summary>
        [Newtonsoft.Json.JsonProperty("lb_fips_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Lb_fips_enabled { get; set; } = false;
    
    
    }
    
    /// <summary>Child wrapper for ALBPriorityLabels, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBPriorityLabels : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBPriorityLabels object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBPriorityLabels", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBPriorityLabels ALBPriorityLabels { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyTepCsvListResult : CsvListResult
    {
        /// <summary>Timestamp when the data was last updated; unset if data source has never updated the data.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyTepTableCsvRecord> Results { get; set; }
    
    
    }
    
    /// <summary>Contains BGP routing configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BgpRoutingConfig : PolicyConfigResource
    {
        /// <summary>Flag to enable inter SR IBGP configuration.
        /// When not specified, inter SR IBGP is automatically enabled if Tier-0
        /// is created in ACTIVE_ACTIVE ha_mode.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inter_sr_ibgp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Inter_sr_ibgp { get; set; }
    
        /// <summary>Specify BGP AS number for Tier-0 to advertize to BGP peers.
        /// AS number can be specified in ASPLAIN (e.g., "65546") or
        /// ASDOT (e.g., "1.10") format. Empty string disables BGP feature.
        /// It is required by normal tier0 but not required in vrf tier0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("local_as_num", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Local_as_num { get; set; }
    
        /// <summary>Flag to enable graceful restart. This field is deprecated, please use
        /// graceful_restart_config parameter for graceful restart configuration.
        /// If both parameters are set and consistent with each other
        /// (i.e. graceful_restart=false and graceful_restart_mode=HELPER_ONLY OR
        /// graceful_restart=true and graceful_restart_mode=GR_AND_HELPER)
        /// then this is allowed, but if inconsistent with each other then this
        /// is not allowed and validation error will be thrown.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("graceful_restart", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Graceful_restart { get; set; }
    
        /// <summary>List of routes to be aggregated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("route_aggregations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1000)]
        public System.Collections.Generic.ICollection<RouteAggregationEntry> Route_aggregations { get; set; }
    
        /// <summary>Flag to enable BGP configuration. Disabling will stop feature and
        /// BGP peering.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }
    
        /// <summary>Configuration field to hold BGP Restart mode and timer.</summary>
        [Newtonsoft.Json.JsonProperty("graceful_restart_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public BgpGracefulRestartConfig Graceful_restart_config { get; set; }
    
        /// <summary>Flag to enable BGP multipath relax option.</summary>
        [Newtonsoft.Json.JsonProperty("multipath_relax", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Multipath_relax { get; set; }
    
        /// <summary>Flag to enable ECMP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ecmp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Ecmp { get; set; }
    
    
    }
    
    /// <summary>Paged collection of Port Monitoring Profile Binding Maps</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PortMonitoringProfileBindingMapListResult : ListResult
    {
        /// <summary>Port Monitoring Profile Binding Map list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PortMonitoringProfileBindingMap> Results { get; set; } = new System.Collections.ObjectModel.Collection<PortMonitoringProfileBindingMap>();
    
    
    }
    
    /// <summary>Used to specify the display name and value of the IPv4Address.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyIPAddressInfo 
    {
        /// <summary>Next hop used in auto-plumbing of static route. If a value is not
        /// provided, static route will not be auto-plumbed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("next_hop", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Next_hop { get; set; }
    
        /// <summary>Value of the IPv4Address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("address_value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Address_value { get; set; }
    
        /// <summary>Display name used to help identify the IPv4Address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Display_name { get; set; }
    
    
    }
    
    /// <summary>Aggregate statistics of all the IDS rules in a security policy for a specific
    /// enforcement point.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsSecurityPolicyStatisticsForEnforcementPoint 
    {
        /// <summary>Enforcement point to fetch the statistics from.</summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enforcement_point { get; set; }
    
        /// <summary>Statistics for the specified enforcement point</summary>
        [Newtonsoft.Json.JsonProperty("statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IdsSecurityPolicyStatistics Statistics { get; set; }
    
    
    }
    
    /// <summary>Statistics for NICs for a PolicyServiceInstance</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyServiceInstanceStatistics : Resource
    {
        /// <summary>PolicyServiceInsatnce path</summary>
        [Newtonsoft.Json.JsonProperty("service_instance_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Service_instance_id { get; set; }
    
        /// <summary>Statistics for the data NICs for all the runtimes associated
        /// with this service instance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("instance_runtime_statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InstanceRuntimeStatistic> Instance_runtime_statistics { get; set; }
    
        /// <summary>Enforcement point path, forward slashes must be escaped using %2F.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enforcement_point_path { get; set; }
    
    
    }
    
    /// <summary>This resource is relevant only when Evpn Service is configured in ROUTE-SERVER mode.
    /// The resource defines Vlans to VNIs mappings used by Evpn tenant VMs for overlay VXLAN transmission when attached
    /// to vRouter. The resource contains overlay transport_zone_path and vni_pool_path to orchestrate creation of child Logical-Switches.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EvpnTenantConfig : PolicyConfigResource
    {
        /// <summary>Policy path to transport zone. Only overlay transport zone is supported.</summary>
        [Newtonsoft.Json.JsonProperty("transport_zone_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Transport_zone_path { get; set; }
    
        /// <summary>This property specifies a mapping spec of incoming Evpn tenant vlan-ids to VXLAN VNIs used for overlay
        /// transmission to Physical-Gateways used by vRouters.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mappings", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(2000)]
        public System.Collections.Generic.ICollection<VlanVniRangePair> Mappings { get; set; } = new System.Collections.ObjectModel.Collection<VlanVniRangePair>();
    
        /// <summary>Policy path to the vni pool used for Evpn in ROUTE-SERVER mode.</summary>
        [Newtonsoft.Json.JsonProperty("vni_pool_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Vni_pool_path { get; set; }
    
    
    }
    
    /// <summary>Base security profile binding map</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SecurityProfileBindingMap : PolicyConfigResource
    {
    
    }
    
    /// <summary>L4PolicySetApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBL4PolicySetApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of L4PolicySet
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBL4PolicySet> Results { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer VSDataScripts object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBVSDataScripts 
    {
        /// <summary>Index of the virtual service datascript collection.</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public long Index { get; set; }
    
        /// <summary>path of the virtual service datascript collection.
        /// It is a reference to an object of type VSDataScriptSet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vs_datascript_set_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Vs_datascript_set_path { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer QueryMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBQueryMatch 
    {
        /// <summary>Case sensitivity to use for the match.
        /// Enum options - SENSITIVE, INSENSITIVE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as INSENSITIVE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_case", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBQueryMatchMatch_case? Match_case { get; set; } = SDKGenerator.ALBQueryMatchMatch_case.INSENSITIVE;
    
        /// <summary>path of the string group(s).
        /// It is a reference to an object of type StringGroup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("string_group_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> String_group_paths { get; set; }
    
        /// <summary>String value(s).</summary>
        [Newtonsoft.Json.JsonProperty("match_str", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Match_str { get; set; }
    
        /// <summary>Criterion to use for matching the query in HTTP request
        /// URI.
        /// Enum options - QUERY_MATCH_CONTAINS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBQueryMatchMatch_criteria Match_criteria { get; set; }
    
    
    }
    
    /// <summary>NetworkProfileApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBNetworkProfileApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of NetworkProfile
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBNetworkProfile> Results { get; set; }
    
    
    }
    
    /// <summary>Used to configure DNS Forwarder</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyDnsForwarder : PolicyConfigResource
    {
        /// <summary>The flag, which suggests whether the DNS forwarder is enabled or
        /// disabled. The default is True.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
        /// <summary>Set log_level to DISABLED will stop dumping fowarder log.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("log_level", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyDnsForwarderLog_level? Log_level { get; set; } = SDKGenerator.PolicyDnsForwarderLog_level.INFO;
    
        /// <summary>Max of 5 DNS servers can be configured</summary>
        [Newtonsoft.Json.JsonProperty("conditional_forwarder_zone_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(5)]
        public System.Collections.Generic.ICollection<string> Conditional_forwarder_zone_paths { get; set; }
    
        /// <summary>This is the zone to which DNS requests are forwarded by default
        /// </summary>
        [Newtonsoft.Json.JsonProperty("default_forwarder_zone_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Default_forwarder_zone_path { get; set; }
    
        /// <summary>This is the IP on which the DNS Forwarder listens.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("listener_ip", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Listener_ip { get; set; }
    
    
    }
    
    /// <summary>A packet is classified to have an address binding, if its address
    /// configuration matches with all user specified properties.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PacketAddressClassifier 
    {
        /// <summary>Virtual Local Area Network Identifier</summary>
        [Newtonsoft.Json.JsonProperty("vlan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Vlan { get; set; }
    
        /// <summary>A single IP address or a subnet, e.g. x.x.x.x or x.x.x.x/y</summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ip_address { get; set; }
    
        /// <summary>A single MAC address</summary>
        [Newtonsoft.Json.JsonProperty("mac_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Mac_address { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer NetworkSecurityRule object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBNetworkSecurityRule 
    {
        /// <summary>Number of index.</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public long Index { get; set; }
    
        /// <summary>Placeholder for description of property enable of obj type
        /// NetworkSecurityRule field type str  type boolean.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable", Required = Newtonsoft.Json.Required.Always)]
        public bool Enable { get; set; }
    
        /// <summary>Placeholder for description of property log of obj type
        /// NetworkSecurityRule field type str  type boolean.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("log", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Log { get; set; } = false;
    
        /// <summary>Name of the object.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>Enum options - NETWORK_SECURITY_POLICY_ACTION_TYPE_ALLOW,
        /// NETWORK_SECURITY_POLICY_ACTION_TYPE_DENY,
        /// NETWORK_SECURITY_POLICY_ACTION_TYPE_RATE_LIMIT.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBNetworkSecurityRuleAction Action { get; set; }
    
        /// <summary>Time in minutes after which rule will be deleted.
        /// Allowed values are 1-4294967295.
        /// Special values are 0- 'blocked for ever'.
        /// Unit is MIN.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("age", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? Age { get; set; } = 0L;
    
        /// <summary>Placeholder for description of property rl_param of obj
        /// type NetworkSecurityRule field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rl_param", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBNetworkSecurityPolicyActionRLParam Rl_param { get; set; }
    
        /// <summary>Creator name.</summary>
        [Newtonsoft.Json.JsonProperty("created_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_by { get; set; }
    
        /// <summary>Placeholder for description of property match of obj type
        /// NetworkSecurityRule field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBNetworkSecurityMatchTarget Match { get; set; } = new ALBNetworkSecurityMatchTarget();
    
    
    }
    
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("PlainFilterData", typeof(PlainFilterData))]
    [JsonInheritanceAttribute("FieldsFilterData", typeof(FieldsFilterData))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LiveTraceFilterData 
    {
    
    }
    
    /// <summary>Child wrapper object for PolicyUrlCategorizationConfig, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyUrlCategorizationConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyUrlCategorizationConfig object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyUrlCategorizationConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyUrlCategorizationConfig PolicyUrlCategorizationConfig { get; set; }
    
    
    }
    
    /// <summary>A Limiter configuration entry that specifies type and metrics</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("EgressRateLimiter", typeof(EgressRateLimiter))]
    [JsonInheritanceAttribute("IngressBroadcastRateLimiter", typeof(IngressBroadcastRateLimiter))]
    [JsonInheritanceAttribute("IngressRateLimiter", typeof(IngressRateLimiter))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class QoSBaseRateLimiter 
    {
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }
    
    
    }
    
    /// <summary>The capacity contains basic information and load balancer entity usages
    /// and capacity for the given edge node.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBEdgeNodeUsage : LBNodeUsage
    {
        /// <summary>The count of medium load balancer services configured on the node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_medium_load_balancer_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Current_medium_load_balancer_count { get; set; }
    
        /// <summary>The remaining count of xlarge load balancer services which can be
        /// configured on the given edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remaining_xlarge_load_balancer_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Remaining_xlarge_load_balancer_count { get; set; }
    
        /// <summary>The severity calculation is based on current credit usage percentage
        /// of load balancer for one node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("severity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBEdgeNodeUsageSeverity? Severity { get; set; }
    
        /// <summary>Pool member capacity means maximum number of pool members which can
        /// be configured on the given edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_member_capacity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Pool_member_capacity { get; set; }
    
        /// <summary>The count of virtual servers configured on the node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_virtual_server_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Current_virtual_server_count { get; set; }
    
        /// <summary>The count of xlarge load balancer services configured on the node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_xlarge_load_balancer_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Current_xlarge_load_balancer_count { get; set; }
    
        /// <summary>The count of pools configured on the node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_pool_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Current_pool_count { get; set; }
    
        /// <summary>The remaining count of small load balancer services which can be
        /// configured on the given edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remaining_small_load_balancer_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Remaining_small_load_balancer_count { get; set; }
    
        /// <summary>The count of pool members configured on the node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_pool_member_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Current_pool_member_count { get; set; }
    
        /// <summary>The load balancer credit capacity means the maximum credits which can
        /// be used for load balancer configuration for the given edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("load_balancer_credit_capacity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Load_balancer_credit_capacity { get; set; }
    
        /// <summary>The path of edge cluster which contains the edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_cluster_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Edge_cluster_path { get; set; }
    
        /// <summary>The current load balancer credits means the current credits used on the
        /// node. For example, configuring a medium load balancer on a node
        /// consumes 10 credits. If there are 2 medium instances configured on a
        /// node, the current credit number is 2 * 10 = 20.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_load_balancer_credits", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Current_load_balancer_credits { get; set; }
    
        /// <summary>The remaining count of large load balancer services which can be
        /// configured on the given edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remaining_large_load_balancer_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Remaining_large_load_balancer_count { get; set; }
    
        /// <summary>The count of large load balancer services configured on the node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_large_load_balancer_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Current_large_load_balancer_count { get; set; }
    
        /// <summary>The form factor of the given edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("form_factor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBEdgeNodeUsageForm_factor? Form_factor { get; set; }
    
        /// <summary>The usage percentage of the edge node for load balancer.
        /// The value is the larger value between load balancer credit usage
        /// percentage and pool member usage percentage for the edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("usage_percentage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Usage_percentage { get; set; }
    
        /// <summary>The count of small load balancer services configured on the node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_small_load_balancer_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Current_small_load_balancer_count { get; set; }
    
        /// <summary>The remaining count of medium load balancer services which can be
        /// configured on the given edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remaining_medium_load_balancer_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Remaining_medium_load_balancer_count { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer NetworkSecurityPolicyActionRLParam object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBNetworkSecurityPolicyActionRLParam 
    {
        /// <summary>Maximum number of connections or requests or packets per
        /// second.
        /// Allowed values are 1-4294967295.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_rate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1D, 4294967295D)]
        public long Max_rate { get; set; }
    
        /// <summary>Maximum number of connections or requests or packets to be
        /// rate limited instantaneously.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("burst_size", Required = Newtonsoft.Json.Required.Always)]
        public long Burst_size { get; set; } = 0L;
    
    
    }
    
    /// <summary>Some applications maintain state and require all relevant connections
    /// to be sent to the same server as the application state is not
    /// synchronized among servers. Persistence is enabled on a
    /// PolicyLbVirtualServer
    /// by binding a persistence profile to it.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L7PolicyLbPersistenceProfile : PolicyLbPersistenceProfile
    {
        /// <summary>This field indicates the persistence method used for the
        /// PolicyLbVirtualServer.
        /// - COOKIE persistence allows related client connections, identified by
        /// the same cookie in HTTP requests [Refer to HTTP Cookie for details
        /// on HTTP cookies], to be redirected to the same server. Load
        /// balancer does not maintain any persistence table for cookie
        /// persistence. Instead, it encodes the necessary information in the
        /// HTTP cookie value sent to client and relies on the client to store
        /// it and send it back in subsequent related HTTP requests. Hence
        /// there is no limit on the number of cookie persistence entries that
        /// can be supported.
        /// - This object is not required and persistence is disabled by default
        /// </summary>
        [Newtonsoft.Json.JsonProperty("persistence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public L7PolicyLbPersistenceProfilePersistence? Persistence { get; set; } = SDKGenerator.L7PolicyLbPersistenceProfilePersistence.COOKIE;
    
    
    }
    
    /// <summary>Contains the binding relationship between port and security profile.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PortSecurityProfileBindingMap : SecurityProfileBindingMap
    {
        /// <summary>The policy path of the asscociated SpoofGuard profile</summary>
        [Newtonsoft.Json.JsonProperty("spoofguard_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Spoofguard_profile_path { get; set; }
    
        /// <summary>The policy path of the asscociated Segment Security profile</summary>
        [Newtonsoft.Json.JsonProperty("segment_security_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Segment_security_profile_path { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer WafRuleGroup object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWafRuleGroup 
    {
        /// <summary>Rules as per Modsec language.
        /// Maximum of 1024 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBWafRule> Rules { get; set; }
    
        /// <summary>Exclude list for the WAF rule group.
        /// The fields in the exclude list entry are logically and'ed
        /// to deduce the exclusion criteria.
        /// If there are multiple excludelist entries, it will be
        /// 'logical or' of them.
        /// Maximum of 64 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBWafExcludeListEntry> Exclude_list { get; set; }
    
        /// <summary>Enable or disable WAF Rule Group.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable { get; set; } = true;
    
        /// <summary>Name of the object.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>Number of index.</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public long Index { get; set; }
    
    
    }
    
    /// <summary>Describes the capacity and current usage of virtual servers, pools and pool
    /// members for the given load balancer service.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBServiceUsage : LBServiceUsagePerEP
    {
        /// <summary>Pool capacity means maximum number of pools which could be configured in
        /// the given load balancer service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_capacity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Pool_capacity { get; set; }
    
        /// <summary>The size of load balancer service.</summary>
        [Newtonsoft.Json.JsonProperty("service_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBServiceUsageService_size? Service_size { get; set; }
    
        /// <summary>The severity calculation is based on the largest usage percentage from
        /// virtual servers, pools and pool members for one load balancer service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("severity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBServiceUsageSeverity? Severity { get; set; }
    
        /// <summary>Pool member capacity means maximum number of pool members which could be
        /// configured in the given load balancer service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_member_capacity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Pool_member_capacity { get; set; }
    
        /// <summary>The current number of virtual servers which has been configured in the
        /// given load balancer service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_virtual_server_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Current_virtual_server_count { get; set; }
    
        /// <summary>Timestamp when the data was last updated.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>The current number of pools which has been configured in the given load
        /// balancer service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_pool_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Current_pool_count { get; set; }
    
        /// <summary>The current number of pool members which has been configured in the given
        /// load balancer service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_pool_member_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Current_pool_member_count { get; set; }
    
        /// <summary>The usage percentage is the largest usage percentage from virtual
        /// servers, pools and pool members for the load balancer service. If the
        /// property relax_scale_validation is set as true for LBService, it is
        /// possible that the value is larger than 100.0. For example, if SMALL LBS
        /// is deployed on MEDIUM edge node and configured with MEDIUM LBS virtual
        /// server scale number, LBS usage percentage is shown larger than 100.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("usage_percentage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Usage_percentage { get; set; }
    
        /// <summary>Virtual server capacity means maximum number of virtual servers which
        /// could be configured in the given load balancer service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("virtual_server_capacity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Virtual_server_capacity { get; set; }
    
        /// <summary>LBService object path.</summary>
        [Newtonsoft.Json.JsonProperty("service_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Service_path { get; set; }
    
    
    }
    
    /// <summary>Field Setting Value.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("ConstantFieldValue", typeof(ConstantFieldValue))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FieldSettingValue 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EthernetHeader 
    {
        /// <summary>The destination MAC address of form:
        /// "^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$". For example: 00:00:00:00:00:00.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dst_mac", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dst_mac { get; set; }
    
        /// <summary>This field defaults to IPv4.</summary>
        [Newtonsoft.Json.JsonProperty("eth_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long? Eth_type { get; set; } = 2048L;
    
        /// <summary>The source MAC address of form:
        /// "^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$". For example: 00:00:00:00:00:00.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("src_mac", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Src_mac { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer L4PolicySet object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBL4PolicySet : PolicyConfigResource
    {
        /// <summary>Policy to apply when a new transport connection is setup.</summary>
        [Newtonsoft.Json.JsonProperty("l4_connection_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBL4ConnectionPolicy L4_connection_policy { get; set; }
    
        /// <summary>Creator name.</summary>
        [Newtonsoft.Json.JsonProperty("created_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_by { get; set; }
    
        /// <summary>Placeholder for description of property is_internal_policy
        /// of obj type L4PolicySet field type str  type boolean.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_internal_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_internal_policy { get; set; } = false;
    
    
    }
    
    /// <summary>Resources managed during restore process</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ActionableResource : ManagedResource
    {
        /// <summary>A resource reference on which actions can be performed</summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ip_address { get; set; }
    
    
    }
    
    /// <summary>L2Vpn Session Remote Macs Per Enforcement Point.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("L2VpnSessionRemoteMacNsxT", typeof(L2VpnSessionRemoteMacNsxT))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VpnSessionRemoteMacPerEP : PolicyRuntimeInfoPerEP
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class InterfaceArpTable : ListResult
    {
        /// <summary>Timestamp when the data was last updated; unset if data source has never updated the data.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>The ID of the logical router port</summary>
        [Newtonsoft.Json.JsonProperty("interface_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Interface_path { get; set; }
    
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InterfaceArpEntry> Results { get; set; }
    
        /// <summary>Policy path of edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Edge_path { get; set; }
    
        /// <summary>String Path of the enforcement point.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enforcement_point_path { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class InterSitePortCounters : LogicalRouterPortCounters
    {
    
    }
    
    /// <summary>Advanced load balancer HardwareSecurityModule object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHardwareSecurityModule 
    {
        /// <summary>Thales Remote File Server (RFS), used for the netHSMs,
        /// configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rfs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHSMThalesRFS Rfs { get; set; }
    
        /// <summary>HSM type to use.
        /// Enum options - HSM_TYPE_THALES_NETHSM,
        /// HSM_TYPE_SAFENET_LUNA, HSM_TYPE_AWS_CLOUDHSM.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHardwareSecurityModuleType Type { get; set; }
    
        /// <summary>Safenet/Gemalto Luna/Gem specific configuration.</summary>
        [Newtonsoft.Json.JsonProperty("sluna", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHSMSafenetLuna Sluna { get; set; }
    
        /// <summary>AWS CloudHSM specific configuration.</summary>
        [Newtonsoft.Json.JsonProperty("cloudhsm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHSMAwsCloudHsm Cloudhsm { get; set; }
    
        /// <summary>Thales netHSM specific configuration.</summary>
        [Newtonsoft.Json.JsonProperty("nethsm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBHSMThalesNetHsm> Nethsm { get; set; }
    
    
    }
    
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("LBPassiveMonitorProfile", typeof(LBPassiveMonitorProfile))]
    [JsonInheritanceAttribute("LBTcpMonitorProfile", typeof(LBTcpMonitorProfile))]
    [JsonInheritanceAttribute("LBActiveMonitor", typeof(LBActiveMonitor))]
    [JsonInheritanceAttribute("LBUdpMonitorProfile", typeof(LBUdpMonitorProfile))]
    [JsonInheritanceAttribute("LBIcmpMonitorProfile", typeof(LBIcmpMonitorProfile))]
    [JsonInheritanceAttribute("LBHttpsMonitorProfile", typeof(LBHttpsMonitorProfile))]
    [JsonInheritanceAttribute("LBHttpMonitorProfile", typeof(LBHttpMonitorProfile))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBMonitorProfile : PolicyConfigResource
    {
    
    }
    
    /// <summary>Tier0 or Tier1 interface statistics on specific Enforcement Point.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyInterfaceStatisticsSummary : LogicalRouterPortStatisticsSummary
    {
        /// <summary>Policy path for the interface</summary>
        [Newtonsoft.Json.JsonProperty("interface_policy_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Interface_policy_path { get; set; }
    
    
    }
    
    /// <summary>This action is used to select SSL mode. Three types of SSL mode actions can
    /// be specified in Transport phase, ssl passthrough, ssl offloading and ssl
    /// end-to-end.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBSslModeSelectionAction : LBRuleAction
    {
        /// <summary>SSL Passthrough: LB establishes a TCP connection with client and another
        /// connection with selected backend server. LB won't inspect the stream
        /// data between client and backend server, but just pass it through.
        /// Backend server exchanges SSL connection with client.
        /// SSL Offloading: LB terminiates the connections from client, and
        /// establishes SSL connection with it. After receiving the HTTP request,
        /// LB connects the selected backend server and talk with it via HTTP
        /// without SSL. LB estalishes new connection to selected backend server
        /// for each HTTP request, in case server_keep_alive or multiplexing are
        /// NOT configured.
        /// SSL End-to-End: LB terminiates the connections from client, and
        /// establishes SSL connection with it. After receiving the HTTP request,
        /// LB connects the selected backend server and talk with it via HTTPS.
        /// LB estalishes new SSL connection to selected backend server for each
        /// HTTP request, in case server_keep_alive or multiplexing are NOT
        /// configured.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ssl_mode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBSslModeSelectionActionSsl_mode Ssl_mode { get; set; }
    
    
    }
    
    /// <summary>Represents configuration of a Grid or Table widget.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GridConfiguration : WidgetConfiguration
    {
        /// <summary>Number of records per page. page_size will be effective only when the urls provided in the datasource support paging.</summary>
        [Newtonsoft.Json.JsonProperty("page_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Page_size { get; set; } = 30L;
    
        /// <summary>Rows of grid or table are formed from the list of objects returned by a row list field.</summary>
        [Newtonsoft.Json.JsonProperty("row_list_fields", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<RowListField> Row_list_fields { get; set; } = new System.Collections.ObjectModel.Collection<RowListField>();
    
        /// <summary>Array of columns of a Grid widget</summary>
        [Newtonsoft.Json.JsonProperty("columns", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ColumnItem> Columns { get; set; } = new System.Collections.ObjectModel.Collection<ColumnItem>();
    
    
    }
    
    /// <summary>Multicast Forwarding.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyMulticastForwarding 
    {
        /// <summary>Policy path to Tier0 or Tier1 gateway.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gateway_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Gateway_path { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mcast_forwarding_per_edge", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MulticastForwardingPerEdge> Mcast_forwarding_per_edge { get; set; }
    
    
    }
    
    /// <summary>Network policy applied to container.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ContainerNetworkPolicy : DiscoveredResource
    {
        /// <summary>Network status of container network policy.</summary>
        [Newtonsoft.Json.JsonProperty("network_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ContainerNetworkPolicyNetwork_status? Network_status { get; set; }
    
        /// <summary>Identifier of the container cluster this network policy belongs to.</summary>
        [Newtonsoft.Json.JsonProperty("container_cluster_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Container_cluster_id { get; set; }
    
        /// <summary>Type e.g. Network Policy, ASG.</summary>
        [Newtonsoft.Json.JsonProperty("policy_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ContainerNetworkPolicyPolicy_type? Policy_type { get; set; }
    
        /// <summary>Array of additional specific properties of container network policy
        /// in key-value format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("origin_properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyValuePair> Origin_properties { get; set; }
    
        /// <summary>Identifier of the container network policy.</summary>
        [Newtonsoft.Json.JsonProperty("external_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string External_id { get; set; }
    
        /// <summary>Identifier of the project which this network policy belongs to.</summary>
        [Newtonsoft.Json.JsonProperty("container_project_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Container_project_id { get; set; }
    
        /// <summary>List of network errors related to container network policy.</summary>
        [Newtonsoft.Json.JsonProperty("network_errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<NetworkError> Network_errors { get; set; }
    
        /// <summary>Container network policy specification.</summary>
        [Newtonsoft.Json.JsonProperty("spec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Spec { get; set; }
    
    
    }
    
    /// <summary>VirtualServiceApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBVirtualServiceApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of VirtualService
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBVirtualService> Results { get; set; }
    
    
    }
    
    /// <summary>Base type for CSV records.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CsvRecord 
    {
    
    }
    
    /// <summary>Advanced load balancer DnsARdata object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsARdata 
    {
        /// <summary>IP address for FQDN.</summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBIpAddr Ip_address { get; set; } = new ALBIpAddr();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VirtualMachineListResult : ListResult
    {
        /// <summary>VirtualMachine list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<VirtualMachine> Results { get; set; } = new System.Collections.ObjectModel.Collection<VirtualMachine>();
    
    
    }
    
    /// <summary>Represents an object on the desired state</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("ChildPolicyMulticastConfig", typeof(ChildPolicyMulticastConfig))]
    [JsonInheritanceAttribute("ChildPolicySIExcludeList", typeof(ChildPolicySIExcludeList))]
    [JsonInheritanceAttribute("ChildALBL4PolicySet", typeof(ChildALBL4PolicySet))]
    [JsonInheritanceAttribute("ChildVirtualEndpoint", typeof(ChildVirtualEndpoint))]
    [JsonInheritanceAttribute("ChildIpAddressBlock", typeof(ChildIpAddressBlock))]
    [JsonInheritanceAttribute("ChildStaticRouteBfdPeer", typeof(ChildStaticRouteBfdPeer))]
    [JsonInheritanceAttribute("ChildALBTrafficCloneProfile", typeof(ChildALBTrafficCloneProfile))]
    [JsonInheritanceAttribute("ChildStaticRoutes", typeof(ChildStaticRoutes))]
    [JsonInheritanceAttribute("ChildALBErrorPageProfile", typeof(ChildALBErrorPageProfile))]
    [JsonInheritanceAttribute("ChildSecurityZoneRule", typeof(ChildSecurityZoneRule))]
    [JsonInheritanceAttribute("ChildServiceSegment", typeof(ChildServiceSegment))]
    [JsonInheritanceAttribute("ChildPolicyFirewallSessionTimerProfile", typeof(ChildPolicyFirewallSessionTimerProfile))]
    [JsonInheritanceAttribute("ChildSecurityZone", typeof(ChildSecurityZone))]
    [JsonInheritanceAttribute("ChildL2Vpn", typeof(ChildL2Vpn))]
    [JsonInheritanceAttribute("ChildPolicyFirewallFloodProtectionProfileBindingMap", typeof(ChildPolicyFirewallFloodProtectionProfileBindingMap))]
    [JsonInheritanceAttribute("ChildTier0", typeof(ChildTier0))]
    [JsonInheritanceAttribute("ChildTier1", typeof(ChildTier1))]
    [JsonInheritanceAttribute("ChildIPSecVpnTunnelProfile", typeof(ChildIPSecVpnTunnelProfile))]
    [JsonInheritanceAttribute("ChildGroup", typeof(ChildGroup))]
    [JsonInheritanceAttribute("ChildSessionTimerProfileBindingMap", typeof(ChildSessionTimerProfileBindingMap))]
    [JsonInheritanceAttribute("ChildALBNetworkSecurityPolicy", typeof(ChildALBNetworkSecurityPolicy))]
    [JsonInheritanceAttribute("ChildALBWafPolicy", typeof(ChildALBWafPolicy))]
    [JsonInheritanceAttribute("ChildConstraint", typeof(ChildConstraint))]
    [JsonInheritanceAttribute("ChildPolicyDnsForwarderZone", typeof(ChildPolicyDnsForwarderZone))]
    [JsonInheritanceAttribute("ChildIPSecVpnDpdProfile", typeof(ChildIPSecVpnDpdProfile))]
    [JsonInheritanceAttribute("ChildPolicyLbVirtualServer", typeof(ChildPolicyLbVirtualServer))]
    [JsonInheritanceAttribute("ChildSpoofGuardProfile", typeof(ChildSpoofGuardProfile))]
    [JsonInheritanceAttribute("ChildTlsCrl", typeof(ChildTlsCrl))]
    [JsonInheritanceAttribute("ChildLBAppProfile", typeof(ChildLBAppProfile))]
    [JsonInheritanceAttribute("ChildALBWebhook", typeof(ChildALBWebhook))]
    [JsonInheritanceAttribute("ChildEndpointRule", typeof(ChildEndpointRule))]
    [JsonInheritanceAttribute("ChildALBStringGroup", typeof(ChildALBStringGroup))]
    [JsonInheritanceAttribute("ChildSIStatusConfiguration", typeof(ChildSIStatusConfiguration))]
    [JsonInheritanceAttribute("ChildPortMirroringProfile", typeof(ChildPortMirroringProfile))]
    [JsonInheritanceAttribute("ChildGeneralSecurityProfile", typeof(ChildGeneralSecurityProfile))]
    [JsonInheritanceAttribute("ChildTier0Interface", typeof(ChildTier0Interface))]
    [JsonInheritanceAttribute("ChildALBPriorityLabels", typeof(ChildALBPriorityLabels))]
    [JsonInheritanceAttribute("ChildPolicyUrlCategorizationConfig", typeof(ChildPolicyUrlCategorizationConfig))]
    [JsonInheritanceAttribute("ChildALBHealthMonitor", typeof(ChildALBHealthMonitor))]
    [JsonInheritanceAttribute("ChildSite", typeof(ChildSite))]
    [JsonInheritanceAttribute("ChildForwardingRule", typeof(ChildForwardingRule))]
    [JsonInheritanceAttribute("ChildSegmentSecurityProfile", typeof(ChildSegmentSecurityProfile))]
    [JsonInheritanceAttribute("ChildCommunicationMap", typeof(ChildCommunicationMap))]
    [JsonInheritanceAttribute("ChildIPFIXDFWCollectorProfile", typeof(ChildIPFIXDFWCollectorProfile))]
    [JsonInheritanceAttribute("ChildGroupDiscoveryProfileBindingMap", typeof(ChildGroupDiscoveryProfileBindingMap))]
    [JsonInheritanceAttribute("ChildGatewayQosProfile", typeof(ChildGatewayQosProfile))]
    [JsonInheritanceAttribute("ChildALBAutoScaleLaunchConfig", typeof(ChildALBAutoScaleLaunchConfig))]
    [JsonInheritanceAttribute("ChildPolicyEdgeCluster", typeof(ChildPolicyEdgeCluster))]
    [JsonInheritanceAttribute("ChildSslTrustObjectData", typeof(ChildSslTrustObjectData))]
    [JsonInheritanceAttribute("ChildVhc", typeof(ChildVhc))]
    [JsonInheritanceAttribute("ChildALBHTTPPolicySet", typeof(ChildALBHTTPPolicySet))]
    [JsonInheritanceAttribute("ChildOspfAreaConfig", typeof(ChildOspfAreaConfig))]
    [JsonInheritanceAttribute("ChildALBWafProfile", typeof(ChildALBWafProfile))]
    [JsonInheritanceAttribute("ChildALBPoolGroup", typeof(ChildALBPoolGroup))]
    [JsonInheritanceAttribute("ChildDomain", typeof(ChildDomain))]
    [JsonInheritanceAttribute("ChildDnsSecurityProfile", typeof(ChildDnsSecurityProfile))]
    [JsonInheritanceAttribute("ChildL3VpnContext", typeof(ChildL3VpnContext))]
    [JsonInheritanceAttribute("ChildDomainDeploymentMap", typeof(ChildDomainDeploymentMap))]
    [JsonInheritanceAttribute("ChildResourceReference", typeof(ChildResourceReference))]
    [JsonInheritanceAttribute("ChildIPSecVpnSession", typeof(ChildIPSecVpnSession))]
    [JsonInheritanceAttribute("ChildALBAnalyticsProfile", typeof(ChildALBAnalyticsProfile))]
    [JsonInheritanceAttribute("ChildPolicyDnsForwarder", typeof(ChildPolicyDnsForwarder))]
    [JsonInheritanceAttribute("ChildALBPool", typeof(ChildALBPool))]
    [JsonInheritanceAttribute("ChildPolicyLbPoolAccess", typeof(ChildPolicyLbPoolAccess))]
    [JsonInheritanceAttribute("ChildLBService", typeof(ChildLBService))]
    [JsonInheritanceAttribute("ChildMacDiscoveryProfile", typeof(ChildMacDiscoveryProfile))]
    [JsonInheritanceAttribute("ChildPolicyLbRule", typeof(ChildPolicyLbRule))]
    [JsonInheritanceAttribute("ChildPolicyFirewallCPUMemThresholdsProfileBindingMap", typeof(ChildPolicyFirewallCPUMemThresholdsProfileBindingMap))]
    [JsonInheritanceAttribute("ChildPrefixList", typeof(ChildPrefixList))]
    [JsonInheritanceAttribute("ChildPolicyIgmpProfile", typeof(ChildPolicyIgmpProfile))]
    [JsonInheritanceAttribute("ChildTier1Interface", typeof(ChildTier1Interface))]
    [JsonInheritanceAttribute("ChildALBIpAddrGroup", typeof(ChildALBIpAddrGroup))]
    [JsonInheritanceAttribute("ChildService", typeof(ChildService))]
    [JsonInheritanceAttribute("ChildEndpointPolicy", typeof(ChildEndpointPolicy))]
    [JsonInheritanceAttribute("ChildALBApplicationPersistenceProfile", typeof(ChildALBApplicationPersistenceProfile))]
    [JsonInheritanceAttribute("ChildTier1DeploymentMap", typeof(ChildTier1DeploymentMap))]
    [JsonInheritanceAttribute("ChildEnforcementPoint", typeof(ChildEnforcementPoint))]
    [JsonInheritanceAttribute("ChildALBProtocolParser", typeof(ChildALBProtocolParser))]
    [JsonInheritanceAttribute("ChildApplication", typeof(ChildApplication))]
    [JsonInheritanceAttribute("ChildEvpnConfig", typeof(ChildEvpnConfig))]
    [JsonInheritanceAttribute("ChildServiceInterface", typeof(ChildServiceInterface))]
    [JsonInheritanceAttribute("ChildGlobalManager", typeof(ChildGlobalManager))]
    [JsonInheritanceAttribute("ChildIPFIXL2Profile", typeof(ChildIPFIXL2Profile))]
    [JsonInheritanceAttribute("ChildSegmentPort", typeof(ChildSegmentPort))]
    [JsonInheritanceAttribute("ChildGlobalIdsSignature", typeof(ChildGlobalIdsSignature))]
    [JsonInheritanceAttribute("ChildL2VpnContext", typeof(ChildL2VpnContext))]
    [JsonInheritanceAttribute("ChildDhcpRelayConfig", typeof(ChildDhcpRelayConfig))]
    [JsonInheritanceAttribute("ChildApplicationTier", typeof(ChildApplicationTier))]
    [JsonInheritanceAttribute("ChildLBClientSslProfile", typeof(ChildLBClientSslProfile))]
    [JsonInheritanceAttribute("ChildVhcDnsConfig", typeof(ChildVhcDnsConfig))]
    [JsonInheritanceAttribute("ChildSegmentMonitoringProfileBindingMap", typeof(ChildSegmentMonitoringProfileBindingMap))]
    [JsonInheritanceAttribute("ChildFloodProtectionProfile", typeof(ChildFloodProtectionProfile))]
    [JsonInheritanceAttribute("ChildALBServerAutoScalePolicy", typeof(ChildALBServerAutoScalePolicy))]
    [JsonInheritanceAttribute("ChildSegmentDiscoveryProfileBindingMap", typeof(ChildSegmentDiscoveryProfileBindingMap))]
    [JsonInheritanceAttribute("ChildRedirectionPolicy", typeof(ChildRedirectionPolicy))]
    [JsonInheritanceAttribute("ChildALBSSOPolicy", typeof(ChildALBSSOPolicy))]
    [JsonInheritanceAttribute("ChildPolicyServiceChain", typeof(ChildPolicyServiceChain))]
    [JsonInheritanceAttribute("ChildServiceReference", typeof(ChildServiceReference))]
    [JsonInheritanceAttribute("ChildCommunicationEntry", typeof(ChildCommunicationEntry))]
    [JsonInheritanceAttribute("ChildGeneralSecurityProfileBindingMap", typeof(ChildGeneralSecurityProfileBindingMap))]
    [JsonInheritanceAttribute("ChildDeploymentZone", typeof(ChildDeploymentZone))]
    [JsonInheritanceAttribute("ChildIpAddressPool", typeof(ChildIpAddressPool))]
    [JsonInheritanceAttribute("ChildStandaloneHostIdfwConfiguration", typeof(ChildStandaloneHostIdfwConfiguration))]
    [JsonInheritanceAttribute("ChildEvpnTunnelEndpointConfig", typeof(ChildEvpnTunnelEndpointConfig))]
    [JsonInheritanceAttribute("ChildPortQoSProfileBindingMap", typeof(ChildPortQoSProfileBindingMap))]
    [JsonInheritanceAttribute("ChildQoSProfile", typeof(ChildQoSProfile))]
    [JsonInheritanceAttribute("ChildPolicyEdgeNode", typeof(ChildPolicyEdgeNode))]
    [JsonInheritanceAttribute("ChildLocaleServices", typeof(ChildLocaleServices))]
    [JsonInheritanceAttribute("ChildStaticARPConfig", typeof(ChildStaticARPConfig))]
    [JsonInheritanceAttribute("ChildRule", typeof(ChildRule))]
    [JsonInheritanceAttribute("ChildGatewayPolicy", typeof(ChildGatewayPolicy))]
    [JsonInheritanceAttribute("ChildALBSSLKeyAndCertificate", typeof(ChildALBSSLKeyAndCertificate))]
    [JsonInheritanceAttribute("ChildReaction", typeof(ChildReaction))]
    [JsonInheritanceAttribute("ChildBgpNeighborConfig", typeof(ChildBgpNeighborConfig))]
    [JsonInheritanceAttribute("ChildTlsTrustData", typeof(ChildTlsTrustData))]
    [JsonInheritanceAttribute("ChildPolicyNatRule", typeof(ChildPolicyNatRule))]
    [JsonInheritanceAttribute("ChildIpAddressPoolSubnet", typeof(ChildIpAddressPoolSubnet))]
    [JsonInheritanceAttribute("ChildBgpRoutingConfig", typeof(ChildBgpRoutingConfig))]
    [JsonInheritanceAttribute("ChildL2VPNSession", typeof(ChildL2VPNSession))]
    [JsonInheritanceAttribute("ChildIdsStandaloneHostConfig", typeof(ChildIdsStandaloneHostConfig))]
    [JsonInheritanceAttribute("ChildALBHardwareSecurityModuleGroup", typeof(ChildALBHardwareSecurityModuleGroup))]
    [JsonInheritanceAttribute("ChildALBVirtualService", typeof(ChildALBVirtualService))]
    [JsonInheritanceAttribute("ChildALBApplicationProfile", typeof(ChildALBApplicationProfile))]
    [JsonInheritanceAttribute("ChildIdsSettings", typeof(ChildIdsSettings))]
    [JsonInheritanceAttribute("ChildPolicyExcludeList", typeof(ChildPolicyExcludeList))]
    [JsonInheritanceAttribute("ChildIpAddressAllocation", typeof(ChildIpAddressAllocation))]
    [JsonInheritanceAttribute("ChildCommunityList", typeof(ChildCommunityList))]
    [JsonInheritanceAttribute("ChildIdsRule", typeof(ChildIdsRule))]
    [JsonInheritanceAttribute("ChildPolicyNat", typeof(ChildPolicyNat))]
    [JsonInheritanceAttribute("ChildLBPersistenceProfile", typeof(ChildLBPersistenceProfile))]
    [JsonInheritanceAttribute("ChildALBSecurityPolicy", typeof(ChildALBSecurityPolicy))]
    [JsonInheritanceAttribute("ChildPolicyFirewallScheduler", typeof(ChildPolicyFirewallScheduler))]
    [JsonInheritanceAttribute("ChildL2VPNService", typeof(ChildL2VPNService))]
    [JsonInheritanceAttribute("ChildIdsSecurityPolicy", typeof(ChildIdsSecurityPolicy))]
    [JsonInheritanceAttribute("ChildLBVirtualServer", typeof(ChildLBVirtualServer))]
    [JsonInheritanceAttribute("ChildByodPolicyServiceInstance", typeof(ChildByodPolicyServiceInstance))]
    [JsonInheritanceAttribute("ChildPolicyFirewallCpuMemThresholdsProfile", typeof(ChildPolicyFirewallCpuMemThresholdsProfile))]
    [JsonInheritanceAttribute("ChildFloodProtectionProfileBindingMap", typeof(ChildFloodProtectionProfileBindingMap))]
    [JsonInheritanceAttribute("ChildL3Vpn", typeof(ChildL3Vpn))]
    [JsonInheritanceAttribute("ChildALBWafPolicyPSMGroup", typeof(ChildALBWafPolicyPSMGroup))]
    [JsonInheritanceAttribute("ChildPolicyTransportZone", typeof(ChildPolicyTransportZone))]
    [JsonInheritanceAttribute("ChildALBVSDataScriptSet", typeof(ChildALBVSDataScriptSet))]
    [JsonInheritanceAttribute("ChildIPFIXL2CollectorProfile", typeof(ChildIPFIXL2CollectorProfile))]
    [JsonInheritanceAttribute("ChildGlobalConfig", typeof(ChildGlobalConfig))]
    [JsonInheritanceAttribute("ChildIPDiscoveryProfile", typeof(ChildIPDiscoveryProfile))]
    [JsonInheritanceAttribute("ChildIpv6NdraProfile", typeof(ChildIpv6NdraProfile))]
    [JsonInheritanceAttribute("ChildBfdProfile", typeof(ChildBfdProfile))]
    [JsonInheritanceAttribute("ChildServiceEntry", typeof(ChildServiceEntry))]
    [JsonInheritanceAttribute("ChildServiceInstanceEndpoint", typeof(ChildServiceInstanceEndpoint))]
    [JsonInheritanceAttribute("ChildPolicyServiceInstance", typeof(ChildPolicyServiceInstance))]
    [JsonInheritanceAttribute("ChildSegmentSecurityProfileBindingMap", typeof(ChildSegmentSecurityProfileBindingMap))]
    [JsonInheritanceAttribute("ChildPolicyContextProfile", typeof(ChildPolicyContextProfile))]
    [JsonInheritanceAttribute("ChildIdsClusterConfig", typeof(ChildIdsClusterConfig))]
    [JsonInheritanceAttribute("ChildLBServerSslProfile", typeof(ChildLBServerSslProfile))]
    [JsonInheritanceAttribute("ChildIPSecVpnIkeProfile", typeof(ChildIPSecVpnIkeProfile))]
    [JsonInheritanceAttribute("ChildDhcpServerConfig", typeof(ChildDhcpServerConfig))]
    [JsonInheritanceAttribute("ChildALBWafCRS", typeof(ChildALBWafCRS))]
    [JsonInheritanceAttribute("ChildSegmentQoSProfileBindingMap", typeof(ChildSegmentQoSProfileBindingMap))]
    [JsonInheritanceAttribute("ChildDfwFirewallConfiguration", typeof(ChildDfwFirewallConfiguration))]
    [JsonInheritanceAttribute("ChildL2BridgeEndpointProfile", typeof(ChildL2BridgeEndpointProfile))]
    [JsonInheritanceAttribute("ChildGroupMonitoringProfileBindingMap", typeof(ChildGroupMonitoringProfileBindingMap))]
    [JsonInheritanceAttribute("ChildPolicyLbPersistenceProfile", typeof(ChildPolicyLbPersistenceProfile))]
    [JsonInheritanceAttribute("ChildPolicyLbMonitorProfile", typeof(ChildPolicyLbMonitorProfile))]
    [JsonInheritanceAttribute("ChildLiveTraceConfig", typeof(ChildLiveTraceConfig))]
    [JsonInheritanceAttribute("ChildIpv6DadProfile", typeof(ChildIpv6DadProfile))]
    [JsonInheritanceAttribute("ChildPortSecurityProfileBindingMap", typeof(ChildPortSecurityProfileBindingMap))]
    [JsonInheritanceAttribute("ChildIdsProfile", typeof(ChildIdsProfile))]
    [JsonInheritanceAttribute("ChildALBErrorPageBody", typeof(ChildALBErrorPageBody))]
    [JsonInheritanceAttribute("ChildVniPoolConfig", typeof(ChildVniPoolConfig))]
    [JsonInheritanceAttribute("ChildIPSecVpnLocalEndpoint", typeof(ChildIPSecVpnLocalEndpoint))]
    [JsonInheritanceAttribute("ChildLBPool", typeof(ChildLBPool))]
    [JsonInheritanceAttribute("ChildLBMonitorProfile", typeof(ChildLBMonitorProfile))]
    [JsonInheritanceAttribute("ChildALBDnsPolicy", typeof(ChildALBDnsPolicy))]
    [JsonInheritanceAttribute("ChildMetadataProxyConfig", typeof(ChildMetadataProxyConfig))]
    [JsonInheritanceAttribute("ChildPortDiscoveryProfileBindingMap", typeof(ChildPortDiscoveryProfileBindingMap))]
    [JsonInheritanceAttribute("ChildPortMonitoringProfileBindingMap", typeof(ChildPortMonitoringProfileBindingMap))]
    [JsonInheritanceAttribute("ChildSegment", typeof(ChildSegment))]
    [JsonInheritanceAttribute("ChildIdsSignature", typeof(ChildIdsSignature))]
    [JsonInheritanceAttribute("ChildComputeClusterIdfwConfiguration", typeof(ChildComputeClusterIdfwConfiguration))]
    [JsonInheritanceAttribute("ChildOspfRoutingConfig", typeof(ChildOspfRoutingConfig))]
    [JsonInheritanceAttribute("ChildPolicyTier1MulticastConfig", typeof(ChildPolicyTier1MulticastConfig))]
    [JsonInheritanceAttribute("ChildTlsCertificate", typeof(ChildTlsCertificate))]
    [JsonInheritanceAttribute("ChildTraceflowConfig", typeof(ChildTraceflowConfig))]
    [JsonInheritanceAttribute("ChildTier0DeploymentMap", typeof(ChildTier0DeploymentMap))]
    [JsonInheritanceAttribute("ChildSecurityPolicy", typeof(ChildSecurityPolicy))]
    [JsonInheritanceAttribute("ChildApplicationService", typeof(ChildApplicationService))]
    [JsonInheritanceAttribute("ChildTier0RouteMap", typeof(ChildTier0RouteMap))]
    [JsonInheritanceAttribute("ChildALBAuthProfile", typeof(ChildALBAuthProfile))]
    [JsonInheritanceAttribute("ChildDnsSecurityProfileBindingMap", typeof(ChildDnsSecurityProfileBindingMap))]
    [JsonInheritanceAttribute("ChildALBPoolGroupDeploymentPolicy", typeof(ChildALBPoolGroupDeploymentPolicy))]
    [JsonInheritanceAttribute("ChildALBNetworkProfile", typeof(ChildALBNetworkProfile))]
    [JsonInheritanceAttribute("ChildALBSSLProfile", typeof(ChildALBSSLProfile))]
    [JsonInheritanceAttribute("ChildIdsSignatureStatus", typeof(ChildIdsSignatureStatus))]
    [JsonInheritanceAttribute("ChildPolicyGroupReference", typeof(ChildPolicyGroupReference))]
    [JsonInheritanceAttribute("ChildRedirectionRule", typeof(ChildRedirectionRule))]
    [JsonInheritanceAttribute("ChildForwardingPolicy", typeof(ChildForwardingPolicy))]
    [JsonInheritanceAttribute("ChildPolicyServiceProfile", typeof(ChildPolicyServiceProfile))]
    [JsonInheritanceAttribute("ChildDhcpStaticBindingConfig", typeof(ChildDhcpStaticBindingConfig))]
    [JsonInheritanceAttribute("ChildPolicyFirewallSessionTimerProfileBindingMap", typeof(ChildPolicyFirewallSessionTimerProfileBindingMap))]
    [JsonInheritanceAttribute("ChildPolicyLabel", typeof(ChildPolicyLabel))]
    [JsonInheritanceAttribute("ChildALBVsVip", typeof(ChildALBVsVip))]
    [JsonInheritanceAttribute("ChildIPFIXDFWProfile", typeof(ChildIPFIXDFWProfile))]
    [JsonInheritanceAttribute("ChildALBPKIProfile", typeof(ChildALBPKIProfile))]
    [JsonInheritanceAttribute("ChildIPSecVpnService", typeof(ChildIPSecVpnService))]
    [JsonInheritanceAttribute("ChildPolicyPimProfile", typeof(ChildPolicyPimProfile))]
    [JsonInheritanceAttribute("ChildFqdnAnalysisConfig", typeof(ChildFqdnAnalysisConfig))]
    [JsonInheritanceAttribute("ChildSecurityZoneBinding", typeof(ChildSecurityZoneBinding))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyConfigResource : ManagedResource
    {
        /// <summary>Indicates whether this object is the overridden intent object Global intent objects cannot be modified by the user. However, certain global intent objects can be overridden locally by use of this property. In such cases, the overridden local values take precedence over the globally defined values for the properties.</summary>
        [Newtonsoft.Json.JsonProperty("mark_for_override", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Mark_for_override { get; set; } = false;
    
        /// <summary>If this field is set to true, delete operation is triggered on the
        /// intent tree. This resource along with its all children in intent tree
        /// will be deleted. This is a cascade delete and should only be used if
        /// intent object along with its all children are to be deleted. This does
        /// not support deletion of single non-leaf node within the tree and should
        /// be used carefully.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("marked_for_delete", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Marked_for_delete { get; set; } = false;
    
    
    }
    
    /// <summary>Advanced load balancer AuthenticationPolicy object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAuthenticationPolicy 
    {
        /// <summary>Auth Profile to use for validating users.
        /// It is a reference to an object of type AuthProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("default_auth_profile_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Default_auth_profile_path { get; set; }
    
        /// <summary>Add rules to apply auth profile to specific targets.</summary>
        [Newtonsoft.Json.JsonProperty("authn_rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBAuthenticationRule> Authn_rules { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OspfStatusInfo 
    {
        /// <summary>Retransmit request counter.</summary>
        [Newtonsoft.Json.JsonProperty("retransmit_counter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Retransmit_counter { get; set; }
    
        /// <summary>request counter.</summary>
        [Newtonsoft.Json.JsonProperty("request_counter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Request_counter { get; set; }
    
        /// <summary>OSPF neighbor state.</summary>
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string State { get; set; }
    
        /// <summary>Tier0 interface name.</summary>
        [Newtonsoft.Json.JsonProperty("interface_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Interface_name { get; set; }
    
        /// <summary>Time remaining in before considering OSPF neighbor dead.</summary>
        [Newtonsoft.Json.JsonProperty("dead_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dead_time { get; set; }
    
        /// <summary>Multicast source address.</summary>
        [Newtonsoft.Json.JsonProperty("source_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source_address { get; set; }
    
        /// <summary>Database summary counter.</summary>
        [Newtonsoft.Json.JsonProperty("database_summary_counter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Database_summary_counter { get; set; }
    
        /// <summary>Time since last change in state.</summary>
        [Newtonsoft.Json.JsonProperty("last_state_change", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_state_change { get; set; }
    
        /// <summary>Priority of the neighbor.</summary>
        [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Priority { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LbHttpRequestHeader 
    {
        /// <summary>Value of HTTP request header</summary>
        [Newtonsoft.Json.JsonProperty("header_value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Header_value { get; set; }
    
        /// <summary>Name of HTTP request header</summary>
        [Newtonsoft.Json.JsonProperty("header_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Header_name { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBHealthMonitor, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBHealthMonitor : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBHealthMonitor object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBHealthMonitor", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBHealthMonitor ALBHealthMonitor { get; set; }
    
    
    }
    
    /// <summary>Action specified at the footer of a widget to provide additional information or to provide a clickable url for navigation. An example usage of footer action is provided under the 'example_request' section of 'CreateWidgetConfiguration' API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FooterAction 
    {
        /// <summary>Hyperlink to the UI page that provides details of action.</summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Url { get; set; }
    
        /// <summary>If true, the footer will appear in the underlying container that holds the widget.</summary>
        [Newtonsoft.Json.JsonProperty("dock_to_container_footer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Dock_to_container_footer { get; set; } = true;
    
        /// <summary>Label to be displayed against the footer action.</summary>
        [Newtonsoft.Json.JsonProperty("label", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Label Label { get; set; } = new Label();
    
    
    }
    
    /// <summary>Define DHCP options other than option 121.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GenericDhcpOption 
    {
        /// <summary>Code of the dhcp option.</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0D, 255D)]
        public long Code { get; set; }
    
        /// <summary>Value of the option.</summary>
        [Newtonsoft.Json.JsonProperty("values", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(10)]
        public System.Collections.Generic.ICollection<string> Values { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>List of Policy URL categories.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyUrlCategoryListResult : ListResult
    {
        /// <summary>Category list result</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyUrlCategory> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyUrlCategory>();
    
    
    }
    
    /// <summary>Advanced load balancer AuthenticationMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAuthenticationMatch 
    {
        /// <summary>Configure the host header.</summary>
        [Newtonsoft.Json.JsonProperty("host_hdr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHostHdrMatch Host_hdr { get; set; }
    
        /// <summary>Configure client ip addresses.</summary>
        [Newtonsoft.Json.JsonProperty("client_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddrMatch Client_ip { get; set; }
    
        /// <summary>Configure request paths.</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBPathMatch Path { get; set; }
    
    
    }
    
    /// <summary>Policy Attributes data holder</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyAttributes 
    {
        /// <summary>Reference to sub attributes for the attribute</summary>
        [Newtonsoft.Json.JsonProperty("sub_attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicySubAttributes> Sub_attributes { get; set; }
    
        /// <summary>Source of attribute value i.e whether system defined or custom value</summary>
        [Newtonsoft.Json.JsonProperty("attribute_source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyAttributesAttribute_source? Attribute_source { get; set; } = SDKGenerator.PolicyAttributesAttribute_source.SYSTEM;
    
        /// <summary>Description for attribute value</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>URL_Reputation is currently not available. Please do not use it in Attribute Key while creating context profile</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyAttributesKey Key { get; set; }
    
        /// <summary>Datatype for attribute</summary>
        [Newtonsoft.Json.JsonProperty("datatype", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyAttributesDatatype Datatype { get; set; }
    
        /// <summary>Describes whether the APP_ID value is ALG type or not.</summary>
        [Newtonsoft.Json.JsonProperty("isALGType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IsALGType { get; set; }
    
        /// <summary>Multiple attribute values can be specified as elements of array.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<string> Value { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>This is optional part that can hold additional data about the attribute key/values.
        /// Example - For URL CATEGORY key , it specified super category for url category value.
        /// This is generic array and can hold multiple meta information about key/values in future
        /// </summary>
        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ContextProfileAttributesMetadata> Metadata { get; set; }
    
    
    }
    
    /// <summary>Edge Cluster.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyEdgeCluster : PolicyConfigResource
    {
        /// <summary>Flag to indicate status of inter site l2 and l3 forwarding in federation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inter_site_forwarding_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Inter_site_forwarding_enabled { get; set; }
    
        /// <summary>UUID of Edge Cluster on NSX-T enforcement point.</summary>
        [Newtonsoft.Json.JsonProperty("nsx_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Nsx_id { get; set; }
    
        /// <summary>List of remote tunnel endpoint ipaddress configured on edge cluster.</summary>
        [Newtonsoft.Json.JsonProperty("rtep_ips", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Rtep_ips { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer MetricsRealTimeUpdate object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBMetricsRealTimeUpdate 
    {
        /// <summary>Real time metrics collection duration in minutes.
        /// 0 for infinite.
        /// Special values are 0 - 'infinite'.
        /// Unit is MIN.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 30.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("duration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Duration { get; set; } = 30L;
    
        /// <summary>Enables real time metrics collection.
        /// When deactivated, 6 hour view is the most granular the
        /// system will track.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; } = false;
    
    
    }
    
    /// <summary>Advanced load balancer UDPFastPathProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBUDPFastPathProfile 
    {
        /// <summary>DSR profile information.</summary>
        [Newtonsoft.Json.JsonProperty("dsr_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDsrProfile Dsr_profile { get; set; }
    
        /// <summary>When enabled, every UDP packet is considered a new
        /// transaction and may be load balanced to a different server.
        /// When disabled, packets from the same client source IP and
        /// port are sent to the same server.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("per_pkt_loadbalance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Per_pkt_loadbalance { get; set; } = false;
    
        /// <summary>When disabled, Source NAT will not be performed for all
        /// client UDP packets.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("snat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Snat { get; set; } = true;
    
        /// <summary>The amount of time (in sec) for which a flow needs to be
        /// idle before it is deleted.
        /// Allowed values are 2-3600.
        /// Unit is SEC.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 10.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("session_idle_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(2D, 3600D)]
        public long? Session_idle_timeout { get; set; } = 10L;
    
    
    }
    
    /// <summary>Service path list</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServicePathListResult : ListResult
    {
        /// <summary>List of homogenous service paths</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ServicePath> Results { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for Site, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildSite : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual Site object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Site", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Site Site { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of IPSecVpnIkeProfile.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnIkeProfileListResult : ListResult
    {
        /// <summary>IPSecVpnIkeProfile list results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IPSecVpnIkeProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<IPSecVpnIkeProfile>();
    
    
    }
    
    /// <summary>Advanced load balancer SSLProfileSelector object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSSLProfileSelector 
    {
        /// <summary>Configure client IP address groups.</summary>
        [Newtonsoft.Json.JsonProperty("client_ip_list", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBIpAddrMatch Client_ip_list { get; set; } = new ALBIpAddrMatch();
    
        /// <summary>SSL profile for the client IP addresses listed.
        /// It is a reference to an object of type SSLProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ssl_profile_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ssl_profile_path { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of Services</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServiceListResult : ListResult
    {
        /// <summary>Service list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Service> Results { get; set; } = new System.Collections.ObjectModel.Collection<Service>();
    
    
    }
    
    /// <summary>Child wrapper object for ForwardingRule used in Hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildForwardingRule : ChildPolicyConfigResource
    {
        /// <summary>Contains actual ForwardingRule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ForwardingRule", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ForwardingRule ForwardingRule { get; set; }
    
    
    }
    
    /// <summary>Combines two or more widgetconfigurations into a multi-widget</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MultiWidgetConfiguration : WidgetConfiguration
    {
        /// <summary>Array of widgets that are part of the multi-widget.</summary>
        [Newtonsoft.Json.JsonProperty("widgets", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(2)]
        public System.Collections.Generic.ICollection<WidgetItem> Widgets { get; set; } = new System.Collections.ObjectModel.Collection<WidgetItem>();
    
        /// <summary>Hyperlink of the specified UI page that provides details.</summary>
        [Newtonsoft.Json.JsonProperty("navigation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Navigation { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer MatchReplacePair object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBMatchReplacePair 
    {
        /// <summary>String to be matched.</summary>
        [Newtonsoft.Json.JsonProperty("match_string", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Match_string { get; set; }
    
        /// <summary>Replacement string.</summary>
        [Newtonsoft.Json.JsonProperty("replacement_string", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBReplaceStringVar Replacement_string { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for SegmentSecurityProfile, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildSegmentSecurityProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual SegmentSecurityProfile object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("SegmentSecurityProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SegmentSecurityProfile SegmentSecurityProfile { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DosThresholdProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDosThresholdProfile 
    {
        /// <summary>Timer value in seconds to collect DoS attack metrics based
        /// on threshold on the Service Engine for this Virtual Service.
        /// Unit is SEC.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 5.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thresh_period", Required = Newtonsoft.Json.Required.Always)]
        public long Thresh_period { get; set; } = 5L;
    
        /// <summary>Attack type, min and max values for DoS attack detection.</summary>
        [Newtonsoft.Json.JsonProperty("thresh_info", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDosThreshold> Thresh_info { get; set; }
    
    
    }
    
    /// <summary>OSPF router link state details.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MpOspfRouterLinkStates 
    {
        /// <summary>Number of router links</summary>
        [Newtonsoft.Json.JsonProperty("router_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Router_links { get; set; }
    
        /// <summary>LSA age</summary>
        [Newtonsoft.Json.JsonProperty("up_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Up_time { get; set; }
    
        /// <summary>OSPF advertised router</summary>
        [Newtonsoft.Json.JsonProperty("advertised_router", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Advertised_router { get; set; }
    
        /// <summary>OSPF link id</summary>
        [Newtonsoft.Json.JsonProperty("link_state_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Link_state_id { get; set; }
    
        /// <summary>Cost of the route</summary>
        [Newtonsoft.Json.JsonProperty("checksum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Checksum { get; set; }
    
        /// <summary>Sequence number</summary>
        [Newtonsoft.Json.JsonProperty("sequence_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sequence_number { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TlsCrl : PolicyConfigResource
    {
        /// <summary>Details of the X509Crl object.</summary>
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public X509Crl Details { get; set; }
    
        /// <summary>Pem encoded crl data.</summary>
        [Newtonsoft.Json.JsonProperty("pem_encoded", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Pem_encoded { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsRuleRLAction object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsRuleRLAction 
    {
        /// <summary>Type of action to be enforced upon hitting the rate limit.
        /// Enum options - DNS_RL_ACTION_NONE, DNS_RL_ACTION_DROP_REQ.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as DNS_RL_ACTION_NONE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBDnsRuleRLActionType? Type { get; set; } = SDKGenerator.ALBDnsRuleRLActionType.DNS_RL_ACTION_NONE;
    
    
    }
    
    /// <summary>Advanced load balancer HostHdrMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHostHdrMatch 
    {
        /// <summary>Case sensitivity to use for the match.
        /// Enum options - SENSITIVE, INSENSITIVE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as INSENSITIVE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_case", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHostHdrMatchMatch_case? Match_case { get; set; } = SDKGenerator.ALBHostHdrMatchMatch_case.INSENSITIVE;
    
        /// <summary>String value(s) in the host header.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Value { get; set; }
    
        /// <summary>Criterion to use for the host header value match.
        /// Enum options - HDR_EXISTS, HDR_DOES_NOT_EXIST,
        /// HDR_BEGINS_WITH, HDR_DOES_NOT_BEGIN_WITH, HDR_CONTAINS,
        /// HDR_DOES_NOT_CONTAIN, HDR_ENDS_WITH, HDR_DOES_NOT_END_WITH,
        /// HDR_EQUALS, HDR_DOES_NOT_EQUAL.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHostHdrMatchMatch_criteria Match_criteria { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TransportInfo 
    {
        /// <summary>Source port</summary>
        [Newtonsoft.Json.JsonProperty("src_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Src_port { get; set; }
    
        /// <summary>Protocol type over IP layer</summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TransportInfoProtocol? Protocol { get; set; }
    
        /// <summary>Destination port</summary>
        [Newtonsoft.Json.JsonProperty("dst_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Dst_port { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer SensitiveLogProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSensitiveLogProfile 
    {
        /// <summary>Match sensitive header fields in HTTP application log.</summary>
        [Newtonsoft.Json.JsonProperty("header_field_rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBSensitiveFieldRule> Header_field_rules { get; set; }
    
        /// <summary>Match sensitive WAF log fields in HTTP application log.</summary>
        [Newtonsoft.Json.JsonProperty("waf_field_rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBSensitiveFieldRule> Waf_field_rules { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for CommunicationMap, used in hierarchical API This type is deprecated. Use the type ChildSecurityPolicy instead.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildCommunicationMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual CommunicationMap object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("CommunicationMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public CommunicationMap CommunicationMap { get; set; }
    
    
    }
    
    /// <summary>Source Field Evaluation represents an evaluation on resource fields.
    /// A source field evaluation will be evaluated against an Event Source which
    /// is of type Resource Operation. For instance, the attribute constraint could
    /// be related to the necessity that one of the source fields equals one of the
    /// specified values.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SourceFieldEvaluation : Evaluation
    {
        /// <summary>Logical operator.</summary>
        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SourceFieldEvaluationOperator Operator { get; set; }
    
        /// <summary>Expected values necessary to apply the specified operation on the source field value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expected", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Expected { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Field in the form of a pointer, describing the location of the attribute within the source
        /// of the event.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("field_pointer", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Field_pointer { get; set; }
    
    
    }
    
    /// <summary>Detailed information about static address for the port.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PortAddressBindingEntry 
    {
        /// <summary>IP Address for port binding</summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ip_address { get; set; }
    
        /// <summary>VLAN ID for port binding</summary>
        [Newtonsoft.Json.JsonProperty("vlan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Vlan_id { get; set; }
    
        /// <summary>Mac address for port binding</summary>
        [Newtonsoft.Json.JsonProperty("mac_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Mac_address { get; set; }
    
    
    }
    
    /// <summary>WafProfileApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWafProfileApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of WafProfile
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBWafProfile> Results { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for IPFIXDFWCollectorProfile, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIPFIXDFWCollectorProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual IPFIXDFWCollectorProfile object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IPFIXDFWCollectorProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IPFIXDFWCollectorProfile IPFIXDFWCollectorProfile { get; set; }
    
    
    }
    
    /// <summary>Realized NSGroup member evaluation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedNSGroupMemberEvaluation : PolicyRealizedResource
    {
        /// <summary>list of logical ports</summary>
        [Newtonsoft.Json.JsonProperty("logical_ports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RealizedLogicalPort> Logical_ports { get; set; }
    
        /// <summary>list of virtual machines</summary>
        [Newtonsoft.Json.JsonProperty("virtual_machines", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RealizedVirtualMachine> Virtual_machines { get; set; }
    
        /// <summary>list of logical switches</summary>
        [Newtonsoft.Json.JsonProperty("logical_switches", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RealizedLogicalSwitch> Logical_switches { get; set; }
    
        /// <summary>Count of the members added to this NSGroup</summary>
        [Newtonsoft.Json.JsonProperty("member_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Member_count { get; set; }
    
    
    }
    
    /// <summary>Domain synchronization settings</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DirectoryDomainSyncSettings 
    {
        /// <summary>Sync delay after Directory domain has been successfully created.
        /// if delay is -1, initial full sync will not be triggered.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sync_delay_in_sec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(-1D, 600D)]
        public long? Sync_delay_in_sec { get; set; } = 30L;
    
        /// <summary>Directory domain full synchronization schedule using cron expression. For example, cron expression "0 0 12 ? * SUN *" means full sync is scheduled every Sunday midnight. If this object is null, it means there is no background cron job running for full sync.</summary>
        [Newtonsoft.Json.JsonProperty("full_sync_cron_expr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Full_sync_cron_expr { get; set; }
    
        /// <summary>Directory domain delta synchronization interval time between two delta sync in minutes.</summary>
        [Newtonsoft.Json.JsonProperty("delta_sync_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(5D, 720D)]
        public long? Delta_sync_interval { get; set; } = 180L;
    
    
    }
    
    /// <summary>BGP neighbor learned/advertised route details.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BgpNeighborRoutes 
    {
        /// <summary>BGP neighbor policy path</summary>
        [Newtonsoft.Json.JsonProperty("neighbor_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Neighbor_path { get; set; }
    
        /// <summary>Array of BGP neighbor route details per edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("egde_node_routes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RoutesPerTransportNode> Egde_node_routes { get; set; }
    
        /// <summary>Enforcement point policy path</summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enforcement_point_path { get; set; }
    
    
    }
    
    /// <summary>This type of subnet allows user to dynamically carve a subnet out of a preconfigured IpAddressBlock. The user must specify the size of the subnet and the IpAddressBlock from which the subnet is to be derived. If the required amount of IP adress space is available in the specified IpAddressBlock, the system automatically configures subnet range.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IpAddressPoolBlockSubnet : IpAddressPoolSubnet
    {
        /// <summary>The path of the IpAddressBlock from which the subnet is to be created.</summary>
        [Newtonsoft.Json.JsonProperty("ip_block_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ip_block_path { get; set; }
    
        /// <summary>For internal system use Only. Represents start ip address of the subnet from IP block. Subnet ip adddress will start from this ip address.</summary>
        [Newtonsoft.Json.JsonProperty("start_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Start_ip { get; set; }
    
        /// <summary>If this property is set to true, the first IP in the range will be reserved for gateway.</summary>
        [Newtonsoft.Json.JsonProperty("auto_assign_gateway", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Auto_assign_gateway { get; set; } = true;
    
        /// <summary>The size parameter is required for subnet creation. It must be specified during creation but cannot be changed later.</summary>
        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Always)]
        public long Size { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceflowObservationRelayedLogical : TraceflowObservation
    {
        /// <summary>This field specified the message type of the relay service REQUEST - The relay service will relay a request message to the destination server REPLY - The relay service will relay a reply message to the client</summary>
        [Newtonsoft.Json.JsonProperty("message_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TraceflowObservationRelayedLogicalMessage_type? Message_type { get; set; } = SDKGenerator.TraceflowObservationRelayedLogicalMessage_type.REQUEST;
    
        /// <summary>This field specified the IP address of the destination which the packet will be relayed.</summary>
        [Newtonsoft.Json.JsonProperty("dst_server_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dst_server_address { get; set; }
    
        /// <summary>This field specified the logical component that relay service located.</summary>
        [Newtonsoft.Json.JsonProperty("logical_comp_uuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Logical_comp_uuid { get; set; }
    
        /// <summary>This field specified the IP address of the relay service.</summary>
        [Newtonsoft.Json.JsonProperty("relay_server_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Relay_server_address { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer SamlServiceProviderSettings object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSamlServiceProviderSettings 
    {
        /// <summary>Service Provider Organization Name.</summary>
        [Newtonsoft.Json.JsonProperty("org_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Org_name { get; set; }
    
        /// <summary>Service Provider technical contact email.</summary>
        [Newtonsoft.Json.JsonProperty("tech_contact_email", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tech_contact_email { get; set; }
    
        /// <summary>Service Provider node information.</summary>
        [Newtonsoft.Json.JsonProperty("sp_nodes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBSamlServiceProviderNode> Sp_nodes { get; set; }
    
        /// <summary>Service Provider Organization Display Name.</summary>
        [Newtonsoft.Json.JsonProperty("org_display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Org_display_name { get; set; }
    
        /// <summary>Service Provider Organization URL.</summary>
        [Newtonsoft.Json.JsonProperty("org_url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Org_url { get; set; }
    
        /// <summary>Service Provider technical contact name.</summary>
        [Newtonsoft.Json.JsonProperty("tech_contact_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tech_contact_name { get; set; }
    
        /// <summary>FQDN if entity type is DNS_FQDN .</summary>
        [Newtonsoft.Json.JsonProperty("fqdn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fqdn { get; set; }
    
        /// <summary>Type of SAML endpoint.
        /// Enum options - AUTH_SAML_CLUSTER_VIP, AUTH_SAML_DNS_FQDN,
        /// AUTH_SAML_APP_VS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("saml_entity_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBSamlServiceProviderSettingsSaml_entity_type? Saml_entity_type { get; set; }
    
    
    }
    
    /// <summary>End User License Agreement content</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EULAContent : Resource
    {
        /// <summary>Content of End User License Agreement</summary>
        [Newtonsoft.Json.JsonProperty("content", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Content { get; set; }
    
    
    }
    
    /// <summary>IpAddressPool is a collection of subnets. The subnets can either be derived from an IpBlock or specified by the user. User can request for IP addresses to be allocated from a pool. When an IP is requested from a pool, the IP that is returned can come from any subnet that belongs to the pool.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IpAddressPool : PolicyConfigResource
    {
        /// <summary>Delay in milliseconds, while releasing allocated IP address from IP pool (Default is 2 mins).</summary>
        [Newtonsoft.Json.JsonProperty("ip_release_delay", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Ip_release_delay { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsRrSet object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsRrSet 
    {
        /// <summary>Canonical name in CNAME record.</summary>
        [Newtonsoft.Json.JsonProperty("cname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDnsCnameRdata Cname { get; set; }
    
        /// <summary>Time To Live for this DNS record.
        /// Allowed values are 0-2147483647.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ttl", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0D, 2147483647D)]
        public long Ttl { get; set; }
    
        /// <summary>IP address in A record.</summary>
        [Newtonsoft.Json.JsonProperty("ip_addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDnsARdata> Ip_addresses { get; set; }
    
        /// <summary>IPv6 address in AAAA record.</summary>
        [Newtonsoft.Json.JsonProperty("ip6_addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDnsAAAARdata> Ip6_addresses { get; set; }
    
        /// <summary>DNS record type.
        /// Enum options - DNS_RECORD_OTHER, DNS_RECORD_A,
        /// DNS_RECORD_NS, DNS_RECORD_CNAME, DNS_RECORD_SOA,
        /// DNS_RECORD_PTR, DNS_RECORD_HINFO, DNS_RECORD_MX,
        /// DNS_RECORD_TXT, DNS_RECORD_RP, DNS_RECORD_DNSKEY,
        /// DNS_RECORD_AAAA, DNS_RECORD_SRV, DNS_RECORD_OPT,
        /// DNS_RECORD_RRSIG, DNS_RECORD_AXFR, DNS_RECORD_ANY.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBDnsRrSetType Type { get; set; }
    
        /// <summary>Fully Qualified Domain Name.</summary>
        [Newtonsoft.Json.JsonProperty("fqdn", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Fqdn { get; set; }
    
        /// <summary>Name Server information in NS record.</summary>
        [Newtonsoft.Json.JsonProperty("nses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDnsNsRdata> Nses { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DhcpServerStatus 
    {
        /// <summary>Error message, if available</summary>
        [Newtonsoft.Json.JsonProperty("error_message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error_message { get; set; }
    
        /// <summary>UP means the dhcp service is working fine on both active transport-node
        /// and stand-by transport-node (if have), hence fail-over can work at this
        /// time if there is failure happens on one of the transport-node;
        /// DOWN means the dhcp service is down on both active transport-node and
        /// stand-by node (if have), hence the dhcp-service will not repsonse any
        /// dhcp request;
        /// Error means error happens on transport-node(s) or no status is reported from
        /// transport-node(s). The dhcp service may be working (or not working);
        /// NO_STANDBY means dhcp service is working in one of the transport node while
        /// not in the other transport-node (if have). Hence if the dhcp service in
        /// the working transport-node is down, fail-over will not happen and the
        /// dhcp service will go down.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service_status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DhcpServerStatusService_status Service_status { get; set; }
    
        /// <summary>uuid of stand_by transport node. null if non-HA mode</summary>
        [Newtonsoft.Json.JsonProperty("stand_by_node", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stand_by_node { get; set; }
    
        /// <summary>uuid of active transport node</summary>
        [Newtonsoft.Json.JsonProperty("active_node", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Active_node { get; set; }
    
    
    }
    
    /// <summary>Child wrapper obejct for GroupDiscoveryProfileBindingMap used in hierarchical API
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildGroupDiscoveryProfileBindingMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual GroupDiscoveryProfileBindingMap object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("GroupDiscoveryProfileBindingMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public GroupDiscoveryProfileBindingMap GroupDiscoveryProfileBindingMap { get; set; }
    
    
    }
    
    /// <summary>Feature Permission</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FeaturePermission 
    {
        /// <summary>Is execute recommended</summary>
        [Newtonsoft.Json.JsonProperty("is_execute_recommended", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_execute_recommended { get; set; }
    
        /// <summary>Feature Name</summary>
        [Newtonsoft.Json.JsonProperty("feature_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Feature_name { get; set; }
    
        /// <summary>Permission</summary>
        [Newtonsoft.Json.JsonProperty("permission", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FeaturePermissionPermission Permission { get; set; }
    
        /// <summary>Is internal</summary>
        [Newtonsoft.Json.JsonProperty("is_internal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_internal { get; set; }
    
        /// <summary>Feature Id</summary>
        [Newtonsoft.Json.JsonProperty("feature", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Feature { get; set; }
    
        /// <summary>Feature Description</summary>
        [Newtonsoft.Json.JsonProperty("feature_description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Feature_description { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of site upgrade information</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FederationUpgradeSummaryListResult : ListResult
    {
        /// <summary>Paged collection of site upgrade information</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FederationUpgradeSummary> Results { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RoutingTableListResult : ListResult
    {
        /// <summary>Paged Collection of Routes per transport node ID.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RoutingTable> Results { get; set; }
    
    
    }
    
    /// <summary>Paged collection of Tier-1 instances</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier1ListResult : ListResult
    {
        /// <summary>Tier-1 list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Tier1> Results { get; set; } = new System.Collections.ObjectModel.Collection<Tier1>();
    
    
    }
    
    /// <summary>Paged collection of IPFIX collector profiles.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPFIXCollectorProfileListResult : ListResult
    {
        /// <summary>IPFIX collector Instances list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IPFIXCollectorProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<IPFIXCollectorProfile>();
    
    
    }
    
    /// <summary>Paged collection of Tier-1 Interfaces</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier1InterfaceListResult : ListResult
    {
        /// <summary>Tier-1 Interface list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Tier1Interface> Results { get; set; } = new System.Collections.ObjectModel.Collection<Tier1Interface>();
    
    
    }
    
    /// <summary>Advanced load balancer DnsInfo object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsInfo 
    {
        /// <summary>Canonical name in CNAME record.</summary>
        [Newtonsoft.Json.JsonProperty("cname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDnsCnameRdata Cname { get; set; }
    
        /// <summary>Specifies the algorithm to pick the IP address(es) to be
        /// returned, when multiple entries are configured.
        /// This does not apply if num_records_in_response is 0.
        /// Default is consistent hash.
        /// Enum options - DNS_RECORD_RESPONSE_ROUND_ROBIN,
        /// DNS_RECORD_RESPONSE_CONSISTENT_HASH.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// DNS_RECORD_RESPONSE_CONSISTENT_HASH.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("algorithm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBDnsInfoAlgorithm? Algorithm { get; set; } = SDKGenerator.ALBDnsInfoAlgorithm.DNS_RECORD_RESPONSE_CONSISTENT_HASH;
    
        /// <summary>Time to live for fqdn record.
        /// Default value is chosen from DNS profile for this cloud if
        /// no value provided.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ttl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Ttl { get; set; }
    
        /// <summary>Specifies the number of records returned for this FQDN.
        /// Enter 0 to return all records.
        /// Default is 0.
        /// Allowed values are 0-20.
        /// Special values are 0- 'Return all records'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("num_records_in_response", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 20D)]
        public long? Num_records_in_response { get; set; } = 1L;
    
        /// <summary>DNS record type.
        /// Enum options - DNS_RECORD_OTHER, DNS_RECORD_A,
        /// DNS_RECORD_NS, DNS_RECORD_CNAME, DNS_RECORD_SOA,
        /// DNS_RECORD_PTR, DNS_RECORD_HINFO, DNS_RECORD_MX,
        /// DNS_RECORD_TXT, DNS_RECORD_RP, DNS_RECORD_DNSKEY,
        /// DNS_RECORD_AAAA, DNS_RECORD_SRV, DNS_RECORD_OPT,
        /// DNS_RECORD_RRSIG, DNS_RECORD_AXFR, DNS_RECORD_ANY.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as DNS_RECORD_A.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBDnsInfoType? Type { get; set; } = SDKGenerator.ALBDnsInfoType.DNS_RECORD_A;
    
        /// <summary>Fully qualified domain name.</summary>
        [Newtonsoft.Json.JsonProperty("fqdn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fqdn { get; set; }
    
        /// <summary>Any metadata associated with this record.</summary>
        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Metadata { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer TCPApplicationProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBTCPApplicationProfile 
    {
        /// <summary>Version of proxy protocol to be used to convey client
        /// connection information to the back-end servers.
        /// Enum options - PROXY_PROTOCOL_VERSION_1,
        /// PROXY_PROTOCOL_VERSION_2.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as PROXY_PROTOCOL_VERSION_1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("proxy_protocol_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBTCPApplicationProfileProxy_protocol_version? Proxy_protocol_version { get; set; } = SDKGenerator.ALBTCPApplicationProfileProxy_protocol_version.PROXY_PROTOCOL_VERSION_1;
    
        /// <summary>Specifies whether the client side verification is set to
        /// none, request or require.
        /// Enum options - SSL_CLIENT_CERTIFICATE_NONE,
        /// SSL_CLIENT_CERTIFICATE_REQUEST,
        /// SSL_CLIENT_CERTIFICATE_REQUIRE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// SSL_CLIENT_CERTIFICATE_NONE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ssl_client_certificate_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBTCPApplicationProfileSsl_client_certificate_mode? Ssl_client_certificate_mode { get; set; } = SDKGenerator.ALBTCPApplicationProfileSsl_client_certificate_mode.SSL_CLIENT_CERTIFICATE_NONE;
    
        /// <summary>Select the PKI profile to be associated with the Virtual
        /// Service.
        /// This profile defines the Certificate Authority and
        /// Revocation List.
        /// It is a reference to an object of type PKIProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pki_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pki_profile_path { get; set; }
    
        /// <summary>Enable/Disable the usage of proxy protocol to convey client
        /// connection information to the back-end servers.
        /// Valid only for L4 application profiles and TCP proxy.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("proxy_protocol_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Proxy_protocol_enabled { get; set; } = false;
    
    
    }
    
    /// <summary>Arbitrary key-value pairs that may be attached to an entity</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tag 
    {
        /// <summary>Tag searches may optionally be restricted by scope</summary>
        [Newtonsoft.Json.JsonProperty("scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(128)]
        public string Scope { get; set; } = "";
    
        /// <summary>Identifier meaningful to user with maximum length of 256 characters</summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tag1 { get; set; } = "";
    
    
    }
    
    /// <summary>Networking and Security policy for Application.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ApplicationService : PolicyConfigResource
    {
        /// <summary>Application Service template id using which Application Service will be created.
        /// This will be available under the application service templates.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service_template_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Service_template_id { get; set; }
    
        /// <summary>Property containing attributes for Policy Application Service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ApplicationServiceAttribute> Attributes { get; set; }
    
    
    }
    
    /// <summary>Transport Zone.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyTransportZone : PolicyConfigResource
    {
        /// <summary>Flag to indicate if the transport zone is the default one. Only one
        /// transport zone can be the default one for a given transport zone type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_default", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_default { get; set; } = false;
    
        /// <summary>Transport Zone Type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tz_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyTransportZoneTz_type? Tz_type { get; set; }
    
        /// <summary>UUID of transport zone on NSX-T enforcement point.</summary>
        [Newtonsoft.Json.JsonProperty("nsx_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Nsx_id { get; set; }
    
        /// <summary>The names of switching uplink teaming policies that all transport nodes in this transport zone support. Uplinkin teaming policies are only valid for VLAN backed transport zones.</summary>
        [Newtonsoft.Json.JsonProperty("uplink_teaming_policy_names", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Uplink_teaming_policy_names { get; set; }
    
    
    }
    
    /// <summary>This condition is used to match SSL handshake and SSL connection at
    /// all phases.If multiple properties are configured, the rule is considered
    /// a match when all the configured properties are matched.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBHttpSslCondition : LBRuleCondition
    {
        /// <summary>Cipher list which supported by client.</summary>
        [Newtonsoft.Json.JsonProperty("client_supported_ssl_ciphers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Client_supported_ssl_ciphers> Client_supported_ssl_ciphers { get; set; }
    
        /// <summary>The issuer DN match condition of the client certificate for an
        /// established SSL connection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_certificate_issuer_dn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LBClientCertificateIssuerDnCondition Client_certificate_issuer_dn { get; set; }
    
        /// <summary>The subject DN match condition of the client certificate for an
        /// established SSL connection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_certificate_subject_dn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LBClientCertificateSubjectDnCondition Client_certificate_subject_dn { get; set; }
    
        /// <summary>Cipher used for an established SSL connection.</summary>
        [Newtonsoft.Json.JsonProperty("used_ssl_cipher", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBHttpSslConditionUsed_ssl_cipher? Used_ssl_cipher { get; set; }
    
        /// <summary>The type of SSL session reused.</summary>
        [Newtonsoft.Json.JsonProperty("session_reused", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBHttpSslConditionSession_reused? Session_reused { get; set; } = SDKGenerator.LBHttpSslConditionSession_reused.IGNORE;
    
        /// <summary>Protocol of an established SSL connection.</summary>
        [Newtonsoft.Json.JsonProperty("used_protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBHttpSslConditionUsed_protocol? Used_protocol { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for GatewayQosProfile, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildGatewayQosProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual GatewayQosProfile object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("QosProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public GatewayQosProfile QosProfile { get; set; }
    
    
    }
    
    /// <summary>Global Manager federation configuration. This configuration is distributed
    /// to all Sites participating in federation.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FederationConfig 
    {
        /// <summary>Federation configurations of all Sites</summary>
        [Newtonsoft.Json.JsonProperty("site_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SiteFederationConfig> Site_config { get; set; }
    
    
    }
    
    /// <summary>Represents a NAT rule between source and destination at T0/T1 router.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyNatRule : PolicyConfigResource
    {
        /// <summary>This supports single IP address or comma separated list of single IP
        /// addresses or CIDR. This does not support IP range or IP sets.
        /// For SNAT, DNAT, NAT64 and REFLEXIVE rules, this ia a mandatory field, which
        /// represents the translated network address.
        /// For NO_SNAT and NO_DNAT this should be empty.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("translated_network", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Translated_network { get; set; }
    
        /// <summary>The flag, which suggests whether the logging of NAT rule is enabled or
        /// disabled. The default is False.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("logging", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Logging { get; set; } = false;
    
        /// <summary>It represents the path of Service on which the NAT rule will be applied.
        /// If not provided or if it is blank then Policy manager will consider it
        /// as ANY.
        /// Please note, if this is a DNAT, the destination_port of the service will
        /// be realized on NSX Manager as the translated_port. And if this is a SNAT,
        /// the destination_port will be ignored.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Service { get; set; }
    
        /// <summary>This supports single IP address or comma separated list of single IP
        /// addresses or CIDR. This does not support IP range or IP sets.
        /// For SNAT, NO_SNAT, NAT64 and REFLEXIVE rules, this is a mandatory field and
        /// represents the source network of the packets leaving the network.
        /// For DNAT and NO_DNAT rules, optionally it can contain source network
        /// of incoming packets.
        /// NULL value for this field represents ANY network.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source_network", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source_network { get; set; }
    
        /// <summary>The flag, which suggests whether the NAT rule is enabled or
        /// disabled. The default is True.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
        /// <summary>Please note, if there is service configured in this NAT rule, the translated_port
        /// will be realized on NSX Manager as the destination_port. If there is no sevice configured,
        /// the port will be ignored.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("translated_ports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Translated_ports { get; set; }
    
        /// <summary>Source NAT(SNAT) - translates a source IP address in an outbound packet so that
        /// the packet appears to originate from a different network. SNAT is only supported
        /// when the logical router is running in active-standby mode.
        /// Destination NAT(DNAT) - translates the destination IP address of inbound packets
        /// so that packets are delivered to a target address into another network. DNAT is
        /// only supported when the logical router is running in active-standby mode.
        /// Reflexive NAT(REFLEXIVE) - IP-Range and CIDR are supported to define the "n".
        /// The number of original networks should be exactly the same as that of
        /// translated networks. The address translation is deterministic. Reflexive is
        /// supported on both Active/Standby and Active/Active LR.
        /// NO_SNAT and NO_DNAT - These do not have support for translated_fields, only
        /// source_network and destination_network fields are supported.
        /// NAT64 - translates an external IPv6 address to a internal IPv4 address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyNatRuleAction Action { get; set; }
    
        /// <summary>Represents the array of policy paths of ProviderInterface or NetworkInterface or
        /// labels of type ProviderInterface or NetworkInterface on which the NAT rule should
        /// get enforced.
        /// The interfaces must belong to the same router for which the NAT Rule is created.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Scope { get; set; }
    
        /// <summary>It indicates how the firewall matches the address after NATing if firewall
        /// stage is not skipped.
        /// 
        /// MATCH_EXTERNAL_ADDRESS indicates the firewall will be applied to external address
        /// of a NAT rule. For SNAT, the external address is the translated source address
        /// after NAT is done. For DNAT, the external address is the original destination
        /// address before NAT is done. For REFLEXIVE, to egress traffic, the firewall
        /// will be applied to the translated source address after NAT is done; To ingress
        /// traffic, the firewall will be applied to the original destination address
        /// before NAT is done.
        /// 
        /// MATCH_INTERNAL_ADDRESS indicates the firewall will be applied to internal
        /// address of a NAT rule. For SNAT, the internal address is the original source
        /// address before NAT is done. For DNAT, the internal address is the translated
        /// destination address after NAT is done. For REFLEXIVE, to egress traffic, the
        /// firewall will be applied to the original source address before NAT is done;
        /// To ingress traffic, the firewall will be applied to the translated destination
        /// address after NAT is done.
        /// 
        /// BYPASS indicates the firewall stage will be skipped.
        /// 
        /// For NO_SNAT or NO_DNAT, it must be BYPASS or leave it unassigned
        /// </summary>
        [Newtonsoft.Json.JsonProperty("firewall_match", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyNatRuleFirewall_match? Firewall_match { get; set; } = SDKGenerator.PolicyNatRuleFirewall_match.MATCH_INTERNAL_ADDRESS;
    
        /// <summary>This supports single IP address or comma separated list of single IP
        /// addresses or CIDR. This does not support IP range or IP sets.
        /// For DNAT and NO_DNAT rules, this is a mandatory field, and represents
        /// the destination network for the incoming packets.
        /// For other type of rules, optionally it can contain destination network
        /// of outgoing packets.
        /// NULL value for this field represents ANY network.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destination_network", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Destination_network { get; set; }
    
        /// <summary>The sequence_number decides the rule_priority of a NAT rule.
        /// Sequence_number and rule_priority have 1:1 mapping.For each NAT section,
        /// there will be reserved rule_priority numbers.The valid range of
        /// rule_priority number is from 0 to 2147483647(MAX_INT).
        /// 1. INTERNAL section
        ///     rule_priority reserved from 0 - 1023 (1024 rules)
        ///     valid sequence_number range  0 - 1023
        /// 2. USER section
        ///    rule_priority reserved from 1024 - 2147482623 (2147481600 rules)
        ///    valid sequence_number range  0 - 2147481599
        /// 3. DEFAULT section
        ///    rule_priority reserved from 2147482624 - 2147483647 (1024 rules)
        ///    valid sequence_number range  0 - 1023
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sequence_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Sequence_number { get; set; } = 0L;
    
    
    }
    
    /// <summary>This entity will be used to establish association between CPU Memory
    /// Thresholds Profile and Transport Node. Using this entity, user can specify
    /// intent for applying Firewall CPU Memory Thresholds Profile to particular
    /// Transport Node.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyFirewallCPUMemThresholdsProfileBindingMap : ProfileBindingMap
    {
        /// <summary>Sequence number is used to resolve conflicts when two profiles get
        /// applied to a single node. Lower value gets higher precedence. Two
        /// binding maps having the same profile path should have the same sequence
        /// number.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sequence_number", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long Sequence_number { get; set; }
    
        /// <summary>References of transport nodes on which the profile intended to
        /// be applied.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transport_nodes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyResourceReference> Transport_nodes { get; set; }
    
    
    }
    
    /// <summary>Paged collection of DhcpServerConfigs</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DhcpServerConfigListResult : ListResult
    {
        /// <summary>DhcpServerConfig results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<DhcpServerConfig> Results { get; set; } = new System.Collections.ObjectModel.Collection<DhcpServerConfig>();
    
    
    }
    
    /// <summary>Child wrapper for ALBAutoScaleLaunchConfig, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBAutoScaleLaunchConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBAutoScaleLaunchConfig object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBAutoScaleLaunchConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBAutoScaleLaunchConfig ALBAutoScaleLaunchConfig { get; set; }
    
    
    }
    
    /// <summary>DHCP IPv4 static bindings are configured for each segment.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DhcpV4StaticBindingConfig : DhcpStaticBindingConfig
    {
        /// <summary>When not specified, gateway address is auto-assigned from segment
        /// configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gateway_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Gateway_address { get; set; }
    
        /// <summary>Hostname to assign to the host.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("host_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(63)]
        public string Host_name { get; set; }
    
        /// <summary>MAC address of the host.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mac_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Mac_address { get; set; }
    
        /// <summary>DHCP lease time in seconds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lease_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(60D, 4294967295D)]
        public long? Lease_time { get; set; } = 86400L;
    
        /// <summary>IP assigned to host. The IP address must belong to the subnet, if any,
        /// configured on Segment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ip_address { get; set; }
    
        /// <summary>IPv4 DHCP options.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("options", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DhcpV4Options Options { get; set; }
    
    
    }
    
    /// <summary>Represents realized entity</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GenericPolicyRealizedResource : PolicyRealizedResource
    {
        /// <summary>The site where this entity resides.</summary>
        [Newtonsoft.Json.JsonProperty("site_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Site_path { get; set; }
    
        /// <summary>Collection of intent paths</summary>
        [Newtonsoft.Json.JsonProperty("intent_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Intent_paths { get; set; }
    
        /// <summary>The path of the enforcement point.</summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enforcement_point_path { get; set; }
    
        /// <summary>Collection of type specific properties</summary>
        [Newtonsoft.Json.JsonProperty("extended_attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AttributeVal> Extended_attributes { get; set; }
    
        /// <summary>Type of realized entity</summary>
        [Newtonsoft.Json.JsonProperty("entity_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Entity_type { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PimRpMappingCsvRecord : CsvRecord
    {
        /// <summary>Value of this field will be true if this edge transport node
        /// acts as rendezvous point, otherwise false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_rp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_rp { get; set; }
    
        /// <summary>Transport node uuid or policy path.</summary>
        [Newtonsoft.Json.JsonProperty("transport_node", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_node { get; set; }
    
        /// <summary>Multicast group address.</summary>
        [Newtonsoft.Json.JsonProperty("group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group { get; set; }
    
        /// <summary>Source of learning RP information. Either Static RP configured or
        /// RP learned via BSR (Bootstrap Router).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source { get; set; }
    
        /// <summary>Outgoing/Egress interface for multicast traffic.</summary>
        [Newtonsoft.Json.JsonProperty("outgoing_interface", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Outgoing_interface { get; set; }
    
        /// <summary>RP (Randezvous Point) address.</summary>
        [Newtonsoft.Json.JsonProperty("rp_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rp_address { get; set; }
    
    
    }
    
    /// <summary>OSPF Neighbors.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OspfNeighborsStatusListResult : ListResult
    {
        /// <summary>Policy path to Tier0 gateway.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gateway_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Gateway_path { get; set; }
    
        /// <summary>Timestamp when the data was last updated, unset if data source has never updated the data.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OspfNeighbor> Results { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2ForwarderStatusPerNode 
    {
        /// <summary>Edge node details from where the router status is being retrieved.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transport_node", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceReference Transport_node { get; set; }
    
        /// <summary>High Availability status of a service router on the edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("high_availability_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public L2ForwarderStatusPerNodeHigh_availability_status? High_availability_status { get; set; }
    
    
    }
    
    /// <summary>VSDataScriptSetApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBVSDataScriptSetApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of VSDataScriptSet
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBVSDataScriptSet> Results { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer CertificateAuthority object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBCertificateAuthority 
    {
        /// <summary>It is a reference to an object of type
        /// SSLKeyAndCertificate.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ca_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ca_path { get; set; }
    
        /// <summary>Name of the object.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
    
    }
    
    /// <summary>Paged collection of compute cluster idfw configuration</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ComputeClusterIdfwConfigurationListResult : ListResult
    {
        /// <summary>Compute cluster wise identity firewall configuration list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ComputeClusterIdfwConfiguration> Results { get; set; } = new System.Collections.ObjectModel.Collection<ComputeClusterIdfwConfiguration>();
    
    
    }
    
    /// <summary>Field Setting.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FieldSetting 
    {
        /// <summary>Value that the field must be set to.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public FieldSettingValue Value { get; set; } = new FieldSettingValue();
    
        /// <summary>Field Pointer.</summary>
        [Newtonsoft.Json.JsonProperty("field_pointer", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Field_pointer { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for PolicyEdgeCluster, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyEdgeCluster : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyEdgeCluster object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyEdgeCluster", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyEdgeCluster PolicyEdgeCluster { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentMacAddressListResult : ListResult
    {
        /// <summary>Timestamp when the data was last updated; unset if data source has never updated the data.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MacTableEntry> Results { get; set; }
    
        /// <summary>Transport node identifier</summary>
        [Newtonsoft.Json.JsonProperty("transport_node_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_node_id { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer SSLKeyRSAParams object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSSLKeyRSAParams 
    {
        /// <summary>Enum options - SSL_KEY_1024_BITS, SSL_KEY_2048_BITS,
        /// SSL_KEY_3072_BITS, SSL_KEY_4096_BITS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as SSL_KEY_2048_BITS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBSSLKeyRSAParamsKey_size? Key_size { get; set; } = SDKGenerator.ALBSSLKeyRSAParamsKey_size.SSL_KEY_2048_BITS;
    
        /// <summary>Number of exponent.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 65537.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exponent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Exponent { get; set; } = 65537L;
    
    
    }
    
    /// <summary>Advanced load balancer ClientLogStreamingConfig object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBClientLogStreamingConfig 
    {
        /// <summary>The service port to use for the external servers.
        /// If multiple external servers have been specified, the
        /// single port number specified here will apply to all those
        /// servers for which an explicit port number has not been
        /// specified in the external server list.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 514.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("external_server_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? External_server_port { get; set; } = 514L;
    
        /// <summary>Protocol to use for streaming logs.
        /// Enum options - LOG_STREAMING_PROTOCOL_UDP,
        /// LOG_STREAMING_PROTOCOL_SYSLOG_OVER_UDP,
        /// LOG_STREAMING_PROTOCOL_TCP,
        /// LOG_STREAMING_PROTOCOL_SYSLOG_OVER_TCP,
        /// LOG_STREAMING_PROTOCOL_RAW_OVER_UDP.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as LOG_STREAMING_PROTOCOL_UDP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBClientLogStreamingConfigProtocol? Protocol { get; set; } = SDKGenerator.ALBClientLogStreamingConfigProtocol.LOG_STREAMING_PROTOCOL_UDP;
    
        /// <summary>Syslog configuration if a Syslog-based protocol is
        /// specified for streaming.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("syslog_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBStreamingSyslogConfig Syslog_config { get; set; }
    
        /// <summary>Maximum number of logs per second streamed to the remote
        /// server.
        /// By default, 100 logs per second are streamed.
        /// Set this to zero(0) to not enforce any limit.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 100.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_logs_per_second", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Max_logs_per_second { get; set; } = 100L;
    
        /// <summary>Configuration to specify the format of streamed logs.
        /// By default, each log is encoded in JSON format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("format_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBClientLogStreamingFormat Format_config { get; set; }
    
        /// <summary>Type of logs to stream to the external server.
        /// Default is LOGS_ALL, i.e., send all logs.
        /// Enum options - LOGS_SIGNIFICANT_ONLY, LOGS_UDF_ONLY,
        /// LOGS_UDF_SIGNIFICANT, LOGS_ALL.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as LOGS_ALL.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("log_types_to_send", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBClientLogStreamingConfigLog_types_to_send? Log_types_to_send { get; set; } = SDKGenerator.ALBClientLogStreamingConfigLog_types_to_send.LOGS_ALL;
    
        /// <summary>IP address or hostnames (FQDNs) of destination servers.
        /// If an FQDN is provided, this should be resolvable on Avi
        /// Service Engines.
        /// Multiple servers are supported by furnishing a
        /// comma-separated list of IP addresses or host names, for
        /// example, 11.11.11.11,23.12.12.4.
        /// Optionally, a separate port can be specified for each
        /// external server in the list, for example, 11.11.11.11
        /// 234,12.12.12.12 343.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("external_server", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string External_server { get; set; }
    
    
    }
    
    /// <summary>OSPF Routes Per Edge.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OspfRoutes 
    {
        [Newtonsoft.Json.JsonProperty("route_details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OspfRoute> Route_details { get; set; }
    
        /// <summary>Policy path to edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Edge_path { get; set; }
    
        /// <summary>Display name to edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Edge_display_name { get; set; }
    
    
    }
    
    /// <summary>Represents a Label-Value widget configuration</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LabelValueConfiguration : WidgetConfiguration
    {
        /// <summary>Layout of properties can be vertical or grid. If layout is not specified a default vertical layout is applied.</summary>
        [Newtonsoft.Json.JsonProperty("layout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Layout Layout { get; set; }
    
        /// <summary>Hyperlink of the specified UI page that provides details.</summary>
        [Newtonsoft.Json.JsonProperty("navigation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Navigation { get; set; }
    
        /// <summary>A sub-type of LabelValueConfiguration. If sub-type is not specified the parent type is rendered. For VERTICALLY_ALIGNED sub_type, the value is placed below the label.</summary>
        [Newtonsoft.Json.JsonProperty("sub_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LabelValueConfigurationSub_type? Sub_type { get; set; }
    
        /// <summary>An array of label-value properties.</summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PropertyItem> Properties { get; set; } = new System.Collections.ObjectModel.Collection<PropertyItem>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyMulticastForwardingInCsvFormat : CsvListResult
    {
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MulticastForwardingCsvRecord> Results { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer VSDataScript object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBVSDataScript 
    {
        /// <summary>Event triggering execution of datascript.
        /// Enum options - VS_DATASCRIPT_EVT_HTTP_REQ,
        /// VS_DATASCRIPT_EVT_HTTP_RESP,
        /// VS_DATASCRIPT_EVT_HTTP_RESP_DATA,
        /// VS_DATASCRIPT_EVT_HTTP_LB_FAILED,
        /// VS_DATASCRIPT_EVT_HTTP_REQ_DATA,
        /// VS_DATASCRIPT_EVT_HTTP_RESP_FAILED,
        /// VS_DATASCRIPT_EVT_HTTP_LB_DONE, VS_DATASCRIPT_EVT_HTTP_AUTH,
        /// VS_DATASCRIPT_EVT_HTTP_POST_AUTH,
        /// VS_DATASCRIPT_EVT_TCP_CLIENT_ACCEPT,
        /// VS_DATASCRIPT_EVT_SSL_HANDSHAKE_DONE,
        /// VS_DATASCRIPT_EVT_DNS_REQ, VS_DATASCRIPT_EVT_DNS_RESP,
        /// VS_DATASCRIPT_EVT_L4_REQUEST, VS_DATASCRIPT_EVT_L4_RESPONSE,
        /// VS_DATASCRIPT_EVT_MAX.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("evt", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBVSDataScriptEvt Evt { get; set; }
    
        /// <summary>Datascript to execute when the event triggers.</summary>
        [Newtonsoft.Json.JsonProperty("script", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Script { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer PathMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBPathMatch 
    {
        /// <summary>Case sensitivity to use for the matching.
        /// Enum options - SENSITIVE, INSENSITIVE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as INSENSITIVE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_case", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBPathMatchMatch_case? Match_case { get; set; } = SDKGenerator.ALBPathMatchMatch_case.INSENSITIVE;
    
        /// <summary>path of the string group(s).
        /// It is a reference to an object of type StringGroup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("string_group_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> String_group_paths { get; set; }
    
        /// <summary>String values.</summary>
        [Newtonsoft.Json.JsonProperty("match_str", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Match_str { get; set; }
    
        /// <summary>Criterion to use for matching the path in the HTTP request
        /// URI.
        /// Enum options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS,
        /// DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS,
        /// DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as CONTAINS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBPathMatchMatch_criteria Match_criteria { get; set; } = SDKGenerator.ALBPathMatchMatch_criteria.CONTAINS;
    
    
    }
    
    /// <summary>This action is used to select a pool for matched HTTP request messages. The
    /// pool is specified by path. The matched HTTP request messages are forwarded
    /// to the specified pool.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBSelectPoolAction : LBRuleAction
    {
        /// <summary>Path of load balancer pool.</summary>
        [Newtonsoft.Json.JsonProperty("pool_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Pool_id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentPortMacAddressCsvListResult : CsvListResult
    {
        /// <summary>Timestamp when the data was last updated; unset if data source has never updated the data.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SegmentPortMacTableCsvEntry> Results { get; set; }
    
    
    }
    
    /// <summary>IPFIX data from source logical segment will be copied to IPFIX collector.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPFIXSwitchCollectionInstance : PolicyConfigResource
    {
        /// <summary>Policy path for IPFIX collector profiles. IPFIX data from
        /// these logical segments will be sent to all specified IPFIX
        /// collectors.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipfix_collector_profile_paths", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Ipfix_collector_profile_paths { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>The time in seconds after a Flow is expired if
        /// no more packets matching this Flow are received by the cache.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("idle_timeout", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(60D, 3600D)]
        public long Idle_timeout { get; set; } = 300L;
    
        /// <summary>Policy path for source tier-1 segment. IPFIX data from
        /// these logical segments will be sent IPFIX collector.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source_logical_segment_paths", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Source_logical_segment_paths { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>The maximum number of flow entries in
        /// each exporter flow cache.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_flows", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? Max_flows { get; set; } = 16384L;
    
        /// <summary>An identifier that is unique to the exporting process and used to
        /// meter the Flows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("observation_domain_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? Observation_domain_id { get; set; } = 0L;
    
        /// <summary>The time in seconds after a flow is expired even if
        /// more packets matching this flow are received by the cache.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("active_timeout", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(60D, 3600D)]
        public long Active_timeout { get; set; } = 300L;
    
        /// <summary>The probability in percentage that a packet is sampled,
        /// in range 0-100. The probability is equal for every packet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packet_sample_probability", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 100)]
        public double Packet_sample_probability { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for SslTrustObjectData, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildSslTrustObjectData : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual SslTrustObjectData object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("SslTrustObjectData", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SslTrustObjectData SslTrustObjectData { get; set; }
    
    
    }
    
    /// <summary>OSPF Interface configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyInterfaceOspfConfig 
    {
        /// <summary>Specifies the number of seconds that router must wait before it declares
        /// a OSPF neighbor router down because it has not received OSPF hello packet.
        /// OSPF dead interval should be minimum 3 times greater than the hello interval
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dead_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(3D, 65535D)]
        public long? Dead_interval { get; set; } = 40L;
    
        /// <summary>Attache Tier0 Interface to specified OSPF Area.
        /// all peers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ospf_area", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ospf_area { get; set; }
    
        /// <summary>Specifies the interval between the hello packets that OSPF sends on this interface.
        /// OSPF hello interval should be less than the dead interval
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hello_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 21845D)]
        public long? Hello_interval { get; set; } = 10L;
    
        /// <summary>Enable/Disable OSPF to register for BFD event. Use FALSE to disable BFD.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_bfd", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_bfd { get; set; }
    
        /// <summary>enable/disable OSPF on the interface. If enabled flag not specified, defailt is disable OSPF.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = false;
    
        /// <summary>Configure OSPF networkt type, default is BROADCAST network type
        /// </summary>
        [Newtonsoft.Json.JsonProperty("network_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyInterfaceOspfConfigNetwork_type? Network_type { get; set; } = SDKGenerator.PolicyInterfaceOspfConfigNetwork_type.BROADCAST;
    
        /// <summary>This filed is valid only if enable_bfd is set to TRUE.
        /// If enable_bfd flag is set to TRUE, this profile will be applied to all OSPF peers in this interface.
        /// If this field is empty, bfd_path will refer to Tier-0 global BFD profile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bfd_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bfd_path { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DirectoryGroupListResults : ListResult
    {
        /// <summary>Directory group list</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<DirectoryGroup> Results { get; set; } = new System.Collections.ObjectModel.Collection<DirectoryGroup>();
    
    
    }
    
    /// <summary>Represents NAT section. This object is created by default when corresponding
    /// tier-0/tier-1 is created. Under tier-0/tier-1 there will be 4 different NATs(sections).
    /// (INTERNAL, USER, DEFAULT and NAT64).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyNat : PolicyConfigResource
    {
        /// <summary>Represents a NAT section under tier-0/tier-1.</summary>
        [Newtonsoft.Json.JsonProperty("nat_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyNatNat_type? Nat_type { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of LBAppProfile</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBAppProfileListResult : ListResult
    {
        /// <summary>LBAppProfile list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<LBAppProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<LBAppProfile>();
    
    
    }
    
    /// <summary>Paged collection of Port Discovery Profile Binding Maps</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PortDiscoveryProfileBindingMapListResult : ListResult
    {
        /// <summary>Port Discovery Profile Binding Map list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PortDiscoveryProfileBindingMap> Results { get; set; } = new System.Collections.ObjectModel.Collection<PortDiscoveryProfileBindingMap>();
    
    
    }
    
    /// <summary>Enable address_families and route filtering in each direction</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BgpRouteFiltering 
    {
        /// <summary>Specify path of prefix-list or route map to filter routes for OUT direction.
        /// When not specified, a built-in prefix-list named 'prefixlist-out-default'
        /// is automatically applied.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("out_route_filters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Out_route_filters { get; set; }
    
        /// <summary>Specify path of prefix-list or route map to filter routes for IN direction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("in_route_filters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> In_route_filters { get; set; }
    
        /// <summary>Flag to enable address family.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
        /// <summary>Address family type.
        /// If not configured, this property automatically derived for IPv4 &amp; IPv6
        /// peer configuration.</summary>
        [Newtonsoft.Json.JsonProperty("address_family", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BgpRouteFilteringAddress_family? Address_family { get; set; }
    
        /// <summary>Maximum number of routes for the address family.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maximum_routes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 1000000D)]
        public long? Maximum_routes { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MacTableEntry 
    {
        /// <summary>The virtual tunnel endpoint MAC address</summary>
        [Newtonsoft.Json.JsonProperty("vtep_mac_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Vtep_mac_address { get; set; }
    
        /// <summary>RTEP group id is applicable when the logical switch is stretched
        /// across multiple sites. When rtep_group_id is set, mac_address
        /// represents remote mac_address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rtep_group_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Rtep_group_id { get; set; }
    
        /// <summary>The virtual tunnel endpoint IP address</summary>
        [Newtonsoft.Json.JsonProperty("vtep_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Vtep_ip { get; set; }
    
        /// <summary>VTEP group id is applicable when the logical switch is stretched
        /// across multiple sites. When vtep_group_id is set, mac_address
        /// represents remote mac_address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vtep_group_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Vtep_group_id { get; set; }
    
        /// <summary>The MAC address</summary>
        [Newtonsoft.Json.JsonProperty("mac_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Mac_address { get; set; }
    
    
    }
    
    /// <summary>compute collection ID and status connected to VC.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdfwComputeCollectionStatus 
    {
        /// <summary>IDFW enabled compute collection status.</summary>
        [Newtonsoft.Json.JsonProperty("compute_collection_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IdfwComputeCollectionCondition> Compute_collection_status { get; set; }
    
        /// <summary>IDFW compute collection ID connected to VC.</summary>
        [Newtonsoft.Json.JsonProperty("compute_collection_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Compute_collection_id { get; set; }
    
    
    }
    
    /// <summary>This condition is used to match HTTP response messages from backend servers
    /// by HTTP header fields. HTTP header fields are components of the header
    /// section of HTTP request and response messages. They define the operating
    /// parameters of an HTTP transaction. For example, Cookie, Authorization,
    /// User-Agent, etc. One condition can be used to match one header field, to
    /// match multiple header fields, multiple conditions must be specified.
    /// The match_type field defines how header_value field is used to match HTTP
    /// responses. The header_name field does not support match types.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBHttpResponseHeaderCondition : LBRuleCondition
    {
        /// <summary>Value of HTTP header field</summary>
        [Newtonsoft.Json.JsonProperty("header_value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Header_value { get; set; }
    
        /// <summary>If true, case is significant when comparing HTTP header value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("case_sensitive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Case_sensitive { get; set; } = true;
    
        /// <summary>Match type of HTTP header value</summary>
        [Newtonsoft.Json.JsonProperty("match_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBHttpResponseHeaderConditionMatch_type? Match_type { get; set; } = SDKGenerator.LBHttpResponseHeaderConditionMatch_type.REGEX;
    
        /// <summary>Name of HTTP header field</summary>
        [Newtonsoft.Json.JsonProperty("header_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Header_name { get; set; }
    
    
    }
    
    /// <summary>Constraint object to constraint any attribute on a resource based on
    /// specified expression.
    /// Example- Restrict the allowed services in Edge Communication Entry to list of
    ///  services, if the destinationGroups contain vCenter.
    /// {
    ///   "target":{
    ///      "target_resource_type":"CommunicationEntry",
    ///      "attribute":"services",
    ///      "path_prefix":"/infra/domains/vmc-domain/edge-communication-maps/default/communication-entries"
    ///   }
    ///   "constraint_expression":{
    ///     "related_attribute":{
    ///       "attribute":"destinationGroups"
    ///     }
    ///     "condition":{
    ///       "operator":"INCLUDES",
    ///       "rhs_value":{"vCenter"}
    ///       "value_constraint":{
    ///           "operator":"ALLOW",
    ///           "values":{"/ref/services/HTTPS", "/ref/services/HTTOP", ...}
    ///      }
    ///     }
    ///   }
    /// }
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Constraint : PolicyConfigResource
    {
        /// <summary>User friendly message to be shown to users upon violation.</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        /// <summary>Expression to constrain the target attribute value.</summary>
        [Newtonsoft.Json.JsonProperty("constraint_expression", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ConstraintExpression Constraint_expression { get; set; }
    
        /// <summary>Target resource attribute details.</summary>
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ConstraintTarget Target { get; set; } = new ConstraintTarget();
    
    
    }
    
    /// <summary>Advanced load balancer DnsPolicies object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsPolicies 
    {
        /// <summary>Index of the dns policy.</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public long Index { get; set; }
    
        /// <summary>path of the dns policy.
        /// It is a reference to an object of type DnsPolicy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dns_policy_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Dns_policy_path { get; set; }
    
    
    }
    
    /// <summary>Placeholder to reference group entity.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyGroupReference : PolicyConfigResource
    {
        /// <summary>Policy entity paths referred by the group instance</summary>
        [Newtonsoft.Json.JsonProperty("refs", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Refs { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>Tooltip to be shown while hovering over the dashboard UI element.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tooltip 
    {
        /// <summary>Text to be shown on tooltip while hovering over UI element. The text would be wrapped if it exceeds 80 chars.</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Text { get; set; }
    
        /// <summary>If true, displays tooltip text in bold</summary>
        [Newtonsoft.Json.JsonProperty("heading", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Heading { get; set; }
    
        /// <summary>If the condition is met then the tooltip will be applied. If no condition is provided, then the tooltip will be applied unconditionally. Examples of expression syntax are provided under 'example_request' section of 'CreateWidgetConfiguration' API.</summary>
        [Newtonsoft.Json.JsonProperty("condition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Condition { get; set; }
    
    
    }
    
    /// <summary>Cluster restore status</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ClusterRestoreStatus 
    {
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GlobalRestoreStatus Status { get; set; }
    
        [Newtonsoft.Json.JsonProperty("step", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RestoreStep Step { get; set; }
    
        /// <summary>The list of allowed endpoints, based on the current state of
        /// the restore process
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endpoints", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ResourceLink> Endpoints { get; set; }
    
        /// <summary>Total number of steps in the entire restore process</summary>
        [Newtonsoft.Json.JsonProperty("total_steps", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total_steps { get; set; }
    
        /// <summary>Timestamp when restore was started in epoch millisecond</summary>
        [Newtonsoft.Json.JsonProperty("restore_start_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Restore_start_time { get; set; }
    
        /// <summary>Timestamp when restore was completed in epoch millisecond</summary>
        [Newtonsoft.Json.JsonProperty("restore_end_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Restore_end_time { get; set; }
    
        /// <summary>Timestamp when backup was initiated in epoch millisecond</summary>
        [Newtonsoft.Json.JsonProperty("backup_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Backup_timestamp { get; set; }
    
        /// <summary>Unique id for backup request</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
        /// <summary>Instructions for users to reconcile Restore operations</summary>
        [Newtonsoft.Json.JsonProperty("instructions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InstructionInfo> Instructions { get; set; }
    
    
    }
    
    /// <summary>All the nodes of the expression extend from this abstract class. This
    /// is present for extensibility.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("PathExpression", typeof(PathExpression))]
    [JsonInheritanceAttribute("IPAddressExpression", typeof(IPAddressExpression))]
    [JsonInheritanceAttribute("ExternalIDExpression", typeof(ExternalIDExpression))]
    [JsonInheritanceAttribute("MACAddressExpression", typeof(MACAddressExpression))]
    [JsonInheritanceAttribute("NestedExpression", typeof(NestedExpression))]
    [JsonInheritanceAttribute("IdentityGroupExpression", typeof(IdentityGroupExpression))]
    [JsonInheritanceAttribute("ConjunctionOperator", typeof(ConjunctionOperator))]
    [JsonInheritanceAttribute("Condition", typeof(Condition))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Expression : PolicyConfigResource
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Ipv6Header 
    {
        /// <summary>The source ip address.</summary>
        [Newtonsoft.Json.JsonProperty("src_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Src_ip { get; set; }
    
        /// <summary>The destination ip address.</summary>
        [Newtonsoft.Json.JsonProperty("dst_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dst_ip { get; set; }
    
        /// <summary>Identifies the type of header immediately following the IPv6 header.</summary>
        [Newtonsoft.Json.JsonProperty("next_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 255D)]
        public long? Next_header { get; set; } = 58L;
    
        /// <summary>Decremented by 1 by each node that forwards the packets. The packet is discarded if Hop Limit is decremented to zero.</summary>
        [Newtonsoft.Json.JsonProperty("hop_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 255D)]
        public long? Hop_limit { get; set; } = 64L;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class QoSProfile : PolicyConfigResource
    {
        /// <summary>Array of Rate limiter configurations to applied on Segment or Port.</summary>
        [Newtonsoft.Json.JsonProperty("shaper_configurations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(3)]
        public System.Collections.Generic.ICollection<QoSBaseRateLimiter> Shaper_configurations { get; set; }
    
        /// <summary>Class of service groups similar types of traffic in the network and
        /// each type of traffic is treated as a class with its own level of service
        /// priority. The lower priority traffic is slowed down or in some cases
        /// dropped to provide better throughput for higher priority traffic.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("class_of_service", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 7D)]
        public long? Class_of_service { get; set; } = 0L;
    
        [Newtonsoft.Json.JsonProperty("dscp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public QoSDscp Dscp { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer L4RuleMatchTarget object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBL4RuleMatchTarget 
    {
        /// <summary>IP addresses to match against client IP.</summary>
        [Newtonsoft.Json.JsonProperty("client_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddrMatch Client_ip { get; set; }
    
        /// <summary>TCP/UDP/ICMP protocol to match against transport protocol.</summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBL4RuleProtocolMatch Protocol { get; set; }
    
        /// <summary>Port number to match against Virtual Service listner port.</summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBL4RulePortMatch Port { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyNonCompliantConfig 
    {
        /// <summary>Id and name of non compliant resource/service</summary>
        [Newtonsoft.Json.JsonProperty("reported_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PolicyResourceReference Reported_by { get; set; }
    
        /// <summary>Resources/Services impacted by non compliant configuration</summary>
        [Newtonsoft.Json.JsonProperty("affected_resources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyResourceReference> Affected_resources { get; set; }
    
        /// <summary>Code for non compliant configuration</summary>
        [Newtonsoft.Json.JsonProperty("non_compliance_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Non_compliance_code { get; set; }
    
        /// <summary>Detail description of non compliant configuration with suggestive action</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer CompressionProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBCompressionProfile 
    {
        /// <summary>Custom filters used when auto compression is not selected.</summary>
        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBCompressionFilter> Filter { get; set; }
    
        /// <summary>Compress content automatically or add custom filters to
        /// define compressible content and compression levels.
        /// Enum options - AUTO_COMPRESSION, CUSTOM_COMPRESSION.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as AUTO_COMPRESSION.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBCompressionProfileType Type { get; set; } = SDKGenerator.ALBCompressionProfileType.AUTO_COMPRESSION;
    
        /// <summary>Compress only content types listed in this string group.
        /// Content types not present in this list are not compressed.
        /// It is a reference to an object of type StringGroup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("compressible_content_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Compressible_content_path { get; set; }
    
        /// <summary>Offload compression from the servers to AVI.
        /// Saves compute cycles on the servers.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remove_accept_encoding_header", Required = Newtonsoft.Json.Required.Always)]
        public bool Remove_accept_encoding_header { get; set; } = true;
    
        /// <summary>Compress HTTP response content if it wasn't already
        /// compressed.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("compression", Required = Newtonsoft.Json.Required.Always)]
        public bool Compression { get; set; } = false;
    
    
    }
    
    /// <summary>Advanced load balancer ReplaceStringVar object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBReplaceStringVar 
    {
        /// <summary>Type of replacement string - can be a variable exposed from
        /// datascript, value of an HTTP header or a custom user-input
        /// literal string.
        /// Enum options - DATASCRIPT_VAR, HTTP_HEADER_VAR,
        /// LITERAL_STRING.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBReplaceStringVarType? Type { get; set; }
    
        /// <summary>Value of the replacement string - name of variable exposed
        /// from datascript, name of the HTTP header or a custom
        /// user-input literal string.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("val", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Val { get; set; }
    
    
    }
    
    /// <summary>PolicyAlarmResource list result</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyAlarmResourceListResult : ListResult
    {
        /// <summary>List of alarm resources</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyAlarmResource> Results { get; set; }
    
    
    }
    
    /// <summary>Realized groups</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedGroups : PolicyRealizedResource
    {
        /// <summary>list of realized groups</summary>
        [Newtonsoft.Json.JsonProperty("realized_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RealizedGroup> Realized_groups { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HttpCookiePersistenceProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHttpCookiePersistenceProfile 
    {
        /// <summary>HTTP cookie name for cookie persistence.</summary>
        [Newtonsoft.Json.JsonProperty("cookie_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cookie_name { get; set; }
    
        /// <summary>If no persistence cookie was received from the client,
        /// always send it.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("always_send_cookie", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Always_send_cookie { get; set; } = false;
    
        /// <summary>Placeholder for description of property key of obj type
        /// HttpCookiePersistenceProfile field type str  type array.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBHttpCookiePersistenceKey> Key { get; set; }
    
        /// <summary>The maximum lifetime of any session cookie.
        /// No value or 'zero' indicates no timeout.
        /// Allowed values are 1-14400.
        /// Special values are 0- 'No Timeout'.
        /// Unit is MIN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 14400D)]
        public long? Timeout { get; set; }
    
        /// <summary>Key name to use for cookie encryption.</summary>
        [Newtonsoft.Json.JsonProperty("encryption_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Encryption_key { get; set; }
    
    
    }
    
    /// <summary>AnalyticsProfileApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAnalyticsProfileApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of AnalyticsProfile
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBAnalyticsProfile> Results { get; set; }
    
    
    }
    
    /// <summary>List of String values</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class StringArrayConstraintValue : ConstraintValue
    {
        /// <summary>Array of string values</summary>
        [Newtonsoft.Json.JsonProperty("values", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(100)]
        public System.Collections.Generic.ICollection<string> Values { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>Operation based Injection Value.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class UnaryOperationBasedInjectionValue : InjectionValue
    {
        /// <summary>Represents an optional operation to be done on the initial value.</summary>
        [Newtonsoft.Json.JsonProperty("operation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public UnaryOperation Operation { get; set; }
    
        /// <summary>Resource field pointer representing the initial value for the injection value. If an
        /// operation is supplied, the value is handed to the operation function to produce a
        /// final result.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("initial_value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ResourceFieldPointer Initial_value { get; set; } = new ResourceFieldPointer();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceflowObservationCounters 
    {
        /// <summary>Total number of forwarded observations for this traceflow round.</summary>
        [Newtonsoft.Json.JsonProperty("forwarded_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Forwarded_count { get; set; }
    
        /// <summary>Total number of dropped observations for this round.</summary>
        [Newtonsoft.Json.JsonProperty("dropped_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dropped_count { get; set; }
    
        /// <summary>Total number of delivered observations for this traceflow round.</summary>
        [Newtonsoft.Json.JsonProperty("delivered_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Delivered_count { get; set; }
    
        /// <summary>Total number of received observations for this traceflow round.</summary>
        [Newtonsoft.Json.JsonProperty("received_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Received_count { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyArpProxyEntry 
    {
        /// <summary>Identifier of connected service on port.</summary>
        [Newtonsoft.Json.JsonProperty("service_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Service_id { get; set; }
    
        /// <summary>ARP proxy information for a service with ip.</summary>
        [Newtonsoft.Json.JsonProperty("arp_proxy_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Arp_proxy_ip { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer SSLKeyAndCertificate object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSSLKeyAndCertificate : PolicyConfigResource
    {
        /// <summary>Enum options - SSL_CERTIFICATE_FINISHED,
        /// SSL_CERTIFICATE_PENDING.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as SSL_CERTIFICATE_FINISHED.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBSSLKeyAndCertificateStatus? Status { get; set; } = SDKGenerator.ALBSSLKeyAndCertificateStatus.SSL_CERTIFICATE_FINISHED;
    
        /// <summary>Encrypted private key corresponding to the private key
        /// (e.g.
        /// those generated by an HSM such as Thales nShield).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enckey_base64", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enckey_base64 { get; set; }
    
        /// <summary>Dynamic parameters needed for certificate management
        /// profile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dynamic_params", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBCustomParams> Dynamic_params { get; set; }
    
        /// <summary>Placeholder for description of property certificate of obj
        /// type SSLKeyAndCertificate field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("certificate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBSSLCertificate Certificate { get; set; } = new ALBSSLCertificate();
    
        /// <summary>States if the private key is base64 encoded.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key_base64", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Key_base64 { get; set; } = false;
    
        /// <summary>Enum options - SSL_CERTIFICATE_TYPE_VIRTUALSERVICE,
        /// SSL_CERTIFICATE_TYPE_SYSTEM, SSL_CERTIFICATE_TYPE_CA.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBSSLKeyAndCertificateType? Type { get; set; }
    
        /// <summary>Name of the encrypted private key (e.g.
        /// those generated by an HSM such as Thales nShield).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enckey_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enckey_name { get; set; }
    
        /// <summary>Configuration related to OCSP.</summary>
        [Newtonsoft.Json.JsonProperty("ocsp_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBOCSPConfig Ocsp_config { get; set; }
    
        /// <summary>Creator name.</summary>
        [Newtonsoft.Json.JsonProperty("created_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_by { get; set; }
    
        /// <summary>Placeholder for description of property key_params of obj
        /// type SSLKeyAndCertificate field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key_params", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBSSLKeyParams Key_params { get; set; }
    
        /// <summary>Passphrase used to encrypt the private key.</summary>
        [Newtonsoft.Json.JsonProperty("key_passphrase", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key_passphrase { get; set; }
    
        /// <summary>Private key.</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }
    
        /// <summary>States if the certificate is base64 encoded.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("certificate_base64", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Certificate_base64 { get; set; } = false;
    
        /// <summary>CA certificates in certificate chain.</summary>
        [Newtonsoft.Json.JsonProperty("ca_certs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBCertificateAuthority> Ca_certs { get; set; }
    
        /// <summary>It is a reference to an object of type
        /// HardwareSecurityModuleGroup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hardwaresecuritymodulegroup_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Hardwaresecuritymodulegroup_path { get; set; }
    
        /// <summary>Enables OCSP Stapling.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_ocsp_stapling", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_ocsp_stapling { get; set; } = false;
    
        /// <summary>Format of the Key/Certificate file.
        /// Enum options - SSL_PEM, SSL_PKCS12.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as SSL_PEM.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("format", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBSSLKeyAndCertificateFormat? Format { get; set; } = SDKGenerator.ALBSSLKeyAndCertificateFormat.SSL_PEM;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBServiceInstanceDetailPerStatus 
    {
        /// <summary>The type of load balancer instance status.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBServiceInstanceDetailPerStatusStatus? Status { get; set; }
    
        /// <summary>It means the total number of instances in this status type for the
        /// given transport node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("instance_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Instance_number { get; set; }
    
        /// <summary>The detailed information of the load balancer instance. This field
        /// will be only returned on realtime status API.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("instance_details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBServiceInstanceDetail> Instance_details { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for VHC, used in hierarchical API
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildVhc : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual VHC object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Vhc", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Vhc Vhc { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer WafPolicy object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWafPolicy : PolicyConfigResource
    {
        /// <summary>Parameters for tuning Application learning.</summary>
        [Newtonsoft.Json.JsonProperty("learning_params", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBAppLearningParams Learning_params { get; set; }
    
        /// <summary>Minimum confidence label required for auto rule updates.
        /// Enum options - CONFIDENCE_VERY_HIGH, CONFIDENCE_HIGH,
        /// CONFIDENCE_PROBABLE, CONFIDENCE_LOW, CONFIDENCE_NONE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as CONFIDENCE_VERY_HIGH.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("min_confidence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBWafPolicyMin_confidence? Min_confidence { get; set; } = SDKGenerator.ALBWafPolicyMin_confidence.CONFIDENCE_VERY_HIGH;
    
        /// <summary>WAF Rules are categorized in to groups based on their
        /// characterization.
        /// These groups are created by the user and will be enforced
        /// after the CRS groups.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("post_crs_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBWafRuleGroup> Post_crs_groups { get; set; }
    
        /// <summary>Enable Application Learning based rule updates on the WAF
        /// Profile.
        /// Rules will be programmed in dedicated WAF learning group.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_auto_rule_updates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_auto_rule_updates { get; set; } = true;
    
        /// <summary>WAF Rules are categorized in to groups based on their
        /// characterization.
        /// These groups are created by the user and will be  enforced
        /// before the CRS groups.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pre_crs_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBWafRuleGroup> Pre_crs_groups { get; set; }
    
        /// <summary>WAF Rules are categorized in to groups based on their
        /// characterization.
        /// These groups are system created with CRS groups.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("crs_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBWafRuleGroup> Crs_groups { get; set; }
    
        /// <summary>Allow Rules to overwrite the policy mode.
        /// This must be set if the policy mode is set to enforcement.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allow_mode_delegation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Allow_mode_delegation { get; set; } = true;
    
        /// <summary>Creator name.</summary>
        [Newtonsoft.Json.JsonProperty("created_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_by { get; set; }
    
        /// <summary>Application Specific Signatures.</summary>
        [Newtonsoft.Json.JsonProperty("application_signatures", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBWafApplicationSignatures Application_signatures { get; set; }
    
        /// <summary>WAF Ruleset paranoia  mode.
        /// This is used to select Rules based on the paranoia-level
        /// tag.
        /// Enum options - WAF_PARANOIA_LEVEL_LOW,
        /// WAF_PARANOIA_LEVEL_MEDIUM, WAF_PARANOIA_LEVEL_HIGH,
        /// WAF_PARANOIA_LEVEL_EXTREME.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as WAF_PARANOIA_LEVEL_LOW.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("paranoia_level", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBWafPolicyParanoia_level? Paranoia_level { get; set; } = SDKGenerator.ALBWafPolicyParanoia_level.WAF_PARANOIA_LEVEL_LOW;
    
        /// <summary>WAF Policy mode.
        /// This can be detection or enforcement.
        /// It can be overwritten by rules if allow_mode_delegation is
        /// set.
        /// Enum options - WAF_MODE_DETECTION_ONLY,
        /// WAF_MODE_ENFORCEMENT.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as WAF_MODE_DETECTION_ONLY.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBWafPolicyMode? Mode { get; set; } = SDKGenerator.ALBWafPolicyMode.WAF_MODE_DETECTION_ONLY;
    
        /// <summary>WAF Profile for WAF policy.
        /// It is a reference to an object of type WafProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("waf_profile_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Waf_profile_path { get; set; }
    
        /// <summary>Enable Application Learning for this WAF policy.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_app_learning", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_app_learning { get; set; } = false;
    
        /// <summary>The Positive Security Model.
        /// This is used to describe how the request or parts of the
        /// request should look like.
        /// It is executed in the Request Body Phase of Avi WAF.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("positive_security_model", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBWafPositiveSecurityModel Positive_security_model { get; set; }
    
        /// <summary>Configure thresholds for confidence labels.</summary>
        [Newtonsoft.Json.JsonProperty("confidence_override", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBAppLearningConfidenceOverride Confidence_override { get; set; }
    
        /// <summary>WAF core ruleset used for the CRS part of this Policy.
        /// It is a reference to an object of type WafCRS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("waf_crs_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Waf_crs_path { get; set; }
    
        /// <summary>WAF Policy failure mode.
        /// This can be 'Open' or 'Closed'.
        /// Enum options - WAF_FAILURE_MODE_OPEN,
        /// WAF_FAILURE_MODE_CLOSED.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as WAF_FAILURE_MODE_OPEN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("failure_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBWafPolicyFailure_mode? Failure_mode { get; set; } = SDKGenerator.ALBWafPolicyFailure_mode.WAF_FAILURE_MODE_OPEN;
    
    
    }
    
    /// <summary>Get the peer_code for each tunnel to paste on the remote end of the tunnel.
    /// Currently only stand-along/unmanaged edge is supported on the remote end of
    /// the tunnel.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VpnPeerCodes : L2VpnPeerConfigPerEnforcementPoint
    {
        /// <summary>List of peer codes per transport tunnel.</summary>
        [Newtonsoft.Json.JsonProperty("peer_codes", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<L2VpnTransportTunnelPeerCode> Peer_codes { get; set; } = new System.Collections.ObjectModel.Collection<L2VpnTransportTunnelPeerCode>();
    
    
    }
    
    /// <summary>Only support IP address or subnet. Its type can be of
    /// IPv4 or IPv6. It will be converted to subnet when netmask
    /// is specified(e.g., 192.168.1.3/24 =&gt; 192.168.1.0/24,
    /// 2008:12:12:12::2/64 =&gt; 2008:12:12:12::/64).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IpInfo 
    {
        /// <summary>The source IP address or subnet</summary>
        [Newtonsoft.Json.JsonProperty("src_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Src_ip { get; set; }
    
        /// <summary>The destination IP address or subnet</summary>
        [Newtonsoft.Json.JsonProperty("dst_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dst_ip { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RecommendedFeaturePermissionListResult : ListResult
    {
        /// <summary>List results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<RecommendedFeaturePermission> Results { get; set; } = new System.Collections.ObjectModel.Collection<RecommendedFeaturePermission>();
    
    
    }
    
    /// <summary>Advanced load balancer VSDataScriptSet object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBVSDataScriptSet : PolicyConfigResource
    {
        /// <summary>List of protocol parsers that could be referred by
        /// VSDataScriptSet objects.
        /// It is a reference to an object of type ProtocolParser.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol_parser_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Protocol_parser_paths { get; set; }
    
        /// <summary>DataScripts to execute.</summary>
        [Newtonsoft.Json.JsonProperty("datascript", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBVSDataScript> Datascript { get; set; }
    
        /// <summary>path of String Groups that could be referred by
        /// VSDataScriptSet objects.
        /// It is a reference to an object of type StringGroup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("string_group_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> String_group_paths { get; set; }
    
        /// <summary>The Rate Limit definitions needed for this DataScript.
        /// The name is composed of the Virtual Service name and the
        /// DataScript name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rate_limiters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBRateLimiter> Rate_limiters { get; set; }
    
        /// <summary>path of IP Groups that could be referred by VSDataScriptSet
        /// objects.
        /// It is a reference to an object of type IpAddrGroup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipgroup_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Ipgroup_paths { get; set; }
    
        /// <summary>path of pool groups that could be referred by
        /// VSDataScriptSet objects.
        /// It is a reference to an object of type PoolGroup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_group_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Pool_group_paths { get; set; }
    
        /// <summary>path of pools that could be referred by VSDataScriptSet
        /// objects.
        /// It is a reference to an object of type Pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Pool_paths { get; set; }
    
        /// <summary>Creator name.</summary>
        [Newtonsoft.Json.JsonProperty("created_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_by { get; set; }
    
    
    }
    
    /// <summary>Multicast routing configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyTier1MulticastConfig : PolicyConfigResource
    {
        /// <summary>Enable/disable Multicast Configuration. Whenever service router needs to be added/deleted from tier1, user needs to disable multicast first.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = false;
    
    
    }
    
    /// <summary>Route advertisement rules and filtering</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RouteAdvertisementRule 
    {
        /// <summary>Action to advertise filtered routes to the connected Tier0 gateway.
        /// PERMIT: Enables the advertisment
        /// DENY: Disables the advertisement
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RouteAdvertisementRuleAction Action { get; set; } = SDKGenerator.RouteAdvertisementRuleAction.PERMIT;
    
        /// <summary>Network CIDRs to be routed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Subnets { get; set; }
    
        /// <summary>Prefix operator to filter subnets.
        /// GE prefix operator filters all the routes with prefix length greater
        /// than or equal to the subnets configured.
        /// EQ prefix operator filter all the routes with prefix length equal to
        /// the subnets configured.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("prefix_operator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RouteAdvertisementRulePrefix_operator? Prefix_operator { get; set; } = SDKGenerator.RouteAdvertisementRulePrefix_operator.GE;
    
        /// <summary>Display name should be unique.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>Enable different types of route advertisements.
        /// When not specified, routes to IPSec VPN local-endpoint subnets
        /// (TIER1_IPSEC_LOCAL_ENDPOINT) are automatically advertised.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("route_advertisement_types", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Route_advertisement_types> Route_advertisement_types { get; set; }
    
    
    }
    
    /// <summary>Tier1 gateway state</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier1GatewayState 
    {
        /// <summary>Detailed realized status information for Tier1
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tier1_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LogicalRouterStatus Tier1_status { get; set; }
    
        /// <summary>IPv6 DAD status for interfaces configured on Tier1
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipv6_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IPv6Status> Ipv6_status { get; set; }
    
        /// <summary>Detailed realized state information for Tier1
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tier1_state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LogicalRouterState Tier1_state { get; set; }
    
        /// <summary>String Path of the enforcement point.
        /// When not specified, routes from all enforcement-points are returned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enforcement_point_path { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBHTTPPolicySet, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBHTTPPolicySet : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBHTTPPolicySet object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBHTTPPolicySet", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBHTTPPolicySet ALBHTTPPolicySet { get; set; }
    
    
    }
    
    /// <summary>Paged collection of LiveTraceConfig entities</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LiveTraceConfigListResult : ListResult
    {
        /// <summary>LiveTraceConfig list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<LiveTraceConfig> Results { get; set; } = new System.Collections.ObjectModel.Collection<LiveTraceConfig>();
    
    
    }
    
    /// <summary>L3Vpn Statistics Per Enforcement Point.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("IPSecVpnSessionStatistics", typeof(IPSecVpnSessionStatistics))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L3VpnStatisticsPerEnforcementPoint 
    {
        /// <summary>Policy Path referencing the enforcement point wehere the statistics are fetched.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enforcement_point_path { get; set; }
    
    
    }
    
    /// <summary>Aggregate of LBNodeUsageSummary across Enforcement Points.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregateLBNodeUsageSummary : AggregatePolicyRuntimeInfo
    {
        /// <summary>LBNodeUsageSummary list results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBNodeUsageSummary> Results { get; set; }
    
    
    }
    
    /// <summary>Evpn Tunnel Endpoint Configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EvpnTunnelEndpointConfig : PolicyConfigResource
    {
        /// <summary>MTU</summary>
        [Newtonsoft.Json.JsonProperty("mtu", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(64D, 9100D)]
        public long? Mtu { get; set; }
    
        /// <summary>edge path</summary>
        [Newtonsoft.Json.JsonProperty("edge_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Edge_path { get; set; }
    
        /// <summary>local addresses</summary>
        [Newtonsoft.Json.JsonProperty("local_addresses", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Local_addresses { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>Describes the configuration of a view to be displayed on the dashboard.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class View : ManagedResource
    {
        /// <summary>Comma separated list of roles to which the shared view is visible. Allows user to specify the visibility of a shared view to the specified roles. User defined roles can also be specified in the list. The roles can be obtained via GET /api/v1/aaa/roles. Please visit API documentation for details about roles.</summary>
        [Newtonsoft.Json.JsonProperty("include_roles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Include_roles { get; set; }
    
        /// <summary>Title of the widget.</summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string Display_name { get; set; }
    
        /// <summary>Comma separated list of roles to which the shared view is not visible. Allows user to prevent the visibility of a shared view to the specified roles. User defined roles can also be specified in the list. The roles can be obtained via GET /api/v1/aaa/roles. Please visit API documentation for details about roles. If include_roles is specified then exclude_roles cannot be specified.</summary>
        [Newtonsoft.Json.JsonProperty("exclude_roles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Exclude_roles { get; set; }
    
        /// <summary>Determines placement of view relative to other views. The lower the weight, the higher it is in the placement order.</summary>
        [Newtonsoft.Json.JsonProperty("weight", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Weight { get; set; } = 10000L;
    
        /// <summary>Array of widgets that are part of the view.</summary>
        [Newtonsoft.Json.JsonProperty("widgets", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<WidgetItem> Widgets { get; set; } = new System.Collections.ObjectModel.Collection<WidgetItem>();
    
        /// <summary>Defaults to false. Set to true to publish the view to other users. The widgets of a shared view are visible to other users.</summary>
        [Newtonsoft.Json.JsonProperty("shared", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Shared { get; set; } = false;
    
    
    }
    
    /// <summary>Traffic counters for IPSec VPN session.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVPNTrafficCounters 
    {
        /// <summary>Total number of packets sent.</summary>
        [Newtonsoft.Json.JsonProperty("packets_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_out { get; set; }
    
        /// <summary>Total number of outgoing packets dropped on outbound security association.</summary>
        [Newtonsoft.Json.JsonProperty("dropped_packets_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dropped_packets_out { get; set; }
    
        /// <summary>Total number of bytes recevied.</summary>
        [Newtonsoft.Json.JsonProperty("bytes_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_in { get; set; }
    
        /// <summary>Total number of bytes sent.</summary>
        [Newtonsoft.Json.JsonProperty("bytes_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_out { get; set; }
    
        /// <summary>Total number of incoming packets dropped on inbound security association.</summary>
        [Newtonsoft.Json.JsonProperty("dropped_packets_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dropped_packets_in { get; set; }
    
        /// <summary>Total number of packets received.</summary>
        [Newtonsoft.Json.JsonProperty("packets_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_in { get; set; }
    
    
    }
    
    /// <summary>WebhookApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWebhookApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of Webhook
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBWebhook> Results { get; set; }
    
    
    }
    
    /// <summary>A link to a related resource</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ResourceLink 
    {
        /// <summary>Optional action</summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Action { get; set; }
    
        /// <summary>Link to resource</summary>
        [Newtonsoft.Json.JsonProperty("href", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Href { get; set; }
    
        /// <summary>Custom relation type (follows RFC 5988 where appropriate definitions exist)</summary>
        [Newtonsoft.Json.JsonProperty("rel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rel { get; set; }
    
    
    }
    
    /// <summary>New Role</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class NewRole 
    {
        /// <summary>New role name</summary>
        [Newtonsoft.Json.JsonProperty("new_role_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string New_role_name { get; set; }
    
        /// <summary>New role description</summary>
        [Newtonsoft.Json.JsonProperty("new_role_description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string New_role_description { get; set; }
    
        /// <summary>New role id</summary>
        [Newtonsoft.Json.JsonProperty("new_role_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string New_role_id { get; set; }
    
    
    }
    
    /// <summary>Paged collection of segment security profiles</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentSecurityProfileListResult : ListResult
    {
        /// <summary>Segment Security profile list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SegmentSecurityProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<SegmentSecurityProfile>();
    
    
    }
    
    /// <summary>Child wrapper object for OspfAreaConfig used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildOspfAreaConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains actual OspfAreaConfig.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("OspfAreaConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OspfAreaConfig OspfAreaConfig { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsAAAARdata object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsAAAARdata 
    {
        /// <summary>IPv6 address for FQDN.</summary>
        [Newtonsoft.Json.JsonProperty("ip6_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBIpAddr Ip6_address { get; set; } = new ALBIpAddr();
    
    
    }
    
    /// <summary>Advanced load balancer WafExcludeListEntry object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWafExcludeListEntry 
    {
        /// <summary>URI Path to exclude for WAF rules.</summary>
        [Newtonsoft.Json.JsonProperty("uri_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uri_path { get; set; }
    
        /// <summary>Free-text comment about this exclusion.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Criteria for URI matching.</summary>
        [Newtonsoft.Json.JsonProperty("uri_match_criteria", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBWafExclusionType Uri_match_criteria { get; set; }
    
        /// <summary>Criteria for match_element matching.</summary>
        [Newtonsoft.Json.JsonProperty("match_element_criteria", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBWafExclusionType Match_element_criteria { get; set; }
    
        /// <summary>Client IP Subnet to exclude for WAF rules.</summary>
        [Newtonsoft.Json.JsonProperty("client_subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddrPrefix Client_subnet { get; set; }
    
        /// <summary>The match_element can be 'ARGS xxx', 'ARGS_GET xxx',
        /// 'ARGS_POST xxx', 'ARGS_NAMES xxx', 'FILES xxx',
        /// 'QUERY_STRING', 'REQUEST_BASENAME', 'REQUEST_BODY',
        /// 'REQUEST_URI', 'REQUEST_URI_RAW', 'REQUEST_COOKIES xxx',
        /// 'REQUEST_HEADERS xxx' or 'RESPONSE_HEADERS xxx'.
        /// These match_elements in the HTTP Transaction (if present)
        /// will be excluded when executing WAF Rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_element", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Match_element { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer NetworkFilter object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBNetworkFilter 
    {
        /// <summary>server_filter of NetworkFilter.</summary>
        [Newtonsoft.Json.JsonProperty("server_filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Server_filter { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBWafProfile, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBWafProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBWafProfile object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBWafProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBWafProfile ALBWafProfile { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBPoolGroup, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBPoolGroup : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBPoolGroup object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBPoolGroup", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBPoolGroup ALBPoolGroup { get; set; }
    
    
    }
    
    /// <summary>Contains information required to connect to enforcement point.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("NSXVConnectionInfo", typeof(NSXVConnectionInfo))]
    [JsonInheritanceAttribute("NSXTConnectionInfo", typeof(NSXTConnectionInfo))]
    [JsonInheritanceAttribute("AviConnectionInfo", typeof(AviConnectionInfo))]
    [JsonInheritanceAttribute("CvxConnectionInfo", typeof(CvxConnectionInfo))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EnforcementPointConnectionInfo 
    {
        /// <summary>Value of this property could be Hostname or IP. For instance:
        /// - On an NSX-T MP running on default port, the value could be "10.192.1.1"
        /// - On an NSX-T MP running on custom port, the value could be "192.168.1.1:32789"
        /// - On an NSX-T MP in VMC deployments, the value could be "192.168.1.1:5480/nsxapi"
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Enforcement_point_address { get; set; }
    
    
    }
    
    /// <summary>IPSec VPN Session Status Per Enforcement Point.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("IPSecVpnSessionStatusNsxT", typeof(IPSecVpnSessionStatusNsxT))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnSessionStatusPerEP : PolicyRuntimeInfoPerEP
    {
    
    }
    
    /// <summary>Child wrapper object for domain, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildDomain : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual domain object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Domain", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Domain Domain { get; set; }
    
    
    }
    
    /// <summary>This action is used to delete header fields of HTTP request messages at
    /// HTTP_REQUEST_REWRITE phase. One action can be used to delete all headers
    /// with same header name. To delete headers with different header names,
    /// multiple actions must be defined.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBHttpRequestHeaderDeleteAction : LBRuleAction
    {
        /// <summary>Name of a header field of HTTP request message.</summary>
        [Newtonsoft.Json.JsonProperty("header_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Header_name { get; set; }
    
    
    }
    
    /// <summary>NSX-T Enforced Status.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EnforcedStatusNsxT 
    {
        /// <summary>Enforced Realized Status.</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EnforcedStatusNsxTStatus? Status { get; set; }
    
        /// <summary>Status Message conveying hints depending on the status value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status_message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Status_message { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DistributedFloodProtectionProfile : FloodProtectionProfile
    {
        /// <summary>If set to true, rst spoofing will be enabled. Flag is used only for distributed firewall profiles.</summary>
        [Newtonsoft.Json.JsonProperty("enable_rst_spoofing", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_rst_spoofing { get; set; } = false;
    
        /// <summary>If set to true, sync cache will be enabled. Flag is used only for distributed firewall profiles.</summary>
        [Newtonsoft.Json.JsonProperty("enable_syncache", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_syncache { get; set; } = false;
    
    
    }
    
    /// <summary>Some applications maintain state and require all relevant connections
    /// to be sent to the same server as the application state is not
    /// synchronized among servers. Persistence is enabled on a PolicyLbVirtualServer
    /// by binding a persistence profile to it.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CustomPolicyLbPersistenceProfile : PolicyLbPersistenceProfile
    {
        /// <summary>Persistence shared setting indicates that all PolicyLbVirtualServers
        /// that consume this PolicyLbPersistenceProfile should share the same
        /// persistence mechanism when enabled.  Meaning, persistence entries of
        /// a client accessing one virtual server will also affect the same
        /// client's connections to a different virtual server. For example, say
        /// there are two virtual servers vip-ip1:80 and vip-ip1:8080 bound to
        /// the same Group g1 consisting of two servers (s11:80 and s12:80). By
        /// default, each virtual server will have its own persistence table or
        /// cookie. So, in the earlier example, there will be two tables
        /// (vip-ip1:80, p1) and (vip-ip1:8080, p1) or cookies. So, if a client
        /// connects to vip1:80 and later connects to vip1:8080, the second
        /// connection may be sent to a different server than the first.  When
        /// persistence_shared is enabled, then the second connection will always
        /// connect to the same server as the original connection. For COOKIE
        /// persistence type, the same cookie will be shared by multiple virtual
        /// servers. For SOURCE_IP persistenct type, the persistence table will
        /// be shared across virtual servers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("persistence_shared", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Persistence_shared { get; set; } = false;
    
        /// <summary>This field indicates the persistence method used for the
        /// PolicyLbVirtualServer.
        /// - COOKIE persistence allows related client connections, identified by
        /// the same cookie in HTTP requests [Refer to HTTP Cookie for details
        /// on HTTP cookies], to be redirected to the same server. Load
        /// balancer does not maintain any persistence table for cookie
        /// persistence. Instead, it encodes the necessary information in the
        /// HTTP cookie value sent to client and relies on the client to store
        /// it and send it back in subsequent related HTTP requests. Hence
        /// there is no limit on the number of cookie persistence entries that
        /// can be supported.
        /// - SOURCE_IP persistence ensures all connections from a client
        /// (identified by IP address) are sent to the same backend server for a
        /// specified period.
        /// - This object is not required and without creation of this object the
        /// virtual server persistence is disabled by default
        /// </summary>
        [Newtonsoft.Json.JsonProperty("persistence", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CustomPolicyLbPersistenceProfilePersistence Persistence { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DhcpLeases 
    {
        /// <summary>timestamp of the lease info</summary>
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Timestamp { get; set; }
    
        /// <summary>The lease info list of the server</summary>
        [Newtonsoft.Json.JsonProperty("leases", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(65535)]
        public System.Collections.Generic.ICollection<DhcpLeasePerIP> Leases { get; set; }
    
        /// <summary>dhcp server uuid</summary>
        [Newtonsoft.Json.JsonProperty("dhcp_server_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dhcp_server_id { get; set; }
    
    
    }
    
    /// <summary>It represents status of Service Insertion for North-South and East-West context types.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicySIStatusConfiguration : PolicyConfigResource
    {
        /// <summary>If set to true, service insertion for east-west traffic is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("east_west_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? East_west_enabled { get; set; } = false;
    
        /// <summary>If set to true, service insertion for north-south traffic is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("north_south_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? North_south_enabled { get; set; } = false;
    
    
    }
    
    /// <summary>L2VPN transport tunnel peer code.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VPNSessionTransportTunnelPeerCode 
    {
        /// <summary>Peer code represents a base64 encoded string which has
        /// all the configuration for tunnel. E.g local/peer ips and
        /// protocol, encryption algorithm, etc. Peer code also contains
        /// PSK; be careful when sharing or storing it.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("peer_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Peer_code { get; set; }
    
        /// <summary>Policy Path referencing the transport tunnel.</summary>
        [Newtonsoft.Json.JsonProperty("transport_tunnel_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_tunnel_path { get; set; }
    
    
    }
    
    /// <summary>Represents external ID expressions in the form of an array, to support addition of objects like virtual interfaces, virtual machines, CloudNativeServiceInstance PhysicalServer to a group.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ExternalIDExpression : Expression
    {
        /// <summary>This array can consist of one or more external IDs for the specified member type.</summary>
        [Newtonsoft.Json.JsonProperty("external_ids", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<string> External_ids { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>External ID member type</summary>
        [Newtonsoft.Json.JsonProperty("member_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ExternalIDExpressionMember_type Member_type { get; set; }
    
    
    }
    
    /// <summary>A shaper that specifies egress rate properties in Mb/s</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EgressRateLimiter : QoSBaseRateLimiter
    {
        /// <summary>Peak bandwidth in Mb/s</summary>
        [Newtonsoft.Json.JsonProperty("peak_bandwidth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, int.MaxValue)]
        public long? Peak_bandwidth { get; set; } = 0L;
    
        /// <summary>Average bandwidth in Mb/s</summary>
        [Newtonsoft.Json.JsonProperty("average_bandwidth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, int.MaxValue)]
        public long? Average_bandwidth { get; set; } = 0L;
    
        /// <summary>Burst size in bytes</summary>
        [Newtonsoft.Json.JsonProperty("burst_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, int.MaxValue)]
        public long? Burst_size { get; set; } = 0L;
    
    
    }
    
    /// <summary>Advanced load balancer HardwareSecurityModuleGroup object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHardwareSecurityModuleGroup : PolicyConfigResource
    {
        /// <summary>Hardware Security Module configuration.</summary>
        [Newtonsoft.Json.JsonProperty("hsm", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBHardwareSecurityModule Hsm { get; set; } = new ALBHardwareSecurityModule();
    
    
    }
    
    /// <summary>This condition is used to match HTTP request messages by HTTP header
    /// fields. HTTP header fields are components of the header section of HTTP
    /// request and response messages. They define the operating parameters of an
    /// HTTP transaction. For example, Cookie, Authorization, User-Agent, etc. One
    /// condition can be used to match one header field, to match multiple header
    /// fields, multiple conditions must be specified.
    /// The match_type field defines how header_value field is used to match HTTP
    /// requests. The header_name field does not support match types.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBHttpRequestHeaderCondition : LBRuleCondition
    {
        /// <summary>Value of HTTP header</summary>
        [Newtonsoft.Json.JsonProperty("header_value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Header_value { get; set; }
    
        /// <summary>If true, case is significant when comparing HTTP header value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("case_sensitive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Case_sensitive { get; set; } = true;
    
        /// <summary>Match type of HTTP header value</summary>
        [Newtonsoft.Json.JsonProperty("match_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBHttpRequestHeaderConditionMatch_type? Match_type { get; set; } = SDKGenerator.LBHttpRequestHeaderConditionMatch_type.REGEX;
    
        /// <summary>Name of HTTP header</summary>
        [Newtonsoft.Json.JsonProperty("header_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Header_name { get; set; } = "Host";
    
    
    }
    
    /// <summary>Child wrapper object for DnsSecurityProfile, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildDnsSecurityProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual DnsSecurityProfile object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("DnsSecurityProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public DnsSecurityProfile DnsSecurityProfile { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for L3VpnContext, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildL3VpnContext : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual L3VpnContext object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("L3VpnContext", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public L3VpnContext L3VpnContext { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for DomainDeploymentMap, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildDomainDeploymentMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual DomainDeploymentMap object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("DomainDeploymentMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public DomainDeploymentMap DomainDeploymentMap { get; set; }
    
    
    }
    
    /// <summary>Represents a reference to ChildPolicyConfigResource in the hierarchical API. resource_type, id and target_type are mandatory fields.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildResourceReference : ChildPolicyConfigResource
    {
        /// <summary>subtree for this type within policy tree containing nested elements.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("children", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ChildPolicyConfigResource> Children { get; set; }
    
        /// <summary>The target type of this reference</summary>
        [Newtonsoft.Json.JsonProperty("target_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Target_type { get; set; }
    
    
    }
    
    /// <summary>The Event is the criterion or criteria applied to the source and,
    /// when met, prompt Policy to run the action.
    /// All Reaction Events are constructed with reference to
    /// the object, the "source", that is logically deemed to be the
    /// object upon which the Event in question initially occurred upon.
    /// Some example events include:
    /// - New object was created.
    /// - Change in realization state.
    /// - Specific API is called.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Event 
    {
        /// <summary>Source that is logically deemed to be the "object" upon which the Event
        /// in question initially occurred upon.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Source Source { get; set; } = new Source();
    
        /// <summary>Criteria applied to the source and, if satisfied, would trigger the
        /// action. Criteria is composed of criterions. In order for the Criteria
        /// to be met, only one of the criterion must be fulfilled (implicit OR).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("criteria", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Criterion> Criteria { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for IPSecVpnSession, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIPSecVpnSession : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual IPSecVpnSession object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IPSecVpnSession", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IPSecVpnSession IPSecVpnSession { get; set; }
    
    
    }
    
    /// <summary>Contains ordered list of forwarding rules that determine when to
    /// forward traffic to / from the underlay for accessing cloud native services.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ForwardingPolicy : Policy
    {
        /// <summary>Rules that are a part of this ForwardingPolicy</summary>
        [Newtonsoft.Json.JsonProperty("rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ForwardingRule> Rules { get; set; }
    
    
    }
    
    /// <summary>Base Discovery Profile Binding Map</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DiscoveryProfileBindingMap : PolicyConfigResource
    {
    
    }
    
    /// <summary>Child wrapper for ALBAnalyticsProfile, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBAnalyticsProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBAnalyticsProfile object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBAnalyticsProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBAnalyticsProfile ALBAnalyticsProfile { get; set; }
    
    
    }
    
    /// <summary>A profile holding TCP, UDP and ICMP and other protcol connection limits.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("GatewayFloodProtectionProfile", typeof(GatewayFloodProtectionProfile))]
    [JsonInheritanceAttribute("DistributedFloodProtectionProfile", typeof(DistributedFloodProtectionProfile))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FloodProtectionProfile : PolicyConfigResource
    {
        /// <summary>If this field is empty, firewall will not set a limit to active ICMP connections.</summary>
        [Newtonsoft.Json.JsonProperty("icmp_active_flow_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 1000000D)]
        public long? Icmp_active_flow_limit { get; set; }
    
        /// <summary>If this field is empty, firewall will not set a limit to half open TCP connections.</summary>
        [Newtonsoft.Json.JsonProperty("tcp_half_open_conn_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 1000000D)]
        public long? Tcp_half_open_conn_limit { get; set; }
    
        /// <summary>If this field is empty, firewall will not set a limit to active UDP connections.</summary>
        [Newtonsoft.Json.JsonProperty("udp_active_flow_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 1000000D)]
        public long? Udp_active_flow_limit { get; set; }
    
        /// <summary>If this field is empty, firewall will not set a limit to other active connections. besides UDP, ICMP and half open TCP connections.</summary>
        [Newtonsoft.Json.JsonProperty("other_active_conn_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 1000000D)]
        public long? Other_active_conn_limit { get; set; }
    
    
    }
    
    /// <summary>AuthProfileApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAuthProfileApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of AuthProfile
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBAuthProfile> Results { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RaDNSConfig 
    {
        /// <summary>Lifetime of Domain names in milliseconds</summary>
        [Newtonsoft.Json.JsonProperty("domain_name_lifetime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? Domain_name_lifetime { get; set; } = 1800000L;
    
        /// <summary>DNS server.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dns_server", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(8)]
        public System.Collections.Generic.ICollection<string> Dns_server { get; set; }
    
        /// <summary>Domain name in RA message.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("domain_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(8)]
        public System.Collections.Generic.ICollection<string> Domain_name { get; set; }
    
        /// <summary>Lifetime of DNS server in milliseconds</summary>
        [Newtonsoft.Json.JsonProperty("dns_server_lifetime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? Dns_server_lifetime { get; set; } = 1800000L;
    
    
    }
    
    /// <summary>Configuration field to hold BGP restart timers</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BgpGracefulRestartTimer 
    {
        /// <summary>Maximum time taken (in seconds) for a BGP session to be established after a restart.
        /// This can be used to speed up routing convergence by its peer in case the BGP speaker
        /// does not come back up after a restart. If the session is not re-established within this
        /// timer,  the receiving speaker will delete all the stale routes from that peer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("restart_timer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 3600D)]
        public long? Restart_timer { get; set; } = 180L;
    
        /// <summary>Maximum time (in seconds) before stale routes are removed from the
        /// RIB (Routing Information Base) when BGP restarts.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stale_route_timer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 3600D)]
        public long? Stale_route_timer { get; set; } = 600L;
    
    
    }
    
    /// <summary>Child wrapper object for PolicyDnsForwarder, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyDnsForwarder : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyDnsForwarder object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyDnsForwarder", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyDnsForwarder PolicyDnsForwarder { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of gateway policies</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GatewayPolicyListResult : PolicyListResult
    {
        /// <summary>GatewayPolicy list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<GatewayPolicy> Results { get; set; } = new System.Collections.ObjectModel.Collection<GatewayPolicy>();
    
    
    }
    
    /// <summary>L2VPN Session Data represents meta data necessary to create
    /// the L2VPN Session. It is represented by an array of peer code
    /// for each tunnel.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VPNSessionData 
    {
        /// <summary>Enable to extend all the associated segments.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
        /// <summary>List of L2VPN transport tunnel data.</summary>
        [Newtonsoft.Json.JsonProperty("transport_tunnels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<L2VPNSessionTransportTunnelData> Transport_tunnels { get; set; }
    
        /// <summary>Defaults to id if not set.</summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string Display_name { get; set; }
    
        /// <summary>Description of L2VPN Session</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Description { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsAttacks object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsAttacks 
    {
        /// <summary>Mode of dealing with the attacks - perform detection only,
        /// or detect and mitigate the attacks.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("attacks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDnsAttack> Attacks { get; set; }
    
        /// <summary>Mode of dealing with the attacks - perform detection only,
        /// or detect and mitigate the attacks.
        /// Enum options - DETECTION, MITIGATION.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oper_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBDnsAttacksOper_mode? Oper_mode { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DataSourceParameters 
    {
        /// <summary>The data source, either realtime or cached. If not provided, cached data is returned.</summary>
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DataSourceParametersSource? Source { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBPool, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBPool : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBPool object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBPool", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBPool ALBPool { get; set; }
    
    
    }
    
    /// <summary>List of effective ip address along with site id</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EffectiveIPInfo 
    {
        [Newtonsoft.Json.JsonProperty("effective_ips", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Effective_ips { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Id of the site to which the effective IPs belong to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("site_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Site_id { get; set; }
    
    
    }
    
    /// <summary>Collection of only Byod SI objects</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ByodPolicyServiceInstanceListResult : ListResult
    {
        /// <summary>Byod Service instance list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ByodPolicyServiceInstance> Results { get; set; } = new System.Collections.ObjectModel.Collection<ByodPolicyServiceInstance>();
    
    
    }
    
    /// <summary>Advanced load balancer WafPSMRule object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWafPSMRule 
    {
        /// <summary>Rule index, this is used to determine the order of the
        /// rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public long Index { get; set; }
    
        /// <summary>Enable or disable this rule.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable { get; set; } = true;
    
        /// <summary>Free-text comment about this rule.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>A regular expression which describes the expected value.</summary>
        [Newtonsoft.Json.JsonProperty("match_value_pattern", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Match_value_pattern { get; set; }
    
        /// <summary>The match elements, for example ARGS id or ARGS|!ARGS
        /// password.
        /// Maximum of 64 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_elements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBWafPSMMatchElement> Match_elements { get; set; }
    
        /// <summary>WAF Rule mode.
        /// This can be detection or enforcement.
        /// If this is not set, the Policy mode is used.
        /// This only takes effect if the policy allows delegation.
        /// Enum options - WAF_MODE_DETECTION_ONLY,
        /// WAF_MODE_ENFORCEMENT.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBWafPSMRuleMode? Mode { get; set; }
    
        /// <summary>The field match_value_pattern regular expression is case
        /// sensitive.
        /// Enum options - SENSITIVE, INSENSITIVE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as INSENSITIVE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_case", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBWafPSMRuleMatch_case? Match_case { get; set; } = SDKGenerator.ALBWafPSMRuleMatch_case.INSENSITIVE;
    
        /// <summary>The maximum allowed length of the match_value.
        /// If this is not set, the length will not be checked.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_value_max_length", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Match_value_max_length { get; set; }
    
        /// <summary>WAF Ruleset paranoia mode.
        /// This is used to select Rules based on the paranoia-level.
        /// Enum options - WAF_PARANOIA_LEVEL_LOW,
        /// WAF_PARANOIA_LEVEL_MEDIUM, WAF_PARANOIA_LEVEL_HIGH,
        /// WAF_PARANOIA_LEVEL_EXTREME.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as WAF_PARANOIA_LEVEL_LOW.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("paranoia_level", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBWafPSMRuleParanoia_level? Paranoia_level { get; set; } = SDKGenerator.ALBWafPSMRuleParanoia_level.WAF_PARANOIA_LEVEL_LOW;
    
        /// <summary>Id field which is used for log and metric generation.
        /// This id must be unique for all rules in this group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rule_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Rule_id { get; set; }
    
        /// <summary>Name of the rule.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
    
    }
    
    /// <summary>Remote server</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RemoteServerFingerprintRequest 
    {
        /// <summary>Server port</summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long? Port { get; set; } = 22L;
    
        /// <summary>Remote server hostname or IP address</summary>
        [Newtonsoft.Json.JsonProperty("server", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Server { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer LocationHdrMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBLocationHdrMatch 
    {
        /// <summary>Case sensitivity to use for the match.
        /// Enum options - SENSITIVE, INSENSITIVE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as INSENSITIVE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_case", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBLocationHdrMatchMatch_case? Match_case { get; set; } = SDKGenerator.ALBLocationHdrMatchMatch_case.INSENSITIVE;
    
        /// <summary>String value(s) in the location header.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Value { get; set; }
    
        /// <summary>Criterion to use for matching location header value in the
        /// HTTP response.
        /// Enum options - HDR_EXISTS, HDR_DOES_NOT_EXIST,
        /// HDR_BEGINS_WITH, HDR_DOES_NOT_BEGIN_WITH, HDR_CONTAINS,
        /// HDR_DOES_NOT_CONTAIN, HDR_ENDS_WITH, HDR_DOES_NOT_END_WITH,
        /// HDR_EQUALS, HDR_DOES_NOT_EQUAL.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBLocationHdrMatchMatch_criteria Match_criteria { get; set; }
    
    
    }
    
    /// <summary>Paged collection of Segments</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentListResult : ListResult
    {
        /// <summary>Segment list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Segment> Results { get; set; } = new System.Collections.ObjectModel.Collection<Segment>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GatewayRouteCsvRecord : CsvRecord
    {
        /// <summary>Logical router component(Service Router/Distributed Router) id</summary>
        [Newtonsoft.Json.JsonProperty("lr_component_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lr_component_id { get; set; }
    
        /// <summary>The IP of the next hop</summary>
        [Newtonsoft.Json.JsonProperty("next_hop", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Next_hop { get; set; }
    
        /// <summary>Logical router component(Service Router/Distributed Router) type</summary>
        [Newtonsoft.Json.JsonProperty("lr_component_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lr_component_type { get; set; }
    
        /// <summary>CIDR network address</summary>
        [Newtonsoft.Json.JsonProperty("network", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Network { get; set; }
    
        /// <summary>Route type (USER, CONNECTED, NSX_INTERNAL,..)</summary>
        [Newtonsoft.Json.JsonProperty("route_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Route_type { get; set; }
    
        /// <summary>The policy path of the interface which is used as the next hop</summary>
        [Newtonsoft.Json.JsonProperty("interface", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Interface { get; set; }
    
        /// <summary>Edge node policy path.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Edge_path { get; set; }
    
        /// <summary>The admin distance of the next hop</summary>
        [Newtonsoft.Json.JsonProperty("admin_distance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Admin_distance { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class InitiateClusterRestoreRequest 
    {
        /// <summary>Timestamp of the backed-up configuration from which
        /// the appliance will be restored
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Timestamp { get; set; }
    
        /// <summary>Unique id of the backed-up configuration from which
        /// the appliance will be restored
        /// </summary>
        [Newtonsoft.Json.JsonProperty("node_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Node_id { get; set; }
    
        /// <summary>IP address or FQDN of the node from which the backup was taken</summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ip_address { get; set; }
    
    
    }
    
    /// <summary>Represents the operator AND.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsProfileConjunctionOperator : IdsProfileCriteria
    {
        /// <summary>IDS Profile Filter Condition</summary>
        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IdsProfileConjunctionOperatorOperator Operator { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer PoolGroupDeploymentPolicy object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBPoolGroupDeploymentPolicy : PolicyConfigResource
    {
        /// <summary>Target traffic ratio before pool is made production.
        /// Allowed values are 1-100.
        /// Unit is RATIO.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 100.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("target_test_traffic_ratio", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 100D)]
        public long? Target_test_traffic_ratio { get; set; } = 100L;
    
        /// <summary>Duration of evaluation period for automatic deployment.
        /// Allowed values are 60-86400.
        /// Unit is SEC.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 300.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("evaluation_duration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(60D, 86400D)]
        public long? Evaluation_duration { get; set; } = 300L;
    
        /// <summary>Ratio of the traffic that is sent to the pool under test.
        /// test ratio of 100 means blue green.
        /// Allowed values are 1-100.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 100.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("test_traffic_ratio_rampup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 100D)]
        public long? Test_traffic_ratio_rampup { get; set; } = 100L;
    
        /// <summary>Placeholder for description of property rules of obj type
        /// PoolGroupDeploymentPolicy field type str  type array.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBPGDeploymentRule> Rules { get; set; }
    
        /// <summary>It will automatically disable old production pools once
        /// there is a new production candidate.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("auto_disable_old_prod_pools", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Auto_disable_old_prod_pools { get; set; } = true;
    
        /// <summary>deployment scheme.
        /// Enum options - BLUE_GREEN, CANARY.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as BLUE_GREEN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scheme", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBPoolGroupDeploymentPolicyScheme? Scheme { get; set; } = SDKGenerator.ALBPoolGroupDeploymentPolicyScheme.BLUE_GREEN;
    
        /// <summary>Webhook configured with URL that Avi controller will pass
        /// back information about pool group, old and new pool
        /// information and current deployment rule results.
        /// It is a reference to an object of type Webhook.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("webhook_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Webhook_path { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GroupMemberTypeListResult 
    {
        /// <summary>Collection of member types for the given Group</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Results> Results { get; set; } = new System.Collections.ObjectModel.Collection<Results>();
    
        /// <summary>Count of the member types in the results array</summary>
        [Newtonsoft.Json.JsonProperty("result_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Result_count { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for PolicyLbPoolAccess, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyLbPoolAccess : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyLbPoolAccess object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyLbPoolAccess", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyLbPoolAccess PolicyLbPoolAccess { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer OCSPConfig object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBOCSPConfig 
    {
        /// <summary>Describes the type of action to take with the Responder
        /// URLs.
        /// Enum options - OCSP_RESPONDER_URL_FAILOVER,
        /// OCSP_RESPONDER_URL_OVERRIDE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// OCSP_RESPONDER_URL_FAILOVER.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("url_action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBOCSPConfigUrl_action? Url_action { get; set; } = SDKGenerator.ALBOCSPConfigUrl_action.OCSP_RESPONDER_URL_FAILOVER;
    
        /// <summary>Interval between the OCSP queries.
        /// Allowed values are 60-31536000.
        /// Unit is SEC.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 86400.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ocsp_req_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(60D, 31536000D)]
        public long? Ocsp_req_interval { get; set; } = 86400L;
    
        /// <summary>Time in seconds that the system waits for a reply from the
        /// OCSP responder before dropping the connection.
        /// Unit is SEC.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ocsp_resp_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Ocsp_resp_timeout { get; set; }
    
        /// <summary>Maximum number of times the failed OCSP jobs can be
        /// scheduled.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 10.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_tries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Max_tries { get; set; } = 10L;
    
        /// <summary>Describes the Time Interval after which the next OCSP job
        /// needs to be scheduled in case of the OCSP job failures.
        /// Allowed values are 60-86400.
        /// Unit is SEC.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 3600.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("failed_ocsp_jobs_retry_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(60D, 86400D)]
        public long? Failed_ocsp_jobs_retry_interval { get; set; } = 3600L;
    
        /// <summary>List of Responder URLs configured by user to do
        /// failover/override the AIA extension contained in the OCSP
        /// responder's SSL/TLS certificate.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("responder_url_lists", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Responder_url_lists { get; set; }
    
    
    }
    
    /// <summary>TCP MSS Clamping Direction and Value.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TcpMaximumSegmentSizeClamping 
    {
        /// <summary>MSS defines the maximum amount of data that a host is willing to
        /// accept in a single TCP segment. This field is set in TCP header
        /// during connection establishment. To avoid packet fragmentation,
        /// you can set this field depending on uplink MTU and VPN overhead.
        /// This is an optional field and in case it is left unconfigured,
        /// best possible MSS value will be calculated based on effective
        /// mtu of uplink interface. Supported MSS range is 216 to 8960.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_segment_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(108D, 8902D)]
        public long? Max_segment_size { get; set; }
    
        /// <summary>Specifies the traffic direction for which to apply MSS Clamping.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("direction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TcpMaximumSegmentSizeClampingDirection? Direction { get; set; } = SDKGenerator.TcpMaximumSegmentSizeClampingDirection.NONE;
    
    
    }
    
    /// <summary>Advanced load balancer AppCookiePersistenceProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAppCookiePersistenceProfile 
    {
        /// <summary>Header or cookie name for application cookie persistence.</summary>
        [Newtonsoft.Json.JsonProperty("prst_hdr_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Prst_hdr_name { get; set; }
    
        /// <summary>Key to use for cookie encryption.</summary>
        [Newtonsoft.Json.JsonProperty("encryption_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Encryption_key { get; set; }
    
        /// <summary>The length of time after a client's connections have closed
        /// before expiring the client's persistence to a server.
        /// Allowed values are 1-720.
        /// Unit is MIN.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 20.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 720D)]
        public long? Timeout { get; set; } = 20L;
    
    
    }
    
    /// <summary>Advanced load balancer DnsRule object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsRule 
    {
        /// <summary>Index of the rule.</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public long Index { get; set; }
    
        /// <summary>Enable or disable the rule.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable { get; set; } = true;
    
        /// <summary>Log DNS query upon rule match.</summary>
        [Newtonsoft.Json.JsonProperty("log", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Log { get; set; }
    
        /// <summary>Action to be performed upon successful matching.</summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDnsRuleAction Action { get; set; }
    
        /// <summary>Add match criteria to the rule.</summary>
        [Newtonsoft.Json.JsonProperty("match", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDnsRuleMatchTarget Match { get; set; }
    
        /// <summary>Name of the rule.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HTTPLocalFile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPLocalFile 
    {
        /// <summary>File content to used in the local HTTP response body.</summary>
        [Newtonsoft.Json.JsonProperty("file_content", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string File_content { get; set; }
    
        /// <summary>Mime-type of the content in the file.</summary>
        [Newtonsoft.Json.JsonProperty("content_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Content_type { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for LBService, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildLBService : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual LBService object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("LBService", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public LBService LBService { get; set; }
    
    
    }
    
    /// <summary>Vni Pool Configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VniPoolConfig : PolicyConfigResource
    {
        /// <summary>Start value of VNI Pool range</summary>
        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(75001D, 16777215D)]
        public long Start { get; set; }
    
        /// <summary>End value of VNI Pool range</summary>
        [Newtonsoft.Json.JsonProperty("end", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(75001D, 16777215D)]
        public long End { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of Rules</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RuleListResult : BaseRuleListResult
    {
        /// <summary>Rule list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Rule> Results { get; set; } = new System.Collections.ObjectModel.Collection<Rule>();
    
    
    }
    
    /// <summary>Child wrapper object for MacDiscoveryProfile, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildMacDiscoveryProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual MacDiscoveryProfile object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("MacDiscoveryProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public MacDiscoveryProfile MacDiscoveryProfile { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HTTPRewriteURLAction object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPRewriteURLAction 
    {
        /// <summary>Host config.</summary>
        [Newtonsoft.Json.JsonProperty("host_hdr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBURIParam Host_hdr { get; set; }
    
        /// <summary>Query config.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBURIParamQuery Query { get; set; }
    
        /// <summary>Path config.</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBURIParam Path { get; set; }
    
    
    }
    
    /// <summary>Schedule to specify the interval time at which automated backups need to be taken</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IntervalBackupSchedule : BackupSchedule
    {
        /// <summary>Time interval in seconds between two consecutive automated backups</summary>
        [Newtonsoft.Json.JsonProperty("seconds_between_backups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(300D, 86400D)]
        public long? Seconds_between_backups { get; set; } = 3600L;
    
    
    }
    
    /// <summary>The type contains information about the configuration of the feature for a
    /// specific node. It contains information like the whether the feature is
    /// enabled/disabled, the context profiles defining the category list to
    /// detect.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyUrlCategorizationConfig : PolicyConfigResource
    {
        /// <summary>The frequency in minutes at which the updates are downloaded from the
        /// URL categorization cloud service. The minimum allowed value is 5
        /// minutes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("update_frequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(5D, int.MaxValue)]
        public long? Update_frequency { get; set; } = 30L;
    
        /// <summary>The ids of the context profiles that provides the list of categories to
        /// be detected. This field is deprecated. URL Categorization will not be
        /// supported in association with context profiles.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("context_profiles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Context_profiles { get; set; }
    
        /// <summary>Property which specifies the enabling/disabling of the feature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for PolicyLbRule, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyLbRule : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyLbRule object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyLbRule", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyLbRule PolicyLbRule { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BinaryPacketData : PacketData
    {
        /// <summary>Up to 1000 bytes of payload may be supplied (with a base64-encoded length of 1336 bytes.) Additional bytes of traceflow metadata will be appended to the payload. The payload must contain all headers (Ethernet, IP, etc). Note that VLAN is not supported in the logical space. Hence, payload must not contain 802.1Q headers.</summary>
        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1336)]
        public string Payload { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConsolidatedEffectiveIPAddressMemberListResult : ListResult
    {
        /// <summary>Paged Collection of site wise consolidated effective ip addresses for the given NSGroup</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<EffectiveIPInfo> Results { get; set; } = new System.Collections.ObjectModel.Collection<EffectiveIPInfo>();
    
    
    }
    
    /// <summary>IPFIX DFW data will be collected on collector
    /// Host IP and Port address should be provided for collector.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPFIXDFWCollector : PolicyConfigResource
    {
        /// <summary>IP address for the IPFIX DFW collector.
        /// IP addresses such as 0.0.0.0, 127.0.0.1, 255.255.255.255 are invalid.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("collector_ip_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Collector_ip_address { get; set; }
    
        /// <summary>Port for the IPFIX DFW collector.</summary>
        [Newtonsoft.Json.JsonProperty("collector_port", Required = Newtonsoft.Json.Required.Always)]
        public long Collector_port { get; set; }
    
    
    }
    
    /// <summary>DNS forwarder status per enforcement point.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("NsxTDNSForwarderStatus", typeof(NsxTDNSForwarderStatus))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DNSForwarderStatusPerEnforcementPoint 
    {
        /// <summary>Policy path referencing the enforcement point from where the status is fetched.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enforcement_point_path { get; set; }
    
    
    }
    
    /// <summary>An ServiceEntry that represents an ALG protocol</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALGTypeServiceEntry : ServiceEntry
    {
        /// <summary>The Application Layer Gateway (ALG) protocol.
        /// Please note, protocol NBNS_BROADCAST and NBDG_BROADCAST are  deprecated.
        /// Please use UDP protocol and create L4 Port Set type of service instead.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALGTypeServiceEntryAlg Alg { get; set; }
    
        /// <summary>The destination_port cannot be empty and must be a single value.</summary>
        [Newtonsoft.Json.JsonProperty("destination_ports", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(15)]
        public System.Collections.Generic.ICollection<string> Destination_ports { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        [Newtonsoft.Json.JsonProperty("source_ports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(15)]
        public System.Collections.Generic.ICollection<string> Source_ports { get; set; }
    
    
    }
    
    /// <summary>L2Vpn transport tunnel peer code.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VpnTransportTunnelPeerCode 
    {
        /// <summary>Copy this code to paste on the remote end of the tunnel.
        /// This is a base64 encoded string which has all the configuration for tunnel.
        /// E.g local/remote ips and protocol, encryption algorithm, etc. Peer code also
        /// contains PSK; be careful when sharing or storing it.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("peer_code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Peer_code { get; set; }
    
        /// <summary>Policy path referencing the transport tunnel.</summary>
        [Newtonsoft.Json.JsonProperty("transport_tunnel_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Transport_tunnel_path { get; set; }
    
    
    }
    
    /// <summary>List of directory domain LDAP servers</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DirectoryLdapServerListResults : ListResult
    {
        /// <summary>List of directory domain LDAP servers</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(50)]
        public System.Collections.Generic.ICollection<DirectoryLdapServer> Results { get; set; } = new System.Collections.ObjectModel.Collection<DirectoryLdapServer>();
    
    
    }
    
    /// <summary>Multicast PIM configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier0InterfacePimConfig 
    {
        /// <summary>PIM hold interval(seconds) at interface level.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hold_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 630D)]
        public long? Hold_interval { get; set; }
    
        /// <summary>enable/disable PIM configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = false;
    
        /// <summary>PIM hello interval(seconds) at interface level.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hello_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 180D)]
        public long? Hello_interval { get; set; } = 30L;
    
    
    }
    
    /// <summary>An instance of a datasource configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DefaultFilterValue 
    {
        /// <summary>Filter alias.</summary>
        [Newtonsoft.Json.JsonProperty("alias", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Alias { get; set; }
    
        /// <summary>Filter default value.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HealthMonitorRadius object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHealthMonitorRadius 
    {
        /// <summary>Radius monitor will query Radius server with this username.</summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Username { get; set; }
    
        /// <summary>Radius monitor will query Radius server with this password.</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Password { get; set; }
    
        /// <summary>Radius monitor will query Radius server with this shared
        /// secret.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("shared_secret", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Shared_secret { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for PolicyFirewallCPUMemThresholdsProfileBindingMap,
    /// used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyFirewallCPUMemThresholdsProfileBindingMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyFirewallCPUMemThresholdsProfileBindingMap object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyFirewallCPUMemThresholdsProfileBindingMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyFirewallCPUMemThresholdsProfileBindingMap PolicyFirewallCPUMemThresholdsProfileBindingMap { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer WafConfig object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWafConfig 
    {
        /// <summary>Ignore request body parsing errors due to partial scanning.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ignore_incomplete_request_body_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Ignore_incomplete_request_body_error { get; set; } = true;
    
        /// <summary>Limit CPU utilization for each regular expression match
        /// when processing rules.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 30000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("regex_match_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Regex_match_limit { get; set; } = 30000L;
    
        /// <summary>WAF allowed Content Types.
        /// Maximum of 64 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allowed_request_content_types", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Allowed_request_content_types { get; set; }
    
        /// <summary>WAF allowed HTTP methods.
        /// Enum options - HTTP_METHOD_GET, HTTP_METHOD_HEAD,
        /// HTTP_METHOD_PUT, HTTP_METHOD_DELETE, HTTP_METHOD_POST,
        /// HTTP_METHOD_OPTIONS, HTTP_METHOD_TRACE, HTTP_METHOD_CONNECT,
        /// HTTP_METHOD_PATCH, HTTP_METHOD_PROPFIND,
        /// HTTP_METHOD_PROPPATCH, HTTP_METHOD_MKCOL, HTTP_METHOD_COPY,
        /// HTTP_METHOD_MOVE, HTTP_METHOD_LOCK, HTTP_METHOD_UNLOCK.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allowed_methods", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Allowed_methods> Allowed_methods { get; set; }
    
        /// <summary>The maximum period of time WAF processing is allowed to
        /// take for a single request.
        /// A value of 0 (zero) means no limit and should not be chosen
        /// in production deployments.
        /// It is only used for exceptional situations where crashes of
        /// se_dp processes are acceptable.
        /// The behavior of the system if this time is exceeded depends
        /// on two other configuration settings, the WAF policy mode and
        /// the WAF failure mode.
        /// In WAF policy mode 'Detection', the request is allowed and
        /// flagged for both failure mode 'Closed' and 'Open'.
        /// In enforcement node, 'Closed' means the request is
        /// rejected, 'Open' means the request is allowed and flagged.
        /// Irrespective of these settings, no subsequent WAF rules of
        /// this or other phases will be executed once the maximum
        /// execution time has been exceeded.
        /// Allowed values are 0-5000.
        /// Unit is MILLISECONDS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 50.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_execution_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 5000D)]
        public long? Max_execution_time { get; set; } = 50L;
    
        /// <summary>WAF default action for Response Header Phase.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// phase:3,deny,status:403,log,auditlog.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("response_hdr_default_action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Response_hdr_default_action { get; set; } = "phase:3,deny,status:403,log,auditlog";
    
        /// <summary>WAF allowed HTTP Versions.
        /// Enum options - ZERO_NINE, ONE_ZERO, ONE_ONE, TWO_ZERO.
        /// Maximum of 8 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allowed_http_versions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Allowed_http_versions> Allowed_http_versions { get; set; }
    
        /// <summary>WAF Restricted HTTP Headers.
        /// Maximum of 64 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("restricted_headers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Restricted_headers { get; set; }
    
        /// <summary>WAF default action for Response Body Phase.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// phase:4,deny,status:403,log,auditlog.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("response_body_default_action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Response_body_default_action { get; set; } = "phase:4,deny,status:403,log,auditlog";
    
        /// <summary>WAF default action for Request Header Phase.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// phase:1,deny,status:403,log,auditlog.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("request_hdr_default_action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Request_hdr_default_action { get; set; } = "phase:1,deny,status:403,log,auditlog";
    
        /// <summary>WAF Static File Extensions.
        /// GET and HEAD requests with no query args and one of these
        /// extensions are allowed and not checked by the ruleset.
        /// Maximum of 64 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("static_extensions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Static_extensions { get; set; }
    
        /// <summary>Block or flag XML requests referring to External Entities.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("xml_xxe_protection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Xml_xxe_protection { get; set; } = true;
    
        /// <summary>Limit depth of recursion for each regular expression match
        /// when processing rules.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 10000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("regex_recursion_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Regex_recursion_limit { get; set; } = 10000L;
    
        /// <summary>WAF Restricted File Extensions.
        /// Maximum of 256 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("restricted_extensions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Restricted_extensions { get; set; }
    
        /// <summary>HTTP status code used by WAF Positive Security Model when
        /// rejecting a request.
        /// Enum options - HTTP_RESPONSE_CODE_0,
        /// HTTP_RESPONSE_CODE_100, HTTP_RESPONSE_CODE_101,
        /// HTTP_RESPONSE_CODE_200, HTTP_RESPONSE_CODE_201,
        /// HTTP_RESPONSE_CODE_202, HTTP_RESPONSE_CODE_203,
        /// HTTP_RESPONSE_CODE_204, HTTP_RESPONSE_CODE_205,
        /// HTTP_RESPONSE_CODE_206, HTTP_RESPONSE_CODE_300,
        /// HTTP_RESPONSE_CODE_301, HTTP_RESPONSE_CODE_302,
        /// HTTP_RESPONSE_CODE_303, HTTP_RESPONSE_CODE_304,
        /// HTTP_RESPONSE_CODE_305, HTTP_RESPONSE_CODE_307,
        /// HTTP_RESPONSE_CODE_400, HTTP_RESPONSE_CODE_401,
        /// HTTP_RESPONSE_CODE_402...
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as HTTP_RESPONSE_CODE_403.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status_code_for_rejected_requests", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBWafConfigStatus_code_for_rejected_requests? Status_code_for_rejected_requests { get; set; } = SDKGenerator.ALBWafConfigStatus_code_for_rejected_requests.HTTP_RESPONSE_CODE_403;
    
        /// <summary>Argument seperator.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as &amp;.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("argument_separator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Argument_separator { get; set; } = "&";
    
        /// <summary>0  For Netscape Cookies.
        /// 1  For version 1 cookies.
        /// Allowed values are 0-1.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cookie_format_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 1D)]
        public long? Cookie_format_version { get; set; } = 0L;
    
        /// <summary>WAF default action for Request Body Phase.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// phase:2,deny,status:403,log,auditlog.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("request_body_default_action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Request_body_default_action { get; set; } = "phase:2,deny,status:403,log,auditlog";
    
        /// <summary>Maximum size for response body scanned by WAF.
        /// Allowed values are 1-32768.
        /// Unit is KB.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 128.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server_response_max_body_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 32768D)]
        public long? Server_response_max_body_size { get; set; } = 128L;
    
        /// <summary>Maximum size for the client request body scanned by WAF.
        /// Allowed values are 1-32768.
        /// Unit is KB.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 32.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_request_max_body_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 32768D)]
        public long? Client_request_max_body_size { get; set; } = 32L;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceResult 
    {
        /// <summary>Direction of a trace</summary>
        [Newtonsoft.Json.JsonProperty("direction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TraceResultDirection? Direction { get; set; }
    
        /// <summary>Observation counters for logical components</summary>
        [Newtonsoft.Json.JsonProperty("logical_counters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TraceflowObservationCounters Logical_counters { get; set; }
    
        /// <summary>Trace observation list</summary>
        [Newtonsoft.Json.JsonProperty("observations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TraceflowObservation> Observations { get; set; }
    
        /// <summary>Packet ID in the session</summary>
        [Newtonsoft.Json.JsonProperty("packet_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Packet_id { get; set; }
    
        /// <summary>Whether some observations were deleted from the result set</summary>
        [Newtonsoft.Json.JsonProperty("result_overflowed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Result_overflowed { get; set; }
    
        /// <summary>Trace action result analysis notes</summary>
        [Newtonsoft.Json.JsonProperty("analysis", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Analysis { get; set; }
    
        /// <summary>Observation counters</summary>
        [Newtonsoft.Json.JsonProperty("counters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TraceflowObservationCounters Counters { get; set; }
    
    
    }
    
    /// <summary>Intrusion Detection System Signature .
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsSignature : PolicyConfigResource
    {
        /// <summary>Source-destination direction.</summary>
        [Newtonsoft.Json.JsonProperty("direction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Direction { get; set; }
    
        /// <summary>Flag which tells whether the signature is enabled or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable { get; set; }
    
        /// <summary>Protocol used in the packet analysis.</summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Protocol { get; set; }
    
        /// <summary>Class type of Signature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("class_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Class_type { get; set; }
    
        /// <summary>Flow established from server, from client etc.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("flow", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Flow { get; set; }
    
        /// <summary>Signature action.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Action { get; set; }
    
        /// <summary>Vendor assigned classification tag.</summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Tag { get; set; }
    
        /// <summary>Represents the internal categories a signature belongs to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("categories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Categories> Categories { get; set; }
    
        /// <summary>Signature name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Signature cvssv3 score.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cvssv3", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cvssv3 { get; set; }
    
        /// <summary>Signature cvssv2 score.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cvssv2", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cvssv2 { get; set; }
    
        /// <summary>Represents the severity of the Signature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("severity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Severity { get; set; }
    
        /// <summary>Represents revision of the Signature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("signature_revision", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Signature_revision { get; set; }
    
        /// <summary>Performance impact of the signature.</summary>
        [Newtonsoft.Json.JsonProperty("performance_impact", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Performance_impact { get; set; }
    
        /// <summary>Product affected by this signature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("product_affected", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Product_affected { get; set; }
    
        /// <summary>Signature vendor set severity of the signature rule.</summary>
        [Newtonsoft.Json.JsonProperty("signature_severity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Signature_severity { get; set; }
    
        /// <summary>Family of the malware tracked in the signature.</summary>
        [Newtonsoft.Json.JsonProperty("malware_family", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Malware_family { get; set; }
    
        /// <summary>List of mitre attack URLs pertaining to signature
        /// </summary>
        [Newtonsoft.Json.JsonProperty("urls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Urls { get; set; }
    
        /// <summary>Signature policy.</summary>
        [Newtonsoft.Json.JsonProperty("policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Policy { get; set; }
    
        /// <summary>Target of the signature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("attack_target", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Attack_target { get; set; }
    
        /// <summary>Represents the Signature's id.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("signature_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Signature_id { get; set; }
    
        /// <summary>CVE score
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cves", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Cves { get; set; }
    
        /// <summary>Signature type.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Type { get; set; }
    
        /// <summary>Represents the cvss value of a Signature.
        /// The value is derived from cvssv3 or cvssv2 score.
        /// NONE     means cvssv3/cvssv2 score as 0.0
        /// LOW      means cvssv3/cvssv2 score as 0.1-3.9
        /// MEDIUM   means cvssv3/cvssv2 score as 4.0-6.9
        /// HIGH     means cvssv3/cvssv2 score as 7.0-8.9
        /// CRITICAL means cvssv3/cvssv2 score as 9.0-10.0
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cvss", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IdsSignatureCvss? Cvss { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for PrefixList, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPrefixList : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PrefixList object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PrefixList", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PrefixList PrefixList { get; set; }
    
    
    }
    
    /// <summary>Properties of the layout of a container or widget</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LayoutProperties 
    {
        /// <summary>Describes the number of rows of grid layout of a container or widget. This property is applicable for grid layout only.</summary>
        [Newtonsoft.Json.JsonProperty("num_rows", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Num_rows { get; set; }
    
        /// <summary>Describes the number of columns of grid layout of a container or widget. This property is applicable for grid layout only.</summary>
        [Newtonsoft.Json.JsonProperty("num_columns", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Num_columns { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsMxRdata object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsMxRdata 
    {
        /// <summary>The priority field identifies which mail server should be
        /// preferred.
        /// Allowed values are 0-65535.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long Priority { get; set; }
    
        /// <summary>Fully qualified domain name of a mailserver.
        /// The host name maps directly to one or more address records
        /// in the DNS table, and must not point to any CNAME records
        /// (RFC 2181).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("host", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Host { get; set; }
    
    
    }
    
    /// <summary>RBAC Objects qualifier</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PathPermissionGroup 
    {
        /// <summary>Allowed operation</summary>
        [Newtonsoft.Json.JsonProperty("operation", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PathPermissionGroupOperation Operation { get; set; }
    
        /// <summary>Full Object Path</summary>
        [Newtonsoft.Json.JsonProperty("object_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Object_path { get; set; }
    
    
    }
    
    /// <summary>Contains realized state of the segment port. For example: transport node
    /// on which the port is located, discovered and realized address bindings of
    /// the port.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentPortState 
    {
        /// <summary>Identifiers of the transport nodes where the port is located</summary>
        [Newtonsoft.Json.JsonProperty("transport_node_ids", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Transport_node_ids { get; set; }
    
        /// <summary>Contains the list of address bindings for a segment port that were
        /// automatically dicovered using various snooping methods like ARP, DHCP
        /// etc.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("discovered_bindings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AddressBindingEntry> Discovered_bindings { get; set; }
    
        /// <summary>If any address binding discovered on the port is also found on
        /// other port on the same segment, then it is included in
        /// the duplicate bindings list along with the ID of the port with
        /// which it conflicts.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("duplicate_bindings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<DuplicateAddressBindingEntry> Duplicate_bindings { get; set; }
    
        /// <summary>List of segment port bindings that are realized. This list may be
        /// populated from the discovered bindings or manual user specified bindings.
        /// This binding configuration can be used by features such as firewall,
        /// spoof-guard, traceflow etc.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("realized_bindings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AddressBindingEntry> Realized_bindings { get; set; }
    
        /// <summary>Segment port attachment state</summary>
        [Newtonsoft.Json.JsonProperty("attachment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SegmentPortAttachmentState Attachment { get; set; }
    
    
    }
    
    /// <summary>Abstract base class for all the realized policy objects</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyRealizedResource : PolicyResource
    {
        /// <summary>Realization id of this object</summary>
        [Newtonsoft.Json.JsonProperty("realization_specific_identifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Realization_specific_identifier { get; set; }
    
        /// <summary>Desire state paths of this object</summary>
        [Newtonsoft.Json.JsonProperty("intent_reference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Intent_reference { get; set; }
    
        /// <summary>Realization state of this object</summary>
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyRealizedResourceState State { get; set; }
    
        /// <summary>Realization API of this object on enforcement point</summary>
        [Newtonsoft.Json.JsonProperty("realization_api", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Realization_api { get; set; }
    
        /// <summary>Alarm info detail</summary>
        [Newtonsoft.Json.JsonProperty("alarms", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyAlarmResource> Alarms { get; set; }
    
        /// <summary>It define the root cause for runtime error.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("runtime_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Runtime_error { get; set; }
    
        /// <summary>Possible values could be UP, DOWN, UNKNOWN, DEGRADED
        /// This list is not exhaustive.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("runtime_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Runtime_status { get; set; }
    
    
    }
    
    /// <summary>StringGroupApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBStringGroupApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of StringGroup
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBStringGroup> Results { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for PolicyIgmpProfile used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyIgmpProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains actual PolicyIgmpProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyIgmpProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyIgmpProfile PolicyIgmpProfile { get; set; }
    
    
    }
    
    /// <summary>IPFIX data will be collected on collector
    /// Host ip and port address should be provided for collector.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPFIXCollectorProfile : PolicyConfigResource
    {
        /// <summary>IP address for the IPFIX collector.</summary>
        [Newtonsoft.Json.JsonProperty("ipaddress", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ipaddress { get; set; }
    
        /// <summary>Port for the IPFIX collector.</summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long Port { get; set; } = 4739L;
    
    
    }
    
    /// <summary>Detailed Realized Status of an intent object on an NSX-T type of enforcement point.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConsolidatedStatusNsxT : ConsolidatedStatusPerEnforcementPoint
    {
        /// <summary>Detailed Realized Status inherent to an NSX-T Enforcement Point.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enforced_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EnforcedStatusDetailsNsxT Enforced_status { get; set; }
    
    
    }
    
    /// <summary>Virtual server acts as a facade to an application, receives
    /// all client connections over HTTP
    /// and distributes them among the backend servers.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class HttpPolicyLbVirtualServer : PolicyLbVirtualServer
    {
        /// <summary>Backend web servers typically log each request they handle along with
        /// the requesting client IP address. These logs are used for debugging,
        /// analytics and other such purposes. If the deployment topology requires
        /// enabling SNAT on the load balancer, then server will see the client as
        /// the SNAT IP which defeats the purpose of logging. To work around this
        /// issue, load balancer can be configured to insert XFF HTTP header with
        /// the original client IP address. Backend servers can then be
        /// configured to log the IP address in XFF header instead of the source
        /// IP address of the connection. If XFF header is not present in the
        /// incoming request, load balancer inserts a new XFF header with the
        /// client IP address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insert_client_ip_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Insert_client_ip_header { get; set; } = false;
    
    
    }
    
    /// <summary>Child wrapper object for Tier1Interface, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildTier1Interface : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual Tier1Interface object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Tier1Interface", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Tier1Interface Tier1Interface { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer AuthTacacsPlusAttributeValuePair object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAuthTacacsPlusAttributeValuePair 
    {
        /// <summary>mandatory.</summary>
        [Newtonsoft.Json.JsonProperty("mandatory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Mandatory { get; set; }
    
        /// <summary>attribute name.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>attribute value.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer ProtocolMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBProtocolMatch 
    {
        /// <summary>HTTP or HTTPS protocol.
        /// Enum options - HTTP, HTTPS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocols", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBProtocolMatchProtocols Protocols { get; set; }
    
        /// <summary>Criterion to use for protocol matching the HTTP request.
        /// Enum options - IS_IN, IS_NOT_IN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBProtocolMatchMatch_criteria Match_criteria { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsRecord object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsRecord 
    {
        /// <summary>Specifies the algorithm to pick the IP address(es) to be
        /// returned, when multiple entries are configured.
        /// This does not apply if num_records_in_response is 0.
        /// Default is round-robin.
        /// Enum options - DNS_RECORD_RESPONSE_ROUND_ROBIN,
        /// DNS_RECORD_RESPONSE_CONSISTENT_HASH.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// DNS_RECORD_RESPONSE_ROUND_ROBIN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("algorithm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBDnsRecordAlgorithm? Algorithm { get; set; } = SDKGenerator.ALBDnsRecordAlgorithm.DNS_RECORD_RESPONSE_ROUND_ROBIN;
    
        /// <summary>Details of DNS record.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Enable wild-card match of fqdn  if an exact match is not
        /// found in the DNS table, the longest match is chosen by
        /// wild-carding the fqdn in the DNS request.
        /// Default is false.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wildcard_match", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Wildcard_match { get; set; } = false;
    
        /// <summary>Specifies the number of records returned by the DNS
        /// service.
        /// Enter 0 to return all records.
        /// Default is 0.
        /// Allowed values are 0-20.
        /// Special values are 0- 'Return all records'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("num_records_in_response", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 20D)]
        public long? Num_records_in_response { get; set; } = 0L;
    
        /// <summary>DNS record type.
        /// Enum options - DNS_RECORD_OTHER, DNS_RECORD_A,
        /// DNS_RECORD_NS, DNS_RECORD_CNAME, DNS_RECORD_SOA,
        /// DNS_RECORD_PTR, DNS_RECORD_HINFO, DNS_RECORD_MX,
        /// DNS_RECORD_TXT, DNS_RECORD_RP, DNS_RECORD_DNSKEY,
        /// DNS_RECORD_AAAA, DNS_RECORD_SRV, DNS_RECORD_OPT,
        /// DNS_RECORD_RRSIG, DNS_RECORD_AXFR, DNS_RECORD_ANY.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBDnsRecordType Type { get; set; }
    
        /// <summary>Fully Qualified Domain Name.
        /// Minimum of 1 items required.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fqdn", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Fqdn { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Canonical name in CNAME record.</summary>
        [Newtonsoft.Json.JsonProperty("cname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDnsCnameRdata Cname { get; set; }
    
        /// <summary>Text record.
        /// Maximum of 4 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("txt_records", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDnsTxtRdata> Txt_records { get; set; }
    
        /// <summary>Service locator info in SRV record.
        /// Maximum of 4 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service_locator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDnsSrvRdata> Service_locator { get; set; }
    
        /// <summary>Time To Live for this DNS record.</summary>
        [Newtonsoft.Json.JsonProperty("ttl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Ttl { get; set; }
    
        /// <summary>IPv6 address in AAAA record.
        /// Maximum of 4 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip6_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDnsAAAARdata> Ip6_address { get; set; }
    
        /// <summary>Configured FQDNs are delegated domains (i.e.
        /// they represent a zone cut).
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("delegated", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Delegated { get; set; } = false;
    
        /// <summary>Name Server information in NS record.
        /// Maximum of 13 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ns", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDnsNsRdata> Ns { get; set; }
    
        /// <summary>IP address in A record.
        /// Maximum of 4 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDnsARdata> Ip_address { get; set; }
    
        /// <summary>MX record.
        /// Maximum of 4 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mx_records", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDnsMxRdata> Mx_records { get; set; }
    
        /// <summary>Internal metadata for the DNS record.</summary>
        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Metadata { get; set; }
    
    
    }
    
    /// <summary>LBPoolStatus on specific Enforcement Point</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("LBPoolStatus", typeof(LBPoolStatus))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBPoolStatusPerEP : PolicyRuntimeInfoPerEP
    {
    
    }
    
    /// <summary>Advanced load balancer SSLClientRequestHeader object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSSLClientRequestHeader 
    {
        /// <summary>Set the request header with the value as indicated by this
        /// SSL variable.
        /// Eg.
        /// send the whole certificate in PEM format.
        /// Enum options - HTTP_POLICY_VAR_CLIENT_IP,
        /// HTTP_POLICY_VAR_VS_PORT, HTTP_POLICY_VAR_VS_IP,
        /// HTTP_POLICY_VAR_HTTP_HDR,
        /// HTTP_POLICY_VAR_SSL_CLIENT_FINGERPRINT,
        /// HTTP_POLICY_VAR_SSL_CLIENT_SERIAL,
        /// HTTP_POLICY_VAR_SSL_CLIENT_ISSUER,
        /// HTTP_POLICY_VAR_SSL_CLIENT_SUBJECT,
        /// HTTP_POLICY_VAR_SSL_CLIENT_RAW,
        /// HTTP_POLICY_VAR_SSL_PROTOCOL,
        /// HTTP_POLICY_VAR_SSL_SERVER_NAME, HTTP_POLICY_VAR_USER_NAME,
        /// HTTP_POLICY_VAR_SSL_CIPHER, HTTP_POLICY_VAR_REQUEST_ID.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("request_header_value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBSSLClientRequestHeaderRequest_header_value? Request_header_value { get; set; }
    
        /// <summary>If this header exists, reset the connection.
        /// If the ssl variable is specified, add a header with this
        /// value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("request_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Request_header { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBIpAddrGroup, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBIpAddrGroup : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBIpAddrGroup object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBIpAddrGroup", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBIpAddrGroup ALBIpAddrGroup { get; set; }
    
    
    }
    
    /// <summary>Collection of only SI objects</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyServiceInstanceListResult : ListResult
    {
        /// <summary>Service instance list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyServiceInstance> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyServiceInstance>();
    
    
    }
    
    /// <summary>Advanced load balancer DosThreshold object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDosThreshold 
    {
        /// <summary>Maximum number of packets or connections or requests in a
        /// given interval of time to be deemed as attack.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_value", Required = Newtonsoft.Json.Required.Always)]
        public long Max_value { get; set; }
    
        /// <summary>Attack type.
        /// Enum options - LAND, SMURF, ICMP_PING_FLOOD,
        /// UNKOWN_PROTOCOL, TEARDROP, IP_FRAG_OVERRUN,
        /// IP_FRAG_TOOSMALL, IP_FRAG_FULL, IP_FRAG_INCOMPLETE,
        /// PORT_SCAN, TCP_NON_SYN_FLOOD_OLD, SYN_FLOOD, BAD_RST_FLOOD,
        /// MALFORMED_FLOOD, FAKE_SESSION, ZERO_WINDOW_STRESS,
        /// SMALL_WINDOW_STRESS, DOS_HTTP_TIMEOUT, DOS_HTTP_ERROR,
        /// DOS_HTTP_ABORT...
        /// </summary>
        [Newtonsoft.Json.JsonProperty("attack", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBDosThresholdAttack Attack { get; set; }
    
        /// <summary>Minimum number of packets or connections or requests in a
        /// given interval of time to be deemed as attack.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("min_value", Required = Newtonsoft.Json.Required.Always)]
        public long Min_value { get; set; }
    
    
    }
    
    /// <summary>This object holds the information of the export task.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ExportTask : PolicyTask
    {
        /// <summary>Policy path of a draft if this is an export task to export draft
        /// configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("draft_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Draft_path { get; set; }
    
        /// <summary>Name of the exported file generated after completion of export task.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exported_file", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Exported_file { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceflowObservationReceivedLogical : TraceflowObservation
    {
        /// <summary>MAC address of SAN volume controller for service insertion(SI)
        /// in service VM(SVM) where the traceflow packet was received.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("svc_mac", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Svc_mac { get; set; }
    
        /// <summary>The id of the source component from which the traceflow packet was received.</summary>
        [Newtonsoft.Json.JsonProperty("src_component_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Src_component_id { get; set; }
    
        /// <summary>The id of the component that received the traceflow packet.</summary>
        [Newtonsoft.Json.JsonProperty("component_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Component_id { get; set; }
    
        /// <summary>The id of the logical port at which the traceflow packet was received</summary>
        [Newtonsoft.Json.JsonProperty("lport_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lport_id { get; set; }
    
        /// <summary>The type of the source component from which the traceflow packet was received.</summary>
        [Newtonsoft.Json.JsonProperty("src_component_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TraceflowObservationReceivedLogicalSrc_component_type? Src_component_type { get; set; }
    
        /// <summary>The name of the logical port at which the traceflow packet was received</summary>
        [Newtonsoft.Json.JsonProperty("lport_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lport_name { get; set; }
    
        /// <summary>The name of source component from which the traceflow packet was received.</summary>
        [Newtonsoft.Json.JsonProperty("src_component_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Src_component_name { get; set; }
    
        /// <summary>VNI for the logical network on which the traceflow packet was received.</summary>
        [Newtonsoft.Json.JsonProperty("vni", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Vni { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer MethodMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBMethodMatch 
    {
        /// <summary>Configure HTTP method(s).
        /// Enum options - HTTP_METHOD_GET, HTTP_METHOD_HEAD,
        /// HTTP_METHOD_PUT, HTTP_METHOD_DELETE, HTTP_METHOD_POST,
        /// HTTP_METHOD_OPTIONS, HTTP_METHOD_TRACE, HTTP_METHOD_CONNECT,
        /// HTTP_METHOD_PATCH, HTTP_METHOD_PROPFIND,
        /// HTTP_METHOD_PROPPATCH, HTTP_METHOD_MKCOL, HTTP_METHOD_COPY,
        /// HTTP_METHOD_MOVE, HTTP_METHOD_LOCK, HTTP_METHOD_UNLOCK.
        /// Minimum of 1 items required.
        /// Maximum of 16 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("methods", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Methods> Methods { get; set; } = new System.Collections.ObjectModel.Collection<Methods>();
    
        /// <summary>Criterion to use for HTTP method matching the method in the
        /// HTTP request.
        /// Enum options - IS_IN, IS_NOT_IN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBMethodMatchMatch_criteria Match_criteria { get; set; }
    
    
    }
    
    /// <summary>Detail information about port attachment</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PortAttachment 
    {
        /// <summary>Not valid when type field is INDEPENDENT, mainly used to identify
        /// traffic from different ports in container use case.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("traffic_tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Traffic_tag { get; set; }
    
        /// <summary>Indicate how IP will be allocated for the port</summary>
        [Newtonsoft.Json.JsonProperty("allocate_addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PortAttachmentAllocate_addresses? Allocate_addresses { get; set; }
    
        /// <summary>Flag to indicate if hyperbus configuration is required.</summary>
        [Newtonsoft.Json.JsonProperty("hyperbus_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PortAttachmentHyperbus_mode? Hyperbus_mode { get; set; } = SDKGenerator.PortAttachmentHyperbus_mode.DISABLE;
    
        /// <summary>Set to PARENT when type field is CHILD. Read only field.</summary>
        [Newtonsoft.Json.JsonProperty("context_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PortAttachmentContext_type? Context_type { get; set; }
    
        /// <summary>If type is CHILD and the parent port is on the same segment as the child port, then this
        /// field should be VIF ID of the parent port.
        /// If type is CHILD and the parent port is on a different segment, then this
        /// field should be policy path of the parent port.
        /// If type is INDEPENDENT/STATIC, then this field should be transport node ID.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("context_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Context_id { get; set; }
    
        /// <summary>List of Evpn tenant VLAN IDs the Parent logical-port serves in Evpn Route-Server mode. Only effective when attachment type is PARENT and the logical-port is attached to vRouter VM.</summary>
        [Newtonsoft.Json.JsonProperty("evpn_vlans", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1000)]
        public System.Collections.Generic.ICollection<string> Evpn_vlans { get; set; }
    
        /// <summary>Indicate application interface configuration for Bare Metal Server.</summary>
        [Newtonsoft.Json.JsonProperty("bms_interface_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AttachedInterfaceEntry Bms_interface_config { get; set; }
    
        /// <summary>Type of port attachment. STATIC is added to replace INDEPENDENT. INDEPENDENT type and PARENT type are deprecated.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PortAttachmentType? Type { get; set; }
    
        /// <summary>ID used to identify/look up a child attachment behind a parent attachment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("app_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string App_id { get; set; }
    
        /// <summary>VIF UUID on NSX Manager. If the attachement type is PARENT, this property is required.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
    
    }
    
    /// <summary>Binding of domain to the enforcement point.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DomainDeploymentMap : PolicyConfigResource
    {
        /// <summary>Path of enforcement point on which domain shall be enforced.</summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Enforcement_point_path { get; set; }
    
    
    }
    
    /// <summary>Role</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Role 
    {
        /// <summary>Short identifier for the role. Must be all lower case with no spaces.</summary>
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Role1 { get; set; }
    
        /// <summary>A short, human-friendly display name of the role.</summary>
        [Newtonsoft.Json.JsonProperty("role_display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Role_display_name { get; set; }
    
    
    }
    
    /// <summary>Persistence cookie time.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBPersistenceCookieTime : LBCookieTime
    {
        /// <summary>HTTP cookie max-age to expire cookie, only available for insert mode.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cookie_max_idle", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long Cookie_max_idle { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LogicalPortStatistics : AggregatedDataCounterEx
    {
        /// <summary>The id of the logical port</summary>
        [Newtonsoft.Json.JsonProperty("logical_port_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Logical_port_id { get; set; }
    
        /// <summary>Timestamp when the data was last updated; unset if data source has never updated the data.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
    
    }
    
    /// <summary>DHCP relay configuration.
    /// Please note, the realized-state of this entity returned by the
    /// "GET /policy/api/v1/infra/realized-state/realized-entity" with this entity
    /// policy-path is irrelevant with the application status of this entity.
    /// Please do not rely on this returned realized-state to determine how this
    /// dhcp-relay-config was applied. The dhcp realization information was
    /// reflected in the realization states of the referencing Segment or T0/T1
    /// gateway.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DhcpRelayConfig : PolicyConfigResource
    {
        /// <summary>DHCP server IP addresses for DHCP relay configuration.
        /// Both IPv4 and IPv6 addresses are supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server_addresses", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(8)]
        public System.Collections.Generic.ICollection<string> Server_addresses { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>A set of IPv4 or IPv6 addresses defined by a start and end address.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IpPoolRange : Resource
    {
        /// <summary>The start IP Address of the IP Range.</summary>
        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Start { get; set; }
    
        /// <summary>The end IP Address of the IP Range.</summary>
        [Newtonsoft.Json.JsonProperty("end", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string End { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregatedLogicalRouterPortCounters 
    {
        /// <summary>Timestamp when the data was last updated; unset if data source has never updated the data.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        [Newtonsoft.Json.JsonProperty("rx", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LogicalRouterPortCounters Rx { get; set; }
    
        [Newtonsoft.Json.JsonProperty("tx", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LogicalRouterPortCounters Tx { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for Service, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildService : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual Service object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Service", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Service Service { get; set; }
    
    
    }
    
    /// <summary>An instance of service chain that consists of forward and reverse service paths.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServicePath 
    {
        /// <summary>Reverse service path if available that applies to egress traffic.</summary>
        [Newtonsoft.Json.JsonProperty("reverse_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public UnidirectionalServicePath Reverse_path { get; set; }
    
        /// <summary>Uuid of a service chain.</summary>
        [Newtonsoft.Json.JsonProperty("service_chain_uuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Service_chain_uuid { get; set; }
    
        /// <summary>Forward service path if available that applies to ingress traffic.</summary>
        [Newtonsoft.Json.JsonProperty("forward_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public UnidirectionalServicePath Forward_path { get; set; }
    
        /// <summary>Unique identifier of a service path.</summary>
        [Newtonsoft.Json.JsonProperty("service_path_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Service_path_id { get; set; }
    
        /// <summary>A unique id of a service chain.</summary>
        [Newtonsoft.Json.JsonProperty("service_chain_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Service_chain_id { get; set; }
    
    
    }
    
    /// <summary>Paged collection of DNS Security Profile Binding Map</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DnsSecurityProfileBindingMapListResult : ListResult
    {
        /// <summary>DNS Security Profile Binding Map List Results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<DnsSecurityProfileBindingMap> Results { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for EndpointPolicy used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildEndpointPolicy : ChildPolicyConfigResource
    {
        /// <summary>Contains actual EndpointPolicy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("EndpointPolicy", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public EndpointPolicy EndpointPolicy { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer ContentRewriteProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBContentRewriteProfile 
    {
        /// <summary>Enable rewrite on response body.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("response_rewrite_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Response_rewrite_enabled { get; set; } = false;
    
        /// <summary>Rewrite only content types listed in this string group.
        /// Content types not present in this list are not rewritten.
        /// It is a reference to an object of type StringGroup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rewritable_content_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rewritable_content_path { get; set; }
    
        /// <summary>Strings to be matched and replaced with on the response
        /// body.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rsp_match_replace_pair", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBMatchReplacePair> Rsp_match_replace_pair { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsRuleDnsRrSet object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsRuleDnsRrSet 
    {
        /// <summary>DNS resource record set - (records in the resource record
        /// set share the DNS domain name, type, and class).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resource_record_set", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBDnsRrSet Resource_record_set { get; set; } = new ALBDnsRrSet();
    
        /// <summary>DNS message section for the resource record set.
        /// Enum options - DNS_MESSAGE_SECTION_QUESTION,
        /// DNS_MESSAGE_SECTION_ANSWER, DNS_MESSAGE_SECTION_AUTHORITY,
        /// DNS_MESSAGE_SECTION_ADDITIONAL.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as DNS_MESSAGE_SECTION_ANSWER.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("section", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBDnsRuleDnsRrSetSection? Section { get; set; } = SDKGenerator.ALBDnsRuleDnsRrSetSection.DNS_MESSAGE_SECTION_ANSWER;
    
    
    }
    
    /// <summary>Advanced load balancer IpAddrPort object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBIpAddrPort 
    {
        /// <summary>IP Address of host.
        /// One of IP address or hostname should be set.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddr Ip { get; set; }
    
        /// <summary>Hostname of server.
        /// One of IP address or hostname should be set.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hostname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Hostname { get; set; }
    
        /// <summary>Name of the object.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Port number of server.
        /// Allowed values are 1-65535.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long Port { get; set; }
    
    
    }
    
    /// <summary>Load balancer rule actions are used to manipulate application traffic.
    /// Currently load balancer rules can be used at three load balancer processing
    /// phases. Each phase has its own supported type of actions.
    /// Supported actions in HTTP_REQUST_REWRITE phase are:
    ///   LBHttpRequestUriRewriteAction
    ///   LBHttpRequestHeaderRewriteAction
    ///   LBHttpRequestHeaderDeleteAction
    ///   LBVariableAssignmentAction
    /// Supported actions in HTTP_FORWARDING phase are:
    ///   LBHttpRejectAction
    ///   LBHttpRedirectAction
    ///   LBSelectPoolAction
    ///   LBVariablePersistenceOnAction
    ///   LBConnectionDropAction
    /// Supported action in HTTP_RESPONSE_REWRITE phase is:
    ///   LBHttpResponseHeaderRewriteAction
    ///   LBHttpResponseHeaderDeleteAction
    ///   LBVariablePersistenceLearnAction
    /// Supported action in HTTP_ACCESS phase is:
    ///   LBJwtAuthAction
    ///   LBConnectionDropAction
    ///   LBVariableAssignmentAction
    /// Supported action in TRANSPORT phase is:
    ///   LBSslModeSelectionAction
    ///   LBSelectPoolAction
    /// 
    /// If the match type of an LBRuleCondition field is specified as REGEX and
    /// named capturing groups are used in the specified regular expression. The
    /// groups can be used as variables in LBRuleAction fields.
    /// For example, define a rule with LBHttpRequestUriCondition as match
    /// condition and LBHttpRequestUriRewriteAction as action. Set match_type field
    /// of LBHttpRequestUriCondition to REGEX, and set uri field to
    ///   "/news/(?&amp;lt;year&amp;gt;\d+)/(?&amp;lt;month&amp;gt;\d+)/(?&amp;lt;article&amp;gt;.*)".
    /// Set uri field of LBHttpRequestUriRewriteAction to:
    ///   "/news/$year-$month/$article"
    /// In uri field of LBHttpRequestUriCondition, the (?&amp;lt;year&amp;gt;\d+),
    /// (?&amp;lt;month&amp;gt;\d+) and (?&amp;lt;article&amp;gt;.*) are named capturing groups,
    /// they define variables named $year, $month and $article respectively. The
    /// defined variables are used in LBHttpRequestUriRewriteAction.
    /// For a matched HTTP request with URI "/news/2017/06/xyz.html", the substring
    /// "2017" is captured in variable $year, "06" is captured in variable $month,
    /// and "xyz.html" is captured in variable $article. The
    /// LBHttpRequestUriRewriteAction will rewrite the URI to:
    ///   "/news/2017-06/xyz.html"
    /// A set of built-in variables can be used in LBRuleAction as well. The name
    /// of built-in variables start with underscore, the name of user defined
    /// variables is not allowed to start with underscore.
    /// Following are some of the built-in variables:
    ///   $_scheme: Reference the scheme part of matched HTTP messages, could be
    /// "http" or "https".
    ///   $_host: Host of matched HTTP messages, for example "www.example.com".
    ///   $_server_port: Port part of URI, it is also the port of the server which
    /// accepted a request. Default port is 80 for http and 443 for https.
    ///   $_uri: The URI path, for example "/products/sample.html".
    ///   $_request_uri: Full original request URI with arguments, for example,
    ///     "/products/sample.html?a=b&amp;c=d".
    ///   $_args: URI arguments, for instance "a=b&amp;c=d"
    ///   $_is_args: "?" if a request has URI arguments, or an empty string
    /// otherwise.
    /// For the full list of built-in variables, please reference the NSX-T
    /// Administrator's Guide.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "type")]
    [JsonInheritanceAttribute("LBVariableAssignmentAction", typeof(LBVariableAssignmentAction))]
    [JsonInheritanceAttribute("LBConnectionDropAction", typeof(LBConnectionDropAction))]
    [JsonInheritanceAttribute("LBSslModeSelectionAction", typeof(LBSslModeSelectionAction))]
    [JsonInheritanceAttribute("LBSelectPoolAction", typeof(LBSelectPoolAction))]
    [JsonInheritanceAttribute("LBHttpRequestHeaderDeleteAction", typeof(LBHttpRequestHeaderDeleteAction))]
    [JsonInheritanceAttribute("LBHttpResponseHeaderRewriteAction", typeof(LBHttpResponseHeaderRewriteAction))]
    [JsonInheritanceAttribute("LBHttpResponseHeaderDeleteAction", typeof(LBHttpResponseHeaderDeleteAction))]
    [JsonInheritanceAttribute("LBHttpRedirectAction", typeof(LBHttpRedirectAction))]
    [JsonInheritanceAttribute("LBHttpRequestUriRewriteAction", typeof(LBHttpRequestUriRewriteAction))]
    [JsonInheritanceAttribute("LBHttpRequestHeaderRewriteAction", typeof(LBHttpRequestHeaderRewriteAction))]
    [JsonInheritanceAttribute("LBVariablePersistenceLearnAction", typeof(LBVariablePersistenceLearnAction))]
    [JsonInheritanceAttribute("LBHttpRejectAction", typeof(LBHttpRejectAction))]
    [JsonInheritanceAttribute("LBVariablePersistenceOnAction", typeof(LBVariablePersistenceOnAction))]
    [JsonInheritanceAttribute("LBJwtAuthAction", typeof(LBJwtAuthAction))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBRuleAction 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FieldsPacketData : PacketData
    {
        /// <summary>The IPv6 header</summary>
        [Newtonsoft.Json.JsonProperty("ipv6_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Ipv6Header Ipv6_header { get; set; }
    
        /// <summary>The ARP header</summary>
        [Newtonsoft.Json.JsonProperty("arp_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ArpHeader Arp_header { get; set; }
    
        /// <summary>This field contains a protocol that is above IP. It is not restricted to the 'transport' defined by the OSI model (e.g., ICMP is supported).</summary>
        [Newtonsoft.Json.JsonProperty("transport_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TransportProtocolHeader Transport_header { get; set; }
    
        /// <summary>The IPv4 header</summary>
        [Newtonsoft.Json.JsonProperty("ip_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Ipv4Header Ip_header { get; set; }
    
        /// <summary>The ethernet header</summary>
        [Newtonsoft.Json.JsonProperty("eth_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EthernetHeader Eth_header { get; set; }
    
        /// <summary>Up to 1000 bytes of payload may be supplied (with a base64-encoded length of 1336 bytes.) Additional bytes of traceflow metadata will be appended to the payload. The payload contains any data the user wants to put after the transport header.</summary>
        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1336)]
        public string Payload { get; set; }
    
    
    }
    
    /// <summary>DHCP configuration of IPv6 subnet in a segment</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentDhcpV6Config : SegmentDhcpConfig
    {
        /// <summary>Excluded addresses to define dynamic ip allocation ranges.</summary>
        [Newtonsoft.Json.JsonProperty("excluded_ranges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<string> Excluded_ranges { get; set; }
    
        /// <summary>IPv6 address of SNTP servers for subnet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sntp_servers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(2)]
        public System.Collections.Generic.ICollection<string> Sntp_servers { get; set; }
    
        /// <summary>The length of time that a valid address is preferred. When the
        /// preferred lifetime expires, the address becomes deprecated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preferred_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(60D, 4294967295D)]
        public long? Preferred_time { get; set; }
    
        /// <summary>Domain names for subnet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("domain_names", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Domain_names { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CountResult 
    {
        /// <summary>Count results in a transport node</summary>
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CountObservation> Details { get; set; }
    
        /// <summary>Transport node ID</summary>
        [Newtonsoft.Json.JsonProperty("transport_node_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_node_id { get; set; }
    
    
    }
    
    /// <summary>Defines a graph</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GraphDefinition 
    {
        /// <summary>Defines the points of a graph.</summary>
        [Newtonsoft.Json.JsonProperty("point_definition", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PointDefinition Point_definition { get; set; } = new PointDefinition();
    
        /// <summary>Describes the graph. It labels the entities of graph. If the label is not provided then it is not shown for a graph. For example, for a single graph, the title of widget can describe the graph and a label may not be necessary to be shown.</summary>
        [Newtonsoft.Json.JsonProperty("label", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Label Label { get; set; }
    
        /// <summary>Identifier of graph. It can be used to differentiate multiple graph series present in GraphWidgetConfiguration.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
        /// <summary>Additional rendering or conditional evaluation of the field values to be performed, if any.</summary>
        [Newtonsoft.Json.JsonProperty("render_configuration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RenderConfiguration> Render_configuration { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBApplicationPersistenceProfile, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBApplicationPersistenceProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBApplicationPersistenceProfile object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBApplicationPersistenceProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBApplicationPersistenceProfile ALBApplicationPersistenceProfile { get; set; }
    
    
    }
    
    /// <summary>The packet capture result for transport nodes
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PktCapResult 
    {
        /// <summary>The packet capture resource info for ports where packet
        /// capture action is performed
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pktcap_resource_list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PktCapResource> Pktcap_resource_list { get; set; }
    
        /// <summary>Type of the transport node</summary>
        [Newtonsoft.Json.JsonProperty("transport_node_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PktCapResultTransport_node_type? Transport_node_type { get; set; }
    
        /// <summary>The ID of transport node where packet capture action is deployed</summary>
        [Newtonsoft.Json.JsonProperty("transport_node_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_node_id { get; set; }
    
    
    }
    
    /// <summary>Peer config per Enforcement Point to configure the other
    /// side of the tunnel.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("L2VPNSessionPeerConfigNsxT", typeof(L2VPNSessionPeerConfigNsxT))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VPNSessionPeerConfigPerEP : PolicyRuntimeInfoPerEP
    {
    
    }
    
    /// <summary>Child wrapper object for Tier1DeploymentMap, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildTier1DeploymentMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual Tier1DeploymentMap object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Tier1DeploymentMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Tier1DeploymentMap Tier1DeploymentMap { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceflowObservationDelivered : TraceflowObservation
    {
        /// <summary>This field specifies the resolution type of ARP ARP_SUPPRESSION_PORT_CACHE - ARP request is suppressed by port DB ARP_SUPPRESSION_TABLE - ARP request is suppressed by ARP table ARP_SUPPRESSION_CP_QUERY - ARP request is suppressed by info derived from CP ARP_VM - No suppression and the ARP request is resolved.</summary>
        [Newtonsoft.Json.JsonProperty("resolution_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TraceflowObservationDeliveredResolution_type? Resolution_type { get; set; }
    
        /// <summary>The name of the logical port into which the traceflow packet was delivered</summary>
        [Newtonsoft.Json.JsonProperty("lport_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lport_name { get; set; }
    
        /// <summary>The source MAC address of form:
        /// "^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$". For example: 00:00:00:00:00:00.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("target_mac", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Target_mac { get; set; }
    
        /// <summary>VLAN on bridged network</summary>
        [Newtonsoft.Json.JsonProperty("vlan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Vlan_id { get; set; }
    
        /// <summary>The id of the logical port into which the traceflow packet was delivered</summary>
        [Newtonsoft.Json.JsonProperty("lport_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lport_id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GatewayRouteTableInCsvFormat : CsvListResult
    {
        /// <summary>Timestamp when the data was last updated; unset if data source has never updated the data.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<GatewayRouteCsvRecord> Results { get; set; }
    
    
    }
    
    /// <summary>This is the base type for all identity sources that use LDAP for authentication and group membership.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("OpenLdapIdentitySource", typeof(OpenLdapIdentitySource))]
    [JsonInheritanceAttribute("ActiveDirectoryIdentitySource", typeof(ActiveDirectoryIdentitySource))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LdapIdentitySource : ManagedResource
    {
        /// <summary>The list of LDAP servers that provide LDAP service for this identity source. Currently, only one LDAP server is supported.</summary>
        [Newtonsoft.Json.JsonProperty("ldap_servers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<IdentitySourceLdapServer> Ldap_servers { get; set; }
    
        /// <summary>The subtree of the LDAP identity source to search when locating users and groups.</summary>
        [Newtonsoft.Json.JsonProperty("base_dn", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Base_dn { get; set; }
    
        /// <summary>The name of the authentication domain. When users log into NSX using an identity of the form "user@domain", NSX uses the domain portion to determine which LDAP identity source to use.</summary>
        [Newtonsoft.Json.JsonProperty("domain_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Domain_name { get; set; }
    
        /// <summary>After parsing the "user@domain", the domain portion is used to select the LDAP identity source to use. Additional domains listed here will also be directed to this LDAP identity source. In Active Directory these are sometimes referred to as Alternative UPN Suffixes.</summary>
        [Newtonsoft.Json.JsonProperty("alternative_domain_names", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Alternative_domain_names { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of Edge Cluster</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyEdgeClusterListResult : ListResult
    {
        /// <summary>Edge Cluster list result.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyEdgeCluster> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyEdgeCluster>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyMetadataProxyStatus 
    {
        /// <summary>UP means the metadata proxy is working fine on both transport-nodes(if configured);
        /// DOWN means the metadata proxy is is down on both transport-nodes(if configured),
        /// hence the metadata proxy will not repsond to any metadata request;
        /// Error means there is an error on transport-node(s) or no status is reported from
        /// transport-node(s). The metadata proxy may be working (or not working);
        /// NO_BACK means metadata proxy is working on one of the transport node while
        /// not in the other transport-node (if configured). If the metadata proxy on
        /// the working transport-node goes down, the metadata proxy will go down.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("proxy_status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyMetadataProxyStatusProxy_status Proxy_status { get; set; }
    
        /// <summary>Error message, if available</summary>
        [Newtonsoft.Json.JsonProperty("error_message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error_message { get; set; }
    
        /// <summary>Order of the transport nodes is insensitive because Metadata Proxy
        /// is running in Active-Active mode among target transport nodes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transport_nodes", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Transport_nodes { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>Service profile represents specialization of a vendor template. User may provide any of the vendor_template_name or vendor_template_key properties. But in case of multiple vendor templates with the same name, it is recommended to use the vendor_template_key. When both attributes are provided, name is ignored and only key is used to identify the template. If there are multiple templates with same name, and vendor_template_name is provided, realization will fail.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyServiceProfile : PolicyConfigResource
    {
        /// <summary>The vendor template key property of actual vendor template. This should be used when multiple templates with same name exist.</summary>
        [Newtonsoft.Json.JsonProperty("vendor_template_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Vendor_template_key { get; set; }
    
        /// <summary>List of attributes specific to a partner for which the service is created. These attributes are passed on to the partner appliance and are opaque to NSX. If a vendor template exposes configurable parameters, then their values are specified here.</summary>
        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<Attribute> Attributes { get; set; }
    
        /// <summary>The redirection action represents if the packet is exclusively redirected to the service, or if a copy is forwarded to the service. Redirection action is not applicable to guest introspection service.</summary>
        [Newtonsoft.Json.JsonProperty("redirection_action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyServiceProfileRedirection_action? Redirection_action { get; set; }
    
        /// <summary>Name of the vendor template for which this Service Profile is being created.</summary>
        [Newtonsoft.Json.JsonProperty("vendor_template_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Vendor_template_name { get; set; }
    
    
    }
    
    /// <summary>TCP MSS Clamping Direction and Value.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2TcpMaxSegmentSizeClamping 
    {
        /// <summary>MSS defines the maximum amount of data that a host is willing to
        /// accept in a single TCP segment. This field is set in TCP header
        /// during connection establishment. To avoid packet fragmentation,
        /// you can set this field depending on uplink MTU and VPN overhead.
        /// This is an optional field and in case it is left unconfigured,
        /// best possible MSS value will be calculated based on effective
        /// mtu of uplink interface. Supported MSS range is 108 to 8852.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_segment_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(108D, 8860D)]
        public long? Max_segment_size { get; set; }
    
        /// <summary>Specifies the traffic direction for which to apply MSS Clamping.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("direction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public L2TcpMaxSegmentSizeClampingDirection? Direction { get; set; } = SDKGenerator.L2TcpMaxSegmentSizeClampingDirection.BOTH;
    
    
    }
    
    /// <summary>Detailed information about an API Error</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyApiError : PolicyRelatedApiError
    {
        /// <summary>Other errors related to this error</summary>
        [Newtonsoft.Json.JsonProperty("related_errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyRelatedApiError> Related_errors { get; set; }
    
    
    }
    
    /// <summary>SSLProfileApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSSLProfileApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of SSLProfile
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBSSLProfile> Results { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer Service object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBService 
    {
        /// <summary>Enable SSL termination and offload for traffic from
        /// clients.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_ssl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_ssl { get; set; } = false;
    
        /// <summary>The end of the Virtual Service's port number range.
        /// Allowed values are 1-65535.
        /// Special values are 0- 'single port'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port_range_end", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Port_range_end { get; set; } = 0L;
    
        /// <summary>Override the network profile for this specific service
        /// port.
        /// It is a reference to an object of type NetworkProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("override_network_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Override_network_profile_path { get; set; }
    
        /// <summary>Enable application layer specific features for the this
        /// specific service.
        /// It is a reference to an object of type ApplicationProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("override_application_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Override_application_profile_path { get; set; }
    
        /// <summary>The Virtual Service's port number.
        /// Allowed values are 0-65535.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long Port { get; set; }
    
        /// <summary>Enable HTTP2 on this port.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_http2", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_http2 { get; set; } = false;
    
    
    }
    
    /// <summary>Some applications maintain state and require all relevant connections
    /// to be sent to the same server as the application state is not
    /// synchronized among servers. Persistence is enabled on a
    /// PolicyLbVirtualServer by binding a persistence profile to it.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("L7PolicyLbPersistenceProfile", typeof(L7PolicyLbPersistenceProfile))]
    [JsonInheritanceAttribute("CustomPolicyLbPersistenceProfile", typeof(CustomPolicyLbPersistenceProfile))]
    [JsonInheritanceAttribute("L4PolicyLbPersistenceProfile", typeof(L4PolicyLbPersistenceProfile))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyLbPersistenceProfile : PolicyConfigResource
    {
    
    }
    
    /// <summary>Advanced load balancer AnalyticsProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAnalyticsProfile : PolicyConfigResource
    {
        /// <summary>Time window (in secs) within which only unique health
        /// change events should occur.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1209600.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_event_throttle_window", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Hs_event_throttle_window { get; set; } = 1209600L;
    
        /// <summary>This flag sets the time duration of no live data traffic
        /// after which Virtual Service metrics processing is suspended.
        /// It is applicable only when enable_ondemand_metrics is set
        /// to false.
        /// Unit is SECONDS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1800.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ondemand_metrics_idle_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Ondemand_metrics_idle_timeout { get; set; } = 1800L;
    
        /// <summary>Tolerated client to Avi Round Trip Time(RTT) factor.
        /// It is a multiple of apdex_rtt_tolerated_factor.
        /// Allowed values are 1-1000.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 4.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apdex_server_rtt_tolerated_factor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Apdex_server_rtt_tolerated_factor { get; set; } = 4D;
    
        /// <summary>Penalty for allowing non-PFS handshakes.
        /// Allowed values are 0-5.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_security_nonpfs_penalty", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_security_nonpfs_penalty { get; set; } = 1D;
    
        /// <summary>Score assigned when the certificate expires in more than 30
        /// days.
        /// Allowed values are 0-5.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 5.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_security_certscore_gt30d", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_security_certscore_gt30d { get; set; } = 5D;
    
        /// <summary>Exclude server TCP reset from errors.
        /// It is common for applications like MS Exchange.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_server_tcp_reset_as_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exclude_server_tcp_reset_as_error { get; set; } = false;
    
        /// <summary>DoS connection rate below which the DoS security assessment
        /// will not kick in.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_min_dos_rate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Hs_min_dos_rate { get; set; } = 1000L;
    
        /// <summary>Exclude queries to domains that did not have configured
        /// services/records from the list of errors.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_no_dns_record_as_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exclude_no_dns_record_as_error { get; set; } = false;
    
        /// <summary>A server connection is considered lossy when percentage of
        /// times a packet could not be trasmitted due to TCP zero
        /// window is above this threshold.
        /// Allowed values are 0-100.
        /// Unit is PERCENT.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 2.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("conn_server_lossy_zero_win_size_event_threshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 100D)]
        public long? Conn_server_lossy_zero_win_size_event_threshold { get; set; } = 2L;
    
        /// <summary>Maximum penalty that may be deducted from health score for
        /// high resource utilization.
        /// Allowed values are 0-100.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 25.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_max_resources_penalty", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 100D)]
        public long? Hs_max_resources_penalty { get; set; } = 25L;
    
        /// <summary>A connection between client and Avi is considered lossy
        /// when more than this percentage of packets are retransmitted.
        /// Allowed values are 1-100.
        /// Unit is PERCENT.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 50.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("conn_lossy_total_rexmt_threshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 100D)]
        public long? Conn_lossy_total_rexmt_threshold { get; set; } = 50L;
    
        /// <summary>Skips health score computation of pool servers when number
        /// of servers in a pool is more than this setting.
        /// Allowed values are 0-5000.
        /// Special values are 0- 'server health score is deactivated'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 20.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("healthscore_max_server_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 5000D)]
        public long? Healthscore_max_server_limit { get; set; } = 20L;
    
        /// <summary>Threshold number of connections in 5min, below which
        /// apdexr, apdexc, rum_apdex, and other network quality metrics
        /// are not computed.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 10.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_pscore_traffic_threshold_l4_client", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_pscore_traffic_threshold_l4_client { get; set; } = 10D;
    
        /// <summary>Score assigned when supporting SSL3.0 encryption protocol.
        /// Allowed values are 0-5.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 3.5.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_security_ssl30_score", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_security_ssl30_score { get; set; } = 3.5D;
    
        /// <summary>Exclude queries to GSLB services that have no available
        /// members from the list of errors.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_no_valid_gs_member_as_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exclude_no_valid_gs_member_as_error { get; set; } = false;
    
        /// <summary>Enables Advanced Analytics features like Anomaly detection.
        /// If set to false, anomaly computation (and associated
        /// rules/events) for VS, Pool and Server metrics will be
        /// deactivated.
        /// However, setting it to false reduces cpu and memory
        /// requirements for Analytics subsystem.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_advanced_analytics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_advanced_analytics { get; set; } = true;
    
        /// <summary>List of SIP status codes to be excluded from being
        /// classified as an error.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_sip_error_codes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<long> Exclude_sip_error_codes { get; set; }
    
        /// <summary>A server HTTP response is considered Satisfied if latency
        /// is less than the Satisfactory Latency Threshold.
        /// The response is considered tolerated when it is greater
        /// than Satisfied but less than the Tolerated Latency Factor (STAR)
        /// S_Latency.
        /// Greater than this number and the server response is
        /// considered Frustrated.
        /// Allowed values are 1-30000.
        /// Unit is MILLISECONDS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 400.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apdex_server_response_threshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 30000D)]
        public long? Apdex_server_response_threshold { get; set; } = 400L;
    
        /// <summary>Exclude the Issuer-Revoked OCSP Responses from the list of
        /// errors.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_issuer_revoked_ocsp_responses_as_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exclude_issuer_revoked_ocsp_responses_as_error { get; set; } = true;
    
        /// <summary>Adds free performance score credits to health score.
        /// It can be used for compensating health score for known slow
        /// applications.
        /// Allowed values are 0-100.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_performance_boost", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 100D)]
        public long? Hs_performance_boost { get; set; } = 0L;
    
        /// <summary>Virtual service threshold factor for tolerated Page Load
        /// Time (PLT) as multiple of apdex_rum_threshold.
        /// Allowed values are 1-1000.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 4.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apdex_rum_tolerated_factor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Apdex_rum_tolerated_factor { get; set; } = 4D;
    
        /// <summary>Enable VirtualService (frontend) Analytics.
        /// This flag enables metrics and healthscore for
        /// Virtualservice.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_vs_analytics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_vs_analytics { get; set; } = true;
    
        /// <summary>Exclude dns queries to domains outside the domains
        /// configured in the DNS application profile from the list of
        /// errors.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_invalid_dns_domain_as_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exclude_invalid_dns_domain_as_error { get; set; } = false;
    
        /// <summary>List of HTTP status codes to be excluded from being
        /// classified as an error.
        /// Error connections or responses impacts health score, are
        /// included as significant logs, and may be classified as part
        /// of a DoS attack.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_http_error_codes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<long> Exclude_http_error_codes { get; set; }
    
        /// <summary>Maximum penalty that may be deducted from health score for
        /// anomalies.
        /// Allowed values are 0-100.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 10.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_max_anomaly_penalty", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 100D)]
        public long? Hs_max_anomaly_penalty { get; set; } = 10L;
    
        /// <summary>Enables analytics on backend servers.
        /// This may be desired in container environment when there are
        /// large number of ephemeral servers.
        /// Additionally, no healthscore of servers is computed when
        /// server analytics is enabled.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_server_analytics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_server_analytics { get; set; } = true;
    
        /// <summary>Exclude queries to GSLB services that are operationally
        /// down from the list of errors.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_gs_down_as_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exclude_gs_down_as_error { get; set; } = false;
    
        /// <summary>Exclude dns policy drops from the list of errors.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_dns_policy_drop_as_significant", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exclude_dns_policy_drop_as_significant { get; set; } = false;
    
        /// <summary>Server tolerated response latency factor.
        /// Servermust response within this factor times the
        /// satisfactory threshold (apdex_server_response_threshold) to
        /// be considered tolerated.
        /// Allowed values are 1-1000.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 4.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apdex_server_response_tolerated_factor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Apdex_server_response_tolerated_factor { get; set; } = 4D;
    
        /// <summary>Threshold number of connections in 5min, below which
        /// apdexr, apdexc, rum_apdex, and other network quality metrics
        /// are not computed.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 10.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_pscore_traffic_threshold_l4_server", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_pscore_traffic_threshold_l4_server { get; set; } = 10D;
    
        /// <summary>Penalty for not enabling HSTS.
        /// Allowed values are 0-5.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_security_hsts_penalty", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_security_hsts_penalty { get; set; } = 1D;
    
        /// <summary>Maximum number of SIP messages added in logs for a SIP
        /// transaction.
        /// By default, this value is 20.
        /// Allowed values are 1-1000.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 20.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sip_log_depth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 1000D)]
        public long? Sip_log_depth { get; set; } = 20L;
    
        /// <summary>Exclude client closed connection before an HTTP request
        /// could be completed from being classified as an error.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_client_close_before_request_as_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exclude_client_close_before_request_as_error { get; set; } = false;
    
        /// <summary>Exclude unsupported dns queries from the list of errors.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_unsupported_dns_query_as_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exclude_unsupported_dns_query_as_error { get; set; } = false;
    
        /// <summary>A connection between Avi and server is considered lossy
        /// when more than this percentage of packets are retransmitted
        /// due to timeout.
        /// Allowed values are 1-100.
        /// Unit is PERCENT.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 20.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("conn_server_lossy_timeo_rexmt_threshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 100D)]
        public long? Conn_server_lossy_timeo_rexmt_threshold { get; set; } = 20L;
    
        /// <summary>Deprecated.
        /// Allowed values are 0-5.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_security_selfsignedcert_penalty", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_security_selfsignedcert_penalty { get; set; } = 1D;
    
        /// <summary>A connection between Avi and server is considered lossy
        /// when more than this percentage of packets are retransmitted.
        /// Allowed values are 1-100.
        /// Unit is PERCENT.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 50.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("conn_server_lossy_total_rexmt_threshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 100D)]
        public long? Conn_server_lossy_total_rexmt_threshold { get; set; } = 50L;
    
        /// <summary>A connection between client and Avi is considered lossy
        /// when more than this percentage of packets are retransmitted
        /// due to timeout.
        /// Allowed values are 1-100.
        /// Unit is PERCENT.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 20.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("conn_lossy_timeo_rexmt_threshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 100D)]
        public long? Conn_lossy_timeo_rexmt_threshold { get; set; } = 20L;
    
        /// <summary>Tolerated client to Avi Round Trip Time(RTT) factor.
        /// It is a multiple of apdex_rtt_tolerated_factor.
        /// Allowed values are 1-1000.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 4.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apdex_rtt_tolerated_factor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Apdex_rtt_tolerated_factor { get; set; } = 4D;
    
        /// <summary>Score assigned when supporting TLS1.2 encryption protocol.
        /// Allowed values are 0-5.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 5.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_security_tls12_score", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_security_tls12_score { get; set; } = 5D;
    
        /// <summary>Enable adaptive configuration for optimizing resource
        /// usage.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_adaptive_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_adaptive_config { get; set; } = true;
    
        /// <summary>Configure which logs are sent to the Avi Controller from
        /// SEs and how they are processed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_log_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBClientLogConfiguration Client_log_config { get; set; }
    
        /// <summary>Exclude the unavailable OCSP Responses from the list of
        /// errors.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_unavailable_ocsp_responses_as_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exclude_unavailable_ocsp_responses_as_error { get; set; } = true;
    
        /// <summary>Rules applied to the HTTP application log for filtering
        /// sensitive information.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sensitive_log_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBSensitiveLogProfile Sensitive_log_profile { get; set; }
    
        /// <summary>Score assigned when the minimum cipher strength is 0 bits.
        /// Allowed values are 0-5.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_security_cipherscore_eq000b", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_security_cipherscore_eq000b { get; set; } = 0D;
    
        /// <summary>Score assigned when OCSP Certificate Status is set to
        /// Revoked or Issuer Revoked.
        /// Allowed values are 0.0-5.0.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_security_ocsp_revoked_score", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_security_ocsp_revoked_score { get; set; } = 0D;
    
        /// <summary>Penalty for allowing weak signature algorithm(s).
        /// Allowed values are 0-5.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_security_weak_signature_algo_penalty", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_security_weak_signature_algo_penalty { get; set; } = 1D;
    
        /// <summary>Exclude persistence server changed while load balancing'
        /// from the list of errors.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_persistence_change_as_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exclude_persistence_change_as_error { get; set; } = false;
    
        /// <summary>Score assigned when the minimum cipher strength is greater
        /// than equal to 128 bits.
        /// Allowed values are 0-5.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 5.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_security_cipherscore_ge128b", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_security_cipherscore_ge128b { get; set; } = 5D;
    
        /// <summary>Exclude 'server unanswered syns' from the list of errors.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_syn_retransmit_as_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exclude_syn_retransmit_as_error { get; set; } = false;
    
        /// <summary>List of HTTP status code ranges to be excluded from being
        /// classified as an error.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ranges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBHTTPStatusRange> Ranges { get; set; }
    
        /// <summary>A connection between Avi and server is considered lossy
        /// when more than this percentage of out of order packets are
        /// received.
        /// Allowed values are 1-100.
        /// Unit is PERCENT.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 50.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("conn_server_lossy_ooo_threshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 100D)]
        public long? Conn_server_lossy_ooo_threshold { get; set; } = 50L;
    
        /// <summary>Score assigned when supporting TLS1.3 encryption protocol.
        /// Allowed values are 0-5.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_security_tls13_score", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_security_tls13_score { get; set; }
    
        /// <summary>Virtual Service (VS) metrics are processed only when there
        /// is live data traffic on the VS.
        /// In case, VS is idle for a period of time as specified by
        /// ondemand_metrics_idle_timeout then metrics processing is
        /// suspended for that VS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_ondemand_metrics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_ondemand_metrics { get; set; } = true;
    
        /// <summary>Exclude server dns error response from the list of errors.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_server_dns_error_as_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exclude_server_dns_error_as_error { get; set; } = false;
    
        /// <summary>Score assigned when the certificate expires in less than or
        /// equal to 7 days.
        /// Allowed values are 0-5.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 2.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_security_certscore_le07d", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_security_certscore_le07d { get; set; } = 2D;
    
        /// <summary>Block of HTTP response codes to be excluded from being
        /// classified as an error.
        /// Enum options - AP_HTTP_RSP_4XX, AP_HTTP_RSP_5XX.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resp_code_block", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Resp_code_block> Resp_code_block { get; set; }
    
        /// <summary>Enable node (service engine) level analytics forvs metrics.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_se_analytics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_se_analytics { get; set; } = true;
    
        /// <summary>Score assigned when no algorithm is used for encryption.
        /// Allowed values are 0-5.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_security_encalgo_score_none", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_security_encalgo_score_none { get; set; } = 0D;
    
        /// <summary>A client connection is considered lossy when percentage of
        /// times a packet could not be trasmitted due to TCP zero
        /// window is above this threshold.
        /// Allowed values are 0-100.
        /// Unit is PERCENT.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 2.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("conn_lossy_zero_win_size_event_threshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 100D)]
        public long? Conn_lossy_zero_win_size_event_threshold { get; set; } = 2L;
    
        /// <summary>Score assigned when supporting TLS1.1 encryption protocol.
        /// Allowed values are 0-5.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 5.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_security_tls11_score", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_security_tls11_score { get; set; } = 5D;
    
        /// <summary>Score assigned when RC4 algorithm is used for encryption.
        /// Allowed values are 0-5.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 2.5.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_security_encalgo_score_rc4", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_security_encalgo_score_rc4 { get; set; } = 2.5D;
    
        /// <summary>Exclude the Revoked OCSP certificate status responses from
        /// the list of errors.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_revoked_ocsp_responses_as_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exclude_revoked_ocsp_responses_as_error { get; set; } = true;
    
        /// <summary>Penalty for allowing certificates with invalid chain.
        /// Allowed values are 0-5.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_security_chain_invalidity_penalty", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_security_chain_invalidity_penalty { get; set; } = 1D;
    
        /// <summary>Satisfactory client to Avi Round Trip Time(RTT).
        /// Allowed values are 1-2000.
        /// Unit is MILLISECONDS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 250.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apdex_rtt_threshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2000D)]
        public long? Apdex_rtt_threshold { get; set; } = 250L;
    
        /// <summary>Configure to stream logs to an external server.</summary>
        [Newtonsoft.Json.JsonProperty("client_log_streaming_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBClientLogStreamingConfig Client_log_streaming_config { get; set; }
    
        /// <summary>Client tolerated response latency factor.
        /// Client must receive a response within this factor times the
        /// satisfactory threshold (apdex_response_threshold) to be
        /// considered tolerated.
        /// Allowed values are 1-1000.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 4.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apdex_response_tolerated_factor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Apdex_response_tolerated_factor { get; set; } = 4D;
    
        /// <summary>Exclude TCP resets by client from the list of potential
        /// errors.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_tcp_reset_as_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exclude_tcp_reset_as_error { get; set; } = false;
    
        /// <summary>Maximum penalty that may be deducted from health score
        /// based on security assessment.
        /// Allowed values are 0-100.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 100.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_max_security_penalty", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 100D)]
        public long? Hs_max_security_penalty { get; set; } = 100L;
    
        /// <summary>Score assigned when the certificate expires in less than or
        /// equal to 30 days.
        /// Allowed values are 0-5.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 4.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_security_certscore_le30d", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_security_certscore_le30d { get; set; } = 4D;
    
        /// <summary>Exclude invalid dns queries from the list of errors.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_invalid_dns_query_as_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exclude_invalid_dns_query_as_error { get; set; } = false;
    
        /// <summary>A connection between client and Avi is considered lossy
        /// when more than this percentage of out of order packets are
        /// received.
        /// Allowed values are 1-100.
        /// Unit is PERCENT.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 50.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("conn_lossy_ooo_threshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 100D)]
        public long? Conn_lossy_ooo_threshold { get; set; } = 50L;
    
        /// <summary>Score assigned when the minimum cipher strength is less
        /// than 128 bits.
        /// Allowed values are 0-5.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 3.5.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_security_cipherscore_lt128b", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_security_cipherscore_lt128b { get; set; } = 3.5D;
    
        /// <summary>Score assigned when supporting TLS1.0 encryption protocol.
        /// Allowed values are 0-5.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 5.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_security_tls10_score", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_security_tls10_score { get; set; } = 5D;
    
        /// <summary>Score assigned when the certificate has expired.
        /// Allowed values are 0-5.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hs_security_certscore_expired", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hs_security_certscore_expired { get; set; } = 0D;
    
        /// <summary>If a client receives an HTTP response in less than the
        /// Satisfactory Latency Threshold, the request is considered
        /// Satisfied.
        /// It is considered Tolerated if it is not Satisfied and less
        /// than Tolerated Latency Factor multiplied by the Satisfactory
        /// Latency Threshold.
        /// Greater than this number and the client's request is
        /// considered Frustrated.
        /// Allowed values are 1-30000.
        /// Unit is MILLISECONDS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 500.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apdex_response_threshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 30000D)]
        public long? Apdex_response_threshold { get; set; } = 500L;
    
        /// <summary>Exclude the Stale OCSP certificate status responses from
        /// the list of errors.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_stale_ocsp_responses_as_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exclude_stale_ocsp_responses_as_error { get; set; } = true;
    
        /// <summary>If a client is able to load a page in less than the
        /// Satisfactory Latency Threshold, the PageLoad is considered
        /// Satisfied.
        /// It is considered tolerated if it is greater than Satisfied
        /// but less than the Tolerated Latency multiplied by Satisifed
        /// Latency.
        /// Greater than this number and the client's request is
        /// considered Frustrated.
        /// A PageLoad includes the time for DNS lookup, download of
        /// all HTTP objects, and page render time.
        /// Allowed values are 1-30000.
        /// Unit is MILLISECONDS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 5000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apdex_rum_threshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 30000D)]
        public long? Apdex_rum_threshold { get; set; } = 5000L;
    
        /// <summary>Satisfactory client to Avi Round Trip Time(RTT).
        /// Allowed values are 1-2000.
        /// Unit is MILLISECONDS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 125.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apdex_server_rtt_threshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2000D)]
        public long? Apdex_server_rtt_threshold { get; set; } = 125L;
    
    
    }
    
    /// <summary>Child wrapper object for EnforcementPoint, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildEnforcementPoint : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual Enforcement point object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("EnforcementPoint", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public EnforcementPoint EnforcementPoint { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer AuthorizationRule object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAuthorizationRule 
    {
        /// <summary>Authorization action when rule is matched.</summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBAuthorizationAction Action { get; set; } = new ALBAuthorizationAction();
    
        /// <summary>Index of the Authorization Policy rule.</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public long Index { get; set; }
    
        /// <summary>Enable or disable the rule.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable { get; set; } = true;
    
        /// <summary>Name of the rule.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>Authorization match criteria for the rule.</summary>
        [Newtonsoft.Json.JsonProperty("match", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBAuthorizationMatch Match { get; set; } = new ALBAuthorizationMatch();
    
    
    }
    
    /// <summary>Advanced load balancer ApplicationProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBApplicationProfile : PolicyConfigResource
    {
        /// <summary>Specifies the TCP application proxy profile parameters.</summary>
        [Newtonsoft.Json.JsonProperty("tcp_app_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBTCPApplicationProfile Tcp_app_profile { get; set; }
    
        /// <summary>Specifies various DNS service related controls for virtual
        /// service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dns_service_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDnsServiceApplicationProfile Dns_service_profile { get; set; }
    
        /// <summary>Specifies which application layer proxy is enabled for the
        /// virtual service.
        /// Enum options - APPLICATION_PROFILE_TYPE_L4,
        /// APPLICATION_PROFILE_TYPE_HTTP,
        /// APPLICATION_PROFILE_TYPE_SYSLOG,
        /// APPLICATION_PROFILE_TYPE_DNS, APPLICATION_PROFILE_TYPE_SSL,
        /// APPLICATION_PROFILE_TYPE_SIP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBApplicationProfileType Type { get; set; }
    
        /// <summary>Specifies if destination IP and port needs to be preserved
        /// for backend connection.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preserve_dest_ip_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Preserve_dest_ip_port { get; set; } = false;
    
        /// <summary>Specifies various SIP service related controls for virtual
        /// service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sip_service_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBSipServiceApplicationProfile Sip_service_profile { get; set; }
    
        /// <summary>Name of the application profile creator.</summary>
        [Newtonsoft.Json.JsonProperty("created_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_by { get; set; }
    
        /// <summary>Specifies if we need to preserve client port while
        /// preserving client IP for backend connections.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preserve_client_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Preserve_client_port { get; set; } = false;
    
        /// <summary>Checksum of application profiles.
        /// Internally set by cloud connector.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cloud_config_cksum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cloud_config_cksum { get; set; }
    
        /// <summary>Specifies the HTTP application proxy profile parameters.</summary>
        [Newtonsoft.Json.JsonProperty("http_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPApplicationProfile Http_profile { get; set; }
    
        /// <summary>Specifies various security related controls for virtual
        /// service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dos_rl_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDosRateLimitProfile Dos_rl_profile { get; set; }
    
        /// <summary>Specifies if client IP needs to be preserved for backend
        /// connection.
        /// Not compatible with Connection Multiplexing.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preserve_client_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Preserve_client_ip { get; set; } = false;
    
    
    }
    
    /// <summary>Child wrapper for ALBProtocolParser, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBProtocolParser : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBProtocolParser object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBProtocolParser", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBProtocolParser ALBProtocolParser { get; set; }
    
    
    }
    
    /// <summary>A ServiceEntry that represents an IP protocol</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPProtocolServiceEntry : ServiceEntry
    {
        [Newtonsoft.Json.JsonProperty("protocol_number", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0D, 255D)]
        public long Protocol_number { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for Application, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildApplication : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual Application object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Application", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Application Application { get; set; }
    
    
    }
    
    /// <summary>Additional gateway configuration required for federation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FederationGatewayConfig : FederationConnectivityConfig
    {
        /// <summary>Indicies for cross site allocation for edge cluster
        /// and its members referred by gateway.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("site_allocation_indices", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SiteAllocationIndexForEdge> Site_allocation_indices { get; set; }
    
        /// <summary>Global UUID for transit segment id to be used by Layer2 services for
        /// federation usecases.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transit_segment_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transit_segment_id { get; set; }
    
    
    }
    
    /// <summary>HealthMonitorApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHealthMonitorApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of HealthMonitor
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBHealthMonitor> Results { get; set; }
    
    
    }
    
    /// <summary>L3Vpn Context provides the configuration context that different L3Vpns can consume.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L3VpnContext : PolicyConfigResource
    {
        /// <summary>Log level for internet key exchange (IKE).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ike_log_level", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public L3VpnContextIke_log_level? Ike_log_level { get; set; } = SDKGenerator.L3VpnContextIke_log_level.INFO;
    
        /// <summary>If true, enable L3Vpn Service for given tier-0. Enabling/disabling this
        /// service affects all L3Vpns under the given tier-0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
        /// <summary>Bypass L3Vpn rules that will be shared across L3Vpns. Only Bypass action is
        /// supported on these L3Vpn rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bypass_rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<L3VpnRule> Bypass_rules { get; set; }
    
        /// <summary>Local gateway IPv4 addresses available for configuration of each L3Vpn.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("available_local_addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyIPAddressInfo> Available_local_addresses { get; set; }
    
        /// <summary>Policy path referencing Label. A label is used as a mechanism to group
        /// route-based L3Vpns in order to apply edge firewall rules on members' VTIs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("label", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Label { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DiscoveredNode : DiscoveredResource
    {
        /// <summary>The stateless property describes whether host persists its state across reboot or not. If state persists, value is set as false otherwise true.</summary>
        [Newtonsoft.Json.JsonProperty("stateless", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Stateless { get; set; }
    
        /// <summary>External id of the compute collection to which this node belongs</summary>
        [Newtonsoft.Json.JsonProperty("parent_compute_collection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Parent_compute_collection { get; set; }
    
        /// <summary>Certificate of the discovered node</summary>
        [Newtonsoft.Json.JsonProperty("certificate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Certificate { get; set; }
    
        /// <summary>Id of the compute manager from where this node was discovered</summary>
        [Newtonsoft.Json.JsonProperty("origin_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Origin_id { get; set; }
    
        /// <summary>IP Addresses of the the discovered node.</summary>
        [Newtonsoft.Json.JsonProperty("ip_addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Ip_addresses { get; set; }
    
        /// <summary>Hardware Id is generated using system hardware info. It is used to retrieve fabric node of the esx.</summary>
        [Newtonsoft.Json.JsonProperty("hardware_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Hardware_id { get; set; }
    
        /// <summary>OS version of the discovered node</summary>
        [Newtonsoft.Json.JsonProperty("os_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Os_version { get; set; }
    
        /// <summary>Discovered Node type like Host</summary>
        [Newtonsoft.Json.JsonProperty("node_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Node_type { get; set; }
    
        /// <summary>OS type of the discovered node</summary>
        [Newtonsoft.Json.JsonProperty("os_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Os_type { get; set; }
    
        /// <summary>Key-Value map of additional specific properties of discovered
        /// node in the Compute Manager
        /// </summary>
        [Newtonsoft.Json.JsonProperty("origin_properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyValuePair> Origin_properties { get; set; }
    
        /// <summary>External id of the discovered node, ex. a mo-ref from VC</summary>
        [Newtonsoft.Json.JsonProperty("external_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string External_id { get; set; }
    
        /// <summary>Local Id of the discovered node in the Compute Manager</summary>
        [Newtonsoft.Json.JsonProperty("cm_local_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cm_local_id { get; set; }
    
    
    }
    
    /// <summary>Paged collection of enforcement points.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EnforcementPointListResult : ListResult
    {
        /// <summary>Enforcement Point list Results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<EnforcementPoint> Results { get; set; } = new System.Collections.ObjectModel.Collection<EnforcementPoint>();
    
    
    }
    
    /// <summary>SpoofGuard is a tool that is designed to prevent virtual machines in your
    /// environment from sending traffic with IP addresses which are not authorized
    /// to send traffic from. A SpoofGuard policy profile once enabled blocks the
    /// traffic determined to be spoofed.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SpoofGuardProfile : PolicyConfigResource
    {
        /// <summary>If true, enable the SpoofGuard, which only allows VM sending traffic
        /// with the IPs in the whitelist.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("address_binding_whitelist", Required = Newtonsoft.Json.Required.Always)]
        public bool Address_binding_whitelist { get; set; } = false;
    
    
    }
    
    /// <summary>Child wrapper object for EvpnConfig, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildEvpnConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual EvpnConfig object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("EvpnConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public EvpnConfig EvpnConfig { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HTTPHdrData object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPHdrData 
    {
        /// <summary>HTTP header name.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>HTTP header value.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPHdrValue Value { get; set; }
    
    
    }
    
    /// <summary>Represents the leaf level expression to restrict the target attribute value
    /// based on the set of existing values. Generally, used in combination with
    /// RelatedAttributeConditionalExpression to constraint the values related to
    /// another attribute on the same resource. This object is always used in
    /// conjunction with some exression.
    /// Example -
    /// {
    ///   "condition" : {
    ///       "operator":"INCLUDES",
    ///       "rhs_value": ["/infra/domains/mgw/groups/VCENTER", "/infra/domains/mgw/groups/SRM", "/infra/domains/mgw/groups/NSX"],
    ///       "value_constraint": {
    ///           "resource_type": "ValueConstraintExpression",
    ///           "operator":"EXCLUDES",
    ///           "values":["/infra/domains/mgw/groups/VCENTER", "/infra/domains/mgw/groups/SRM", "/infra/domains/mgw/groups/NSX"]
    ///   }
    /// }
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConditionalValueConstraintExpression 
    {
        /// <summary>Set operation to constraint values.</summary>
        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConditionalValueConstraintExpressionOperator Operator { get; set; }
    
        /// <summary>Values to apply the conditional constraint on target.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value_constraint", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ValueConstraintExpression Value_constraint { get; set; }
    
        /// <summary>List of values.</summary>
        [Newtonsoft.Json.JsonProperty("rhs_value_with_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConstraintValue Rhs_value_with_type { get; set; }
    
        /// <summary>List of values.</summary>
        [Newtonsoft.Json.JsonProperty("rhs_value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Rhs_value { get; set; }
    
    
    }
    
    /// <summary>Directory domain selective sync settings</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SelectiveSyncSettings : ListResult
    {
        /// <summary>Enable or disable SelectiveSync</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }
    
        /// <summary>If SelectiveSync is enabled, this contains 1 or more
        /// OrgUnits, which NSX will synchronize with in LDAP server.
        /// The full distiguished name (DN) should be used for OrgUnit.
        /// If SelectiveSync is disabled, do not define this or specify an
        /// empty list.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selected_org_units", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Selected_org_units { get; set; }
    
    
    }
    
    /// <summary>Status of the Identity Firewall enabled Compute collection.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdfwComputeCollectionCondition 
    {
        /// <summary>IDFW enabled Compute collection status.</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IdfwComputeCollectionConditionStatus Status { get; set; }
    
        /// <summary>Status of the Compute collection.</summary>
        [Newtonsoft.Json.JsonProperty("status_detail", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Status_detail { get; set; }
    
    
    }
    
    /// <summary>Reaction Action is the action to take when the stipulated criteria specified
    /// in the event exist over the source. Some example actions include:
    /// - Notify Admin (or VMC's SRE) via email.
    /// - Populate a specific label with the IPSec VPN Session.
    /// - Remove the IPSec VPN Session from a specific label.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("SetFields", typeof(SetFields))]
    [JsonInheritanceAttribute("PatchResources", typeof(PatchResources))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Action 
    {
    
    }
    
    /// <summary>The certificate chain presented by a remote TLS service.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PeerCertificateChain 
    {
        /// <summary>List of X509Certificates.</summary>
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<X509Certificate> Details { get; set; }
    
        /// <summary>PEM encoded certificate data.</summary>
        [Newtonsoft.Json.JsonProperty("pem_encoded", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Pem_encoded { get; set; }
    
    
    }
    
    /// <summary>Livetrace configuration</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LiveTraceConfig : PolicyConfigResource
    {
        /// <summary>Filter for flows of interest.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LiveTraceFilterData Filter { get; set; }
    
        /// <summary>The duration for observing live traffic on the specified source logical port.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(5D, 300D)]
        public long? Timeout { get; set; } = 10L;
    
        /// <summary>Policy path of logical port to start a livetrace session.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("src_port_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Src_port_path { get; set; }
    
        /// <summary>This field indicates whether the intent is transient. If it is set to true, intent will be
        /// cleaned up after 1 hour of inactivity.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_transient", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_transient { get; set; } = true;
    
        /// <summary>Configuration of actions on the filtered packets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("actions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyLiveTraceActionConfig Actions { get; set; } = new PolicyLiveTraceActionConfig();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TcpHeader 
    {
        /// <summary>TCP flags (9bits)</summary>
        [Newtonsoft.Json.JsonProperty("tcp_flags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 511D)]
        public long? Tcp_flags { get; set; }
    
        /// <summary>Source port of tcp header</summary>
        [Newtonsoft.Json.JsonProperty("src_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Src_port { get; set; }
    
        /// <summary>Destination port of tcp header</summary>
        [Newtonsoft.Json.JsonProperty("dst_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Dst_port { get; set; }
    
    
    }
    
    /// <summary>Paged collection of Group Discovery Profile Binding Map</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GroupDiscoveryProfileBindingMapListResult : ListResult
    {
        /// <summary>Group Discovery Profile Binding Map List Results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<GroupDiscoveryProfileBindingMap> Results { get; set; }
    
    
    }
    
    /// <summary>Used to specify subnets in L3Vpn rule.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L3VpnSubnet 
    {
        /// <summary>Subnet used in L3Vpn Rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnet", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Subnet { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of Reactions.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ReactionListResult : ListResult
    {
        /// <summary>Reaction list results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Reaction> Results { get; set; } = new System.Collections.ObjectModel.Collection<Reaction>();
    
    
    }
    
    /// <summary>TAP (Terminal access point) traffic statistics for L2VPN.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VPNTapStatistics 
    {
        /// <summary>Total number of outgoing packets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_out { get; set; }
    
        /// <summary>Total number of incoming bytes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bytes_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_in { get; set; }
    
        /// <summary>Total number of packets dropped while sending for any reason.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_sent_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_sent_error { get; set; }
    
        /// <summary>Total number of incoming packets dropped.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_receive_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_receive_error { get; set; }
    
        /// <summary>Total number of incoming packets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_in { get; set; }
    
        /// <summary>Total number of outgoing bytes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bytes_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_out { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for ServiceInterface, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildServiceInterface : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ServiceInterface object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ServiceInterface", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ServiceInterface ServiceInterface { get; set; }
    
    
    }
    
    /// <summary>Virtual server acts as a facade to an application, receives all client
    /// connections over a specified protocol and distributes them among the backend
    /// servers.  This custom type allows for more complex settings than the
    /// simplified PolicyLbVirtualServer types.  This object allows for complex
    /// configurations for PolicyLbVirtualServers of all types. All HTTP
    /// specific inputs will be rejected when combined with TPC or UDP protocols.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CustomPolicyLbVirtualServer : HttpPolicyLbVirtualServer
    {
        /// <summary>The setting is used when load balancer acts as an SSL
        /// server and terminating the client SSL connection.  A default
        /// certificate should be specified which will be used if the server does
        /// not host multiple hostnames on the same IP address or if the client
        /// does not support SNI extension.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("default_client_ssl_certificate_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Default_client_ssl_certificate_id { get; set; }
    
        /// <summary>As the custom type allows for more complex settings than the simplified
        /// PolicyLbVirtualServer types, also specify the desired protocol for
        /// receiving all client connections.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("app_protocol", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CustomPolicyLbVirtualServerApp_protocol App_protocol { get; set; }
    
        /// <summary>Security settings representing various security settings
        /// when the VirtualServer acts as an SSL server
        /// - BASE_SECURE_111317
        /// - MODERATE_SECURE_111317
        /// - HIGH_SECURE_111317
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_ssl_settings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CustomPolicyLbVirtualServerClient_ssl_settings? Client_ssl_settings { get; set; } = SDKGenerator.CustomPolicyLbVirtualServerClient_ssl_settings.HIGH_SECURE_111317;
    
        /// <summary>To support client authentication (load balancer acting as
        /// a client authenticating to the backend server),
        /// server_ssl_certificate_id can be specified.  When supplied, the
        /// backend server certificate must be signed by one of the trusted
        /// Certificate Authorities (CAs), also referred to as root CAs, whose
        /// self signed certificates are specified. This setting is only applicable
        /// for L7 protocols and will be rejected in combination with TCP or UDP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server_auth_ca_certificate_ids", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Server_auth_ca_certificate_ids { get; set; }
    
        /// <summary>Client-side SSL profile binding allows multiple
        /// certificates, for different hostnames, to be bound to the same virtual
        /// server. The setting is used when load balancer acts as an SSL server
        /// and terminating the client SSL connection
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_ssl_certificate_ids", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Client_ssl_certificate_ids { get; set; }
    
        /// <summary>Indicates whether to enable server side SSL.  Server side SSL will be
        /// enabled when a specific security setting is selected. The selected
        /// security setting or profile represents various configurations related
        /// to SSL when the VirtualServer acts as a client connecting over SSL
        /// to the backend server.  This setting is only applicable for L7 protocols
        /// and will be rejected in combination with TCP or UDP.
        /// - BASE_SECURE_111317
        /// - MODERATE_SECURE_111317
        /// - HIGH_SECURE_111317
        /// - DISABLED
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server_ssl_settings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CustomPolicyLbVirtualServerServer_ssl_settings? Server_ssl_settings { get; set; } = SDKGenerator.CustomPolicyLbVirtualServerServer_ssl_settings.DISABLED;
    
    
    }
    
    /// <summary>ServerAutoScalePolicyApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBServerAutoScalePolicyApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of ServerAutoScalePolicy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBServerAutoScalePolicy> Results { get; set; }
    
    
    }
    
    /// <summary>Time interval on which firewall schedule will be applicable</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyTimeIntervalValue 
    {
        /// <summary>Time in 24 hour and minutes in multiple of 30. Example, 9:00.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("start_interval", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Start_interval { get; set; }
    
        /// <summary>Time in 24 hour and minutes in multiple of 30. Example, 17:30.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("end_interval", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string End_interval { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for Global Manager, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildGlobalManager : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual Global Manager object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("GlobalManager", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public GlobalManager GlobalManager { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer SSLKeyParams object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSSLKeyParams 
    {
        /// <summary>Placeholder for description of property ec_params of obj
        /// type SSLKeyParams field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ec_params", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBSSLKeyECParams Ec_params { get; set; }
    
        /// <summary>Placeholder for description of property rsa_params of obj
        /// type SSLKeyParams field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rsa_params", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBSSLKeyRSAParams Rsa_params { get; set; }
    
        /// <summary>Enum options - SSL_KEY_ALGORITHM_RSA, SSL_KEY_ALGORITHM_EC.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as SSL_KEY_ALGORITHM_RSA.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("algorithm", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBSSLKeyParamsAlgorithm Algorithm { get; set; } = SDKGenerator.ALBSSLKeyParamsAlgorithm.SSL_KEY_ALGORITHM_RSA;
    
    
    }
    
    /// <summary>Resources to take action on</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SelectableResourceReference : ResourceReference
    {
        /// <summary>Set to true if this resource has been selected to be acted upon</summary>
        [Newtonsoft.Json.JsonProperty("selected", Required = Newtonsoft.Json.Required.Always)]
        public bool Selected { get; set; }
    
    
    }
    
    /// <summary>Intrusion Detection System Profile severity.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsProfileSeverity : PolicyConfigResource
    {
        /// <summary>Contains the id of signatures that will be ignored as part of the profile.
        /// This field is deprecated, please use ignore_signatures field under IdsProfile
        /// to ignore the signatures.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ignore_signatures", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Ignore_signatures { get; set; }
    
        /// <summary>Represents the severity of a profile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("severity", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IdsProfileSeveritySeverity Severity { get; set; }
    
    
    }
    
    /// <summary>Injection Value.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("UnaryOperationBasedInjectionValue", typeof(UnaryOperationBasedInjectionValue))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class InjectionValue 
    {
    
    }
    
    /// <summary>Paged collection of Mac Discovery Profiles</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MacDiscoveryProfileListResult : ListResult
    {
        /// <summary>Mac Discovery profile list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<MacDiscoveryProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<MacDiscoveryProfile>();
    
    
    }
    
    /// <summary>Child wrapper object for IPFIXL2Profile, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIPFIXL2Profile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual IPFIXL2Profile object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IPFIXL2Profile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IPFIXL2Profile IPFIXL2Profile { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceActionConfig 
    {
        /// <summary>Sample argument for trace</summary>
        [Newtonsoft.Json.JsonProperty("sampling_argument", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SamplingArgument Sampling_argument { get; set; }
    
        /// <summary>Action argument for trace</summary>
        [Newtonsoft.Json.JsonProperty("action_argument", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TraceActionArgument Action_argument { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer SipServiceApplicationProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSipServiceApplicationProfile 
    {
        /// <summary>SIP transaction timeout in seconds.
        /// Allowed values are 2-512.
        /// Unit is SEC.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 32.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transaction_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(2D, 512D)]
        public long? Transaction_timeout { get; set; } = 32L;
    
    
    }
    
    /// <summary>Used to configure DNS security profile</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DnsSecurityProfile : PolicyConfigResource
    {
        /// <summary>Time to live for DNS cache entry in seconds. Valid TTL values are between 3600
        /// to 864000. However, this field accepts values between 0 through 864000. We define
        /// TTL type based on the value of TTL as follows:
        /// TTL 0 - cached entry never expires.
        /// TTL 1 to 3599 - invalid input and error is thrown
        /// TTL 3600 to 864000 - ttl is set to user input
        /// TTL field not set by user - TTL type is 'AUTO' and ttl value is set from DNS response packet.
        /// 
        /// User defined TTL value is used only when it is betweeen 3600 to 864000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ttl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 864000D)]
        public long? Ttl { get; set; } = 86400L;
    
    
    }
    
    /// <summary>Child wrapper object for SegmentPort, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildSegmentPort : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual SegmentPort object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("SegmentPort", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SegmentPort SegmentPort { get; set; }
    
    
    }
    
    /// <summary>IPv6 status</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPv6Status 
    {
        /// <summary>Array of DAD status which contains DAD information for IP addresses
        /// on the interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dad_statuses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IPv6DADStatus> Dad_statuses { get; set; }
    
        /// <summary>Path of the segment attached to the interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("connected_segment_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Connected_segment_path { get; set; }
    
        /// <summary>Policy path or realization ID of interface for which IPv6 DAD
        /// status is returned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("interface_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Interface_id { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for GlobalIdsSignature, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildGlobalIdsSignature : ChildPolicyConfigResource
    {
        /// <summary>Contains the GlobalIdsSignature object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("GlobalIdsSignature", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public GlobalIdsSignature GlobalIdsSignature { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for L2VpnContext, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildL2VpnContext : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual L2VpnContext object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("L2VpnContext", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public L2VpnContext L2VpnContext { get; set; }
    
    
    }
    
    /// <summary>Represents the space in which the policy is being defined.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AbstractSpace : PolicyConfigResource
    {
        /// <summary>The connectivity strategy is deprecated. Use default layer3 rule,
        /// /infra/domains/default/security-policies/default-layer3-security-policy/rules/default-layer3-rule.
        /// This field indicates the default connectivity policy for the infra
        /// or tenant space
        /// WHITELIST - Adds a default drop rule. Administrator can then use "allow"
        /// rules (aka whitelist) to allow traffic between groups
        /// BLACKLIST - Adds a default allow rule. Admin can then use "drop" rules
        /// (aka blacklist) to block traffic between groups
        /// WHITELIST_ENABLE_LOGGING - Whitelising with logging enabled
        /// BLACKLIST_ENABLE_LOGGING - Blacklisting with logging enabled
        /// NONE - No default rules are added.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("connectivity_strategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AbstractSpaceConnectivity_strategy? Connectivity_strategy { get; set; }
    
    
    }
    
    /// <summary>Represents an instance of partner Service and its configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyServiceInstance : BasePolicyServiceInstance
    {
        /// <summary>Management IP Address of primary interface of the Service</summary>
        [Newtonsoft.Json.JsonProperty("primary_interface_mgmt_ip", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Primary_interface_mgmt_ip { get; set; }
    
        /// <summary>Id of the standard or ditsributed port group for secondary management console.
        /// Please note that only 1 of the 2 values from
        /// 1. secondary_interface_network
        /// 2. secondary_portgroup_id
        /// are allowed to be passed. Both can't be passed in the same request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secondary_portgroup_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Secondary_portgroup_id { get; set; }
    
        /// <summary>UUID of VCenter/Compute Manager as seen on NSX Manager, to which this service needs to be deployed.</summary>
        [Newtonsoft.Json.JsonProperty("context_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Context_id { get; set; }
    
        /// <summary>Id of the standard or ditsributed port group for primary management console.
        /// Please note that only 1 of the 2 values from
        /// 1. primary_interface_network
        /// 2. primary_portgroup_id
        /// are allowed to be passed. Both can't be passed in the same request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("primary_portgroup_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Primary_portgroup_id { get; set; }
    
        /// <summary>Management IP Address of secondary interface of the Service</summary>
        [Newtonsoft.Json.JsonProperty("secondary_interface_mgmt_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Secondary_interface_mgmt_ip { get; set; }
    
        /// <summary>Id of the compute(ResourcePool) to which this service needs to be deployed.</summary>
        [Newtonsoft.Json.JsonProperty("compute_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Compute_id { get; set; }
    
        /// <summary>Form factor for the deployment of partner service.</summary>
        [Newtonsoft.Json.JsonProperty("deployment_spec_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Deployment_spec_name { get; set; }
    
        /// <summary>Template for the deployment of partnet service.</summary>
        [Newtonsoft.Json.JsonProperty("deployment_template_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Deployment_template_name { get; set; }
    
        /// <summary>Gateway address for secondary management console.
        /// If the provided segment already has gateway, this field can be omitted.
        /// But if it is provided, it takes precedence always.
        /// However, if provided segment does not have gateway, this field must be provided.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secondary_gateway_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Secondary_gateway_address { get; set; }
    
        /// <summary>Id of the storage(Datastore). VC moref of Datastore to which this service needs to be deployed.</summary>
        [Newtonsoft.Json.JsonProperty("storage_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Storage_id { get; set; }
    
        /// <summary>Subnet for secondary management console IP.
        /// If the provided segment already has subnet, this field can be omitted.
        /// But if it is provided, it takes precedence always.
        /// However, if provided segment does not have subnet, this field must be provided.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secondary_subnet_mask", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Secondary_subnet_mask { get; set; }
    
        /// <summary>List of attributes specific to a partner for which the service is created. There attributes are passed on to the partner appliance.</summary>
        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<Attribute> Attributes { get; set; } = new System.Collections.ObjectModel.Collection<Attribute>();
    
        /// <summary>Subnet for primary management console IP.
        /// If the provided segment already has subnet, this field can be omitted.
        /// But if it is provided, it takes precedence always.
        /// However, if provided segment does not have subnet, this field must be provided.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("primary_subnet_mask", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Primary_subnet_mask { get; set; }
    
        /// <summary>Gateway address for primary management console.
        /// If the provided segment already has gateway, this field can be omitted.
        /// But if it is provided, it takes precedence always.
        /// However, if provided segment does not have gateway, this field must be provided.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("primary_gateway_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Primary_gateway_address { get; set; }
    
        /// <summary>Path of the segment to which primary interface of the Service VM needs to be connected</summary>
        [Newtonsoft.Json.JsonProperty("primary_interface_network", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Primary_interface_network { get; set; }
    
        /// <summary>Path of segment to which secondary interface of the Service VM needs to be connected</summary>
        [Newtonsoft.Json.JsonProperty("secondary_interface_network", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Secondary_interface_network { get; set; }
    
        /// <summary>Failure policy for the Service VM. If this values is not provided, it will be defaulted to FAIL_CLOSE.</summary>
        [Newtonsoft.Json.JsonProperty("failure_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyServiceInstanceFailure_policy? Failure_policy { get; set; } = SDKGenerator.PolicyServiceInstanceFailure_policy.BLOCK;
    
    
    }
    
    /// <summary>Server SSL profile.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBServerSslProfile : LBSslProfile
    {
        /// <summary>SSL session caching allows SSL client and server to reuse previously
        /// negotiated security parameters avoiding the expensive public key
        /// operation during handshake.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("session_cache_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Session_cache_enabled { get; set; } = true;
    
        /// <summary>This flag is set to true when all the ciphers and protocols are FIPS
        /// compliant.
        /// It is set to false when one of the ciphers or protocols are not
        /// FIPS compliant.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_fips", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_fips { get; set; }
    
        /// <summary>It is a label of cipher group which is mostly consumed by GUI.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cipher_group_label", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBServerSslProfileCipher_group_label? Cipher_group_label { get; set; }
    
        /// <summary>This flag is set to true when all the ciphers and protocols are secure.
        /// It is set to false when one of the ciphers or protocols is insecure.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_secure", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_secure { get; set; }
    
        /// <summary>Supported SSL cipher list to client side.</summary>
        [Newtonsoft.Json.JsonProperty("ciphers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Ciphers> Ciphers { get; set; }
    
        /// <summary>SSL versions TLS1.1 and TLS1.2 are supported and enabled by default.
        /// SSLv2, SSLv3, and TLS1.0 are supported, but disabled by default.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocols", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Protocols> Protocols { get; set; }
    
    
    }
    
    /// <summary>Deployment Specs holds information required to deploy the Service-VMs.i.e. OVF url where the partner Service-VM OVF is hosted. The host type on which the OVF(Open Virtualization Format) can be deployed, Form factor to name a few.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SVMDeploymentSpec 
    {
        /// <summary>Location of the partner VM OVF to be deployed.</summary>
        [Newtonsoft.Json.JsonProperty("ovf_url", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ovf_url { get; set; }
    
        /// <summary>Deployment Spec name for ease of use, since multiple DeploymentSpec can be specified.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Minimum host version supported by this ovf. If a host in the deployment cluster is having version less than this, then service deployment will not happen on that host.</summary>
        [Newtonsoft.Json.JsonProperty("min_host_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Min_host_version { get; set; } = "6.5";
    
        /// <summary>Supported ServiceInsertion Form Factor for the OVF deployment. The default FormFactor is Medium.</summary>
        [Newtonsoft.Json.JsonProperty("service_form_factor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SVMDeploymentSpecService_form_factor? Service_form_factor { get; set; } = SDKGenerator.SVMDeploymentSpecService_form_factor.MEDIUM;
    
        /// <summary>Host Type on which the specified OVF can be deployed.</summary>
        [Newtonsoft.Json.JsonProperty("host_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SVMDeploymentSpecHost_type Host_type { get; set; }
    
        /// <summary>Partner needs to specify the Service VM version which will get deployed.</summary>
        [Newtonsoft.Json.JsonProperty("svm_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Svm_version { get; set; } = "1.0";
    
    
    }
    
    /// <summary>Child wrapper object for DhcpRelayConfig, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildDhcpRelayConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual DhcpRelayConfig object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("DhcpRelayConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public DhcpRelayConfig DhcpRelayConfig { get; set; }
    
    
    }
    
    /// <summary>API Request Body is an Event Source that represents an API request body that
    /// is being reveived as part of an API. Supported Request Bodies are those received
    /// as part of a PATCH/PUT/POST request.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ApiRequestBody : Source
    {
        /// <summary>Regex path representing a regex expression on resources. This regex is used
        /// to identify the request body(ies) that is/are the source of the Event. For
        /// instance: specifying "Lb* | /infra/tier-0s/vmc/ipsec-vpn-services/default"
        /// as a source means that ANY resource starting with Lb or ANY resource with
        /// "/infra/tier-0s/vmc/ipsec-vpn-services/default" as path would be the source
        /// of the event in question.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resource_pointer", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Resource_pointer { get; set; }
    
    
    }
    
    /// <summary>Some applications maintain state and require all relevant connections
    /// to be sent to the same server as the application state is not
    /// synchronized among servers. Persistence is enabled on a
    /// LBVirtualServer by binding a persistence profile to it.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBSourceIpPersistenceProfile : LBPersistenceProfile
    {
        /// <summary>Persistence purge setting.</summary>
        [Newtonsoft.Json.JsonProperty("purge", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBSourceIpPersistenceProfilePurge? Purge { get; set; } = SDKGenerator.LBSourceIpPersistenceProfilePurge.FULL;
    
        /// <summary>Persistence entries are not synchronized to the HA peer by default.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ha_persistence_mirroring_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Ha_persistence_mirroring_enabled { get; set; } = false;
    
        /// <summary>When all connections complete (reference count reaches 0), persistence
        /// entry timer is started with the expiration time.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long? Timeout { get; set; } = 300L;
    
    
    }
    
    /// <summary>The node count for specific load balancer usage severity.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBNodeCountPerSeverity 
    {
        /// <summary>Node count for specific serverity.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("node_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Node_count { get; set; }
    
        /// <summary>The severity calculation is based on current credit usage percentage
        /// of load balancer for one node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("severity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBNodeCountPerSeveritySeverity? Severity { get; set; }
    
    
    }
    
    /// <summary>Recommended Feature Permission</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RecommendedFeaturePermission 
    {
        /// <summary>List of source features</summary>
        [Newtonsoft.Json.JsonProperty("src_features", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Src_features { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Feature</summary>
        [Newtonsoft.Json.JsonProperty("target_feature", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Target_feature { get; set; }
    
        /// <summary>Permission</summary>
        [Newtonsoft.Json.JsonProperty("recommended_permissions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Recommended_permissions { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>Gives the statistics of a NAT rule per logical router on specified enforcement point.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyNatRuleStatisticsPerLogicalRouter 
    {
        /// <summary>Timestamp when the data was last updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>Detailed Rule statistics per logical router.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("per_node_statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyNatRuleStatisticsPerTransportNode> Per_node_statistics { get; set; }
    
        /// <summary>Rolled up statistics for all rules on the logical router.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PolicyNATRuleCounters Statistics { get; set; }
    
        /// <summary>Path of the router.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("router_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Router_path { get; set; }
    
        /// <summary>Policy Path referencing the enforcement point from where the statistics are fetched.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enforcement_point_path { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for ApplicationTier, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildApplicationTier : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ApplicationTier object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ApplicationTier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ApplicationTier ApplicationTier { get; set; }
    
    
    }
    
    /// <summary>Represents policy path expressions in the form of an array, to support addition of objects like groups, segments and policy logical ports in a group.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PathExpression : Expression
    {
        /// <summary>This array can consist of one or more policy paths. Only policy paths of groups, segments and policy logical ports are allowed.</summary>
        [Newtonsoft.Json.JsonProperty("paths", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<string> Paths { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>Paged Collection of PolicyFirewallCpuMemThresholdsProfile</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyFirewallCpuMemThresholdsProfileListResult : ListResult
    {
        /// <summary>PolicyFirewallCpuMemThresholdsProfile list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyFirewallCpuMemThresholdsProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyFirewallCpuMemThresholdsProfile>();
    
    
    }
    
    /// <summary>Used while defining a CommunicationEntry. A service may have multiple
    /// service entries.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Service : PolicyConfigResource
    {
        /// <summary>The flag, if true, indicates that service is created in the system by default.
        /// Such default services can't be modified/deleted.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_default", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_default { get; set; } = false;
    
        /// <summary>Type of service, EITHER or NON_ETHER</summary>
        [Newtonsoft.Json.JsonProperty("service_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Service_type { get; set; }
    
        /// <summary>Service type</summary>
        [Newtonsoft.Json.JsonProperty("service_entries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(50)]
        public System.Collections.Generic.ICollection<ServiceEntry> Service_entries { get; set; }
    
    
    }
    
    /// <summary>WafCRSApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWafCRSApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of WafCRS
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBWafCRS> Results { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer L4RulePortMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBL4RulePortMatch 
    {
        /// <summary>Range of TCP/UDP port numbers of the Virtual Service.</summary>
        [Newtonsoft.Json.JsonProperty("port_ranges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBPortRange> Port_ranges { get; set; }
    
        /// <summary>Virtual Service's listening port(s).
        /// Allowed values are 1-65535.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<long> Ports { get; set; }
    
        /// <summary>Criterion to use for Virtual Service port matching.
        /// Enum options - IS_IN, IS_NOT_IN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBL4RulePortMatchMatch_criteria Match_criteria { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for LBClientSslProfile, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildLBClientSslProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual LBClientSslProfile object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("LBClientSslProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public LBClientSslProfile LBClientSslProfile { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer ErrorPageBody object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBErrorPageBody : PolicyConfigResource
    {
        /// <summary>Error page body sent to client when match.</summary>
        [Newtonsoft.Json.JsonProperty("error_page_body", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error_page_body { get; set; }
    
        /// <summary>Format of an error page body HTML or JSON.
        /// Enum options - ERROR_PAGE_FORMAT_HTML,
        /// ERROR_PAGE_FORMAT_JSON.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as ERROR_PAGE_FORMAT_HTML.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("format", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBErrorPageBodyFormat? Format { get; set; } = SDKGenerator.ALBErrorPageBodyFormat.ERROR_PAGE_FORMAT_HTML;
    
    
    }
    
    /// <summary>Paged Collection of Endpoint Rules</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EndpointRuleListResult : ListResult
    {
        /// <summary>Endpoint Rule list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<EndpointRule> Results { get; set; } = new System.Collections.ObjectModel.Collection<EndpointRule>();
    
    
    }
    
    /// <summary>Detailed Realized Status of an intent object on an NSX-T type of enforcement point. This is
    /// a detailed view of the Realized Status of an intent object from an NSX-T enforcement point
    /// perspective.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EnforcedStatusDetailsNsxT 
    {
        /// <summary>Information about pending changes, if any, that aren't reflected in the Enforced Realized
        /// Status.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pending_changes_info", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PendingChangesInfoNsxT Pending_changes_info { get; set; }
    
        /// <summary>Information about the realized status of the intent on this enforcement point. Some very
        /// recent changes may be excluded when preparing this information, which is indicated by
        /// Pending Changes Info.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enforced_status_info", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EnforcedStatusInfoNsxT Enforced_status_info { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HTTPRedirectAction object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPRedirectAction 
    {
        /// <summary>Host config.</summary>
        [Newtonsoft.Json.JsonProperty("host", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBURIParam Host { get; set; }
    
        /// <summary>Protocol type.
        /// Enum options - HTTP, HTTPS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHTTPRedirectActionProtocol Protocol { get; set; }
    
        /// <summary>Path config.</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBURIParam Path { get; set; }
    
        /// <summary>Keep or drop the query of the incoming request URI in the
        /// redirected URI.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keep_query", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Keep_query { get; set; } = true;
    
        /// <summary>HTTP redirect status code.
        /// Enum options - HTTP_REDIRECT_STATUS_CODE_301,
        /// HTTP_REDIRECT_STATUS_CODE_302,
        /// HTTP_REDIRECT_STATUS_CODE_307.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// HTTP_REDIRECT_STATUS_CODE_302.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHTTPRedirectActionStatus_code? Status_code { get; set; } = SDKGenerator.ALBHTTPRedirectActionStatus_code.HTTP_REDIRECT_STATUS_CODE_302;
    
        /// <summary>Port to which redirect the request.
        /// Allowed values are 1-65535.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long? Port { get; set; }
    
    
    }
    
    /// <summary>Represents configuration of a Donut</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DonutConfiguration : WidgetConfiguration
    {
        /// <summary>Expression to retrieve count to be shown on Donut.</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Count { get; set; }
    
        /// <summary>Hyperlink of the specified UI page that provides details.</summary>
        [Newtonsoft.Json.JsonProperty("navigation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Navigation { get; set; }
    
        /// <summary>If true, displays the count of entities in the donut</summary>
        [Newtonsoft.Json.JsonProperty("display_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Display_count { get; set; } = true;
    
        /// <summary>Sections</summary>
        [Newtonsoft.Json.JsonProperty("sections", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<DonutSection> Sections { get; set; } = new System.Collections.ObjectModel.Collection<DonutSection>();
    
        /// <summary>Displayed at the middle of the donut, by default. It labels the entities of donut.</summary>
        [Newtonsoft.Json.JsonProperty("label", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Label Label { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyArpProxyTableListResult : ListResult
    {
        /// <summary>Paginated list of Gateway interface ARP proxy tables</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InterfaceArpProxy> Results { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DiscoveredNetwork object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDiscoveredNetwork 
    {
        /// <summary>Discovered network for this IP.
        /// It is a reference to an object of type Network.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("network_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Network_path { get; set; }
    
        /// <summary>Discovered subnet for this IP.</summary>
        [Newtonsoft.Json.JsonProperty("subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBIpAddrPrefix> Subnet { get; set; }
    
        /// <summary>Discovered IPv6 subnet for this IP.</summary>
        [Newtonsoft.Json.JsonProperty("subnet6", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBIpAddrPrefix> Subnet6 { get; set; }
    
    
    }
    
    /// <summary>Firewall related configurations</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("DfwFirewallConfiguration", typeof(DfwFirewallConfiguration))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FirewallConfiguration : PolicyConfigResource
    {
        /// <summary>To disable auto drafts, set it to true.
        /// By default, auto drafts are enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disable_auto_drafts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Disable_auto_drafts { get; set; } = false;
    
        /// <summary>If set to true, Firewall is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_firewall", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_firewall { get; set; } = true;
    
    
    }
    
    /// <summary>Advanced load balancer DnsRuleActionResponse object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsRuleActionResponse 
    {
        /// <summary>DNS response is authoritative.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authoritative", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Authoritative { get; set; } = true;
    
        /// <summary>DNS resource record sets - (resource record set share the
        /// DNS domain name, type, and class).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resource_record_sets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDnsRuleDnsRrSet> Resource_record_sets { get; set; }
    
        /// <summary>DNS response code.
        /// Enum options - DNS_RCODE_NOERROR, DNS_RCODE_FORMERR,
        /// DNS_RCODE_SERVFAIL, DNS_RCODE_NXDOMAIN, DNS_RCODE_NOTIMP,
        /// DNS_RCODE_REFUSED, DNS_RCODE_YXDOMAIN, DNS_RCODE_YXRRSET,
        /// DNS_RCODE_NXRRSET, DNS_RCODE_NOTAUTH, DNS_RCODE_NOTZONE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as DNS_RCODE_NOERROR.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rcode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBDnsRuleActionResponseRcode? Rcode { get; set; } = SDKGenerator.ALBDnsRuleActionResponseRcode.DNS_RCODE_NOERROR;
    
        /// <summary>DNS response is truncated.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("truncation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Truncation { get; set; } = false;
    
    
    }
    
    /// <summary>Represents the Site resource information for a Span entity
    /// including both the internal id as well as the site path.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SpanSiteInfo 
    {
        /// <summary>Path of the Site resource
        /// </summary>
        [Newtonsoft.Json.JsonProperty("site_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Site_path { get; set; }
    
        /// <summary>Site UUID representing the Site resource
        /// </summary>
        [Newtonsoft.Json.JsonProperty("site_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Site_id { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for VhcDnsConfig, used in hierarchical API
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildVhcDnsConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual VhcDnsConfig object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("VhcDnsConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public VhcDnsConfig VhcDnsConfig { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CapacityThreshold 
    {
        /// <summary>Set the maximum threshold percentage. Specify a value between 0 and
        /// 100. Usage percentage above this value is tagged as critical.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_threshold_percentage", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 100)]
        public double Max_threshold_percentage { get; set; }
    
        /// <summary>Indicate the object type for which threshold is to be set.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("threshold_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Threshold_type { get; set; }
    
        /// <summary>Set the minimum threshold percentage. Specify a value between 0 and
        /// 100. Usage percentage above this value is tagged as warning.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("min_threshold_percentage", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 100)]
        public double Min_threshold_percentage { get; set; }
    
    
    }
    
    /// <summary>VPN session defines connection between local and peer endpoint. Until VPN session is defined configuration is not realized.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("PolicyBasedIPSecVpnSession", typeof(PolicyBasedIPSecVpnSession))]
    [JsonInheritanceAttribute("RouteBasedIPSecVpnSession", typeof(RouteBasedIPSecVpnSession))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnSession : PolicyConfigResource
    {
        /// <summary>IPSec Pre-shared key. Maximum length of this field is 128 characters.</summary>
        [Newtonsoft.Json.JsonProperty("psk", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Psk { get; set; }
    
        /// <summary>Policy path referencing Dead Peer Detection (DPD) profile. Default is set to system default profile.</summary>
        [Newtonsoft.Json.JsonProperty("dpd_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dpd_profile_path { get; set; }
    
        /// <summary>Policy path referencing IKE profile to be used. Default is set according to system default profile.</summary>
        [Newtonsoft.Json.JsonProperty("ike_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ike_profile_path { get; set; }
    
        /// <summary>Enable/Disable IPSec VPN session.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
        /// <summary>Connection initiation mode used by local endpoint to
        /// establish ike connection with peer site.
        /// INITIATOR - In this mode local endpoint initiates
        /// tunnel setup and will also respond to incoming tunnel
        /// setup requests from peer gateway.
        /// RESPOND_ONLY - In this mode, local endpoint shall only
        /// respond to incoming tunnel setup requests. It shall not
        /// initiate the tunnel setup.
        /// ON_DEMAND - In this mode local endpoint will initiate
        /// tunnel creation once first packet matching the policy
        /// rule is received and will also respond to incoming
        /// initiation request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("connection_initiation_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPSecVpnSessionConnection_initiation_mode? Connection_initiation_mode { get; set; } = SDKGenerator.IPSecVpnSessionConnection_initiation_mode.INITIATOR;
    
        /// <summary>Policy path referencing Local endpoint.</summary>
        [Newtonsoft.Json.JsonProperty("local_endpoint_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Local_endpoint_path { get; set; }
    
        /// <summary>Policy path referencing Tunnel profile to be used. Default is set to system default profile.</summary>
        [Newtonsoft.Json.JsonProperty("tunnel_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tunnel_profile_path { get; set; }
    
        /// <summary>Compliance suite.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("compliance_suite", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPSecVpnSessionCompliance_suite? Compliance_suite { get; set; }
    
        /// <summary>TCP Maximum Segment Size Clamping Direction and Value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tcp_mss_clamping", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TcpMaximumSegmentSizeClamping Tcp_mss_clamping { get; set; }
    
        /// <summary>Peer authentication mode.
        /// PSK - In this mode a secret key shared between local and
        /// peer sites is to be used for authentication. The secret
        /// key can be a string with a maximum length of 128 characters.
        /// CERTIFICATE - In this mode a certificate defined at the
        /// global level is to be used for authentication.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authentication_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPSecVpnSessionAuthentication_mode? Authentication_mode { get; set; } = SDKGenerator.IPSecVpnSessionAuthentication_mode.PSK;
    
        /// <summary>Peer ID to uniquely identify the peer site. The peer ID is the public IP address of the remote device terminating the VPN tunnel. When NAT is configured for the peer, enter the private IP address of the peer.</summary>
        [Newtonsoft.Json.JsonProperty("peer_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Peer_id { get; set; }
    
        /// <summary>Public IPV4 address of the remote device terminating the VPN connection.</summary>
        [Newtonsoft.Json.JsonProperty("peer_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Peer_address { get; set; }
    
    
    }
    
    /// <summary>Paged collection of StaticRouteBfdPeer.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class StaticRouteBfdPeerListResult : ListResult
    {
        /// <summary>StaticRouteBfdPeer list results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<StaticRouteBfdPeer> Results { get; set; } = new System.Collections.ObjectModel.Collection<StaticRouteBfdPeer>();
    
    
    }
    
    /// <summary>Appliance registration access token</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RegistrationToken 
    {
        /// <summary>Access token</summary>
        [Newtonsoft.Json.JsonProperty("token", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Token { get; set; }
    
        /// <summary>User delegated by token</summary>
        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User { get; set; }
    
        /// <summary>List results</summary>
        [Newtonsoft.Json.JsonProperty("roles", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Roles { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>Enables OSPF authentication with specified mode and password.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OspfAuthenticationConfig 
    {
        /// <summary>Authentication secret key id is mandatory for type md5 with min value of 1 and max value 255.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 255D)]
        public long? Key_id { get; set; }
    
        /// <summary>Authentication secret is mandatory for type password and md5 with min length of 1 and max length 8.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secret_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Secret_key { get; set; }
    
        /// <summary>If mode is MD5 or PASSWORD, Authentication secret key is mandatory
        /// if mode is NONE, then authentication is disabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OspfAuthenticationConfigMode? Mode { get; set; } = SDKGenerator.OspfAuthenticationConfigMode.NONE;
    
    
    }
    
    /// <summary>Child wrapper object for SegmentMonitoringProfileBindingMap, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildSegmentMonitoringProfileBindingMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual SegmentMonitoringProfileBindingMap object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("SegmentMonitoringProfileBindingMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SegmentMonitoringProfileBindingMap SegmentMonitoringProfileBindingMap { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DhcpLeasesResult : DhcpLeases
    {
        /// <summary>Policy path to Segment, Tier0 or Tier1 gateway where DHCP server
        /// is attached.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("connectivity_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Connectivity_path { get; set; }
    
    
    }
    
    /// <summary>L2VPN Session Status Per Enforcement Point.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("L2VPNSessionStatusNsxT", typeof(L2VPNSessionStatusNsxT))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VPNSessionStatusPerEP : PolicyRuntimeInfoPerEP
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TransportProtocolHeader 
    {
        /// <summary>UDP header</summary>
        [Newtonsoft.Json.JsonProperty("udp_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public UdpHeader Udp_header { get; set; }
    
        /// <summary>DHCP header</summary>
        [Newtonsoft.Json.JsonProperty("dhcp_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DhcpHeader Dhcp_header { get; set; }
    
        /// <summary>TCP header</summary>
        [Newtonsoft.Json.JsonProperty("tcp_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TcpHeader Tcp_header { get; set; }
    
        /// <summary>ICMP echo request header</summary>
        [Newtonsoft.Json.JsonProperty("icmp_echo_request_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IcmpEchoRequestHeader Icmp_echo_request_header { get; set; }
    
        /// <summary>DHCP v6 header</summary>
        [Newtonsoft.Json.JsonProperty("dhcpv6_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Dhcpv6Header Dhcpv6_header { get; set; }
    
        /// <summary>Neighbor discovery protocol header</summary>
        [Newtonsoft.Json.JsonProperty("ndp_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NdpHeader Ndp_header { get; set; }
    
        /// <summary>DNS header</summary>
        [Newtonsoft.Json.JsonProperty("dns_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DnsHeader Dns_header { get; set; }
    
    
    }
    
    /// <summary>Provides FullSync state for Local Manager from Global Manager.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FullSyncState : PolicyConfigResource
    {
        /// <summary>Timestamp of last update, could be progress or success or error.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_time { get; set; }
    
        /// <summary>Errors occurred during full sync.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Errors { get; set; }
    
        /// <summary>Full sync id generated by Async Replicator (AR) service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("full_sync_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Full_sync_id { get; set; }
    
        /// <summary>Timestamp of Full Sync start.</summary>
        [Newtonsoft.Json.JsonProperty("start_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Start_time { get; set; }
    
        /// <summary>Deprecated, refer to last_update_time for the last update time stamp.</summary>
        [Newtonsoft.Json.JsonProperty("last_upate_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_upate_time { get; set; }
    
        /// <summary>The current stage of full sync completion for ongoing sync.
        /// When Local Manager (LM) receives full sync data from AR, LM starts
        /// with workflow to prserve the state and restore the full sync from
        /// where it has left off in case of change of leadership of the service
        /// to different NSX node or LM is restarted.
        /// LM starts the full sync workflow with state INITIAL capturing the
        /// AR full sync id and data location details. The stage/state transition
        /// follows the order given below
        /// INITIAL - Full sync started
        /// PROCESSED_FULLSYNC_DATA - Compelted processing the full state data
        ///                           provided by AR
        /// PRCESSED_DELTAS - Completed processing pending delta changes provided
        ///                   by AR.
        /// DELETED_STALE_ENTITIES - Completed deletion of all global entities on
        ///                          LM that are not in GM anymore
        /// COMPLETED - Full sync handling is completed on LM
        /// ERROR - Full sync failed with errors on LM, in which case AR will
        ///         re-attempt full sync later point in time for the LM
        /// ABORTED - Indicates that the full sync cancelled as per user request
        /// </summary>
        [Newtonsoft.Json.JsonProperty("last_completed_stage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FullSyncStateLast_completed_stage? Last_completed_stage { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer AppLearningConfidenceOverride object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAppLearningConfidenceOverride 
    {
        /// <summary>Confidence threshold for label CONFIDENCE_LOW.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 7500.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("confid_low_value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Confid_low_value { get; set; } = 7500L;
    
        /// <summary>Confidence threshold for label CONFIDENCE_PROBABLE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 9000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("confid_probable_value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Confid_probable_value { get; set; } = 9000L;
    
        /// <summary>Confidence threshold for label CONFIDENCE_VERY_HIGH.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 9999.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("confid_very_high_value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Confid_very_high_value { get; set; } = 9999L;
    
        /// <summary>Confidence threshold for label CONFIDENCE_HIGH.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 9500.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("confid_high_value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Confid_high_value { get; set; } = 9500L;
    
    
    }
    
    /// <summary>Advanced load balancer HealthMonitor object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHealthMonitor : PolicyConfigResource
    {
        /// <summary>Use this port instead of the port defined for the server in
        /// the Pool.
        /// If the monitor succeeds to this port, the load balanced
        /// traffic will still be sent to the port of the server defined
        /// within the Pool.
        /// Allowed values are 1-65535.
        /// Special values are 0 - 'Use server port'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("monitor_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Monitor_port { get; set; }
    
        /// <summary>Placeholder for description of property https_monitor of
        /// obj type HealthMonitor field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("https_monitor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHealthMonitorHttp Https_monitor { get; set; }
    
        /// <summary>A valid response from the server is expected within the
        /// receive timeout window.
        /// This timeout must be less than the send interval.
        /// If server status is regularly flapping up and down,
        /// consider increasing this value.
        /// Allowed values are 1-2400.
        /// Unit is SEC.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 4.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receive_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2400D)]
        public long? Receive_timeout { get; set; } = 4L;
    
        /// <summary>During addition of a server or healthmonitors or during
        /// bootup, Avi performs sequential health checks rather than
        /// waiting for send-interval to kick in, to mark the server up
        /// as soon as possible.
        /// This knob may be used to turn this feature off.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disable_quickstart", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Disable_quickstart { get; set; }
    
        /// <summary>Health monitor for Radius.</summary>
        [Newtonsoft.Json.JsonProperty("radius_monitor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHealthMonitorRadius Radius_monitor { get; set; }
    
        /// <summary>Placeholder for description of property dns_monitor of obj
        /// type HealthMonitor field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dns_monitor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHealthMonitorDNS Dns_monitor { get; set; }
    
        /// <summary>This field describes the object's replication scope.
        /// If the field is set to false, then the object is visible
        /// within the controller-cluster and its associated
        /// service-engines.
        /// If the field is set to true, then the object is replicated
        /// across the federation.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_federated", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_federated { get; set; } = false;
    
        /// <summary>Health monitor for SIP.</summary>
        [Newtonsoft.Json.JsonProperty("sip_monitor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHealthMonitorSIP Sip_monitor { get; set; }
    
        /// <summary>Placeholder for description of property tcp_monitor of obj
        /// type HealthMonitor field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tcp_monitor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHealthMonitorTcp Tcp_monitor { get; set; }
    
        /// <summary>Authentication information for username/password.</summary>
        [Newtonsoft.Json.JsonProperty("authentication", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHealthMonitorAuthInfo Authentication { get; set; }
    
        /// <summary>Frequency, in seconds, that monitors are sent to a server.
        /// Allowed values are 1-3600.
        /// Unit is SEC.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 10.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("send_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 3600D)]
        public long? Send_interval { get; set; } = 10L;
    
        /// <summary>Placeholder for description of property udp_monitor of obj
        /// type HealthMonitor field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("udp_monitor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHealthMonitorUdp Udp_monitor { get; set; }
    
        /// <summary>Type of the health monitor.
        /// Enum options - HEALTH_MONITOR_PING, HEALTH_MONITOR_TCP,
        /// HEALTH_MONITOR_HTTP, HEALTH_MONITOR_HTTPS,
        /// HEALTH_MONITOR_EXTERNAL, HEALTH_MONITOR_UDP,
        /// HEALTH_MONITOR_DNS, HEALTH_MONITOR_GSLB, HEALTH_MONITOR_SIP,
        /// HEALTH_MONITOR_RADIUS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHealthMonitorType Type { get; set; }
    
        /// <summary>Placeholder for description of property http_monitor of obj
        /// type HealthMonitor field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("http_monitor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHealthMonitorHttp Http_monitor { get; set; }
    
        /// <summary>Placeholder for description of property external_monitor of
        /// obj type HealthMonitor field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("external_monitor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHealthMonitorExternal External_monitor { get; set; }
    
        /// <summary>By default, multiple instances of the same healthmonitor to
        /// the same server are suppressed intelligently.
        /// In rare cases, the monitor may have specific constructs
        /// that go beyond the server keys (ip, port, etc.) during which
        /// such suppression is not desired.
        /// Use this knob to allow duplicates.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allow_duplicate_monitors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Allow_duplicate_monitors { get; set; }
    
        /// <summary>Number of continuous failed health checks before the server
        /// is marked down.
        /// Allowed values are 1-50.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 2.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("failed_checks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 50D)]
        public long? Failed_checks { get; set; } = 2L;
    
        /// <summary>Number of continuous successful health checks before server
        /// is marked up.
        /// Allowed values are 1-50.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 2.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("successful_checks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 50D)]
        public long? Successful_checks { get; set; } = 2L;
    
    
    }
    
    /// <summary>Paged collection of Tier-0s</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier0ListResult : ListResult
    {
        /// <summary>Tier-0 list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Tier0> Results { get; set; } = new System.Collections.ObjectModel.Collection<Tier0>();
    
    
    }
    
    /// <summary>Realized firewall</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("RealizedFirewallSection", typeof(RealizedFirewallSection))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedFirewall : PolicyRealizedResource
    {
    
    }
    
    /// <summary>Contains Static ARP configuration for Segment.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class StaticARPConfig : PolicyConfigResource
    {
        /// <summary>IP Address</summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ip_address { get; set; }
    
        /// <summary>MAC Address</summary>
        [Newtonsoft.Json.JsonProperty("mac_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Mac_address { get; set; }
    
    
    }
    
    /// <summary>Status of the Identity Firewall enabled Compute collection
    /// transport nodes.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdfwTransportNodeStatusListResult : ListResult
    {
        /// <summary>List of transport node ids and  status for idfw enabled
        /// Compute collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IdfwTransportNodeStatus> Results { get; set; } = new System.Collections.ObjectModel.Collection<IdfwTransportNodeStatus>();
    
    
    }
    
    /// <summary>LBPoolStatistics on specific Enforcement Point</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("LBPoolStatistics", typeof(LBPoolStatistics))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBPoolStatisticsPerEP : PolicyRuntimeInfoPerEP
    {
    
    }
    
    /// <summary>Identity Firewall user login/session data for a single user.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdfwUserStats 
    {
        /// <summary>AD user Identifier (String ID)</summary>
        [Newtonsoft.Json.JsonProperty("user_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User_id { get; set; }
    
        /// <summary>List of active (still logged in) user login/sessions data (no limit)</summary>
        [Newtonsoft.Json.JsonProperty("active_sessions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IdfwUserSessionData> Active_sessions { get; set; } = new System.Collections.ObjectModel.Collection<IdfwUserSessionData>();
    
        /// <summary>Optional list of up to 5 most recent archived (previously logged in) user
        /// login/session data.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("archived_sessions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IdfwUserSessionData> Archived_sessions { get; set; }
    
    
    }
    
    /// <summary>Identity Firewall statistics data.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdfwSystemStats 
    {
        /// <summary>Number of concurrent logged on users (across VDI &amp; RDSH).  Multiple
        /// logins by the same user is counted as 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("num_concurrent_users", Required = Newtonsoft.Json.Required.Always)]
        public long Num_concurrent_users { get; set; }
    
        /// <summary>Number of active user sessions/logins in IDFW enabled compute collections
        /// (including both UP and DOWN hosts).  N sessions/logins by the same user
        /// is counted as n.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("num_user_sessions", Required = Newtonsoft.Json.Required.Always)]
        public long Num_user_sessions { get; set; }
    
    
    }
    
    /// <summary>Tag operation status for particular resource type and resource ids.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ResourceTypeTagStatus 
    {
        /// <summary>List of resources on which tag needs to be applied
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resource_tag_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ResourceTagStatus> Resource_tag_status { get; set; }
    
        /// <summary>Resource type</summary>
        [Newtonsoft.Json.JsonProperty("resource_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Resource_type { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for FloodProtectionProfile,
    /// used in hierarchical API
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildFloodProtectionProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual FloodProtectionProfile object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("FloodProtectionProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public FloodProtectionProfile FloodProtectionProfile { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HTTPVersionMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPVersionMatch 
    {
        /// <summary>HTTP protocol version.
        /// Enum options - ZERO_NINE, ONE_ZERO, ONE_ONE, TWO_ZERO.
        /// Minimum of 1 items required.
        /// Maximum of 8 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("versions", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Versions> Versions { get; set; } = new System.Collections.ObjectModel.Collection<Versions>();
    
        /// <summary>Criterion to use for HTTP version matching the version used
        /// in the HTTP request.
        /// Enum options - IS_IN, IS_NOT_IN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHTTPVersionMatchMatch_criteria Match_criteria { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of Service entries</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServiceEntryListResult : ListResult
    {
        /// <summary>Service entry list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ServiceEntry> Results { get; set; } = new System.Collections.ObjectModel.Collection<ServiceEntry>();
    
    
    }
    
    /// <summary>Child wrapper for ALBServerAutoScalePolicy, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBServerAutoScalePolicy : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBServerAutoScalePolicy object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBServerAutoScalePolicy", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBServerAutoScalePolicy ALBServerAutoScalePolicy { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of LBServiceStatisticsPerEP</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregateLBServiceStatistics : AggregatePolicyRuntimeInfo
    {
        /// <summary>LBServiceStatisticsPerEP list results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBServiceStatisticsPerEP> Results { get; set; }
    
    
    }
    
    /// <summary>Snat Translation.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "type")]
    [JsonInheritanceAttribute("LBSnatAutoMap", typeof(LBSnatAutoMap))]
    [JsonInheritanceAttribute("LBSnatDisabled", typeof(LBSnatDisabled))]
    [JsonInheritanceAttribute("LBSnatIpPool", typeof(LBSnatIpPool))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBSnatTranslation 
    {
    
    }
    
    /// <summary>Virtual Machine Details</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VirtualMachineDetails : Resource
    {
        /// <summary>List of active (still logged in) user login/session data (no limit).</summary>
        [Newtonsoft.Json.JsonProperty("active_sessions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<UserSession> Active_sessions { get; set; }
    
        /// <summary>Optional list of up to 5 most recent archived (previously logged in) user login/session data.</summary>
        [Newtonsoft.Json.JsonProperty("archived_sessions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<UserSession> Archived_sessions { get; set; }
    
    
    }
    
    /// <summary>PIM profile.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyPimProfile : PolicyConfigResource
    {
        /// <summary>Static IPv4 multicast address and assciated multicast groups configuration.</summary>
        [Newtonsoft.Json.JsonProperty("rp_address_multicast_ranges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RpAddressMulticastRanges> Rp_address_multicast_ranges { get; set; }
    
        /// <summary>Enable/disable bootstrap messaging Configuration.</summary>
        [Newtonsoft.Json.JsonProperty("bsm_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Bsm_enabled { get; set; } = true;
    
        /// <summary>Static IPv4 multicast address configuration.</summary>
        [Newtonsoft.Json.JsonProperty("rp_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rp_address { get; set; }
    
    
    }
    
    /// <summary>Duplicate address detection status for IP address on the interface.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class InterfaceIPv6DADStatus 
    {
        /// <summary>DAD status for IP address on the port.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InterfaceIPv6DADStatusStatus? Status { get; set; }
    
        /// <summary>Array of edge nodes on which DAD status is reported for
        /// given IP address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Edge_paths { get; set; }
    
        /// <summary>IP address on the port for which DAD status is reported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ip_address { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for SegmentDiscoveryProfileBindingMap, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildSegmentDiscoveryProfileBindingMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual SegmentDiscoveryProfileBindingMap object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("SegmentDiscoveryProfileBindingMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SegmentDiscoveryProfileBindingMap SegmentDiscoveryProfileBindingMap { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer VipPlacementNetwork object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBVipPlacementNetwork 
    {
        /// <summary>Network to use for vip placement.
        /// It is a reference to an object of type Network.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("network_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Network_path { get; set; }
    
        /// <summary>IPv4 Subnet to use for vip placement.</summary>
        [Newtonsoft.Json.JsonProperty("subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddrPrefix Subnet { get; set; }
    
        /// <summary>IPv6 subnet to use for vip placement.</summary>
        [Newtonsoft.Json.JsonProperty("subnet6", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddrPrefix Subnet6 { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for RedirectionPolicy used in Hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildRedirectionPolicy : ChildPolicyConfigResource
    {
        /// <summary>Contains actual RedirectionPolicy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("RedirectionPolicy", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public RedirectionPolicy RedirectionPolicy { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of Edge Node</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyEdgeNodeListResult : ListResult
    {
        /// <summary>Edge Node list result.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyEdgeNode> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyEdgeNode>();
    
    
    }
    
    /// <summary>User login session information</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class UserSession 
    {
        /// <summary>Logout time if applicable.  An active user session has no logout time.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("logout_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Logout_time { get; set; }
    
        /// <summary>Login time.</summary>
        [Newtonsoft.Json.JsonProperty("login_time", Required = Newtonsoft.Json.Required.Always)]
        public long Login_time { get; set; }
    
        /// <summary>AD user name.</summary>
        [Newtonsoft.Json.JsonProperty("user_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string User_name { get; set; }
    
        /// <summary>AD Domain of user.</summary>
        [Newtonsoft.Json.JsonProperty("domain_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Domain_name { get; set; }
    
        /// <summary>User session ID. This also indicates whether this is VDI / RDSH.</summary>
        [Newtonsoft.Json.JsonProperty("user_session_id", Required = Newtonsoft.Json.Required.Always)]
        public long User_session_id { get; set; }
    
    
    }
    
    /// <summary>Realized Service</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("RealizedNSService", typeof(RealizedNSService))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedService : PolicyRealizedResource
    {
    
    }
    
    /// <summary>Paged collection of DhcpRelayConfigs</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DhcpRelayConfigListResult : ListResult
    {
        /// <summary>DhcpRelayConfig results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<DhcpRelayConfig> Results { get; set; } = new System.Collections.ObjectModel.Collection<DhcpRelayConfig>();
    
    
    }
    
    /// <summary>List of entities where Service Insertion will not be enforced. Exclusion List can contain PolicyGroup(s) or SegmentPort(s) or Segment(s).</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicySIExcludeList : PolicyConfigResource
    {
        /// <summary>List of the members in the exclude list</summary>
        [Newtonsoft.Json.JsonProperty("members", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(100)]
        public System.Collections.Generic.ICollection<string> Members { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>Summarized view of all IPSec VPN sessions for a specified service.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyIpsecVpnIkeServiceSummary : PolicyIpsecVpnSessionSummary
    {
        /// <summary>Display name of IPSec VPN service</summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Display_name { get; set; }
    
        /// <summary>Policy path of IPSec VPN service</summary>
        [Newtonsoft.Json.JsonProperty("ipsec_vpn_service_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ipsec_vpn_service_path { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyMetadataProxyStatistics 
    {
        /// <summary>timestamp of the statistics</summary>
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Always)]
        public long Timestamp { get; set; }
    
        /// <summary>Policy path of metadata proxy configuration</summary>
        [Newtonsoft.Json.JsonProperty("metadata_proxy_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Metadata_proxy_path { get; set; }
    
        /// <summary>Metadata Proxy statistics per segment</summary>
        [Newtonsoft.Json.JsonProperty("statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MetadataProxyStatisticsPerSegment> Statistics { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBSSOPolicy, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBSSOPolicy : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBSSOPolicy object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBSSOPolicy", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBSSOPolicy ALBSSOPolicy { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DhcpStaticBindingConfigListResult : ListResult
    {
        /// <summary>Paginated list of DhcpStaticBindingConfig</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<DhcpStaticBindingConfig> Results { get; set; } = new System.Collections.ObjectModel.Collection<DhcpStaticBindingConfig>();
    
    
    }
    
    /// <summary>Child wrapper object for PolicyServiceInstance used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyServiceChain : ChildPolicyConfigResource
    {
        /// <summary>Contains actual PolicyServiceChain.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyServiceChain", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyServiceChain PolicyServiceChain { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentL2ForwarderSiteSpanInfo 
    {
        /// <summary>Timestamp when the L2 forwarder remote mac addresses was last updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>Inter-site forwarder status per node.</summary>
        [Newtonsoft.Json.JsonProperty("inter_site_forwarder_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<L2ForwarderStatusPerNode> Inter_site_forwarder_status { get; set; }
    
        /// <summary>L2 forwarder remote mac addresses per site for logical switch.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remote_macs_per_site", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<L2ForwarderRemoteMacsPerSite> Remote_macs_per_site { get; set; }
    
        /// <summary>Policy path of a segment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("segment_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Segment_path { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HealthMonitorAuthInfo object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHealthMonitorAuthInfo 
    {
        /// <summary>Username for server authentication.</summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Username { get; set; }
    
        /// <summary>Password for server authentication.</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Password { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VmToolsInfo : DiscoveredResource
    {
        /// <summary>Reference of the Host or Public Cloud Gateway that reported the VM.</summary>
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceReference Source { get; set; }
    
        /// <summary>Type of VM - Edge, Service or other.</summary>
        [Newtonsoft.Json.JsonProperty("vm_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public VmToolsInfoVm_type? Vm_type { get; set; }
    
        /// <summary>Version of network agent on the VM of a third party partner solution.</summary>
        [Newtonsoft.Json.JsonProperty("network_agent_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Network_agent_version { get; set; }
    
        /// <summary>Id of the VM which is assigned locally by the host. It is the VM-moref on ESXi hosts, in other environments it is VM UUID.</summary>
        [Newtonsoft.Json.JsonProperty("host_local_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Host_local_id { get; set; }
    
        /// <summary>Current external id of this virtual machine in the system.</summary>
        [Newtonsoft.Json.JsonProperty("external_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string External_id { get; set; }
    
        /// <summary>Version of VMTools installed on the VM.</summary>
        [Newtonsoft.Json.JsonProperty("tools_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tools_version { get; set; }
    
        /// <summary>Endpoint Protection (Third party AV partner using NXGI) status on the VM. TRUE  - VM is configured and protected by EPP Service VM. FALSE - VM is either not configured for protection or VM is disconnected from EPP Service VM.</summary>
        [Newtonsoft.Json.JsonProperty("svm_connectivity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Svm_connectivity { get; set; }
    
        /// <summary>Version of file agent on the VM of a third party partner solution.</summary>
        [Newtonsoft.Json.JsonProperty("file_agent_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string File_agent_version { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for ServiceReference used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildServiceReference : ChildPolicyConfigResource
    {
        /// <summary>Contains actual ServiceReference.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ServiceReference", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ServiceReference ServiceReference { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HealthMonitorDNS object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHealthMonitorDNS 
    {
        /// <summary>When No Error is selected, a DNS query will be marked
        /// failed is any error code is returned by the server.
        /// With Any selected, the monitor ignores error code in the
        /// responses.
        /// Enum options - RCODE_NO_ERROR, RCODE_ANYTHING.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as RCODE_NO_ERROR.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rcode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHealthMonitorDNSRcode? Rcode { get; set; } = SDKGenerator.ALBHealthMonitorDNSRcode.RCODE_NO_ERROR;
    
        /// <summary>The resource record of the queried DNS server's response
        /// for the Request Name must include the IP address defined in
        /// this field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("response_string", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Response_string { get; set; }
    
        /// <summary>The DNS monitor will query the DNS server for the fully
        /// qualified name in this field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("query_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query_name { get; set; }
    
        /// <summary>Query_Type  Response has atleast one answer of which     
        /// the resource record type matches the query type   Any_Type 
        /// Response should contain atleast one answer  AnyThing  An
        /// empty answer is enough.
        /// Enum options - DNS_QUERY_TYPE, DNS_ANY_TYPE, DNS_ANY_THING.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as DNS_QUERY_TYPE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("qtype", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHealthMonitorDNSQtype? Qtype { get; set; } = SDKGenerator.ALBHealthMonitorDNSQtype.DNS_QUERY_TYPE;
    
        /// <summary>Resource record type used in the healthmonitor DNS query,
        /// only A or AAAA type supported.
        /// Enum options - DNS_RECORD_OTHER, DNS_RECORD_A,
        /// DNS_RECORD_NS, DNS_RECORD_CNAME, DNS_RECORD_SOA,
        /// DNS_RECORD_PTR, DNS_RECORD_HINFO, DNS_RECORD_MX,
        /// DNS_RECORD_TXT, DNS_RECORD_RP, DNS_RECORD_DNSKEY,
        /// DNS_RECORD_AAAA, DNS_RECORD_SRV, DNS_RECORD_OPT,
        /// DNS_RECORD_RRSIG, DNS_RECORD_AXFR, DNS_RECORD_ANY.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as DNS_RECORD_A.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("record_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHealthMonitorDNSRecord_type? Record_type { get; set; } = SDKGenerator.ALBHealthMonitorDNSRecord_type.DNS_RECORD_A;
    
    
    }
    
    /// <summary>Task query results</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TaskListResult : ListResult
    {
        /// <summary>Task property results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<TaskProperties> Results { get; set; } = new System.Collections.ObjectModel.Collection<TaskProperties>();
    
    
    }
    
    /// <summary>This object serves as a representation of the edge cluster
    /// index to which the edge node connects. It should not be
    /// mistaken for the edge / transport node itself. Consuming services
    /// can refer to the nsx_id property to fetch the UUID of the
    /// edge / transport node that is attached to this index.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyEdgeNode : PolicyConfigResource
    {
        /// <summary>The numerical value of the member index in the edge cluster
        /// that this object represents and to which the edge node connects.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("member_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Member_index { get; set; }
    
        /// <summary>UUID of edge node on NSX-T enforcement point.</summary>
        [Newtonsoft.Json.JsonProperty("nsx_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Nsx_id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LogicalRouterStatusPerNode 
    {
        /// <summary>A service router's HA status on an edge node</summary>
        [Newtonsoft.Json.JsonProperty("high_availability_status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LogicalRouterStatusPerNodeHigh_availability_status High_availability_status { get; set; }
    
        /// <summary>id of the service router where the router status is retrieved.</summary>
        [Newtonsoft.Json.JsonProperty("service_router_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Service_router_id { get; set; }
    
        /// <summary>id of the transport node where the router status is retrieved.</summary>
        [Newtonsoft.Json.JsonProperty("transport_node_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Transport_node_id { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer SamlSettings object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSamlSettings 
    {
        /// <summary>Configure service provider settings for the Controller.</summary>
        [Newtonsoft.Json.JsonProperty("sp", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBSamlServiceProviderSettings Sp { get; set; } = new ALBSamlServiceProviderSettings();
    
        /// <summary>Configure remote Identity provider settings.</summary>
        [Newtonsoft.Json.JsonProperty("idp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBSamlIdentityProviderSettings Idp { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for CommunicationEntry, used in hierarchical API This type is deprecated. Use the type ChildRule instead.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildCommunicationEntry : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual CommunicationEntry object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("CommunicationEntry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public CommunicationEntry CommunicationEntry { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for GeneralSecurityProfileBindingMap,
    /// used in hierarchical API
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildGeneralSecurityProfileBindingMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual GeneralSecurityProfileBindingMap object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("GeneralSecurityProfileBindingMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public GeneralSecurityProfileBindingMap GeneralSecurityProfileBindingMap { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer NetworkSecurityMatchTarget object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBNetworkSecurityMatchTarget 
    {
        /// <summary>Placeholder for description of property microservice of obj
        /// type NetworkSecurityMatchTarget field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("microservice", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBMicroServiceMatch Microservice { get; set; }
    
        /// <summary>Placeholder for description of property vs_port of obj type
        /// NetworkSecurityMatchTarget field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vs_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBPortMatch Vs_port { get; set; }
    
        /// <summary>Placeholder for description of property client_ip of obj
        /// type NetworkSecurityMatchTarget field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddrMatch Client_ip { get; set; }
    
    
    }
    
    /// <summary>Duplicate address detection status on the interface.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class InterfaceDADState 
    {
        /// <summary>Array of DAD status which contains DAD information for IP addresses
        /// on the interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dad_statuses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InterfaceIPv6DADStatus> Dad_statuses { get; set; }
    
        /// <summary>Policy path or realization ID of interface for which IPv6 DAD
        /// status is returned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("interface_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Interface_path { get; set; }
    
    
    }
    
    /// <summary>Credential info to connect to an NSX-V type of enforcement point.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class NSXVConnectionInfo : EnforcementPointConnectionInfo
    {
        /// <summary>Username.</summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Username { get; set; }
    
        /// <summary>Password.</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Password { get; set; }
    
        /// <summary>Thumbprint of EnforcementPoint in the form of a SHA-256 hash represented in lower case HEX.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thumbprint", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Thumbprint { get; set; }
    
    
    }
    
    /// <summary>Runtime Info Per Enforcement Point.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyRuntimeInfoPerEP 
    {
        /// <summary>Alarm information details.</summary>
        [Newtonsoft.Json.JsonProperty("alarm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PolicyRuntimeAlarm Alarm { get; set; }
    
        /// <summary>Policy Path referencing the enforcement point where the info is fetched.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enforcement_point_path { get; set; }
    
    
    }
    
    /// <summary>Multicast route details.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MulticastRoute 
    {
        /// <summary>Time for which multicast route entry is active.</summary>
        [Newtonsoft.Json.JsonProperty("uptime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uptime { get; set; }
    
        /// <summary>Multicast group address.</summary>
        [Newtonsoft.Json.JsonProperty("group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group { get; set; }
    
        /// <summary>Time-to-live value for multicast packets.</summary>
        [Newtonsoft.Json.JsonProperty("ttl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Ttl { get; set; }
    
        /// <summary>Ingress interface on which multicast traffic is learned.</summary>
        [Newtonsoft.Json.JsonProperty("input_interface", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Input_interface { get; set; }
    
        /// <summary>Multicast source address.</summary>
        [Newtonsoft.Json.JsonProperty("source_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source_address { get; set; }
    
        /// <summary>Egress interface on which multicast traffic is forwarded.</summary>
        [Newtonsoft.Json.JsonProperty("output_interface", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Output_interface { get; set; }
    
    
    }
    
    /// <summary>AutoScaleLaunchConfigApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAutoScaleLaunchConfigApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of AutoScaleLaunchConfig
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBAutoScaleLaunchConfig> Results { get; set; }
    
    
    }
    
    /// <summary>Static Route Bidirectional Forwarding Detection Peer</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class StaticRouteBfdPeer : PolicyConfigResource
    {
        /// <summary>Bfd Profile is not supported for IPv6 networks.</summary>
        [Newtonsoft.Json.JsonProperty("bfd_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bfd_profile_path { get; set; }
    
        /// <summary>Only IPv4 addresses are supported. Only a single BFD config per peer address is allowed.</summary>
        [Newtonsoft.Json.JsonProperty("peer_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Peer_address { get; set; }
    
        /// <summary>Array of Tier0 external interface IP addresses. BFD peering is established from all these source addresses to the neighbor specified in peer_address. Only IPv4 addresses are supported.</summary>
        [Newtonsoft.Json.JsonProperty("source_addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(8)]
        public System.Collections.Generic.ICollection<string> Source_addresses { get; set; }
    
        /// <summary>Flag to enable BFD peer.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
        /// <summary>Represents the array of policy paths of locale services where this BFD peer should
        /// get relalized on.
        /// The locale service service and this BFD peer must belong to the same router.
        /// Default scope is empty.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Scope { get; set; }
    
    
    }
    
    /// <summary>NSX-T Detailed Realized Status Per Scope.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("TransportNodeSpanEnforcedStatus", typeof(TransportNodeSpanEnforcedStatus))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EnforcedStatusPerScopeNsxT 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LogicalRouterPortStatistics 
    {
        /// <summary>Per Node Statistics</summary>
        [Newtonsoft.Json.JsonProperty("per_node_statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LogicalRouterPortStatisticsPerNode> Per_node_statistics { get; set; }
    
        /// <summary>The ID of the logical router port</summary>
        [Newtonsoft.Json.JsonProperty("logical_router_port_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Logical_router_port_id { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HealthMonitorExternal object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHealthMonitorExternal 
    {
        /// <summary>Command script provided inline.</summary>
        [Newtonsoft.Json.JsonProperty("command_code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Command_code { get; set; }
    
        /// <summary>Environment variables to be fed into the script.</summary>
        [Newtonsoft.Json.JsonProperty("command_variables", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Command_variables { get; set; }
    
        /// <summary>Optional arguments to feed into the script.</summary>
        [Newtonsoft.Json.JsonProperty("command_parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Command_parameters { get; set; }
    
        /// <summary>Path of external health monitor script.</summary>
        [Newtonsoft.Json.JsonProperty("command_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Command_path { get; set; }
    
    
    }
    
    /// <summary>Paged collection of IDS rules</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsRuleListResult : BaseRuleListResult
    {
        /// <summary>IDS rule list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IdsRule> Results { get; set; } = new System.Collections.ObjectModel.Collection<IdsRule>();
    
    
    }
    
    /// <summary>Child wrapper object for DeploymentZone, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildDeploymentZone : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual DeploymentZone object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("DeploymentZone", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public DeploymentZone DeploymentZone { get; set; }
    
    
    }
    
    /// <summary>Set Fields is an action to set fields of the source event.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SetFields : Action
    {
        /// <summary>Field Settings.</summary>
        [Newtonsoft.Json.JsonProperty("field_settings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<FieldSetting> Field_settings { get; set; }
    
    
    }
    
    /// <summary>Answer of nslookup</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class NsxTDnsQueryAnswer 
    {
        /// <summary>Matched name of the given address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Resolved IP address matched with the nslookup address provided
        /// as a request parameter.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Address { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for IpAddressPool, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIpAddressPool : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual IpAddressPool object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IpAddressPool", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IpAddressPool IpAddressPool { get; set; }
    
    
    }
    
    /// <summary>Wrapper object for StandaloneHostIdfwConfiguration</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildStandaloneHostIdfwConfiguration : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual standalone host idfw configuration object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("StandaloneHostIdfwConfiguration", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public StandaloneHostIdfwConfiguration StandaloneHostIdfwConfiguration { get; set; }
    
    
    }
    
    /// <summary>Metadata related to a given error_id</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ErrorResolverInfo 
    {
        /// <summary>The error id for which metadata information is needed</summary>
        [Newtonsoft.Json.JsonProperty("error_id", Required = Newtonsoft.Json.Required.Always)]
        public long Error_id { get; set; }
    
        /// <summary>Indicates whether there is a resolver associated with the error or not</summary>
        [Newtonsoft.Json.JsonProperty("resolver_present", Required = Newtonsoft.Json.Required.Always)]
        public bool Resolver_present { get; set; }
    
        /// <summary>User supplied metadata that might be required by the resolver</summary>
        [Newtonsoft.Json.JsonProperty("user_metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ErrorResolverUserMetadata User_metadata { get; set; }
    
    
    }
    
    /// <summary>Represents layout of a container or widget</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Layout 
    {
        /// <summary>Describes layout of a container or widget. Layout describes how individual widgets are placed inside the container. For example, if HORIZONTAL is chosen widgets are placed side by side inside the container. If VERTICAL is chosen then widgets are placed one below the other. If GRID is chosen then the container or widget display area is divided into a grid of m rows and n columns, as specified in the properties, and the widgets are placed inside the grid.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LayoutType? Type { get; set; } = SDKGenerator.LayoutType.HORIZONTAL;
    
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LayoutProperties Properties { get; set; }
    
    
    }
    
    /// <summary>Single route redistribution rule</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier0RouteRedistributionRule 
    {
        /// <summary>Each rule can have more than one destinations. If destinations not specified for a given rule,
        /// default destionation will be BGP
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Destinations> Destinations { get; set; }
    
        /// <summary>Route map to be associated with the redistribution rule</summary>
        [Newtonsoft.Json.JsonProperty("route_map_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Route_map_path { get; set; }
    
        /// <summary>Rule name</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>List of redistribution types</summary>
        [Newtonsoft.Json.JsonProperty("route_redistribution_types", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Route_redistribution_types> Route_redistribution_types { get; set; } = new System.Collections.ObjectModel.Collection<Route_redistribution_types>();
    
    
    }
    
    /// <summary>Aggregate of L2Vpn session remote mac across enforcement points.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregateL2VpnSessionRemoteMac : AggregatePolicyRuntimeInfo
    {
        /// <summary>List of L2Vpn Session remote mac</summary>
        [Newtonsoft.Json.JsonProperty("l2vpn_session_remote_macs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<L2VpnSessionRemoteMacPerEP> L2vpn_session_remote_macs { get; set; }
    
    
    }
    
    /// <summary>Remote server</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RemoteServerFingerprint 
    {
        /// <summary>SSH fingerprint of server</summary>
        [Newtonsoft.Json.JsonProperty("ssh_fingerprint", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ssh_fingerprint { get; set; }
    
        /// <summary>Server port</summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long? Port { get; set; } = 22L;
    
        /// <summary>Remote server hostname or IP address</summary>
        [Newtonsoft.Json.JsonProperty("server", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Server { get; set; }
    
    
    }
    
    /// <summary>Event Criterion is the logical evaluations by which the event may
    /// be deemed fulfilled. All the evaluations must be met in order for
    /// the criterion to be met (implicit AND).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Criterion 
    {
        /// <summary>Criterion Evaluations.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("evaluations", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<Evaluation> Evaluations { get; set; } = new System.Collections.ObjectModel.Collection<Evaluation>();
    
    
    }
    
    /// <summary>Advanced load balancer HealthMonitorSSLAttributes object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHealthMonitorSSLAttributes 
    {
        /// <summary>SSL profile defines ciphers and SSL versions to be used for
        /// healthmonitor traffic to the back-end servers.
        /// It is a reference to an object of type SSLProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ssl_profile_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ssl_profile_path { get; set; }
    
        /// <summary>PKI profile used to validate the SSL certificate presented
        /// by a server.
        /// It is a reference to an object of type PKIProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pki_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pki_profile_path { get; set; }
    
        /// <summary>Service engines will present this SSL certificate to the
        /// server.
        /// It is a reference to an object of type
        /// SSLKeyAndCertificate.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ssl_key_and_certificate_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ssl_key_and_certificate_path { get; set; }
    
        /// <summary>Fully qualified DNS hostname which will be used in the TLS
        /// SNI extension in server connections indicating SNI is
        /// enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Server_name { get; set; }
    
    
    }
    
    /// <summary>Node usage for load balancer contains basic information and LB entity
    /// usages and capacity for the given node. Only edge node is supported.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("LBEdgeNodeUsage", typeof(LBEdgeNodeUsage))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBNodeUsage 
    {
        /// <summary>The property identifies the node path for load balancer node usage.
        /// For example, node_path=/infra/sites/default/enforcement-points/default
        /// /edge-clusters/85175e0b-4d74-461d-83e1-f3b785adef9c/edge-nodes
        /// /86e077c0-449f-11e9-87c8-02004eb37029.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("node_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Node_path { get; set; }
    
    
    }
    
    /// <summary>Aggregate of IPSec VPN Session Status across Enforcement Points.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregateIPSecVpnSessionStatus : AggregatePolicyRuntimeInfo
    {
        /// <summary>List of IPSec VPN Session Status per Enforcement Point.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IPSecVpnSessionStatusPerEP> Results { get; set; }
    
    
    }
    
    /// <summary>Defines the tunnel local and peer addresses along with multiple
    /// tansport tunnels for redundancy. L2VPNSession belongs to only one
    /// L2VPNService.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VPNSession : PolicyConfigResource
    {
        /// <summary>TCP Maximum Segment Size Clamping Direction and Value. This feature is supported for L2VPN Sessions that are
        /// Server mode only.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tcp_mss_clamping", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public L2TcpMaxSegmentSizeClamping Tcp_mss_clamping { get; set; }
    
        /// <summary>List of transport tunnels for redundancy.</summary>
        [Newtonsoft.Json.JsonProperty("transport_tunnels", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Transport_tunnels { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Tunnel encapsulation config. This property only applies in CLIENT
        /// mode. It is auto-populated from the L2VPNSessionData.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tunnel_encapsulation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public L2VPNTunnelEncapsulation Tunnel_encapsulation { get; set; }
    
        /// <summary>Enable to extend all the associated segments.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
    
    }
    
    /// <summary>Paged Collection of LBServices</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBServiceListResult : ListResult
    {
        /// <summary>LBService list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<LBService> Results { get; set; } = new System.Collections.ObjectModel.Collection<LBService>();
    
    
    }
    
    /// <summary>L2VPN tunnel encapsulation config.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VPNTunnelEncapsulation 
    {
        /// <summary>IP Address of the local tunnel port. This property only applies in
        /// CLIENT mode.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("local_endpoint_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Local_endpoint_address { get; set; }
    
        /// <summary>Encapsulation protocol used by the tunnel.</summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public L2VPNTunnelEncapsulationProtocol? Protocol { get; set; } = SDKGenerator.L2VPNTunnelEncapsulationProtocol.GRE;
    
        /// <summary>IP Address of the peer tunnel port. This property only applies in
        /// CLIENT mode.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("peer_endpoint_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Peer_endpoint_address { get; set; }
    
    
    }
    
    /// <summary>A single respose in a list of batched responses</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BatchResponseItem 
    {
        /// <summary>object returned by api</summary>
        [Newtonsoft.Json.JsonProperty("body", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Body { get; set; }
    
        /// <summary>The headers returned by the API call</summary>
        [Newtonsoft.Json.JsonProperty("headers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Headers { get; set; }
    
        /// <summary>http status code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        public long Code { get; set; }
    
    
    }
    
    /// <summary>Footer of a widget that provides additional information or allows an action such as clickable url for navigation. An example usage of footer is provided under 'example_request' section of 'CreateWidgetConfiguration' API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Footer 
    {
        /// <summary>If the condition is met then the footer will be applied. Examples of expression syntax are provided under 'example_request' section of 'CreateWidgetConfiguration' API.</summary>
        [Newtonsoft.Json.JsonProperty("condition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Condition { get; set; }
    
        /// <summary>Action to be performed at the footer of a widget. An action at the footer can be simple text description or a hyperlink to a UI page. Action allows a clickable url for navigation. An example usage of footer action is provided under 'example_request' section of 'CreateWidgetConfiguration' API.</summary>
        [Newtonsoft.Json.JsonProperty("actions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FooterAction> Actions { get; set; }
    
    
    }
    
    /// <summary>Overall restore process status</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GlobalRestoreStatus 
    {
        /// <summary>A description of the restore status</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Global rolled-up restore status value</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public GlobalRestoreStatusValue? Value { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for EvpnTunnelEndpointConfig, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildEvpnTunnelEndpointConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual EvpnTunnelEndpointConfig object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("EvpnTunnelEndpointConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public EvpnTunnelEndpointConfig EvpnTunnelEndpointConfig { get; set; }
    
    
    }
    
    /// <summary>Route map entry</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RouteMapEntry 
    {
        /// <summary>Action for the route map entry
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RouteMapEntryAction Action { get; set; }
    
        /// <summary>Community list match criteria for route map.
        /// Properties community_list_matches and prefix_list_matches are mutually
        /// exclusive and cannot be used in the same route map entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("community_list_matches", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CommunityMatchCriteria> Community_list_matches { get; set; }
    
        /// <summary>Set criteria for route map entry
        /// </summary>
        [Newtonsoft.Json.JsonProperty("set", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RouteMapEntrySet Set { get; set; }
    
        /// <summary>Prefix list match criteria for route map.
        /// Properties community_list_matches and prefix_list_matches are mutually
        /// exclusive and cannot be used in the same route map entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("prefix_list_matches", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(500)]
        public System.Collections.Generic.ICollection<string> Prefix_list_matches { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer IpAddrPrefix object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBIpAddrPrefix 
    {
        /// <summary>Number of mask.</summary>
        [Newtonsoft.Json.JsonProperty("mask", Required = Newtonsoft.Json.Required.Always)]
        public long Mask { get; set; }
    
        /// <summary>Placeholder for description of property ip_addr of obj type
        /// IpAddrPrefix field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip_addr", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBIpAddr Ip_addr { get; set; } = new ALBIpAddr();
    
    
    }
    
    /// <summary>Detailed information about an API Error</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ApiError : RelatedApiError
    {
        /// <summary>Other errors related to this error</summary>
        [Newtonsoft.Json.JsonProperty("related_errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RelatedApiError> Related_errors { get; set; }
    
    
    }
    
    /// <summary>Paginated collection of policy resource references for enforcement point
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyResourceReferenceForEPListResult : ListResult
    {
        /// <summary>Paged Collection of policy resource references for enforcement point</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyResourceReferenceForEP> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyResourceReferenceForEP>();
    
    
    }
    
    /// <summary>Child wrapper object for PortQoSProfileBindingMap, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPortQoSProfileBindingMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PortQoSProfileBindingMap object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PortQoSProfileBindingMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PortQoSProfileBindingMap PortQoSProfileBindingMap { get; set; }
    
    
    }
    
    /// <summary>List of tags applied to the virtual machine. Based on the enforcement
    /// point, the virtual_machine_id will be different. It could be an external
    /// id for NSX T or a moid for NSX V
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VirtualMachineTagsUpdate 
    {
        /// <summary>The identifier that is used in the enforcement point that uniquely
        /// identifies the virtual machine. In case of NSXT it would be the
        /// value of the external_id of the virtual machine.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("virtual_machine_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Virtual_machine_id { get; set; }
    
        /// <summary>List of tags to be applied on the virtual machine
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Tag> Tags { get; set; } = new System.Collections.ObjectModel.Collection<Tag>();
    
    
    }
    
    /// <summary>Contains OSPF Area configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OspfAreaConfig : PolicyConfigResource
    {
        /// <summary>OSPF area-id either in decimal or dotted format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("area_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Area_id { get; set; }
    
        /// <summary>Enables/Disables authentication for an OSPF area.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authentication", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OspfAuthenticationConfig Authentication { get; set; }
    
        /// <summary>Configures OSPF area with defined area type. If area_type field not specified, default is NSSA.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("area_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OspfAreaConfigArea_type? Area_type { get; set; } = SDKGenerator.OspfAreaConfigArea_type.NORMAL;
    
    
    }
    
    /// <summary>Advanced load balancer CustomParams object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBCustomParams 
    {
        /// <summary>Placeholder for description of property is_dynamic of obj
        /// type CustomParams field type str  type boolean.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_dynamic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_dynamic { get; set; } = false;
    
        /// <summary>Placeholder for description of property is_sensitive of obj
        /// type CustomParams field type str  type boolean.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_sensitive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_sensitive { get; set; } = false;
    
        /// <summary>Name of the object.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>value of CustomParams.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBServerSslProfileListResult : ListResult
    {
        /// <summary>Paginated list of load balancer server SSL profiles</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<LBServerSslProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<LBServerSslProfile>();
    
    
    }
    
    /// <summary>Paged collection of IpAddressPools</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IpAddressPoolListResult : ListResult
    {
        /// <summary>IpAddressPool list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IpAddressPool> Results { get; set; } = new System.Collections.ObjectModel.Collection<IpAddressPool>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ClusterBackupInfoListResult : ListResult
    {
        /// <summary>List of timestamps of backed-up cluster files</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ClusterBackupInfo> Results { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer RateLimiterAction object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBRateLimiterAction 
    {
        /// <summary>Parameters for HTTP Redirect rate limit action.</summary>
        [Newtonsoft.Json.JsonProperty("redirect", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPRedirectAction Redirect { get; set; }
    
        /// <summary>HTTP status code for Local Response rate limit action.
        /// Enum options - HTTP_LOCAL_RESPONSE_STATUS_CODE_200,
        /// HTTP_LOCAL_RESPONSE_STATUS_CODE_204,
        /// HTTP_LOCAL_RESPONSE_STATUS_CODE_403,
        /// HTTP_LOCAL_RESPONSE_STATUS_CODE_404,
        /// HTTP_LOCAL_RESPONSE_STATUS_CODE_429,
        /// HTTP_LOCAL_RESPONSE_STATUS_CODE_501.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// HTTP_LOCAL_RESPONSE_STATUS_CODE_429.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBRateLimiterActionStatus_code? Status_code { get; set; } = SDKGenerator.ALBRateLimiterActionStatus_code.HTTP_LOCAL_RESPONSE_STATUS_CODE_429;
    
        /// <summary>Type of action to be enforced upon hitting the rate limit.
        /// Enum options - RL_ACTION_NONE, RL_ACTION_DROP_CONN,
        /// RL_ACTION_RESET_CONN, RL_ACTION_CLOSE_CONN,
        /// RL_ACTION_LOCAL_RSP, RL_ACTION_REDIRECT.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as RL_ACTION_NONE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBRateLimiterActionType? Type { get; set; } = SDKGenerator.ALBRateLimiterActionType.RL_ACTION_NONE;
    
        /// <summary>File to be used for HTTP Local response rate limit action.</summary>
        [Newtonsoft.Json.JsonProperty("file", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPLocalFile File { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DhcpHeader 
    {
        /// <summary>This is used to specify the general type of message. A client sending request to a server uses an op code of BOOTREQUEST, while a server replying uses an op code of BOOTREPLY.</summary>
        [Newtonsoft.Json.JsonProperty("op_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DhcpHeaderOp_code? Op_code { get; set; } = SDKGenerator.DhcpHeaderOp_code.BOOTREQUEST;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IpAddressPoolSubnetListResult : ListResult
    {
        /// <summary>IP Pool subnet list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IpAddressPoolSubnet> Results { get; set; } = new System.Collections.ObjectModel.Collection<IpAddressPoolSubnet>();
    
    
    }
    
    /// <summary>Advanced load balancer AttackMitigationAction object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAttackMitigationAction 
    {
        /// <summary>Deny the attack packets further processing and drop them.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("deny", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Deny { get; set; } = true;
    
    
    }
    
    /// <summary>Paged collection of IDS cluster configuration</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsClusterConfigListResult : ListResult
    {
        /// <summary>Cluster wise IDS configuration list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IdsClusterConfig> Results { get; set; } = new System.Collections.ObjectModel.Collection<IdsClusterConfig>();
    
    
    }
    
    /// <summary>Dropdown item definition</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DropdownItem 
    {
        /// <summary>An expression that represents the items of the dropdown filter.</summary>
        [Newtonsoft.Json.JsonProperty("field", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Field { get; set; }
    
        /// <summary>expression to extract display name to be shown in the drop down.</summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Display_name { get; set; }
    
        /// <summary>Value of filter inside dropdown filter.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for QoSProfile, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildQoSProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual QoSProfile object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("QoSProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public QoSProfile QoSProfile { get; set; }
    
    
    }
    
    /// <summary>OSPF route next hop result.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OspfRouteNextHopResult 
    {
        /// <summary>Check whether OSPF route is directly connected.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("directly_attached", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Directly_attached { get; set; }
    
        /// <summary>OSPF policy interface name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("interface_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Interface_name { get; set; }
    
        /// <summary>next-hop address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("neighbor_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Neighbor_address { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of IPSecVpnSession.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnSessionListResult : ListResult
    {
        /// <summary>IPSecVpnSession list results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IPSecVpnSession> Results { get; set; } = new System.Collections.ObjectModel.Collection<IPSecVpnSession>();
    
    
    }
    
    /// <summary>Multicast Forwarding Per Edge.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MulticastForwardingPerEdge 
    {
        [Newtonsoft.Json.JsonProperty("mcast_forwarding", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MulticastForwarding> Mcast_forwarding { get; set; }
    
        /// <summary>Policy path to edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Edge_path { get; set; }
    
    
    }
    
    /// <summary>DHCP IPv4 and IPv6 static bindings are extended from this abstract class.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("DhcpV4StaticBindingConfig", typeof(DhcpV4StaticBindingConfig))]
    [JsonInheritanceAttribute("DhcpV6StaticBindingConfig", typeof(DhcpV6StaticBindingConfig))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DhcpStaticBindingConfig : PolicyConfigResource
    {
    
    }
    
    /// <summary>Using this profile to configure different options of IP Discovery</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPDiscoveryProfile : PolicyConfigResource
    {
        /// <summary>This property controls the ARP and ND cache timeout period. It
        /// is recommended that this property be greater than the ARP/ND
        /// cache timeout on the VM.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("arp_nd_binding_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(5D, 120D)]
        public long? Arp_nd_binding_timeout { get; set; } = 10L;
    
        /// <summary>Indicates IPv6 Discovery options</summary>
        [Newtonsoft.Json.JsonProperty("ip_v6_discovery_options", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IPv6DiscoveryOptions Ip_v6_discovery_options { get; set; }
    
        /// <summary>Duplicate IP detection is used to determine if there is any IP conflict
        /// with any other port on the same logical switch. If a conflict is detected,
        /// then the IP is marked as a duplicate on the port where the IP was
        /// discovered last. The duplicate IP will not be added to the realized
        /// address binings for the port and hence will not be used in DFW rules or
        /// other security configurations for the port.rt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("duplicate_ip_detection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DuplicateIPDetectionOptions Duplicate_ip_detection { get; set; }
    
        /// <summary>Indicates whether "Trust on First Use(TOFU)" paradigm is enabled.</summary>
        [Newtonsoft.Json.JsonProperty("tofu_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Tofu_enabled { get; set; } = true;
    
        /// <summary>Indicates IPv4 Discovery options</summary>
        [Newtonsoft.Json.JsonProperty("ip_v4_discovery_options", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IPv4DiscoveryOptions Ip_v4_discovery_options { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TunnelSubnet 
    {
        /// <summary>Subnet ip addresses</summary>
        [Newtonsoft.Json.JsonProperty("ip_addresses", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Ip_addresses { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Subnet Prefix Length</summary>
        [Newtonsoft.Json.JsonProperty("prefix_length", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1D, 31D)]
        public long Prefix_length { get; set; }
    
    
    }
    
    /// <summary>Realized services</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedServices : PolicyRealizedResource
    {
        /// <summary>List of realized services</summary>
        [Newtonsoft.Json.JsonProperty("realized_services", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RealizedService> Realized_services { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBPoolStatistics : LBPoolStatisticsPerEP
    {
        /// <summary>Timestamp when the data was last updated.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>Virtual server statistics counter.</summary>
        [Newtonsoft.Json.JsonProperty("statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LBStatisticsCounter Statistics { get; set; }
    
        /// <summary>Load balancer pool object path.</summary>
        [Newtonsoft.Json.JsonProperty("pool_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pool_path { get; set; }
    
        /// <summary>Statistics of load balancer pool members.</summary>
        [Newtonsoft.Json.JsonProperty("members", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBPoolMemberStatistics> Members { get; set; }
    
    
    }
    
    /// <summary>Virtual server acts as a facade to an application, receives all client
    /// connections over TCP and distributes them among the backend servers.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TcpPolicyLbVirtualServer : PolicyLbVirtualServer
    {
    
    }
    
    /// <summary>Information about a single LDAP server.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdentitySourceLdapServer 
    {
        /// <summary>If using LDAPS or STARTTLS, provide the X.509 certificate of the LDAP server in PEM format. This property is not required when connecting without TLS encryption and is ignored in that case.</summary>
        [Newtonsoft.Json.JsonProperty("certificates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Certificates { get; set; }
    
        /// <summary>A username used to authenticate to the directory when admnistering roles in NSX. This user should have privileges to search the LDAP directory for groups and users. This user is also used in some cases (OpenLDAP) to look up an NSX user's distinguished name based on their NSX login name. If omitted, NSX will authenticate to the LDAP server using an LDAP anonymous bind operation. For Active Directory, provide a userPrincipalName (e.g. administrator@airius.com) or the full distinguished nane. For OpenLDAP, provide the distinguished name of the user (e.g. uid=admin, cn=airius, dc=com).</summary>
        [Newtonsoft.Json.JsonProperty("bind_identity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bind_identity { get; set; }
    
        /// <summary>If set to true, Use the StartTLS extended operation to upgrade
        /// the connection to TLS before sending any sensitive information.
        /// The LDAP server must support the StartTLS extended operation
        /// in order for this protocol to operate correctly. This option
        /// is ignored if the URL scheme is LDAPS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("use_starttls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Use_starttls { get; set; } = false;
    
        /// <summary>The URL for the LDAP server. Supported URL schemes are LDAP and LDAPS. Either a hostname or an IP address may be given, and the port number is optional and defaults to 389 for the LDAP scheme and 636 for the LDAPS scheme.</summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Url { get; set; }
    
        /// <summary>A password used when authenticating to the directory.</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Password { get; set; }
    
        /// <summary>Allows the LDAP server to be enabled or disabled. When disabled, this LDAP server will not be used to authenticate users.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
    
    }
    
    /// <summary>Advanced load balancer L4RuleProtocolMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBL4RuleProtocolMatch 
    {
        /// <summary>Transport protocol to match.
        /// Enum options - PROTOCOL_ICMP, PROTOCOL_TCP, PROTOCOL_UDP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBL4RuleProtocolMatchProtocol Protocol { get; set; }
    
        /// <summary>Criterion to use for transport protocol matching.
        /// Enum options - IS_IN, IS_NOT_IN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBL4RuleProtocolMatchMatch_criteria Match_criteria { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VidmInfoListResult : ListResult
    {
        /// <summary>List results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<VidmInfo> Results { get; set; } = new System.Collections.ObjectModel.Collection<VidmInfo>();
    
    
    }
    
    /// <summary>Realized Network and Security Group</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedSecurityGroup : RealizedGroup
    {
        /// <summary>Reference to the evaluted members of the Security Group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("evaluations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(500)]
        public System.Collections.Generic.ICollection<RealizedSecurityGroupMemberEvaluation> Evaluations { get; set; }
    
    
    }
    
    /// <summary>Site fedeation configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SiteFederationConfig 
    {
        /// <summary>Site path</summary>
        [Newtonsoft.Json.JsonProperty("site_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Site_path { get; set; }
    
        /// <summary>Unique site index allocated (from range 0-4095)</summary>
        [Newtonsoft.Json.JsonProperty("site_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Site_index { get; set; }
    
        /// <summary>Site UUID</summary>
        [Newtonsoft.Json.JsonProperty("site_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Site_id { get; set; }
    
        /// <summary>Remote tunnel endpoint IP addresses</summary>
        [Newtonsoft.Json.JsonProperty("rtep_ips", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Rtep_ips { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HTTPStatusMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPStatusMatch 
    {
        /// <summary>HTTP response status code range(s).</summary>
        [Newtonsoft.Json.JsonProperty("ranges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBHTTPStatusRange> Ranges { get; set; }
    
        /// <summary>HTTP response status code(s).</summary>
        [Newtonsoft.Json.JsonProperty("status_codes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<long> Status_codes { get; set; }
    
        /// <summary>Criterion to use for matching the HTTP response status
        /// code(s).
        /// Enum options - IS_IN, IS_NOT_IN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHTTPStatusMatchMatch_criteria Match_criteria { get; set; }
    
    
    }
    
    /// <summary>OSPF Neighbor Status.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OspfNeighborStatus 
    {
        [Newtonsoft.Json.JsonProperty("neighbor_status_info", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OspfStatusInfo> Neighbor_status_info { get; set; }
    
        /// <summary>OSPF neighbor address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("neighbor_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Neighbor_address { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for PolicyEdgeNode, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyEdgeNode : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyEdgeNode object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyEdgeNode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyEdgeNode PolicyEdgeNode { get; set; }
    
    
    }
    
    /// <summary>Traffic statistics for a segment.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VPNTrafficStatisticsPerSegment 
    {
        /// <summary>Total number of outgoing packets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_out { get; set; }
    
        /// <summary>Total number of incoming packets dropped.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_receive_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_receive_error { get; set; }
    
        /// <summary>Total number of incoming bytes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bytes_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_in { get; set; }
    
        /// <summary>Total number of incoming Broadcast, Unknown unicast and Multicast (BUM) packets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bum_packets_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bum_packets_in { get; set; }
    
        /// <summary>Policy path referencing the segment on which stats are gathered.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("segment_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Segment_path { get; set; }
    
        /// <summary>Total number of outgoing Broadcast, Unknown unicast and Multicast (BUM) bytes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bum_bytes_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bum_bytes_out { get; set; }
    
        /// <summary>Total number of outgoing bytes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bytes_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_out { get; set; }
    
        /// <summary>Total number of packets dropped while sending for any reason.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_sent_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_sent_error { get; set; }
    
        /// <summary>Total number of outgoing Broadcast, Unknown unicast and Multicast (BUM) packets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bum_packets_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bum_packets_out { get; set; }
    
        /// <summary>Total number of incoming packets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_in { get; set; }
    
        /// <summary>Total number of incoming Broadcast, Unknown unicast and Multicast (BUM) bytes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bum_bytes_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bum_bytes_in { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer CloneServer object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBCloneServer 
    {
        /// <summary>Network to clone the traffic to.
        /// It is a reference to an object of type Network.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("network_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Network_path { get; set; }
    
        /// <summary>Subnet of the network to clone the traffic to.</summary>
        [Newtonsoft.Json.JsonProperty("subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddrPrefix Subnet { get; set; }
    
        /// <summary>MAC Address of the Clone Server.</summary>
        [Newtonsoft.Json.JsonProperty("mac", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Mac { get; set; }
    
        /// <summary>IP Address of the Clone Server.</summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddr Ip_address { get; set; }
    
    
    }
    
    /// <summary>This holds the state of Logical Router. If there are errors in realizing LR outside of MP, it gives details of the components and specific errors.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LogicalRouterState : EdgeConfigurationState
    {
    
    }
    
    /// <summary>Key value structure for holding metadata of context profile attributes</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ContextProfileAttributesMetadata 
    {
        /// <summary>Value for metadata key</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }
    
        /// <summary>Key for metadata</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }
    
    
    }
    
    /// <summary>OSPF router link state details.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MpOspfNetworkLinkStates 
    {
        /// <summary>Cost of the route</summary>
        [Newtonsoft.Json.JsonProperty("checksum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Checksum { get; set; }
    
        /// <summary>LSA age</summary>
        [Newtonsoft.Json.JsonProperty("up_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Up_time { get; set; }
    
        /// <summary>Sequence number</summary>
        [Newtonsoft.Json.JsonProperty("sequence_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sequence_number { get; set; }
    
        /// <summary>OSPF advertised router</summary>
        [Newtonsoft.Json.JsonProperty("advertised_router", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Advertised_router { get; set; }
    
        /// <summary>OSPF link id</summary>
        [Newtonsoft.Json.JsonProperty("link_state_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Link_state_id { get; set; }
    
    
    }
    
    /// <summary>Route Redistribution config</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier0RouteRedistributionConfig 
    {
        /// <summary>List of redistribution rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("redistribution_rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(5)]
        public System.Collections.Generic.ICollection<Tier0RouteRedistributionRule> Redistribution_rules { get; set; }
    
        /// <summary>Flag to enable route redistribution for OSPF.</summary>
        [Newtonsoft.Json.JsonProperty("ospf_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Ospf_enabled { get; set; } = false;
    
        /// <summary>Flag to enable route redistribution for BGP.</summary>
        [Newtonsoft.Json.JsonProperty("bgp_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Bgp_enabled { get; set; } = true;
    
    
    }
    
    /// <summary>Active healthchecks are disabled by default and can be enabled for a
    /// server pool by binding a health monitor to the Group through the
    /// LBRule object. This represents active health monitoring over TCP.
    /// Active healthchecks are initiated periodically, at a configurable
    /// interval, to each member of the Group. Only if a healthcheck fails
    /// consecutively for a specified number of times (fall_count) to a member
    /// will the member status be marked DOWN. Once a member is DOWN, a specified
    ///  number of consecutive successful healthchecks (rise_count) will bring
    ///  the member back to UP state. After a healthcheck is initiated, if it
    ///  does not complete within a certain period, then also
    /// the healthcheck is considered to be unsuccessful. Completing a
    /// healthcheck within timeout means establishing a connection (TCP or SSL),
    /// if applicable, sending the request and receiving the response, all within
    /// the configured timeout.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBTcpMonitorProfile : LBActiveMonitor
    {
        /// <summary>Expected data, if specified, can be anywhere in the response and it has
        /// to be a string, regular expressions are not supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Receive { get; set; }
    
        /// <summary>If both send and receive are not specified, then just a TCP connection
        /// is established (3-way handshake) to validate server is healthy, no
        /// data is sent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("send", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Send { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MetadataProxyStatisticsPerSegment 
    {
        /// <summary>requests to nova server</summary>
        [Newtonsoft.Json.JsonProperty("requests_to_nova_server", Required = Newtonsoft.Json.Required.Always)]
        public long Requests_to_nova_server { get; set; }
    
        /// <summary>responses to clients</summary>
        [Newtonsoft.Json.JsonProperty("responses_to_clients", Required = Newtonsoft.Json.Required.Always)]
        public long Responses_to_clients { get; set; }
    
        /// <summary>succeeded responses from  nova server</summary>
        [Newtonsoft.Json.JsonProperty("succeeded_responses_from_nova_server", Required = Newtonsoft.Json.Required.Always)]
        public long Succeeded_responses_from_nova_server { get; set; }
    
        /// <summary>requests from clients</summary>
        [Newtonsoft.Json.JsonProperty("requests_from_clients", Required = Newtonsoft.Json.Required.Always)]
        public long Requests_from_clients { get; set; }
    
        /// <summary>error responses from  nova server</summary>
        [Newtonsoft.Json.JsonProperty("error_responses_from_nova_server", Required = Newtonsoft.Json.Required.Always)]
        public long Error_responses_from_nova_server { get; set; }
    
        /// <summary>Policy path of the attached segment</summary>
        [Newtonsoft.Json.JsonProperty("segment_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Segment_path { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for LocaleServices, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildLocaleServices : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual LocaleServices object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("LocaleServices", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public LocaleServices LocaleServices { get; set; }
    
    
    }
    
    /// <summary>Represents site offboarding status.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SiteOffBoardingState : PolicyConfigResource
    {
        /// <summary>Represents site offboarding status.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SiteOffBoardingStateStatus? Status { get; set; }
    
        /// <summary>Captures message associated with status.
        /// If FAILED, can contain folowing errors
        /// local site configuration is null
        /// internal server error with detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        /// <summary>Contains previus failed message in case,
        /// state machine is stuck in a state
        /// </summary>
        [Newtonsoft.Json.JsonProperty("previousErrorMessage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PreviousErrorMessage { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer SAMLSPConfig object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSAMLSPConfig 
    {
        /// <summary>SAML Single Signon URL to be programmed on the IDP.</summary>
        [Newtonsoft.Json.JsonProperty("single_signon_url", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Single_signon_url { get; set; }
    
        /// <summary>Globally unique SAML entityID for this node.
        /// The SAML application entity ID on the IDP should match
        /// this.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("entity_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Entity_id { get; set; }
    
        /// <summary>Key to generate the cookie.</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBHttpCookiePersistenceKey> Key { get; set; }
    
        /// <summary>SP will use this SSL certificate to sign requests going to
        /// the IdP and decrypt the assertions coming from IdP.
        /// It is a reference to an object of type
        /// SSLKeyAndCertificate.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("signing_ssl_key_and_certificate_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Signing_ssl_key_and_certificate_path { get; set; }
    
        /// <summary>SAML SP metadata for this application.</summary>
        [Newtonsoft.Json.JsonProperty("sp_metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sp_metadata { get; set; }
    
        /// <summary>HTTP cookie name for authenticated session.</summary>
        [Newtonsoft.Json.JsonProperty("cookie_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cookie_name { get; set; }
    
        /// <summary>Cookie timeout in minutes.
        /// Allowed values are 1-1440.
        /// Unit is MIN.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 60.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cookie_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 1440D)]
        public long? Cookie_timeout { get; set; } = 60L;
    
        /// <summary>By enabling this field IdP can control how long the SP
        /// session can exist through the SessionNotOnOrAfter field in
        /// the AuthNStatement of SAML Response.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("use_idp_session_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Use_idp_session_timeout { get; set; }
    
    
    }
    
    /// <summary>This action is used to rewrite header fields of HTTP response messages to
    /// specified new values at HTTP_RESPONSE_REWRITE phase. One action can be used
    /// to rewrite one header field. To rewrite multiple header fields, multiple
    /// actions must be defined.
    /// Captured variables and built-in variables can be used in the header_value
    /// field, header_name field does not support variables.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBHttpResponseHeaderRewriteAction : LBRuleAction
    {
        /// <summary>Value of header field</summary>
        [Newtonsoft.Json.JsonProperty("header_value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Header_value { get; set; }
    
        /// <summary>Name of a header field of HTTP request message.</summary>
        [Newtonsoft.Json.JsonProperty("header_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Header_name { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for StaticARPConfig, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildStaticARPConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual StaticARPConfig object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("StaticARPConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public StaticARPConfig StaticARPConfig { get; set; }
    
    
    }
    
    /// <summary>Advanced configuration for Segment</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentAdvancedConfig : ConnectivityAdvancedConfig
    {
        /// <summary>An ordered list of routing policies to forward traffic to the next hop.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("local_egress_routing_policies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<LocalEgressRoutingEntry> Local_egress_routing_policies { get; set; }
    
        /// <summary>Enable multicast on the downlink LRP created to connect the segment to Tier0/Tier1 gateway.
        /// 
        /// Enabled by default, even when segment.advanced_config property is not specified.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("multicast", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Multicast { get; set; }
    
        /// <summary>When set to true, any port attached to this logical switch will
        /// not be visible through VC/ESX UI
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inter_router", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Inter_router { get; set; } = false;
    
        /// <summary>The name of the switching uplink teaming policy for the Segment. This name corresponds to one of the switching uplink teaming policy names listed in TransportZone associated with the Segment. See transport_zone_path property above for more details. When this property is not specified, the segment will not have a teaming policy associated with it and the host switch's default teaming policy will be used by MP.</summary>
        [Newtonsoft.Json.JsonProperty("uplink_teaming_policy_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uplink_teaming_policy_name { get; set; }
    
        /// <summary>Policy path to IP address pools.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("address_pool_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Address_pool_paths { get; set; }
    
        /// <summary>This profile is applie dto the downlink logical router port created
        /// while attaching this semgnet to tier-0 or tier-1. If this field is
        /// empty, NDRA profile of the router is applied to the newly created
        /// port.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ndra_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ndra_profile_path { get; set; }
    
        /// <summary>When set to true, all the ports created on this segment will behave
        /// in a hybrid fashion. The hybrid port indicates to NSX that the
        /// VM intends to operate in underlay mode, but retains the ability to
        /// forward egress traffic to the NSX overlay network.
        /// This property is only applicable for segment created with transport
        /// zone type OVERLAY_STANDARD.
        /// This property cannot be modified after segment is created.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hybrid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Hybrid { get; set; } = false;
    
        /// <summary>This URPF mode is applied to the downlink logical router port created
        /// while attaching this segment to tier-0 or tier-1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("urpf_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SegmentAdvancedConfigUrpf_mode? Urpf_mode { get; set; } = SDKGenerator.SegmentAdvancedConfigUrpf_mode.STRICT;
    
        /// <summary>This property is used to enable proximity routing with local egress.
        /// When set to true, logical router interface (downlink) connecting
        /// Segment to Tier0/Tier1 gateway is configured with prefix-length 32.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("local_egress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Local_egress { get; set; } = false;
    
    
    }
    
    /// <summary>This entity will be used to establish association between Firewall Flood
    /// Protection profile and Group. Using this entity, user can specify intent
    /// for applying Firewall Flood Protection profile to particular Group.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyFirewallFloodProtectionProfileBindingMap : ProfileBindingMap
    {
        /// <summary>Sequence number is used to resolve conflicts when two profiles get
        /// applied to a single port. Lower value gets higher precedence. Two
        /// binding maps having the same profile path should have the same sequence
        /// number.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sequence_number", Required = Newtonsoft.Json.Required.Always)]
        public long Sequence_number { get; set; }
    
    
    }
    
    /// <summary>Aggregate of LBServiceUsagePerEP across Enforcement Points.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregateLBServiceUsage : AggregatePolicyRuntimeInfo
    {
        /// <summary>LBServiceUsagePerEP list results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBServiceUsagePerEP> Results { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of Groups</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GroupListResult : ListResult
    {
        /// <summary>Group list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Group> Results { get; set; } = new System.Collections.ObjectModel.Collection<Group>();
    
    
    }
    
    /// <summary>Child wrapper object for Rule, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildRule : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual Rule object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Rule", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Rule Rule { get; set; }
    
    
    }
    
    /// <summary>This action is used to delete header fields of HTTP response messages at
    /// HTTP_RESPONSE_REWRITE phase. One action can be used to delete allgi headers
    /// with same header name. To delete headers with different header names,
    /// multiple actions must be defined.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBHttpResponseHeaderDeleteAction : LBRuleAction
    {
        /// <summary>Name of a header field of HTTP response message.</summary>
        [Newtonsoft.Json.JsonProperty("header_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Header_name { get; set; }
    
    
    }
    
    /// <summary>IP Address and Port information</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPAddressPortPair 
    {
        /// <summary>The IPAddress to be combined with Port for defining specific access
        /// point.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ip_address { get; set; }
    
        /// <summary>The port to be combined with IPAddress for defining a specific access
        /// point.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Port { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer SamlIdentityProviderSettings object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSamlIdentityProviderSettings 
    {
        /// <summary>SAML IDP metadata.</summary>
        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Metadata { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of RedirectionRules</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RedirectionRuleListResult : BaseRuleListResult
    {
        /// <summary>RedirectionRule list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<RedirectionRule> Results { get; set; } = new System.Collections.ObjectModel.Collection<RedirectionRule>();
    
    
    }
    
    /// <summary>Child wrapper object for GatewayPolicy, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildGatewayPolicy : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual GatewayPolicy object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("GatewayPolicy", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public GatewayPolicy GatewayPolicy { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of Tags</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TagInfoListResult : ListResult
    {
        /// <summary>Tag info list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<TagInfo> Results { get; set; } = new System.Collections.ObjectModel.Collection<TagInfo>();
    
    
    }
    
    /// <summary>Advanced load balancer NetworkSecurityPolicy object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBNetworkSecurityPolicy : PolicyConfigResource
    {
        /// <summary>Placeholder for description of property rules of obj type
        /// NetworkSecurityPolicy field type str  type array.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBNetworkSecurityRule> Rules { get; set; }
    
        /// <summary>Checksum of cloud configuration for Network Sec Policy.
        /// Internally set by cloud connector.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cloud_config_cksum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cloud_config_cksum { get; set; }
    
        /// <summary>Creator name.</summary>
        [Newtonsoft.Json.JsonProperty("created_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_by { get; set; }
    
    
    }
    
    /// <summary>Provides IPSec VPN session status.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnTransportStatus : L2VPNSessionTransportTunnelStatus
    {
        /// <summary>IPSec VPN Session status</summary>
        [Newtonsoft.Json.JsonProperty("session_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IPSecVpnSessionStatusNsxT Session_status { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsRuleActionPoolSwitching object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsRuleActionPoolSwitching 
    {
        /// <summary>Reference of the pool to serve the passthrough DNS query
        /// which cannot be served locally.
        /// It is a reference to an object of type Pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pool_path { get; set; }
    
        /// <summary>Reference of the pool group to serve the passthrough DNS
        /// query which cannot be served locally.
        /// It is a reference to an object of type PoolGroup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_group_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pool_group_path { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBSSLKeyAndCertificate, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBSSLKeyAndCertificate : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBSSLKeyAndCertificate object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBSSLKeyAndCertificate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBSSLKeyAndCertificate ALBSSLKeyAndCertificate { get; set; }
    
    
    }
    
    /// <summary>Information on the Network interfaces present on the partner appliance that needs to be configured by the NSX Manager.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class NicMetadata 
    {
        /// <summary>Network Interface label.</summary>
        [Newtonsoft.Json.JsonProperty("interface_label", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Interface_label { get; set; }
    
        /// <summary>Interface that needs to be configured on the partner appliance. Ex. MANAGEMENT, DATA1, DATA2, HA1, HA2, CONTROL.</summary>
        [Newtonsoft.Json.JsonProperty("interface_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public NicMetadataInterface_type Interface_type { get; set; }
    
        /// <summary>Transport Type of the service, which is the mechanism of redirecting the traffic to the the partner appliance. Transport type is required if Service caters to any functionality other than EPP. Here, the transports array specifies the kinds of transport where this particular NIC is user configurable. If nothing is specified, and the "user_configurable" flag is true, then user configuration will be allowed for all transports. If any transport is/are specified, then it will be considered as user configurable for the specified transports only."</summary>
        [Newtonsoft.Json.JsonProperty("transports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.MaxLength(3)]
        public System.Collections.Generic.ICollection<Transports> Transports { get; set; }
    
        /// <summary>Used to specify if the given interface needs configuration. Management nics will always need the configuration, for others it will be use case specific. For example, a DATA NIC may be user configurable if the appliance is deployed in certain mode, such as L3_ROUTED.</summary>
        [Newtonsoft.Json.JsonProperty("user_configurable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? User_configurable { get; set; }
    
        /// <summary>Network Interface index.</summary>
        [Newtonsoft.Json.JsonProperty("interface_index", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0D, int.MaxValue)]
        public long Interface_index { get; set; }
    
    
    }
    
    /// <summary>Criterion Evaluation is the basic logical condition to evaluate
    /// whether the event could be potentially met.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("SourceFieldEvaluation", typeof(SourceFieldEvaluation))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Evaluation 
    {
    
    }
    
    /// <summary>Child wrapper object for Reaction used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildReaction : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual Reaction object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Reaction", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Reaction Reaction { get; set; }
    
    
    }
    
    /// <summary>This condition is used to match method of HTTP requests. If the method of an
    /// HTTP request is same as the method specified in this condition, the HTTP
    /// request match this condition. For example, if the method field is set to
    /// GET in this condition, any HTTP request with GET method matches the
    /// condition.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBHttpRequestMethodCondition : LBRuleCondition
    {
        /// <summary>Type of HTTP request method</summary>
        [Newtonsoft.Json.JsonProperty("method", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBHttpRequestMethodConditionMethod Method { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBClientSslProfileListResult : ListResult
    {
        /// <summary>Paginated list of load balancer client SSL profiles</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<LBClientSslProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<LBClientSslProfile>();
    
    
    }
    
    /// <summary>Child wrapper object for BgpNeighborConfig, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildBgpNeighborConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual BgpNeighborConfig object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("BgpNeighborConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BgpNeighborConfig BgpNeighborConfig { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer PoolAnalyticsPolicy object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBPoolAnalyticsPolicy 
    {
        /// <summary>Enable real time metrics for server and pool metrics eg.
        /// l4_server.xxx, l7_server.xxx.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_realtime_metrics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_realtime_metrics { get; set; } = false;
    
    
    }
    
    /// <summary>Advanced load balancer HTTP2ApplicationProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTP2ApplicationProfile 
    {
        /// <summary>The maximum number of requests over a client side HTTP/2
        /// connection.
        /// Allowed values are 0-10000.
        /// Special values are 0- 'Unlimited requests on a client side
        /// HTTP/2 connection'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_http2_requests_per_connection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 10000D)]
        public long? Max_http2_requests_per_connection { get; set; } = 1000L;
    
        /// <summary>The max number of control frames that client can send over
        /// an HTTP/2 connection.
        /// '0' means unlimited.
        /// Allowed values are 0-10000.
        /// Special values are 0- 'Unlimited control frames on a client
        /// side HTTP/2 connection'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_http2_control_frames_per_connection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 10000D)]
        public long? Max_http2_control_frames_per_connection { get; set; } = 1000L;
    
        /// <summary>The max number of concurrent streams over a client side
        /// HTTP/2 connection.
        /// Allowed values are 1-256.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 128.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_http2_concurrent_streams_per_connection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 256D)]
        public long? Max_http2_concurrent_streams_per_connection { get; set; } = 128L;
    
        /// <summary>The max number of frames that can be queued waiting to be
        /// sent over a client side HTTP/2 connection at any given time.
        /// '0' means unlimited.
        /// Allowed values are 0-10000.
        /// Special values are 0- 'Unlimited frames can be queued on a
        /// client side HTTP/2 connection'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_http2_queued_frames_to_client_per_connection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 10000D)]
        public long? Max_http2_queued_frames_to_client_per_connection { get; set; } = 1000L;
    
        /// <summary>The max number of empty data frames that client can send
        /// over an HTTP/2 connection.
        /// '0' means unlimited.
        /// Allowed values are 0-10000.
        /// Special values are 0- 'Unlimited empty data frames over a
        /// client side HTTP/2 connection'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_http2_empty_data_frames_per_connection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 10000D)]
        public long? Max_http2_empty_data_frames_per_connection { get; set; } = 1000L;
    
        /// <summary>The maximum size in bytes of the compressed request header
        /// field.
        /// The limit applies equally to both name and value.
        /// Allowed values are 1-8192.
        /// Unit is BYTES.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 4096.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_http2_header_field_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 8192D)]
        public long? Max_http2_header_field_size { get; set; } = 4096L;
    
        /// <summary>The initial flow control window size in KB for HTTP/2
        /// streams.
        /// Allowed values are 64-32768.
        /// Unit is KB.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 64.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("http2_initial_window_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(64D, 32768D)]
        public long? Http2_initial_window_size { get; set; } = 64L;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Ipv4Header 
    {
        /// <summary>The source ip address.</summary>
        [Newtonsoft.Json.JsonProperty("src_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Src_ip { get; set; }
    
        /// <summary>IP flags</summary>
        [Newtonsoft.Json.JsonProperty("flags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 8D)]
        public long? Flags { get; set; } = 0L;
    
        /// <summary>The destination ip address.</summary>
        [Newtonsoft.Json.JsonProperty("dst_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dst_ip { get; set; }
    
        /// <summary>This is used together with src_ip to calculate dst_ip for broadcast when dst_ip is not given; not used in all other cases.</summary>
        [Newtonsoft.Json.JsonProperty("src_subnet_prefix_len", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 32D)]
        public long? Src_subnet_prefix_len { get; set; }
    
        /// <summary>Time to live (ttl)</summary>
        [Newtonsoft.Json.JsonProperty("ttl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 255D)]
        public long? Ttl { get; set; } = 64L;
    
        /// <summary>IP protocol - defaults to ICMP</summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 255D)]
        public long? Protocol { get; set; } = 1L;
    
    
    }
    
    /// <summary>Advanced load balancer WafPositiveSecurityModel object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWafPositiveSecurityModel 
    {
        /// <summary>These groups should be used to separate different levels of
        /// concern.
        /// The order of the groups matters, one group may mark parts
        /// of the request as valid, so that subsequent groups will not
        /// check these parts.
        /// It is a reference to an object of type WafPolicyPSMGroup.
        /// Maximum of 64 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("group_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Group_paths { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer ErrorPageProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBErrorPageProfile : PolicyConfigResource
    {
        /// <summary>Defined Error Pages for HTTP status codes.</summary>
        [Newtonsoft.Json.JsonProperty("error_pages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBErrorPage> Error_pages { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for TlsTrustData, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildTlsTrustData : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual TlsTrustData object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("TlsTrustData", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public TlsTrustData TlsTrustData { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for PolicyNatRule, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyNatRule : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyNatRule object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyNatRule", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyNatRule PolicyNatRule { get; set; }
    
    
    }
    
    /// <summary>Some applications maintain state and require all relevant connections
    /// to be sent to the same server as the application state is not
    /// synchronized among servers. Persistence is enabled on a
    /// LBVirtualServer by binding a persistence profile to it.
    /// LBGenericPersistenceProfile cannot be attached to LBVirtualServer
    /// directly, it can be specified in LBVariablePersistenceOnAction or
    /// LBVariablePersistenceLearnAction in LBRule. If a user attaches a
    /// LBGenericPersistenceProfile directly to a virtual server, the operation
    /// is rejected.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("LBCookiePersistenceProfile", typeof(LBCookiePersistenceProfile))]
    [JsonInheritanceAttribute("LBSourceIpPersistenceProfile", typeof(LBSourceIpPersistenceProfile))]
    [JsonInheritanceAttribute("LBGenericPersistenceProfile", typeof(LBGenericPersistenceProfile))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBPersistenceProfile : PolicyConfigResource
    {
        /// <summary>Persistence shared setting indicates that all LBVirtualServers
        /// that consume this LBPersistenceProfile should share the same
        /// persistence mechanism when enabled.  Meaning, persistence entries of
        /// a client accessing one virtual server will also affect the same
        /// client's connections to a different virtual server. For example, say
        /// there are two virtual servers vip-ip1:80 and vip-ip1:8080 bound to
        /// the same Group g1 consisting of two servers (s11:80 and s12:80). By
        /// default, each virtual server will have its own persistence table or
        /// cookie. So, in the earlier example, there will be two tables
        /// (vip-ip1:80, p1) and (vip-ip1:8080, p1) or cookies. So, if a client
        /// connects to vip1:80 and later connects to vip1:8080, the second
        /// connection may be sent to a different server than the first.  When
        /// persistence_shared is enabled, then the second connection will always
        /// connect to the same server as the original connection. For COOKIE
        /// persistence type, the same cookie will be shared by multiple virtual
        /// servers. For SOURCE_IP persistence type, the persistence table will
        /// be shared across virtual servers. For GENERIC persistence type, the
        /// persistence table will be shared across virtual servers which consume
        /// the same persistence profile in LBRule actions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("persistence_shared", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Persistence_shared { get; set; } = false;
    
    
    }
    
    /// <summary>L2VPN Session Transport Tunnel Data uses a peer code which has all the
    /// information to create the transport tunnel.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VPNSessionTransportTunnelData 
    {
        /// <summary>IPv4 Address of local endpoint.</summary>
        [Newtonsoft.Json.JsonProperty("local_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Local_address { get; set; }
    
        /// <summary>Peer code represents a base64 encoded string which has
        /// all the configuration for tunnel. E.g local/peer ips and
        /// protocol, encryption algorithm, etc. Peer code also contains
        /// PSK; be careful when sharing or storing it.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("peer_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Peer_code { get; set; }
    
        /// <summary>IPv4 Address of Peer endpoint on remote site.</summary>
        [Newtonsoft.Json.JsonProperty("peer_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Peer_address { get; set; }
    
    
    }
    
    /// <summary>A block of IP addresses defined by a start address and a mask/prefix (network CIDR). An IP block is typically large &amp; allocated to a tenant for automated consumption. An IP block is always a contiguous address space, for example 192.0.0.1/8. An IP block can be further subdivided into subnets called IP block subnets. These IP block subnets can be added to IP pools and used for IP allocation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IpAddressBlock : PolicyConfigResource
    {
        /// <summary>Represents a network address and the prefix length which will be associated with a layer-2 broadcast domain. Support IPv4 and IPv6 CIDR.</summary>
        [Newtonsoft.Json.JsonProperty("cidr", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Cidr { get; set; }
    
    
    }
    
    /// <summary>Container application within a project.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ContainerApplication : DiscoveredResource
    {
        /// <summary>Status of the container application.</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ContainerApplicationStatus? Status { get; set; }
    
        /// <summary>Network status of container application.</summary>
        [Newtonsoft.Json.JsonProperty("network_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ContainerApplicationNetwork_status? Network_status { get; set; }
    
        /// <summary>Identifier of the container cluster this container application belongs to.</summary>
        [Newtonsoft.Json.JsonProperty("container_cluster_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Container_cluster_id { get; set; }
    
        /// <summary>Array of additional specific properties of container application
        /// in key-value format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("origin_properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyValuePair> Origin_properties { get; set; }
    
        /// <summary>Identifier of the container application on container cluster
        /// e.g. PCF app id, k8s service id.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("external_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string External_id { get; set; }
    
        /// <summary>Identifier of the project which this container application belongs to.</summary>
        [Newtonsoft.Json.JsonProperty("container_project_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Container_project_id { get; set; }
    
        /// <summary>List of network errors related to container application.</summary>
        [Newtonsoft.Json.JsonProperty("network_errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<NetworkError> Network_errors { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HttpCookiePersistenceKey object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHttpCookiePersistenceKey 
    {
        /// <summary>hmac_key of HttpCookiePersistenceKey.</summary>
        [Newtonsoft.Json.JsonProperty("hmac_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Hmac_key { get; set; }
    
        /// <summary>name to use for cookie encryption.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>aes_key of HttpCookiePersistenceKey.</summary>
        [Newtonsoft.Json.JsonProperty("aes_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Aes_key { get; set; }
    
    
    }
    
    /// <summary>Contains ordered list of Rules for GatewayPolicy</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GatewayPolicy : Policy
    {
        /// <summary>Rules that are a part of this SecurityPolicy</summary>
        [Newtonsoft.Json.JsonProperty("rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Rule> Rules { get; set; }
    
    
    }
    
    /// <summary>Represents configuration of a graph widget</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GraphConfiguration : WidgetConfiguration
    {
        /// <summary>x value type.</summary>
        [Newtonsoft.Json.JsonProperty("x_value_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public GraphConfigurationX_value_type? X_value_type { get; set; } = SDKGenerator.GraphConfigurationX_value_type.String;
    
        /// <summary>Graphs</summary>
        [Newtonsoft.Json.JsonProperty("graphs", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<GraphDefinition> Graphs { get; set; } = new System.Collections.ObjectModel.Collection<GraphDefinition>();
    
        /// <summary>Axes of a graph</summary>
        [Newtonsoft.Json.JsonProperty("axes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Axes Axes { get; set; }
    
        /// <summary>Hyperlink of the specified UI page that provides details.</summary>
        [Newtonsoft.Json.JsonProperty("navigation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Navigation { get; set; }
    
        /// <summary>Describes the the type of graph. LINE_GRAPH shows a line graph chart BAR_GRAPH shows a simple bar graph chart STACKED_BAR_GRAPH shows a stacked bar graph chart</summary>
        [Newtonsoft.Json.JsonProperty("sub_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public GraphConfigurationSub_type? Sub_type { get; set; } = SDKGenerator.GraphConfigurationSub_type.BAR_GRAPH;
    
        /// <summary>If true, value of a point is shown as label on X axis. If false, value of point is not shown as label on X axis. false can be useful in situations where there are too many points and showing the X value as label can clutter the X axis.</summary>
        [Newtonsoft.Json.JsonProperty("display_x_value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Display_x_value { get; set; } = false;
    
    
    }
    
    /// <summary>Advanced load balancer HTTPSecurityRule object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPSecurityRule 
    {
        /// <summary>Index of the rule.</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public long Index { get; set; }
    
        /// <summary>Enable or disable the rule.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable", Required = Newtonsoft.Json.Required.Always)]
        public bool Enable { get; set; } = true;
    
        /// <summary>Log HTTP request upon rule match.</summary>
        [Newtonsoft.Json.JsonProperty("log", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Log { get; set; }
    
        /// <summary>Action to be performed upon successful matching.</summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPSecurityAction Action { get; set; }
    
        /// <summary>Add match criteria to the rule.</summary>
        [Newtonsoft.Json.JsonProperty("match", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBMatchTarget Match { get; set; }
    
        /// <summary>Name of the rule.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
    
    }
    
    /// <summary>Aggregate of DNS forwarder nslookup answer across enforcement points.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregatePolicyDnsAnswer 
    {
        /// <summary>List of DNS forwarder nslookup answer per enforcement point.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dns_answer_per_enforcement_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyDnsAnswerPerEnforcementPoint> Dns_answer_per_enforcement_point { get; set; }
    
        /// <summary>String path of the DNS forwarder intent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("intent_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Intent_path { get; set; }
    
    
    }
    
    /// <summary>Collection of tags used in a policy group for a particular member type
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GroupMemberTagsList 
    {
        /// <summary>Member type for which we will list the tags</summary>
        [Newtonsoft.Json.JsonProperty("member_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Member_type { get; set; }
    
        /// <summary>List of tags for the member type</summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Tags { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>Detailed information about a related API error</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RelatedApiError 
    {
        /// <summary>The module name where the error occurred</summary>
        [Newtonsoft.Json.JsonProperty("module_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Module_name { get; set; }
    
        /// <summary>A description of the error</summary>
        [Newtonsoft.Json.JsonProperty("error_message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error_message { get; set; }
    
        /// <summary>A numeric error code</summary>
        [Newtonsoft.Json.JsonProperty("error_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Error_code { get; set; }
    
        /// <summary>Further details about the error</summary>
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Details { get; set; }
    
        /// <summary>Additional data about the error</summary>
        [Newtonsoft.Json.JsonProperty("error_data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Error_data { get; set; }
    
    
    }
    
    /// <summary>IPSec VPN Session Statistics Per Enforcement Point.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("IPSecVpnSessionStatisticsNsxT", typeof(IPSecVpnSessionStatisticsNsxT))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnSessionStatisticsPerEP : PolicyRuntimeInfoPerEP
    {
    
    }
    
    /// <summary>Child wrapper object for IpAddressPoolSubnet, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIpAddressPoolSubnet : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual IpAddressPoolSubnet object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IpAddressPoolSubnet", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IpAddressPoolSubnet IpAddressPoolSubnet { get; set; }
    
    
    }
    
    /// <summary>Load balancer abstract SSL profile.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBSslProfile : PolicyConfigResource
    {
    
    }
    
    /// <summary>Advanced load balancer TCPProxyProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBTCPProxyProfile 
    {
        /// <summary>Size of the receive window.
        /// Allowed values are 2-65536.
        /// Unit is KB.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 64.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receive_window", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(2D, 65536D)]
        public long? Receive_window { get; set; } = 64L;
    
        /// <summary>Controls the our congestion window to send, normally it's 1
        /// mss, If this option is turned on, we use 10 msses.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("aggressive_congestion_avoidance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Aggressive_congestion_avoidance { get; set; } = false;
    
        /// <summary>Controls the congestion control algorithm we use.
        /// Enum options - CC_ALGO_NEW_RENO, CC_ALGO_CUBIC,
        /// CC_ALGO_HTCP.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as CC_ALGO_NEW_RENO.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cc_algo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBTCPProxyProfileCc_algo? Cc_algo { get; set; } = SDKGenerator.ALBTCPProxyProfileCc_algo.CC_ALGO_NEW_RENO;
    
        /// <summary>Controls the number of duplicate acks required to trigger
        /// retransmission.
        /// Setting a higher value reduces retransmission caused by
        /// packet reordering.
        /// A larger value is recommended in public cloud environments
        /// where packet reordering is quite common.
        /// The default value is 8 in public cloud platforms (AWS,
        /// Azure, GCP), and 3 in other environments.
        /// Allowed values are 1-100.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reorder_threshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 100D)]
        public long? Reorder_threshold { get; set; }
    
        /// <summary>The maximum number of attempts at retransmitting a SYN
        /// packet before giving up.
        /// Allowed values are 3-8.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 8.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_syn_retransmissions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(3D, 8D)]
        public long? Max_syn_retransmissions { get; set; } = 8L;
    
        /// <summary>The duration for keepalive probes or session idle timeout.
        /// Max value is 3600 seconds, min is 5.
        /// Set to 0 to allow infinite idle time.
        /// Allowed values are 5-14400.
        /// Special values are 0 - 'infinite'.
        /// Unit is SEC.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 600.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("idle_connection_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 14400D)]
        public long? Idle_connection_timeout { get; set; } = 600L;
    
        /// <summary>Maximum TCP segment size.
        /// Allowed values are 512-9000.
        /// Special values are 0 - 'Use Interface MTU'.
        /// Unit is BYTES.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_segment_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 9000D)]
        public long? Max_segment_size { get; set; }
    
        /// <summary>Controls the behavior of idle connections.
        /// Enum options - KEEP_ALIVE, CLOSE_IDLE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as KEEP_ALIVE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("idle_connection_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBTCPProxyProfileIdle_connection_type? Idle_connection_type { get; set; } = SDKGenerator.ALBTCPProxyProfileIdle_connection_type.KEEP_ALIVE;
    
        /// <summary>Controls whether to keep the connection alive with
        /// keepalive messages in the TCP half close state.
        /// The interval for sending keepalive messages is 30s.
        /// If a timeout is already configured in the network profile,
        /// this will not override it.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keepalive_in_halfclose_state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Keepalive_in_halfclose_state { get; set; } = true;
    
        /// <summary>The time (in millisec) to wait before closing a connection
        /// in the TIME_WAIT state.
        /// Allowed values are 500-2000.
        /// Special values are 0 - 'immediate'.
        /// Unit is MILLISECONDS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 2000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time_wait_delay", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 2000D)]
        public long? Time_wait_delay { get; set; } = 2000L;
    
        /// <summary>Congestion window scaling factor after recovery.
        /// Allowed values are 0-8.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 2.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("congestion_recovery_scaling_factor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 8D)]
        public long? Congestion_recovery_scaling_factor { get; set; } = 2L;
    
        /// <summary>The minimum wait time (in millisec) to retransmit packet.
        /// Allowed values are 50-5000.
        /// Unit is MILLISECONDS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("min_rexmt_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(50D, 5000D)]
        public long? Min_rexmt_timeout { get; set; }
    
        /// <summary>Controls whether the windows are static or supports
        /// autogrowth.
        /// Maximum that it can grow to is limited to 4MB.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("auto_window_growth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Auto_window_growth { get; set; } = true;
    
        /// <summary>A new SYN is accepted from the same 4-tuple even if there
        /// is already a connection in TIME_WAIT state.
        /// This is equivalent of setting Time Wait Delay to 0.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ignore_time_wait", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Ignore_time_wait { get; set; } = false;
    
        /// <summary>Maximum number of TCP segments that can be queued for
        /// reassembly.
        /// Configuring this to 0 disables the feature and provides
        /// unlimited queuing.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reassembly_queue_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Reassembly_queue_size { get; set; } = 0L;
    
        /// <summary>Consolidates small data packets to send clients fewer but
        /// larger packets.
        /// Adversely affects real time protocols such as telnet or
        /// SSH.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nagles_algorithm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Nagles_algorithm { get; set; } = false;
    
        /// <summary>The number of attempts at retransmit before closing the
        /// connection.
        /// Allowed values are 3-8.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 8.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_retransmissions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(3D, 8D)]
        public long? Max_retransmissions { get; set; } = 8L;
    
        /// <summary>Congestion window scaling factor during slow start.
        /// Allowed values are 0-8.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slow_start_scaling_factor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 8D)]
        public long? Slow_start_scaling_factor { get; set; } = 1L;
    
        /// <summary>Dynamically pick the relevant parameters for connections.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("automatic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Automatic { get; set; } = true;
    
        /// <summary>Controls the value of the Differentiated Services Code
        /// Point field inserted in the IP header.
        /// This has two options   Set to a specific value, or Pass
        /// Through, which uses the incoming DSCP value.
        /// Allowed values are 0-63.
        /// Special values are MAX - 'Passthrough'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip_dscp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 63D)]
        public long? Ip_dscp { get; set; } = 0L;
    
        /// <summary>Use the interface MTU to calculate the TCP max segment
        /// size.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("use_interface_mtu", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Use_interface_mtu { get; set; } = true;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyTraceflowObservationDropped : TraceflowObservationDropped
    {
        /// <summary>The path of the ACL rule that was applied to forward the traceflow packet</summary>
        [Newtonsoft.Json.JsonProperty("acl_rule_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Acl_rule_path { get; set; }
    
        /// <summary>The path of the NAT rule that was applied to forward the traceflow packet</summary>
        [Newtonsoft.Json.JsonProperty("nat_rule_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Nat_rule_path { get; set; }
    
        /// <summary>The path of the segment port or router port at which the traceflow packet was dropped</summary>
        [Newtonsoft.Json.JsonProperty("segment_port_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Segment_port_path { get; set; }
    
    
    }
    
    /// <summary>Paginated result of aggregated configuration of a policy draft
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyDraftPaginatedAggregatedConfigurationResult 
    {
        /// <summary>Paginated aggregated configuration of a given draft.
        /// For an initial API call, if request_id is present in response, then this is
        /// a paginated aggregated configuration of a given draft. To get more granular
        /// aggregated configuration, request_id need to be passed to subsequent API
        /// calls.
        /// Absence of request_id suggests that whole aggregated configuration has been
        /// returned as a response to initial API call, as the size of aggregated
        /// configuration is not big enough to need pagination.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Infra Result { get; set; }
    
        /// <summary>Request identifier to keep track of calculated aggregated configuration
        /// a draft during subsequent API calls after initial API call.
        /// This identifier can be use to fetch the detailed aggregated configuration
        /// at security policy level.
        /// Absence of request_id suggests that whole aggregated configuration has been
        /// returned as a response to initial API call, as the size of aggregated
        /// configuration is not big enough to need pagination.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("request_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Request_id { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer TacacsPlusAuthSettings object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBTacacsPlusAuthSettings 
    {
        /// <summary>TACACS+ authorization attribute value pairs.</summary>
        [Newtonsoft.Json.JsonProperty("authorization_attrs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBAuthTacacsPlusAttributeValuePair> Authorization_attrs { get; set; }
    
        /// <summary>TACACS+ server shared secret.</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Password { get; set; }
    
        /// <summary>TACACS+ server listening port.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 49.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Port { get; set; } = 49L;
    
        /// <summary>TACACS+ service.
        /// Enum options - AUTH_TACACS_PLUS_SERVICE_NONE,
        /// AUTH_TACACS_PLUS_SERVICE_LOGIN,
        /// AUTH_TACACS_PLUS_SERVICE_ENABLE,
        /// AUTH_TACACS_PLUS_SERVICE_PPP, AUTH_TACACS_PLUS_SERVICE_ARAP,
        /// AUTH_TACACS_PLUS_SERVICE_PT, AUTH_TACACS_PLUS_SERVICE_RCMD,
        /// AUTH_TACACS_PLUS_SERVICE_X25, AUTH_TACACS_PLUS_SERVICE_NASI,
        /// AUTH_TACACS_PLUS_SERVICE_FWPROXY.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// AUTH_TACACS_PLUS_SERVICE_LOGIN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBTacacsPlusAuthSettingsService? Service { get; set; } = SDKGenerator.ALBTacacsPlusAuthSettingsService.AUTH_TACACS_PLUS_SERVICE_LOGIN;
    
        /// <summary>TACACS+ server IP address or FQDN.
        /// Minimum of 1 items required.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Server { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>Contains Neighbor Discovery Protocol (ND) snooping related configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class NdSnoopingConfig 
    {
        /// <summary>Maximum number of ND (Neighbor Discovery Protocol) snooped IPv6 addresses
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nd_snooping_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(2D, 15D)]
        public long? Nd_snooping_limit { get; set; } = 3L;
    
        /// <summary>Enable this method will snoop the NS (Neighbor Solicitation) and NA
        /// (Neighbor Advertisement) messages in the ND (Neighbor Discovery Protocol)
        /// family of messages which are transmitted by a VM. From the NS messages,
        /// we will learn about the source which sent this NS message. From the
        /// NA message, we will learn the resolved address in the message which
        /// the VM is a recipient of. Addresses snooped by this method are
        /// subject to TOFU (Trust on First Use) policies as enforced by the system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nd_snooping_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Nd_snooping_enabled { get; set; } = false;
    
    
    }
    
    /// <summary>Child wrapper object for BgpRoutingConfig, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildBgpRoutingConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual BgpRoutingConfig object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("BgpRoutingConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BgpRoutingConfig BgpRoutingConfig { get; set; }
    
    
    }
    
    /// <summary>VIF attachment state of a segment port</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentPortAttachmentState 
    {
        /// <summary>A segment port must be in one of following states.
        /// FREE - If there are no active attachers. The port may or
        /// may not have an attachment ID configured on it. This state is
        /// applicable only to port of static type.
        /// ATTACHED - Segment port has exactly one active attacher and no
        /// further configuration is pending.
        /// ATTACHED_PENDING_CONF - Segment port has exactly one attacher,
        /// however it may not have been configured completely. Additional
        /// configuration will be provided by other nsx components.
        /// ATTACHED_IN_MOTION - Segment port has multiple active attachers.
        /// This state represents a scenario where VM is moving from one
        /// location (host or storage) to another (e.g. vmotion, vSphere HA)
        /// DETACHED - A temporary state after all port attachers have
        /// been detached. This state is applicable only to a port of
        /// ephemeral type and the port will soon be deleted.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SegmentPortAttachmentStateState? State { get; set; }
    
        /// <summary>VM or vmknic entities that are attached to the Segment Port</summary>
        [Newtonsoft.Json.JsonProperty("attachers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PortAttacher> Attachers { get; set; }
    
        /// <summary>VIF ID</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of flood protection profile binding maps</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FloodProtectionProfileBindingListResult : ListResult
    {
        /// <summary>Flood protection profile binding maps list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FloodProtectionProfileBindingMap> Results { get; set; } = new System.Collections.ObjectModel.Collection<FloodProtectionProfileBindingMap>();
    
    
    }
    
    /// <summary>This type of subnet is statically configured by the user. The user provides the range details and the gateway for the subnet.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IpAddressPoolStaticSubnet : IpAddressPoolSubnet
    {
        /// <summary>The collection of upto 3 DNS servers for the subnet.</summary>
        [Newtonsoft.Json.JsonProperty("dns_nameservers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(3)]
        public System.Collections.Generic.ICollection<string> Dns_nameservers { get; set; }
    
        /// <summary>Subnet representation is a network address and prefix length</summary>
        [Newtonsoft.Json.JsonProperty("cidr", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Cidr { get; set; }
    
        /// <summary>The default gateway address on a layer-3 router.</summary>
        [Newtonsoft.Json.JsonProperty("gateway_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Gateway_ip { get; set; }
    
        /// <summary>A collection of IPv4 or IPv6 IP Pool Ranges.</summary>
        [Newtonsoft.Json.JsonProperty("allocation_ranges", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IpPoolRange> Allocation_ranges { get; set; } = new System.Collections.ObjectModel.Collection<IpPoolRange>();
    
        /// <summary>The DNS suffix for the DNS server.</summary>
        [Newtonsoft.Json.JsonProperty("dns_suffix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dns_suffix { get; set; }
    
    
    }
    
    /// <summary>Aggregate statistics of all the rules in a security policy for a specific
    /// enforcement point.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SecurityPolicyStatisticsForEnforcementPoint 
    {
        /// <summary>Enforcement point to fetch the statistics from.</summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enforcement_point { get; set; }
    
        /// <summary>Statistics for the specified enforcement point</summary>
        [Newtonsoft.Json.JsonProperty("statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecurityPolicyStatistics Statistics { get; set; }
    
    
    }
    
    /// <summary>This condition is used to match HTTP request messages by cookie which is a
    /// specific type of HTTP header. The match_type and case_sensitive define how
    /// to compare cookie value.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBHttpRequestCookieCondition : LBRuleCondition
    {
        /// <summary>Match type of cookie value.</summary>
        [Newtonsoft.Json.JsonProperty("match_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBHttpRequestCookieConditionMatch_type? Match_type { get; set; } = SDKGenerator.LBHttpRequestCookieConditionMatch_type.REGEX;
    
        /// <summary>Cookie name.</summary>
        [Newtonsoft.Json.JsonProperty("cookie_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Cookie_name { get; set; }
    
        /// <summary>Cookie value.</summary>
        [Newtonsoft.Json.JsonProperty("cookie_value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Cookie_value { get; set; }
    
        /// <summary>If true, case is significant when comparing cookie value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("case_sensitive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Case_sensitive { get; set; } = true;
    
    
    }
    
    /// <summary>Corresponds to one property entered by the user</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ErrorResolverUserInputData 
    {
        /// <summary>The datatype of the given property. Useful for data validation</summary>
        [Newtonsoft.Json.JsonProperty("data_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ErrorResolverUserInputDataData_type Data_type { get; set; }
    
        /// <summary>Name of the property supplied by the user</summary>
        [Newtonsoft.Json.JsonProperty("property_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Property_name { get; set; }
    
        /// <summary>The value associated with the above property</summary>
        [Newtonsoft.Json.JsonProperty("property_value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Property_value { get; set; }
    
    
    }
    
    /// <summary>Distributed virtual portgroup on a VC</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DistributedVirtualPortgroup : VirtualPortgroup
    {
        /// <summary>This parameters reflects the managed entity status of the portgroup
        /// as reported by VC.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overall_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DistributedVirtualPortgroupOverall_status? Overall_status { get; set; }
    
        /// <summary>For distributed virtual portgroup, backing type is standard.
        /// For logical switch portgroup, the backing type is set to nsx.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("backing_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Backing_type { get; set; }
    
        /// <summary>Generated UUID of the portgroup</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PacketNumberSampling : SamplingArgument
    {
        /// <summary>1 out of how many packets is sampled</summary>
        [Newtonsoft.Json.JsonProperty("sampling_rate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long Sampling_rate { get; set; }
    
    
    }
    
    /// <summary>Paged collection of IpAddressBlocks</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IpAddressBlockListResult : ListResult
    {
        /// <summary>IpAddressBlock list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IpAddressBlock> Results { get; set; } = new System.Collections.ObjectModel.Collection<IpAddressBlock>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BgpAddressFamily 
    {
        /// <summary>Count of out prefixes</summary>
        [Newtonsoft.Json.JsonProperty("out_prefix_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Out_prefix_count { get; set; }
    
        /// <summary>BGP address family type</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BgpAddressFamilyType? Type { get; set; }
    
        /// <summary>Count of in prefixes</summary>
        [Newtonsoft.Json.JsonProperty("in_prefix_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? In_prefix_count { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of Global Managers.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GlobalManagerListResult : ListResult
    {
        /// <summary>Global Manager List Result.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<GlobalManager> Results { get; set; } = new System.Collections.ObjectModel.Collection<GlobalManager>();
    
    
    }
    
    /// <summary>Defines the point of a graph.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PointDefinition 
    {
        /// <summary>Represents the variable for the Y value of points that are plotted on the graph.</summary>
        [Newtonsoft.Json.JsonProperty("y_value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Y_value { get; set; }
    
        /// <summary>An expression that represents the points of the graph</summary>
        [Newtonsoft.Json.JsonProperty("field", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Field { get; set; }
    
        /// <summary>Id of drilldown widget, if any. Id should be a valid id of an existing widget. A widget is considered as drilldown widget when it is associated with any other widget and provides more detailed information about any data item from the parent widget.</summary>
        [Newtonsoft.Json.JsonProperty("drilldown_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Drilldown_id { get; set; }
    
        /// <summary>Represents the variable for the X value of points that are plotted on the graph.</summary>
        [Newtonsoft.Json.JsonProperty("x_value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string X_value { get; set; }
    
        /// <summary>Hyperlink of the specified UI page that provides details.</summary>
        [Newtonsoft.Json.JsonProperty("navigation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Navigation { get; set; }
    
        /// <summary>Multi-line text to be shown on tooltip while hovering over the point of a graph.</summary>
        [Newtonsoft.Json.JsonProperty("tooltip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Tooltip> Tooltip { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for L2VPNSession, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildL2VPNSession : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual L2VPNSession object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("L2VPNSession", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public L2VPNSession L2VPNSession { get; set; }
    
    
    }
    
    /// <summary>A Service entry that describes traffic</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("NestedServiceServiceEntry", typeof(NestedServiceServiceEntry))]
    [JsonInheritanceAttribute("EtherTypeServiceEntry", typeof(EtherTypeServiceEntry))]
    [JsonInheritanceAttribute("ICMPTypeServiceEntry", typeof(ICMPTypeServiceEntry))]
    [JsonInheritanceAttribute("ALGTypeServiceEntry", typeof(ALGTypeServiceEntry))]
    [JsonInheritanceAttribute("IPProtocolServiceEntry", typeof(IPProtocolServiceEntry))]
    [JsonInheritanceAttribute("IGMPTypeServiceEntry", typeof(IGMPTypeServiceEntry))]
    [JsonInheritanceAttribute("L4PortSetServiceEntry", typeof(L4PortSetServiceEntry))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServiceEntry : PolicyConfigResource
    {
    
    }
    
    /// <summary>Advanced load balancer HTTPPolicies object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPPolicies 
    {
        /// <summary>Index of the virtual service HTTP policy collection.</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public long Index { get; set; }
    
        /// <summary>path of the virtual service HTTP policy collection.
        /// It is a reference to an object of type HTTPPolicySet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("http_policy_set_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Http_policy_set_path { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HdrPersistenceProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHdrPersistenceProfile 
    {
        /// <summary>Header name for custom header persistence.</summary>
        [Newtonsoft.Json.JsonProperty("prst_hdr_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Prst_hdr_name { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MacLearningCounters 
    {
        /// <summary>Number of MACs learned</summary>
        [Newtonsoft.Json.JsonProperty("macs_learned", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Macs_learned { get; set; }
    
        /// <summary>The number of packets with unknown source MAC address that are dropped without learning the source MAC address. Applicable only when the MAC limit is reached and MAC Limit policy is MAC_LEARNING_LIMIT_POLICY_DROP.</summary>
        [Newtonsoft.Json.JsonProperty("mac_not_learned_packets_dropped", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Mac_not_learned_packets_dropped { get; set; }
    
        /// <summary>The number of packets with unknown source MAC address that are dispatched without learning the source MAC address. Applicable only when the MAC limit is reached and MAC Limit policy is MAC_LEARNING_LIMIT_POLICY_ALLOW.</summary>
        [Newtonsoft.Json.JsonProperty("mac_not_learned_packets_allowed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Mac_not_learned_packets_allowed { get; set; }
    
    
    }
    
    /// <summary>Indicate the status of End User License Agreement acceptance</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EULAAcceptance : Resource
    {
        /// <summary>Acceptance status of End User License Agreement</summary>
        [Newtonsoft.Json.JsonProperty("acceptance", Required = Newtonsoft.Json.Required.Always)]
        public bool Acceptance { get; set; }
    
    
    }
    
    /// <summary>Size of Directory Domain</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DirectoryDomainSize 
    {
        /// <summary>Number of groups</summary>
        [Newtonsoft.Json.JsonProperty("group_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Group_count { get; set; }
    
        /// <summary>Number of users</summary>
        [Newtonsoft.Json.JsonProperty("user_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? User_count { get; set; }
    
        /// <summary>Number of group members</summary>
        [Newtonsoft.Json.JsonProperty("group_member_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Group_member_count { get; set; }
    
    
    }
    
    /// <summary>Reaction represents a programmable entity which encapsulates the events
    /// and the actions in response to the events, or simply "If This Then That".
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Reaction : PolicyConfigResource
    {
        /// <summary>Events that provide contextual variables about what the reaction should react to.
        /// This field can be interpreted as the WHAT of the Reaction, or simply as "If This"
        /// Clause.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<Event> Events { get; set; } = new System.Collections.ObjectModel.Collection<Event>();
    
        /// <summary>Actions that need to be taken when the events occur. These actions must appear
        /// in the order that they need to be taken in. This field can be interpreted as the
        /// HOW of the Reaction, or simply as "Then That".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("actions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<Action> Actions { get; set; } = new System.Collections.ObjectModel.Collection<Action>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2ForwarderRemoteMacsPerSite 
    {
        /// <summary>Remote standby IP addresses.</summary>
        [Newtonsoft.Json.JsonProperty("remote_standby_ips", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Remote_standby_ips { get; set; }
    
        /// <summary>32 bit unique RTEP group id of the logical switch per site.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rtep_group_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Rtep_group_id { get; set; }
    
        /// <summary>Remote site details.</summary>
        [Newtonsoft.Json.JsonProperty("remote_site", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceReference Remote_site { get; set; }
    
        /// <summary>Remote active IP addresses.</summary>
        [Newtonsoft.Json.JsonProperty("remote_active_ips", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Remote_active_ips { get; set; }
    
        /// <summary>Remote mac addresses.</summary>
        [Newtonsoft.Json.JsonProperty("remote_mac_addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Remote_mac_addresses { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer PoolGroupMember object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBPoolGroupMember 
    {
        /// <summary>All pools with same label are treated similarly in a pool
        /// group.
        /// A pool with a higher priority is selected, as long as the
        /// pool is eligible or an explicit policy chooses a different
        /// pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("priority_label", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Priority_label { get; set; }
    
        /// <summary>Ratio of selecting eligible pools in the pool group.
        /// Allowed values are 1-1000.
        /// Special values are 0 - 'Do not select this pool for new
        /// connections'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ratio", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 1000D)]
        public long? Ratio { get; set; } = 1L;
    
        /// <summary>path of the pool.
        /// It is a reference to an object of type Pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Pool_path { get; set; }
    
        /// <summary>Pool deployment state used with the PG deployment policy.
        /// Enum options - EVALUATION_IN_PROGRESS, IN_SERVICE,
        /// OUT_OF_SERVICE, EVALUATION_FAILED.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("deployment_state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBPoolGroupMemberDeployment_state? Deployment_state { get; set; }
    
    
    }
    
    /// <summary>Collection of all registered ErrorResolverInfo</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ErrorResolverInfoList 
    {
        /// <summary>ErrorResolverInfo list</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ErrorResolverInfo> Results { get; set; } = new System.Collections.ObjectModel.Collection<ErrorResolverInfo>();
    
    
    }
    
    /// <summary>Active healthchecks are disabled by default and can be enabled for a
    /// server pool by binding a health monitor to the Group through the LBRule
    /// object. This represents active health monitoring over UDP. Active
    /// healthchecks are initiated periodically, at a configurable interval, to
    /// each member of the Group. Only if a healthcheck fails consecutively for a
    /// specified number of times (fall_count) to a member will the member status
    /// be marked DOWN. Once a member is DOWN, a specified number of consecutive
    /// successful healthchecks (rise_count) will bring the member back to UP
    /// state. After a healthcheck is initiated, if it does not complete within a
    /// certain period, then also the healthcheck is considered to be
    /// unsuccessful. Completing a healthcheck within timeout means establishing
    /// a connection (TCP or SSL), if applicable, sending the request and
    /// receiving the response, all within the configured timeout.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBUdpMonitorProfile : LBActiveMonitor
    {
        /// <summary>Expected data, can be anywhere in the response and it has to be a
        /// string, regular expressions are not supported.
        /// UDP healthcheck is considered failed if there is no server response
        /// within the timeout period.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receive", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Receive { get; set; }
    
        /// <summary>The data to be sent to the monitored server.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("send", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Send { get; set; }
    
    
    }
    
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "sampling_type")]
    [JsonInheritanceAttribute("FirstNSampling", typeof(FirstNSampling))]
    [JsonInheritanceAttribute("PacketNumberSampling", typeof(PacketNumberSampling))]
    [JsonInheritanceAttribute("IntervalSampling", typeof(IntervalSampling))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SamplingArgument 
    {
    
    }
    
    /// <summary>Child wrapper object for IdsStandaloneHostConfig, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIdsStandaloneHostConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains the IdsStandaloneHostConfig object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IdsStandaloneHostConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IdsStandaloneHostConfig IdsStandaloneHostConfig { get; set; }
    
    
    }
    
    /// <summary>IDS Profile local signature.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsProfileLocalSignature : GlobalIdsSignature
    {
    
    }
    
    /// <summary>Advanced load balancer HTTPRequestPolicy object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPRequestPolicy 
    {
        /// <summary>Add rules to the HTTP request policy.</summary>
        [Newtonsoft.Json.JsonProperty("rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBHTTPRequestRule> Rules { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceflowObservationForwardedLogical : TraceflowObservation
    {
        /// <summary>The path index of the service insertion component</summary>
        [Newtonsoft.Json.JsonProperty("service_path_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Service_path_index { get; set; }
    
        /// <summary>The id of the component that forwarded the traceflow packet.</summary>
        [Newtonsoft.Json.JsonProperty("component_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Component_id { get; set; }
    
        /// <summary>This field specified the VLAN id a traceflow packet matched in the whitelist in spoofguard.</summary>
        [Newtonsoft.Json.JsonProperty("spoofguard_vlan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Spoofguard_vlan_id { get; set; }
    
        /// <summary>ARP_UNKNOWN_FROM_CP - Unknown ARP query result emitted by control plane ND_NS_UNKNOWN_FROM_CP - Unknown neighbor solicitation query result emitted by control plane UNKNOWN - Unknown resend type</summary>
        [Newtonsoft.Json.JsonProperty("resend_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TraceflowObservationForwardedLogicalResend_type? Resend_type { get; set; }
    
        /// <summary>The name of the logical port through which the traceflow packet was forwarded.</summary>
        [Newtonsoft.Json.JsonProperty("lport_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lport_name { get; set; }
    
        /// <summary>The id of the acl rule that was applied to forward the traceflow packet</summary>
        [Newtonsoft.Json.JsonProperty("acl_rule_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Acl_rule_id { get; set; }
    
        /// <summary>The index of the service insertion component</summary>
        [Newtonsoft.Json.JsonProperty("service_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Service_index { get; set; }
    
        /// <summary>VNI for the logical network on which the traceflow packet was forwarded.</summary>
        [Newtonsoft.Json.JsonProperty("vni", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Vni { get; set; }
    
        /// <summary>The name of the destination component to which the traceflow packet was forwarded.</summary>
        [Newtonsoft.Json.JsonProperty("dst_component_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dst_component_name { get; set; }
    
        /// <summary>The ID of the NAT rule that was applied to forward the traceflow packet</summary>
        [Newtonsoft.Json.JsonProperty("nat_rule_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Nat_rule_id { get; set; }
    
        /// <summary>The translated source IP address of VPN/NAT</summary>
        [Newtonsoft.Json.JsonProperty("translated_src_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Translated_src_ip { get; set; }
    
        /// <summary>The translated destination IP address of VNP/NAT</summary>
        [Newtonsoft.Json.JsonProperty("translated_dst_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Translated_dst_ip { get; set; }
    
        /// <summary>The source MAC address of form:
        /// "^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$". For example: 00:00:00:00:00:00.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("spoofguard_mac", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Spoofguard_mac { get; set; }
    
        /// <summary>The type of the destination component to which the traceflow packet was forwarded.</summary>
        [Newtonsoft.Json.JsonProperty("dst_component_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TraceflowObservationForwardedLogicalDst_component_type? Dst_component_type { get; set; }
    
        /// <summary>The id of the logical port through which the traceflow packet was forwarded.</summary>
        [Newtonsoft.Json.JsonProperty("lport_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lport_id { get; set; }
    
        /// <summary>The id of the destination component to which the traceflow packet was forwarded.</summary>
        [Newtonsoft.Json.JsonProperty("dst_component_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dst_component_id { get; set; }
    
        /// <summary>This field specified the prefix IP address a traceflow packet matched in the whitelist in spoofguard.</summary>
        [Newtonsoft.Json.JsonProperty("spoofguard_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Spoofguard_ip { get; set; }
    
        /// <summary>The ttl of the service insertion component</summary>
        [Newtonsoft.Json.JsonProperty("service_ttl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Service_ttl { get; set; }
    
        /// <summary>MAC address of nexthop for service insertion(SI)
        /// in service VM(SVM) where the traceflow packet was received.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("svc_nh_mac", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Svc_nh_mac { get; set; }
    
    
    }
    
    /// <summary>Represents an endpoint which will be used as subject in rule.
    /// It is a polymorphic type object which can be either of the types -
    /// 1. Virtual
    /// 2. Logical
    /// We have 2 separate objects representing these 2 types.
    /// VirtualEndPoint for Virtual type and ServiceInstanceEndpoint
    /// for Logical.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("VirtualEndpoint", typeof(VirtualEndpoint))]
    [JsonInheritanceAttribute("ServiceInstanceEndpoint", typeof(ServiceInstanceEndpoint))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BaseEndpoint : PolicyConfigResource
    {
        /// <summary>IPs where either inbound or outbound traffic is to be redirected.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("target_ips", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<IPInfo> Target_ips { get; set; } = new System.Collections.ObjectModel.Collection<IPInfo>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LacpGroupConfigInfo 
    {
        /// <summary>The key represents the identifier for the group that is unique
        /// across VC.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }
    
        /// <summary>The display name of the LACP group.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Keys for the uplink ports in the group. Each uplink port is
        /// assigned a key that is unique across VC.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uplink_port_keys", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Uplink_port_keys { get; set; }
    
        /// <summary>To set the lag mode as fast for LACP. By default, it will be slow.</summary>
        [Newtonsoft.Json.JsonProperty("timeout_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LacpGroupConfigInfoTimeout_type? Timeout_type { get; set; } = SDKGenerator.LacpGroupConfigInfoTimeout_type.SLOW;
    
        /// <summary>Load balance algorithm used in LACP group. The possible values
        /// are dictated by the values available in VC. Please refer
        /// VMwareDvsLacpLoadBalanceAlgorithm documentation for a full list
        /// of values. A few examples are srcDestIp where source and destination
        /// IP are considered, srcIp where only source IP is considered.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("load_balance_algorithm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Load_balance_algorithm { get; set; }
    
        /// <summary>The number of uplink ports</summary>
        [Newtonsoft.Json.JsonProperty("uplink_num", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Uplink_num { get; set; }
    
        /// <summary>Names for the uplink ports in the group.</summary>
        [Newtonsoft.Json.JsonProperty("uplink_names", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Uplink_names { get; set; }
    
        /// <summary>The mode of LACP can be ACTIVE or PASSIVE. If the mode is ACTIVE, LACP
        /// is enabled unconditionally. If the mode is PASSIVE, LACP is enabled
        /// only if LACP device is detected.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LacpGroupConfigInfoMode? Mode { get; set; }
    
    
    }
    
    /// <summary>An entity that encapsulates attributes to schedule firewall rules to
    /// be active to allow or block traffic for a specific period of time.
    /// Note that at least one property out of "days", "start_time",
    /// "end_time", "start_date", "end_date" is required.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyFirewallScheduler : PolicyConfigResource
    {
        /// <summary>The recurring time interval in a day during which the schedule will be
        /// applicable. It should not be present when the recurring flag is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<PolicyTimeIntervalValue> Time_interval { get; set; }
    
        /// <summary>If recurring field is set false, then this field must be present. The
        /// schedule will be enforced till the end time of the specified end date.
        /// If recurring field is set true, then this field should not be present.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("end_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string End_time { get; set; }
    
        /// <summary>End date on which schedule to end. Example, 12/22/2019.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("end_date", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string End_date { get; set; }
    
        /// <summary>Host Timezone to be used to enforce firewall rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timezone", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyFirewallSchedulerTimezone Timezone { get; set; }
    
        /// <summary>Time in 24 hour and minutes in multiple of 30. Example, 9:00. If
        /// recurring field is set false, then this field must be present. The
        /// schedule will start getting enforced from the start time of the
        /// specified start date. If recurring field is set true, then this
        /// field should not be present.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("start_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Start_time { get; set; }
    
        /// <summary>Flag to indicate whether firewall schedule recurs or not. The default
        /// value is true and it should be set to false when the firewall schedule
        /// does not recur and is a one time time interval.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("recurring", Required = Newtonsoft.Json.Required.Always)]
        public bool Recurring { get; set; } = true;
    
        /// <summary>Days of week on which rules will be enforced. If property is omitted,
        /// then days of the week will not considered while calculating the
        /// firewall schedule. It should not be present when the recurring flag
        /// is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("days", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Days> Days { get; set; }
    
        /// <summary>Start date on which schedule to start. Example, 02/22/2019.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("start_date", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Start_date { get; set; }
    
    
    }
    
    /// <summary>IPSec VPN session statistics represents statistics on an NSX-T type of enforcement
    /// point. It gives aggregated statistics of all policies for all the tunnels.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnSessionStatistics : L3VpnStatisticsPerEnforcementPoint
    {
        /// <summary>Timestamp when the data was last updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>Traffic statistics for IPSec VPN Ike session.
        /// Note - Not supported in this release.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ike_traffic_statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IPSecVpnIkeTrafficStatistics Ike_traffic_statistics { get; set; }
    
        /// <summary>Status for IPSec VPN Ike session UP/DOWN and fail reason if Ike session is down.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ike_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IPSecVpnIkeSessionStatus Ike_status { get; set; }
    
        /// <summary>Gives aggregate traffic statistics across all ipsec tunnels and individual tunnel
        /// statistics.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("policy_statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IPSecVpnPolicyTrafficStatistics> Policy_statistics { get; set; }
    
        /// <summary>Aggregate traffic statistics across all ipsec tunnels.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("aggregate_traffic_counters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IPSecVpnTrafficCounters Aggregate_traffic_counters { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of LBPersistenceProfiles</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBPersistenceProfileListResult : ListResult
    {
        /// <summary>LBPersistenceProfile list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<LBPersistenceProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<LBPersistenceProfile>();
    
    
    }
    
    /// <summary>Paged Collection of IPSecVpnLocalEndpoint.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnLocalEndpointListResult : ListResult
    {
        /// <summary>IPSecVpnLocalEndpoint list results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IPSecVpnLocalEndpoint> Results { get; set; } = new System.Collections.ObjectModel.Collection<IPSecVpnLocalEndpoint>();
    
    
    }
    
    /// <summary>Registering a Service is the first step in the ServiceInsertion mechanism. A ServiceDefinition is used to create a service.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServiceDefinition : ManagedResource
    {
        /// <summary>Service Deployment Specification defines takes in information required to deploy and configure a partner appliance/service-vm.</summary>
        [Newtonsoft.Json.JsonProperty("service_deployment_spec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ServiceDeploymentSpec Service_deployment_spec { get; set; }
    
        /// <summary>Service capability.</summary>
        [Newtonsoft.Json.JsonProperty("service_capability", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ServiceCapability Service_capability { get; set; }
    
        /// <summary>The capabilities provided by the services. Needs to be one or more of the following | NG_FW - Next Generation Firewall | IDS_IPS - Intrusion Detection System / Intrusion Prevention System | NET_MON - Network Monitoring | HCX - Hybrid Cloud Exchange | BYOD - Bring Your Own Device | TLB -  Transparent Load Balancer | EPP - Endpoint Protection.(Third party AntiVirus partners using NXGI should use this functionality for the service)</summary>
        [Newtonsoft.Json.JsonProperty("functionalities", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<Functionalities> Functionalities { get; set; } = new System.Collections.ObjectModel.Collection<Functionalities>();
    
        /// <summary>The point at which the service is deployed/attached for redirecting the traffic to the the partner appliance. Attachment Point is required if Service caters to any functionality other than EPP.</summary>
        [Newtonsoft.Json.JsonProperty("attachment_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.MaxLength(2)]
        public System.Collections.Generic.ICollection<Attachment_point> Attachment_point { get; set; }
    
        /// <summary>ID of the service manager to which this service is attached with.
        /// This field is not set during creation of service. This field will
        /// be set explicitly when Service Manager is created successfully using this service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service_manager_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Service_manager_id { get; set; }
    
        /// <summary>Id which is unique to a vendor or partner for which the service is created.</summary>
        [Newtonsoft.Json.JsonProperty("vendor_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Vendor_id { get; set; }
    
        /// <summary>Failure policy for the service tells datapath, the action to take i.e to Allow or Block traffic during failure scenarios. For north-south ServiceInsertion, failure policy in the service instance takes precedence. For east-west ServiceInsertion, failure policy in the service chain takes precedence. BLOCK is not supported for Endpoint protection (EPP) functionality.</summary>
        [Newtonsoft.Json.JsonProperty("on_failure_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ServiceDefinitionOn_failure_policy? On_failure_policy { get; set; } = SDKGenerator.ServiceDefinitionOn_failure_policy.ALLOW;
    
        /// <summary>Transport Type of the service, which is the mechanism of redirecting the traffic to the the partner appliance. Transport type is required if Service caters to any functionality other than EPP.</summary>
        [Newtonsoft.Json.JsonProperty("transports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<Transports2> Transports { get; set; }
    
        /// <summary>This indicates the insertion point of the service i.e whether the service will be used to protect North-South or East-West traffic in the datacenter.</summary>
        [Newtonsoft.Json.JsonProperty("implementations", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<Implementations> Implementations { get; set; } = new System.Collections.ObjectModel.Collection<Implementations>();
    
    
    }
    
    /// <summary>Query statistics counters of used cache from node
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class NsxTPerNodeUsedCacheStatistics 
    {
        /// <summary>The total number of cached entries</summary>
        [Newtonsoft.Json.JsonProperty("cached_entries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Cached_entries { get; set; }
    
        /// <summary>UUID of active/standby transport node</summary>
        [Newtonsoft.Json.JsonProperty("node_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Node_id { get; set; }
    
        /// <summary>The memory size used in cache, in kb</summary>
        [Newtonsoft.Json.JsonProperty("used_cache_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Used_cache_size { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of PolicyResourceReference</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyResourceReferenceListResult : ListResult
    {
        /// <summary>Policy resource references list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyResourceReference> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyResourceReference>();
    
    
    }
    
    /// <summary>Match conditions are used to match application traffic passing through
    /// load balancers. Multiple match conditions can be specified in one load
    /// balancer rule, each match condition defines a criterion for application
    /// traffic.
    /// If inverse field is set to true, the match result of the condition is
    /// inverted.
    /// If more than one match condition is specified, match strategy determines
    /// if all conditions should match or any one condition should match for the
    /// load balancer rule to be considered a match.
    /// Currently only HTTP messages are supported by load balancer rules.
    /// Each load balancer rule is used at a specific phase of load balancer
    /// processing. Currently three phases are supported, HTTP_REQUEST_REWRITE,
    /// HTTP_FORWARDING and HTTP_RESPONSE_REWRITE.
    /// Each phase supports certain types of match conditions, supported match
    /// conditions in HTTP_REQUEST_REWRITE phase are:
    /// LBHttpRequestMethodCondition
    /// LBHttpRequestUriCondition
    /// LBHttpRequestUriArgumentsCondition
    /// LBHttpRequestVersionCondition
    /// LBHttpRequestHeaderCondition
    /// LBHttpRequestCookieCondition
    /// LBHttpRequestBodyCondition
    /// LBTcpHeaderCondition
    /// LBIpHeaderCondition
    /// LBVariableCondition
    /// LBHttpSslCondition
    /// Supported match conditions in HTTP_FORWARDING phase are:
    /// LBHttpRequestMethodCondition
    /// LBHttpRequestUriCondition
    /// LBHttpRequestUriArgumentsCondition
    /// LBHttpRequestVersionCondition
    /// LBHttpRequestHeaderCondition
    /// LBHttpRequestCookieCondition
    /// LBHttpRequestBodyCondition
    /// LBTcpHeaderCondition
    /// LBIpHeaderCondition
    /// LBVariableCondition
    /// LBHttpSslCondition
    /// LBSslSniCondition
    /// Supported match conditions in HTTP_RESPONSE_REWRITE phase are:
    /// LBHttpResponseHeaderCondition
    /// LBHttpRequestMethodCondition
    /// LBHttpRequestUriCondition
    /// LBHttpRequestUriArgumentsCondition
    /// LBHttpRequestVersionCondition
    /// LBHttpRequestHeaderCondition
    /// LBHttpRequestCookieCondition
    /// LBTcpHeaderCondition
    /// LBIpHeaderCondition
    /// LBVariableCondition
    /// LBHttpSslCondition
    /// Supported match condition in HTTP_ACCESS phase is:
    /// LBHttpRequestMethodCondition
    /// LBHttpRequestUriCondition
    /// LBHttpRequestUriArgumentsCondition
    /// LBHttpRequestVersionCondition
    /// LBHttpRequestHeaderCondition
    /// LBHttpRequestCookieCondition
    /// LBHttpRequestBodyCondition
    /// LBTcpHeaderCondition
    /// LBIpHeaderCondition
    /// LBVariableCondition
    /// LBHttpSslCondition
    /// Supported match condition in TRANSPORT phase is:
    /// LBSslSniCondition
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "type")]
    [JsonInheritanceAttribute("LBHttpRequestUriArgumentsCondition", typeof(LBHttpRequestUriArgumentsCondition))]
    [JsonInheritanceAttribute("LBHttpRequestVersionCondition", typeof(LBHttpRequestVersionCondition))]
    [JsonInheritanceAttribute("LBSslSniCondition", typeof(LBSslSniCondition))]
    [JsonInheritanceAttribute("LBHttpRequestBodyCondition", typeof(LBHttpRequestBodyCondition))]
    [JsonInheritanceAttribute("LBHttpSslCondition", typeof(LBHttpSslCondition))]
    [JsonInheritanceAttribute("LBHttpResponseHeaderCondition", typeof(LBHttpResponseHeaderCondition))]
    [JsonInheritanceAttribute("LBHttpRequestHeaderCondition", typeof(LBHttpRequestHeaderCondition))]
    [JsonInheritanceAttribute("LBHttpRequestMethodCondition", typeof(LBHttpRequestMethodCondition))]
    [JsonInheritanceAttribute("LBHttpRequestCookieCondition", typeof(LBHttpRequestCookieCondition))]
    [JsonInheritanceAttribute("LBVariableCondition", typeof(LBVariableCondition))]
    [JsonInheritanceAttribute("LBHttpRequestUriCondition", typeof(LBHttpRequestUriCondition))]
    [JsonInheritanceAttribute("LBTcpHeaderCondition", typeof(LBTcpHeaderCondition))]
    [JsonInheritanceAttribute("LBIpHeaderCondition", typeof(LBIpHeaderCondition))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBRuleCondition 
    {
        /// <summary>A flag to indicate whether reverse the match result of this condition</summary>
        [Newtonsoft.Json.JsonProperty("inverse", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Inverse { get; set; } = false;
    
    
    }
    
    /// <summary>Container application instance within a project.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ContainerApplicationInstance : DiscoveredResource
    {
        /// <summary>Status of the container application instance.</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ContainerApplicationInstanceStatus? Status { get; set; }
    
        /// <summary>Network status of container application instance.</summary>
        [Newtonsoft.Json.JsonProperty("network_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ContainerApplicationInstanceNetwork_status? Network_status { get; set; }
    
        /// <summary>Identifier of the container cluster this application instance belongs to.</summary>
        [Newtonsoft.Json.JsonProperty("container_cluster_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Container_cluster_id { get; set; }
    
        /// <summary>Cluster node id where application instance is running.</summary>
        [Newtonsoft.Json.JsonProperty("cluster_node_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cluster_node_id { get; set; }
    
        /// <summary>Identifier of the container application instance on container cluster.</summary>
        [Newtonsoft.Json.JsonProperty("external_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string External_id { get; set; }
    
        /// <summary>Array of additional specific properties of container application instance
        /// in key-value format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("origin_properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyValuePair> Origin_properties { get; set; }
    
        /// <summary>List of identifiers of the container application.</summary>
        [Newtonsoft.Json.JsonProperty("container_application_ids", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Container_application_ids { get; set; }
    
        /// <summary>Identifier of the container project which this container application instance
        /// belongs to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("container_project_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Container_project_id { get; set; }
    
        /// <summary>List of network errors related to container application instance.</summary>
        [Newtonsoft.Json.JsonProperty("network_errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<NetworkError> Network_errors { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer PoolGroup object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBPoolGroup : PolicyConfigResource
    {
        /// <summary>Name of the user who created the object.</summary>
        [Newtonsoft.Json.JsonProperty("created_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_by { get; set; }
    
        /// <summary>Metadata pertaining to the service provided by this
        /// PoolGroup.
        /// In Openshift/Kubernetes environments, app metadata info is
        /// stored.
        /// Any user input to this field will be overwritten by Avi
        /// Vantage.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service_metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Service_metadata { get; set; }
    
        /// <summary>Checksum of cloud configuration for PoolGroup.
        /// Internally set by cloud connector.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cloud_config_cksum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cloud_config_cksum { get; set; }
    
        /// <summary>Whether an implicit set of priority labels is generated.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("implicit_priority_labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Implicit_priority_labels { get; set; } = false;
    
        /// <summary>The minimum number of servers to distribute traffic to.
        /// Allowed values are 1-65535.
        /// Special values are 0 - 'Disable'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("min_servers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Min_servers { get; set; } = 0L;
    
        /// <summary>path of the priority labels.
        /// If not provided, pool group member priority label will be
        /// interpreted as a number with a larger number considered
        /// higher priority.
        /// It is a reference to an object of type PriorityLabels.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("priority_labels_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Priority_labels_path { get; set; }
    
        /// <summary>Enable an action - Close Connection, HTTP Redirect, or
        /// Local HTTP Response - when a pool group failure happens.
        /// By default, a connection will be closed, in case the pool
        /// group experiences a failure.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fail_action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBFailAction Fail_action { get; set; }
    
        /// <summary>When setup autoscale manager will automatically promote new
        /// pools into production when deployment goals are met.
        /// It is a reference to an object of type
        /// PoolGroupDeploymentPolicy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("deployment_policy_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Deployment_policy_path { get; set; }
    
        /// <summary>List of pool group members object of type PoolGroupMember.</summary>
        [Newtonsoft.Json.JsonProperty("members", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBPoolGroupMember> Members { get; set; }
    
        /// <summary>Enable HTTP/2 for traffic from VirtualService to all the
        /// backend servers in all the pools configured under this
        /// PoolGroup.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_http2", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_http2 { get; set; } = false;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LiveTraceResult 
    {
        /// <summary>PktCap action results</summary>
        [Newtonsoft.Json.JsonProperty("pktcap_results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PktCapResult> Pktcap_results { get; set; }
    
        /// <summary>Count action list results</summary>
        [Newtonsoft.Json.JsonProperty("count_results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CountResult> Count_results { get; set; }
    
        /// <summary>The id is assigned by live trace and cannot be specified by user.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
        /// <summary>Trace action observation list results</summary>
        [Newtonsoft.Json.JsonProperty("trace_results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TraceResult> Trace_results { get; set; }
    
    
    }
    
    /// <summary>Virtual server acts as a facade to an application, receives all client
    /// connections over HTTPS and distributes them among the backend servers.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class HttpsPolicyLbVirtualServer : HttpPolicyLbVirtualServer
    {
        /// <summary>Security settings representing various security settings
        /// when the VirtualServer acts as an SSL server
        /// - BASE_SECURE_111317
        /// - MODERATE_SECURE_111317
        /// - HIGH_SECURE_111317
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_ssl_settings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public HttpsPolicyLbVirtualServerClient_ssl_settings? Client_ssl_settings { get; set; } = SDKGenerator.HttpsPolicyLbVirtualServerClient_ssl_settings.HIGH_SECURE_111317;
    
        /// <summary>Client-side SSL profile binding allows multiple
        /// certificates, for different hostnames, to be bound to the same virtual
        /// server. The setting is used when load balancer acts as an SSL server
        /// and terminating the client SSL connection
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_ssl_certificate_ids", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Client_ssl_certificate_ids { get; set; }
    
        /// <summary>The setting is used when load balancer acts as an SSL
        /// server and terminating the client SSL connection.  A default
        /// certificate should be specified which will be used if the server does
        /// not host multiple hostnames on the same IP address or if the client
        /// does not support SNI extension.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("default_client_ssl_certificate_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Default_client_ssl_certificate_id { get; set; }
    
    
    }
    
    /// <summary>Encapsulation method for EVPN.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EvpnEncapConfig : PolicyConfigResource
    {
        /// <summary>vni pool path</summary>
        [Newtonsoft.Json.JsonProperty("vni_pool_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Vni_pool_path { get; set; }
    
        /// <summary>EVPN tenant config path</summary>
        [Newtonsoft.Json.JsonProperty("evpn_tenant_config_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Evpn_tenant_config_path { get; set; }
    
    
    }
    
    /// <summary>List of IP address allocations</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IpAddressAllocationListResult : ListResult
    {
        /// <summary>List of IpAddressAllocations</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IpAddressAllocation> Results { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsTransportProtocolMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsTransportProtocolMatch 
    {
        /// <summary>Protocol to match against transport protocol used by DNS
        /// query.
        /// Enum options - DNS_OVER_UDP, DNS_OVER_TCP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBDnsTransportProtocolMatchProtocol Protocol { get; set; }
    
        /// <summary>Criterion to use for matching the DNS transport protocol.
        /// Enum options - IS_IN, IS_NOT_IN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBDnsTransportProtocolMatchMatch_criteria Match_criteria { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBHardwareSecurityModuleGroup, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBHardwareSecurityModuleGroup : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBHardwareSecurityModuleGroup object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBHardwareSecurityModuleGroup", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBHardwareSecurityModuleGroup ALBHardwareSecurityModuleGroup { get; set; }
    
    
    }
    
    /// <summary>Information about recent changes, if any, that are not reflected in the Enforced Realized Status.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PendingChangesInfoNsxT 
    {
        /// <summary>Flag describing whether there are any pending changes that are not reflected in the status.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pending_changes_flag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Pending_changes_flag { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of Groups</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EndpointPolicyListResult : ListResult
    {
        /// <summary>Guest Introspection Map list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<EndpointPolicy> Results { get; set; } = new System.Collections.ObjectModel.Collection<EndpointPolicy>();
    
    
    }
    
    /// <summary>ProtocolParserApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBProtocolParserApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of ProtocolParser
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBProtocolParser> Results { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPInfo 
    {
        /// <summary>IPv4 Addresses</summary>
        [Newtonsoft.Json.JsonProperty("ip_addresses", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Ip_addresses { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Subnet Prefix Length</summary>
        [Newtonsoft.Json.JsonProperty("prefix_length", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1D, 32D)]
        public long Prefix_length { get; set; }
    
    
    }
    
    /// <summary>Contains ARP snooping related configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ArpSnoopingConfig 
    {
        /// <summary>Number of arp snooped IP addresses
        /// Indicates the number of arp snooped IP addresses to be remembered
        /// per LogicalPort. Decreasing this value, will retain the latest
        /// bindings from the existing list of address bindings. Increasing this
        /// value will retain existing bindings and also learn any new address
        /// bindings discovered on the port until the new limit is reached.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("arp_binding_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 256D)]
        public long? Arp_binding_limit { get; set; } = 1L;
    
        /// <summary>Indicates whether ARP snooping is enabled</summary>
        [Newtonsoft.Json.JsonProperty("arp_snooping_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Arp_snooping_enabled { get; set; } = true;
    
    
    }
    
    /// <summary>Paged Collection of LBPoolStatusPerEP</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregateLBPoolStatus : AggregatePolicyRuntimeInfo
    {
        /// <summary>LBPoolStatusPerEP list results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBPoolStatusPerEP> Results { get; set; }
    
    
    }
    
    /// <summary>Contains information necessary to configure L2Vpn.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2Vpn : PolicyConfigResource
    {
        /// <summary>List of paths referencing transport tunnels.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transport_tunnels", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Transport_tunnels { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Enable to extend all the associated segments.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
    
    }
    
    /// <summary>Child wrapper for ALBVirtualService, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBVirtualService : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBVirtualService object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBVirtualService", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBVirtualService ALBVirtualService { get; set; }
    
    
    }
    
    /// <summary>This holds the list of policy drafts.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyDraftListResult : ListResult
    {
        /// <summary>Paginated list of policy drafts.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyDraft> Results { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of LBPoolStatisticsPerEP</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregateLBPoolStatistics : AggregatePolicyRuntimeInfo
    {
        /// <summary>LBPoolStatisticsPerEP list results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBPoolStatisticsPerEP> Results { get; set; }
    
    
    }
    
    /// <summary>This entity will be used to establish association between qos
    /// profile and Port. Using this entity, you can  specify intent for applying
    /// qos profile to particular Port. Port here is Segment Port.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PortQoSProfileBindingMap : QoSProfileBindingMap
    {
        /// <summary>PolicyPath of associated  QoS Profile</summary>
        [Newtonsoft.Json.JsonProperty("qos_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Qos_profile_path { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedVirtualMachineListResult : ListResult
    {
        /// <summary>Paged Collection of VMs</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RealizedVirtualMachine> Results { get; set; }
    
    
    }
    
    /// <summary>Represents X and Y axes of a graph. For a multi-graph, the same axes are shared by all the graphs.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Axes 
    {
        /// <summary>Label for X axis of a graph</summary>
        [Newtonsoft.Json.JsonProperty("x_label", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Label X_label { get; set; }
    
        /// <summary>Label for Y axis of a graph</summary>
        [Newtonsoft.Json.JsonProperty("y_label", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Label Y_label { get; set; }
    
    
    }
    
    /// <summary>Set criteria for route map entry</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RouteMapEntrySet 
    {
        /// <summary>For incoming and import route_maps on receiving both v6 global
        /// and v6 link-local address for the route, prefer to use the global
        /// address as the next hop. By default, it prefers the link-local next hop.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("prefer_global_v6_next_hop", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Prefer_global_v6_next_hop { get; set; }
    
        /// <summary>Multi exit descriminator (MED) is a hint to BGP neighbors about
        /// the preferred path into an autonomous system (AS) that has multiple
        /// entry points. A lower MED value is preferred over a higher value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("med", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? Med { get; set; }
    
        /// <summary>Local preference indicates the degree of preference for one BGP route
        /// over other BGP routes. The path with highest local preference is
        /// preferred.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("local_preference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(int.MinValue, 4294967295D)]
        public long? Local_preference { get; set; } = 100L;
    
        /// <summary>Weight is used to select a route when multiple routes are available
        /// to the same network. Route with the highest weight is preferred.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("weight", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Weight { get; set; }
    
        /// <summary>AS path prepend to influence route selection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("as_path_prepend", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string As_path_prepend { get; set; }
    
        /// <summary>Set BGP regular or large community for matching routes. A maximum of one value for each community
        /// type separated by space. Well-known community name, community value in aa:nn (2byte:2byte) format for regular
        /// community and community value in aa:bb:nn (4byte:4byte:4byte) format for large community are supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("community", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Community { get; set; }
    
    
    }
    
    /// <summary>LBJwtKey specifies the symmetric key or asymmetric public key used to
    /// decrypt the data in JWT.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "type")]
    [JsonInheritanceAttribute("LBJwtCertificateKey", typeof(LBJwtCertificateKey))]
    [JsonInheritanceAttribute("LBJwtSymmetricKey", typeof(LBJwtSymmetricKey))]
    [JsonInheritanceAttribute("LBJwtPublicKey", typeof(LBJwtPublicKey))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBJwtKey 
    {
    
    }
    
    /// <summary>Child wrapper for ALBApplicationProfile, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBApplicationProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBApplicationProfile object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBApplicationProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBApplicationProfile ALBApplicationProfile { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for IdsSettings, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIdsSettings : ChildPolicyConfigResource
    {
        /// <summary>Contains the IdsSettings object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IdsSettings", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IdsSettings IdsSettings { get; set; }
    
    
    }
    
    /// <summary>List of CIDR values</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CidrArrayConstraintValue : ConstraintValue
    {
        /// <summary>This array can consist of a single IP address, IP address range or a subnet. Its type can be of either IPv4 or IPv6. Both IPv4 and IPv6 addresses within one expression is not allowed. Supported list of formats are, "192.168.1.1", "192.168.1.1-192.168.1.100", "192.168.0.0/24", "fe80::250:56ff:fe83:318c", "fe80::250:56ff:fe83:3181-fe80::250:56ff:fe83:318c", "fe80::250:56ff:fe83:318c/64".</summary>
        [Newtonsoft.Json.JsonProperty("values", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(100)]
        public System.Collections.Generic.ICollection<string> Values { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>User supplied metadata needed for resolving errors</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ErrorResolverUserMetadata 
    {
        /// <summary>List of user supplied input data.</summary>
        [Newtonsoft.Json.JsonProperty("user_input_list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ErrorResolverUserInputData> User_input_list { get; set; }
    
    
    }
    
    /// <summary>Base class for list results from collections</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ListResult : Resource
    {
        /// <summary>Opaque cursor to be used for getting next page of records (supplied by current result page)</summary>
        [Newtonsoft.Json.JsonProperty("cursor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cursor { get; set; }
    
        /// <summary>If true, results are sorted in ascending order</summary>
        [Newtonsoft.Json.JsonProperty("sort_ascending", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Sort_ascending { get; set; }
    
        /// <summary>Field by which records are sorted</summary>
        [Newtonsoft.Json.JsonProperty("sort_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sort_by { get; set; }
    
        /// <summary>Count of results found (across all pages), set only on first page</summary>
        [Newtonsoft.Json.JsonProperty("result_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Result_count { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DhcpIpPoolUsage 
    {
        /// <summary>allocated percentage. COULD BE INACCURATE, REFERENCE ONLY.</summary>
        [Newtonsoft.Json.JsonProperty("allocated_percentage", Required = Newtonsoft.Json.Required.Always)]
        public long Allocated_percentage { get; set; }
    
        /// <summary>pool size</summary>
        [Newtonsoft.Json.JsonProperty("pool_size", Required = Newtonsoft.Json.Required.Always)]
        public long Pool_size { get; set; }
    
        /// <summary>allocated number. COULD BE INACCURATE, REFERENCE ONLY.</summary>
        [Newtonsoft.Json.JsonProperty("allocated_number", Required = Newtonsoft.Json.Required.Always)]
        public long Allocated_number { get; set; }
    
        /// <summary>uuid of dhcp ip pool</summary>
        [Newtonsoft.Json.JsonProperty("dhcp_ip_pool_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Dhcp_ip_pool_id { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of security policies</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SecurityPolicyListResult : PolicyListResult
    {
        /// <summary>SecurityPolicy list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SecurityPolicy> Results { get; set; } = new System.Collections.ObjectModel.Collection<SecurityPolicy>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AdvanceClusterRestoreInput 
    {
        /// <summary>Unique id of an instruction (as returned by the GET /restore/status
        /// call) for which input is to be provided
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
        /// <summary>List of resources for which the instruction is applicable.</summary>
        [Newtonsoft.Json.JsonProperty("resources", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SelectableResourceReference> Resources { get; set; } = new System.Collections.ObjectModel.Collection<SelectableResourceReference>();
    
    
    }
    
    /// <summary>A key-value pair with no limitations on size</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class UnboundedKeyValuePair 
    {
        /// <summary>Value</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }
    
        /// <summary>Key</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }
    
    
    }
    
    /// <summary>The reputation severity of an URL.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyUrlReputationSeverity : PolicyConfigResource
    {
        /// <summary>The maximum reputation for the severity.</summary>
        [Newtonsoft.Json.JsonProperty("max_reputation", Required = Newtonsoft.Json.Required.Always)]
        public long Max_reputation { get; set; }
    
        /// <summary>The minimum reputation for the severity.</summary>
        [Newtonsoft.Json.JsonProperty("min_reputation", Required = Newtonsoft.Json.Required.Always)]
        public long Min_reputation { get; set; }
    
        /// <summary>The id of the reputation severity.</summary>
        [Newtonsoft.Json.JsonProperty("reputation_severity_id", Required = Newtonsoft.Json.Required.Always)]
        public long Reputation_severity_id { get; set; }
    
        /// <summary>The name of the severity.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
    
    }
    
    /// <summary>Wrapper object for PolicyExcludeList</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyExcludeList : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual policy exclude list object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyExcludeList", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyExcludeList PolicyExcludeList { get; set; }
    
    
    }
    
    /// <summary>Policy port will create LogicalPort on LogicalSwitch corresponding to the Segment. Address bindings cannot be removed after realization.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentPort : PolicyConfigResource
    {
        /// <summary>Set initial state when a new logical port is created. 'UNBLOCKED_VLAN'
        /// means new port will be unblocked on traffic in creation, also VLAN will
        /// be set with corresponding logical switch setting. This port setting
        /// can only be configured at port creation, and cannot be modified.
        /// 'RESTORE_VIF' fetches and restores VIF attachment from ESX host.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("init_state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SegmentPortInit_state? Init_state { get; set; }
    
        /// <summary>Represents desired state of the segment port</summary>
        [Newtonsoft.Json.JsonProperty("admin_state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SegmentPortAdmin_state? Admin_state { get; set; } = SDKGenerator.SegmentPortAdmin_state.UP;
    
        /// <summary>Only VIF attachment is supported</summary>
        [Newtonsoft.Json.JsonProperty("attachment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PortAttachment Attachment { get; set; }
    
        /// <summary>This property could be used for vendor specific configuration in key value
        /// string pairs. Segment port setting will override segment setting if
        /// the same key was set on both segment and segment port.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("extra_configs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SegmentExtraConfig> Extra_configs { get; set; }
    
        /// <summary>IP Discovery module uses various mechanisms to discover address
        /// bindings being used on each segment port. If a user would like to
        /// ignore any specific discovered address bindings or prevent the
        /// discovery of a particular set of discovered bindings, then those
        /// address bindings can be provided here. Currently IP range in CIDR format
        /// is not supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ignored_address_bindings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(16)]
        public System.Collections.Generic.ICollection<PortAddressBindingEntry> Ignored_address_bindings { get; set; }
    
        /// <summary>Static address binding used for the port.</summary>
        [Newtonsoft.Json.JsonProperty("address_bindings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(512)]
        public System.Collections.Generic.ICollection<PortAddressBindingEntry> Address_bindings { get; set; }
    
        /// <summary>This field will refer to the source site on which the segment
        /// port is discovered. This field is populated by GM, when it
        /// receives corresponding notification from LM.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source_site_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source_site_id { get; set; }
    
    
    }
    
    /// <summary>Paged collection of segment security profile binding maps</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentSecurityProfileBindingMapListResult : ListResult
    {
        /// <summary>Segment security profile binding map list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SegmentSecurityProfileBindingMap> Results { get; set; } = new System.Collections.ObjectModel.Collection<SegmentSecurityProfileBindingMap>();
    
    
    }
    
    /// <summary>Active healthchecks are disabled by default and can be enabled for a
    /// server pool by binding a health monitor to the Group through the
    /// PolicyLbRule object. This represents active health monitoring over TCP.
    /// Active healthchecks are initiated periodically, at a configurable
    /// interval, to each member of the Group. Only if a healthcheck fails
    /// consecutively for a specified number of times (fall_count) to a member
    /// will the member status be marked DOWN. Once a member is DOWN, a specified
    ///  number of consecutive successful healthchecks (rise_count) will bring
    ///  the member back to UP state. After a healthcheck is initiated, if it
    ///  does not complete within a certain period, then also
    /// the healthcheck is considered to be unsuccessful. Completing a
    /// healthcheck within timeout means establishing a connection (TCP or SSL),
    /// if applicable, sending the request and receiving the response, all within
    /// the configured timeout.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TcpPolicyLbMonitorProfile : PolicyLbMonitorProfile
    {
    
    }
    
    /// <summary>Paged collection of IP Discovery Profiles</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPDiscoveryProfileListResult : ListResult
    {
        /// <summary>IP Discovery profile list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IPDiscoveryProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<IPDiscoveryProfile>();
    
    
    }
    
    /// <summary>Paged Collection of session timer profile binding maps</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SessionTimerProfileBindingListResult : ListResult
    {
        /// <summary>Session timer profile binding maps list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SessionTimerProfileBindingMap> Results { get; set; } = new System.Collections.ObjectModel.Collection<SessionTimerProfileBindingMap>();
    
    
    }
    
    /// <summary>Paged collection of Group Monitoring Profile Binding Maps</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GroupMonitoringProfileBindingMapListResult : ListResult
    {
        /// <summary>Group Monitoring Profile Binding Map list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<GroupMonitoringProfileBindingMap> Results { get; set; } = new System.Collections.ObjectModel.Collection<GroupMonitoringProfileBindingMap>();
    
    
    }
    
    /// <summary>Paged Collection of IPFIX L2 Profile</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPFIXL2ProfileListResult : ListResult
    {
        /// <summary>IPFIX L2 Profile list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IPFIXL2Profile> Results { get; set; } = new System.Collections.ObjectModel.Collection<IPFIXL2Profile>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBServiceStatistics : LBServiceStatisticsPerEP
    {
        /// <summary>Statistics of load balancer pools</summary>
        [Newtonsoft.Json.JsonProperty("pools", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBPoolStatistics> Pools { get; set; }
    
        /// <summary>Timestamp when the data was last updated.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>Statistics of load balancer virtual servers.</summary>
        [Newtonsoft.Json.JsonProperty("virtual_servers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBVirtualServerStatistics> Virtual_servers { get; set; }
    
        /// <summary>load balancer service identifier.</summary>
        [Newtonsoft.Json.JsonProperty("service_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Service_path { get; set; }
    
        /// <summary>Load balancer service statistics counter.</summary>
        [Newtonsoft.Json.JsonProperty("statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LBServiceStatisticsCounter Statistics { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer AuthorizationAction object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAuthorizationAction 
    {
        /// <summary>HTTP status code to use for local response when an policy
        /// rule is matched.
        /// Enum options - HTTP_RESPONSE_STATUS_CODE_401,
        /// HTTP_RESPONSE_STATUS_CODE_403.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBAuthorizationActionStatus_code? Status_code { get; set; }
    
        /// <summary>Defines the action taken when an authorization policy rule
        /// is matched.
        /// By default, access is allowed to the requested resource.
        /// Enum options - ALLOW_ACCESS, CLOSE_CONNECTION,
        /// HTTP_LOCAL_RESPONSE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as ALLOW_ACCESS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBAuthorizationActionType? Type { get; set; } = SDKGenerator.ALBAuthorizationActionType.ALLOW_ACCESS;
    
    
    }
    
    /// <summary>Service chain is a set of network Services. A Service chain is made up of ordered list of service profiles belonging to any same or different services.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyServiceChain : PolicyConfigResource
    {
        /// <summary>Reverse path service profiles are applied to egress traffic and is optional. 2 different set of profiles can be defined for forward and reverse path. If not defined, the reverse of the forward path service profile is applied.</summary>
        [Newtonsoft.Json.JsonProperty("reverse_path_service_profiles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(4)]
        public System.Collections.Generic.ICollection<string> Reverse_path_service_profiles { get; set; }
    
        /// <summary>Path selection policy can be - ANY - Service Insertion is free to redirect to any service path regardless of any load balancing considerations or flow pinning. LOCAL - Preference to be given to local service insances. REMOTE - Preference to be given to the SVM co-located on the same host. ROUND_ROBIN - All active service paths are hit with equal probability.</summary>
        [Newtonsoft.Json.JsonProperty("path_selection_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyServiceChainPath_selection_policy? Path_selection_policy { get; set; } = SDKGenerator.PolicyServiceChainPath_selection_policy.ANY;
    
        /// <summary>Path to service segment using which the traffic needs to be redirected.</summary>
        [Newtonsoft.Json.JsonProperty("service_segment_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Service_segment_path { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Forward path service profiles are applied to ingress traffic.</summary>
        [Newtonsoft.Json.JsonProperty("forward_path_service_profiles", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(4)]
        public System.Collections.Generic.ICollection<string> Forward_path_service_profiles { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Failure policy for the service defines the action to be taken i.e to allow or to block the traffic during failure scenarios.</summary>
        [Newtonsoft.Json.JsonProperty("failure_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyServiceChainFailure_policy? Failure_policy { get; set; } = SDKGenerator.PolicyServiceChainFailure_policy.ALLOW;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceflowObservationDroppedLogical : TraceflowObservationDropped
    {
        /// <summary>The index of service path that is a chain of services
        /// represents the point where the traceflow packet was dropped.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service_path_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Service_path_index { get; set; }
    
        /// <summary>The id of the component that dropped the traceflow packet.</summary>
        [Newtonsoft.Json.JsonProperty("component_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Component_id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedEnforcementPointListResult : ListResult
    {
        /// <summary>Paged Collection of Enforcement Point's</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RealizedEnforcementPoint> Results { get; set; }
    
    
    }
    
    /// <summary>ID and status of the Identity Firewall enabled Compute collection's
    /// transport node.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdfwTransportNodeStatus 
    {
        /// <summary>Status of the IDFW transport node.</summary>
        [Newtonsoft.Json.JsonProperty("transport_node_status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IdfwTransportNodeCondition> Transport_node_status { get; set; } = new System.Collections.ObjectModel.Collection<IdfwTransportNodeCondition>();
    
        /// <summary>TransportNode ID of the Identity Firewall enabled Compute
        /// collection's transport node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transport_node_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Transport_node_id { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DosRateLimitProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDosRateLimitProfile 
    {
        /// <summary>Profile for Connections/Requests rate limiting.</summary>
        [Newtonsoft.Json.JsonProperty("rl_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBRateLimiterProfile Rl_profile { get; set; }
    
        /// <summary>Profile for DoS attack detection.</summary>
        [Newtonsoft.Json.JsonProperty("dos_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDosThresholdProfile Dos_profile { get; set; }
    
    
    }
    
    /// <summary>Represents configuration for filter widget. This is abstract representation of filter widget.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FilterWidgetConfiguration : WidgetConfiguration
    {
        /// <summary>Alias to be used when emitting filter value.</summary>
        [Newtonsoft.Json.JsonProperty("alias", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Alias { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for IpAddressAllocation, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIpAddressAllocation : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual IpAddressAllocation object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IpAddressAllocation", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IpAddressAllocation IpAddressAllocation { get; set; }
    
    
    }
    
    /// <summary>The key is used to specify certificate which is used to verify the
    /// signature of JWT tokens.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBJwtCertificateKey : LBJwtKey
    {
        /// <summary>Certificate identifier</summary>
        [Newtonsoft.Json.JsonProperty("certificate_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Certificate_path { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for CommunityList, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildCommunityList : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual CommunityList object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("CommunityList", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public CommunityList CommunityList { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for IdsRule, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIdsRule : ChildPolicyConfigResource
    {
        /// <summary>Contains the IdsRule object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IdsRule", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IdsRule IdsRule { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class InterfaceArpCsvRecord : CsvRecord
    {
        /// <summary>The IP address</summary>
        [Newtonsoft.Json.JsonProperty("ip", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ip { get; set; }
    
        /// <summary>The MAC address</summary>
        [Newtonsoft.Json.JsonProperty("mac_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Mac_address { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HTTPHdrAction object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPHdrAction 
    {
        /// <summary>ADD  A new header with the new value is added irrespective
        /// of the existence of an HTTP header of the given name.
        /// REPLACE  A new header with the new value is added if no
        /// header of the given name exists, else existing headers with
        /// the given name are removed and a new header with the new
        /// value is added.
        /// REMOVE  All the headers of the given name are removed.
        /// Enum options - HTTP_ADD_HDR, HTTP_REMOVE_HDR,
        /// HTTP_REPLACE_HDR.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHTTPHdrActionAction Action { get; set; }
    
        /// <summary>Cookie information.</summary>
        [Newtonsoft.Json.JsonProperty("cookie", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPCookieData Cookie { get; set; }
    
        /// <summary>HTTP header information.</summary>
        [Newtonsoft.Json.JsonProperty("hdr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPHdrData Hdr { get; set; }
    
    
    }
    
    /// <summary>Create and manage IPSec VPN service for given locale service.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnService : PolicyConfigResource
    {
        /// <summary>Log level for internet key exchange (IKE).</summary>
        [Newtonsoft.Json.JsonProperty("ike_log_level", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPSecVpnServiceIke_log_level? Ike_log_level { get; set; } = SDKGenerator.IPSecVpnServiceIke_log_level.INFO;
    
        /// <summary>Bypass policy rules are configured using VPN service.
        /// Bypass rules always have higher priority over protect
        /// rules and they affect all policy based vpn sessions associated
        /// with the IPSec VPN service. Protect rules are defined per
        /// policy based vpn session.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bypass_rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IPSecVpnRule> Bypass_rules { get; set; }
    
        /// <summary>Enable/disable IPSec HA state sync. IPSec HA state sync can be disabled if in case there are performance issues w.r.t. the state sync messages.</summary>
        [Newtonsoft.Json.JsonProperty("ha_sync", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Ha_sync { get; set; } = true;
    
        /// <summary>If true, enable VPN services for given locale service.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
    
    }
    
    /// <summary>List of values</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IntegerArrayConstraintValue : ConstraintValue
    {
        /// <summary>Array of integer values</summary>
        [Newtonsoft.Json.JsonProperty("values", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(100)]
        public System.Collections.Generic.ICollection<long> Values { get; set; } = new System.Collections.ObjectModel.Collection<long>();
    
    
    }
    
    /// <summary>Advanced load balancer DnsPolicy object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsPolicy : PolicyConfigResource
    {
        /// <summary>DNS rules.</summary>
        [Newtonsoft.Json.JsonProperty("rule", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDnsRule> Rule { get; set; }
    
        /// <summary>Creator name.</summary>
        [Newtonsoft.Json.JsonProperty("created_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_by { get; set; }
    
    
    }
    
    /// <summary>Realized Firewall Rule</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedFirewallRule : PolicyRealizedResource
    {
        /// <summary>Flag to disable rule. Disabled will only be persisted but never provisioned/realized.</summary>
        [Newtonsoft.Json.JsonProperty("disabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Disabled { get; set; }
    
        /// <summary>List of sources. Null will be treated as any.</summary>
        [Newtonsoft.Json.JsonProperty("sources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<ResourceReference> Sources { get; set; }
    
        /// <summary>Rule direction in case of stateless firewall rules. This will only considered if section level parameter is set to stateless. Default to IN_OUT if not specified.</summary>
        [Newtonsoft.Json.JsonProperty("direction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RealizedFirewallRuleDirection? Direction { get; set; } = SDKGenerator.RealizedFirewallRuleDirection.IN_OUT;
    
        /// <summary>List of the services. Null will be treated as any.</summary>
        [Newtonsoft.Json.JsonProperty("services", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<ResourceReference> Services { get; set; }
    
        /// <summary>Action enforced on the packets which matches the firewall rule.</summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RealizedFirewallRuleAction? Action { get; set; }
    
        /// <summary>List of the destinations. Null will be treated as any.</summary>
        [Newtonsoft.Json.JsonProperty("destinations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<ResourceReference> Destinations { get; set; }
    
    
    }
    
    /// <summary>Alarm base class of realized policy object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyAlarmResource : PolicyResource
    {
        /// <summary>path of the object on which alarm is created</summary>
        [Newtonsoft.Json.JsonProperty("source_reference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source_reference { get; set; }
    
        /// <summary>error message to describe the issue</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        /// <summary>Detailed information about errors from an API call made to the
        /// enforcement point, if any.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("error_details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PolicyApiError Error_details { get; set; }
    
        /// <summary>This field will refer to the source site on which the alarm is
        /// generated. This field is populated by GM, when it receives
        /// corresponding notification from LM.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source_site_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source_site_id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LogicalRouterStatus 
    {
        /// <summary>Timestamp when the data was last updated; unset if data source has never updated the data.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>The id of the logical router</summary>
        [Newtonsoft.Json.JsonProperty("logical_router_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Logical_router_id { get; set; }
    
        /// <summary>Per Node Status</summary>
        [Newtonsoft.Json.JsonProperty("per_node_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LogicalRouterStatusPerNode> Per_node_status { get; set; }
    
        /// <summary>Egress mode for the logical router at given mode
        /// </summary>
        [Newtonsoft.Json.JsonProperty("locale_operation_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LogicalRouterStatusLocale_operation_mode? Locale_operation_mode { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsRuleActionAllowDrop object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsRuleActionAllowDrop 
    {
        /// <summary>Reset the TCP connection of the DNS query, if allow is set
        /// to false to drop the query.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reset_conn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Reset_conn { get; set; } = true;
    
        /// <summary>Allow the DNS query.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allow", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Allow { get; set; } = true;
    
    
    }
    
    /// <summary>DNS configuration for the VHC.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VhcDnsConfig : PolicyConfigResource
    {
        /// <summary>DNS servers to which the DNS request needs to be forwarded.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dns_upstream_servers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Dns_upstream_servers { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>Information about arbitrary key-value pairs that may be attached to an entity</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TagInfo : Tag
    {
        /// <summary>Number of objects with assigned with matching scope and tag values</summary>
        [Newtonsoft.Json.JsonProperty("tagged_objects_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Tagged_objects_count { get; set; }
    
    
    }
    
    /// <summary>A list of LDAP entries returned from a search of an LDAP identity source.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LdapIdentitySourceSearchResultList : Resource
    {
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LdapIdentitySourceSearchResultItem> Results { get; set; }
    
    
    }
    
    /// <summary>Virtual portgroup on a virtual switch</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VirtualPortgroup : DiscoveredResource
    {
        /// <summary>External id of the virtual portgroup</summary>
        [Newtonsoft.Json.JsonProperty("external_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string External_id { get; set; }
    
        /// <summary>Portgroup type like DistributedVirtualPortgroup</summary>
        [Newtonsoft.Json.JsonProperty("origin_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Origin_type { get; set; }
    
        /// <summary>Id of the portgroup, eg. a mo-ref from VC.</summary>
        [Newtonsoft.Json.JsonProperty("cm_local_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cm_local_id { get; set; }
    
    
    }
    
    /// <summary>Represents the leaf level type expression to express constraint as
    /// value of realted attribute to the target.
    /// Example - Constraint traget attribute 'X' (example in Constraint),
    ///   if destinationGroups contains 'vCeneter' then allow only values
    ///   "HTTPS", "HTTP" for attribute X.
    ///   {
    ///     "target":{
    ///       "target_resource_type":"CommunicationEntry",
    ///       "attribute":"services",
    ///       "path_prefix": "/infra/domains/{{DOMAIN}}/edge-communication-maps/default/communication-entries/"
    ///     },
    ///     "constraint_expression": {
    ///       "resource_type": "RelatedAttributeConditionalExpression",
    ///       "related_attribute":{
    ///         "attribute":"destinationGroups"
    ///       },
    ///       "condition" : {
    ///         "operator":"INCLUDES",
    ///         "rhs_value": ["/infra/domains/mgw/groups/VCENTER"],
    ///         "value_constraint": {
    ///           "resource_type": "ValueConstraintExpression",
    ///           "operator":"INCLUDES",
    ///           "values":["/infra/services/HTTP", "/infra/services/HTTPS"]
    ///         }
    ///       }
    ///     }
    ///   }
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RelatedAttributeConditionalExpression : ConstraintExpression
    {
        /// <summary>Related attribute.</summary>
        [Newtonsoft.Json.JsonProperty("related_attribute", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public RelatedAttribute Related_attribute { get; set; } = new RelatedAttribute();
    
        /// <summary>Conditional value expression for target based on realted attribute value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("condition", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ConditionalValueConstraintExpression Condition { get; set; } = new ConditionalValueConstraintExpression();
    
    
    }
    
    /// <summary>Aggregate of PolicyRuntimeInfoPerEP across Enforcement Points.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregatePolicyRuntimeInfo 
    {
        /// <summary>Intent path of object, forward slashes must be escaped using %2F.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("intent_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Intent_path { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer WafRule object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWafRule 
    {
        /// <summary>Exclude list for the WAF rule.
        /// The fields in the exclude list entry are logically and'ed
        /// to deduce the exclusion criteria.
        /// If there are multiple excludelist entries, it will be
        /// 'logical or' of them.
        /// Maximum of 64 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude_list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBWafExcludeListEntry> Exclude_list { get; set; }
    
        /// <summary>Enable or disable WAF Rule Group.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable { get; set; } = true;
    
        /// <summary>User-friendly optional name for a rule.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Tags for WAF rule as per Modsec language.
        /// They are extracted from the tag action in a ModSec rule.
        /// Maximum of 64 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("avi_tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Avi_tags { get; set; }
    
        /// <summary>Number of index.</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public long Index { get; set; }
    
        /// <summary>The execution phase where this rule will be executed.
        /// Enum options - WAF_PHASE_CONNECTION,
        /// WAF_PHASE_REQUEST_HEADER, WAF_PHASE_REQUEST_BODY,
        /// WAF_PHASE_RESPONSE_HEADER, WAF_PHASE_RESPONSE_BODY,
        /// WAF_PHASE_LOGGING.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("phase", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBWafRulePhase? Phase { get; set; }
    
        /// <summary>The rule field is sensitive and will not be displayed.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_sensitive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_sensitive { get; set; } = false;
    
        /// <summary>Identifier (id) for a rule per Modsec language.
        /// All SecRule and SecAction directives require an id.
        /// It is extracted from the id action in a ModSec rule.
        /// Rules within a single WAF Policy are required to have
        /// unique rule_ids.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rule_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rule_id { get; set; }
    
        /// <summary>Rule as per Modsec language.</summary>
        [Newtonsoft.Json.JsonProperty("rule", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Rule { get; set; }
    
        /// <summary>WAF Rule mode.
        /// This can be detection or enforcement.
        /// If this is not set, the Policy mode is used.
        /// This only takes effect if the policy allows delegation.
        /// Enum options - WAF_MODE_DETECTION_ONLY,
        /// WAF_MODE_ENFORCEMENT.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBWafRuleMode? Mode { get; set; }
    
    
    }
    
    /// <summary>DHCP IPv6 static bindings are configured for each segment.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DhcpV6StaticBindingConfig : DhcpStaticBindingConfig
    {
        /// <summary>SNTP server IP addresses.</summary>
        [Newtonsoft.Json.JsonProperty("sntp_servers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(2)]
        public System.Collections.Generic.ICollection<string> Sntp_servers { get; set; }
    
        /// <summary>Preferred time, in seconds. If this value is not provided, the value
        /// of lease_time*0.8 will be used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preferred_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(48D, 4294967295D)]
        public long? Preferred_time { get; set; }
    
        /// <summary>Lease time, in seconds.</summary>
        [Newtonsoft.Json.JsonProperty("lease_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(60D, 4294967295D)]
        public long? Lease_time { get; set; } = 86400L;
    
        /// <summary>The MAC address of the client host. Either client-duid or mac-address,
        /// but not both.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mac_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Mac_address { get; set; }
    
        /// <summary>When not specified, no ip address will be assigned to client host.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip_addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Ip_addresses { get; set; }
    
        /// <summary>When not specified, no DNS nameserver will be set to client host.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dns_nameservers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(2)]
        public System.Collections.Generic.ICollection<string> Dns_nameservers { get; set; }
    
        /// <summary>When not specified, no domain name will be assigned to client host.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("domain_names", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Domain_names { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BaseCountObservation : CountObservation
    {
        /// <summary>Packet count</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Port ID, which is either a logical port ID or an uplink name</summary>
        [Newtonsoft.Json.JsonProperty("port_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Port_id { get; set; }
    
        /// <summary>Type of checkpoint</summary>
        [Newtonsoft.Json.JsonProperty("checkpoint_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Checkpoint_type { get; set; }
    
    
    }
    
    /// <summary>NSX global configs for WAVE_FRONT global collector</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class WaveFrontGlobalCollector : GlobalCollectorConfig
    {
    
    }
    
    /// <summary>List result of PolicyFirewallSchedulers</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyFirewallSchedulerListResult : ListResult
    {
        /// <summary>Paged collection of PolicyFirewallSchedulers</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyFirewallScheduler> Results { get; set; }
    
    
    }
    
    /// <summary>Active healthchecks are disabled by default and can be enabled for a
    /// server pool by binding a health monitor to the Group through the PolicyLbRule
    /// object. This represents active health monitoring over HTTPS. Active
    /// healthchecks are initiated periodically, at a configurable interval, to
    /// each member of the Group. Only if a healthcheck fails consecutively for a
    /// specified number of times (fall_count) to a member will the member status
    /// be marked DOWN. Once a member is DOWN, a specified number of consecutive
    /// successful healthchecks (rise_count) will bring the member back to UP
    /// state. After a healthcheck is initiated, if it does not complete within a
    /// certain period, then also the healthcheck is considered to be
    /// unsuccessful. Completing a healthcheck within timeout means establishing
    /// a connection (TCP or SSL), if applicable, sending the request and
    /// receiving the response, all within the configured timeout.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class HttpsPolicyLbMonitorProfile : HttpPolicyLbMonitorProfile
    {
    
    }
    
    /// <summary>Advanced load balancer Webhook object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWebhook : PolicyConfigResource
    {
        /// <summary>Verification token sent back with the callback asquery
        /// parameters.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("verification_token", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Verification_token { get; set; }
    
        /// <summary>Callback URL for the Webhook.</summary>
        [Newtonsoft.Json.JsonProperty("callback_url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Callback_url { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AcceptableComponentVersion : VersionList
    {
        /// <summary>Node type</summary>
        [Newtonsoft.Json.JsonProperty("component_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AcceptableComponentVersionComponent_type Component_type { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for PolicyNat, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyNat : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyNAT object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyNat", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyNat PolicyNat { get; set; }
    
    
    }
    
    /// <summary>Next hop configuration for network</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RouterNexthop 
    {
        /// <summary>Interface path associated with current route.
        /// For example: specify a policy path referencing the IPSec VPN Session.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<string> Scope { get; set; }
    
        /// <summary>Next hop gateway IP address</summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ip_address { get; set; }
    
        /// <summary>Cost associated with next hop route</summary>
        [Newtonsoft.Json.JsonProperty("admin_distance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 255D)]
        public long? Admin_distance { get; set; } = 1L;
    
    
    }
    
    /// <summary>Remote MAC addresses for logical switch.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VpnSessionRemoteMacForSegment 
    {
        /// <summary>Remote Mac addresses.</summary>
        [Newtonsoft.Json.JsonProperty("remote_mac_addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Remote_mac_addresses { get; set; }
    
        /// <summary>Intent path of the segment.</summary>
        [Newtonsoft.Json.JsonProperty("segment_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Segment_path { get; set; }
    
    
    }
    
    /// <summary>Tier0 or Tier1 interface statistics on specific Enforcement Point.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyInterfaceStatistics : LogicalRouterPortStatistics
    {
    
    }
    
    /// <summary>ErrorPageBodyApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBErrorPageBodyApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of ErrorPageBody
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBErrorPageBody> Results { get; set; }
    
    
    }
    
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("TraceflowObservationReplicationLogical", typeof(TraceflowObservationReplicationLogical))]
    [JsonInheritanceAttribute("PolicyTraceflowObservationRelayedLogical", typeof(PolicyTraceflowObservationRelayedLogical))]
    [JsonInheritanceAttribute("TraceflowObservationRelayedLogical", typeof(TraceflowObservationRelayedLogical))]
    [JsonInheritanceAttribute("PolicyTraceflowObservationDelivered", typeof(PolicyTraceflowObservationDelivered))]
    [JsonInheritanceAttribute("TraceflowObservationDelivered", typeof(TraceflowObservationDelivered))]
    [JsonInheritanceAttribute("TraceflowObservationDropped", typeof(TraceflowObservationDropped))]
    [JsonInheritanceAttribute("TraceflowObservationForwarded", typeof(TraceflowObservationForwarded))]
    [JsonInheritanceAttribute("TraceflowObservationReceivedLogical", typeof(TraceflowObservationReceivedLogical))]
    [JsonInheritanceAttribute("PolicyTraceflowObservationDropped", typeof(PolicyTraceflowObservationDropped))]
    [JsonInheritanceAttribute("TraceflowObservationForwardedLogical", typeof(TraceflowObservationForwardedLogical))]
    [JsonInheritanceAttribute("TraceflowObservationDroppedLogical", typeof(TraceflowObservationDroppedLogical))]
    [JsonInheritanceAttribute("TraceflowObservationReceived", typeof(TraceflowObservationReceived))]
    [JsonInheritanceAttribute("PolicyTraceflowObservationReceivedLogical", typeof(PolicyTraceflowObservationReceivedLogical))]
    [JsonInheritanceAttribute("PolicyTraceflowObservationForwardedLogical", typeof(PolicyTraceflowObservationForwardedLogical))]
    [JsonInheritanceAttribute("PolicyTraceflowObservationDroppedLogical", typeof(PolicyTraceflowObservationDroppedLogical))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceflowObservation 
    {
        /// <summary>Timestamp when the observation was created by the transport node (microseconds epoch)</summary>
        [Newtonsoft.Json.JsonProperty("timestamp_micro", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Timestamp_micro { get; set; }
    
        /// <summary>The sub type of the component that issued the observation.</summary>
        [Newtonsoft.Json.JsonProperty("component_sub_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TraceflowObservationComponent_sub_type? Component_sub_type { get; set; }
    
        /// <summary>The type of the component that issued the observation.</summary>
        [Newtonsoft.Json.JsonProperty("component_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TraceflowObservationComponent_type? Component_type { get; set; }
    
        /// <summary>name of the transport node that observed a traceflow packet</summary>
        [Newtonsoft.Json.JsonProperty("transport_node_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_node_name { get; set; }
    
        /// <summary>Timestamp when the observation was created by the transport node (milliseconds epoch)</summary>
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Timestamp { get; set; }
    
        /// <summary>id of the transport node that observed a traceflow packet</summary>
        [Newtonsoft.Json.JsonProperty("transport_node_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_node_id { get; set; }
    
        /// <summary>the hop count for observations on the transport node that a traceflow packet is injected in will be 0. The hop count is incremented each time a subsequent transport node receives the traceflow packet. The sequence number of 999 indicates that the hop count could not be determined for the containing observation.</summary>
        [Newtonsoft.Json.JsonProperty("sequence_no", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Sequence_no { get; set; }
    
        /// <summary>type of the transport node that observed a traceflow packet</summary>
        [Newtonsoft.Json.JsonProperty("transport_node_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TraceflowObservationTransport_node_type? Transport_node_type { get; set; }
    
        /// <summary>The name of the component that issued the observation.</summary>
        [Newtonsoft.Json.JsonProperty("component_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Component_name { get; set; }
    
    
    }
    
    /// <summary>Global Manager federation RTEP configuration. This configuration is distributed
    /// to all Sites participating in federation.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GmRtepConfig 
    {
        /// <summary>Password to authenticate IBGP session between remote tunnel endpoints
        /// created on federated sites. This is applied to inter-site underlay
        /// IBGP neighbors created over remote tunnel endpoints on all sites.
        /// Empty string ("") clears existing password.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ibgp_password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(20)]
        public string Ibgp_password { get; set; }
    
    
    }
    
    /// <summary>Policy resource reference for enforcement point
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyResourceReferenceForEP : PolicyResourceReference
    {
    
    }
    
    /// <summary>Advanced load balancer ClientLogConfiguration object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBClientLogConfiguration 
    {
        /// <summary>Enable significant log collection.
        /// By default, this flag is enabled, which means that Avi SEs
        /// collect significant logs and forward them to Controller for
        /// further processing.
        /// For example, these logs correspond to error conditions such
        /// as when the response code for a request is 500.
        /// Users can deactivate this flag to turn off default
        /// significant log collection.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_significant_log_collection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_significant_log_collection { get; set; } = true;
    
        /// <summary>Significant logs are processed by the Logs Analytics system
        /// according to this setting.
        /// Enum options - LOGS_PROCESSING_NONE,
        /// LOGS_PROCESSING_SYNC_AND_INDEX_ON_DEMAND,
        /// LOGS_PROCESSING_AUTO_SYNC_AND_INDEX,
        /// LOGS_PROCESSING_AUTO_SYNC_BUT_INDEX_ON_DEMAND.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// LOGS_PROCESSING_SYNC_AND_INDEX_ON_DEMAND.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("significant_log_processing", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBClientLogConfigurationSignificant_log_processing? Significant_log_processing { get; set; } = SDKGenerator.ALBClientLogConfigurationSignificant_log_processing.LOGS_PROCESSING_SYNC_AND_INDEX_ON_DEMAND;
    
        /// <summary>Logs that are neither significant nor filtered, are
        /// processed by the Logs Analytics system according to this
        /// setting.
        /// Enum options - LOGS_PROCESSING_NONE,
        /// LOGS_PROCESSING_SYNC_AND_INDEX_ON_DEMAND,
        /// LOGS_PROCESSING_AUTO_SYNC_AND_INDEX,
        /// LOGS_PROCESSING_AUTO_SYNC_BUT_INDEX_ON_DEMAND.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// LOGS_PROCESSING_SYNC_AND_INDEX_ON_DEMAND.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("non_significant_log_processing", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBClientLogConfigurationNon_significant_log_processing? Non_significant_log_processing { get; set; } = SDKGenerator.ALBClientLogConfigurationNon_significant_log_processing.LOGS_PROCESSING_SYNC_AND_INDEX_ON_DEMAND;
    
        /// <summary>Filtered logs are logs that match any client log filters or
        /// rules with logging enabled.
        /// Such logs are processed by the Logs Analytics system
        /// according to this setting.
        /// Enum options - LOGS_PROCESSING_NONE,
        /// LOGS_PROCESSING_SYNC_AND_INDEX_ON_DEMAND,
        /// LOGS_PROCESSING_AUTO_SYNC_AND_INDEX,
        /// LOGS_PROCESSING_AUTO_SYNC_BUT_INDEX_ON_DEMAND.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// LOGS_PROCESSING_SYNC_AND_INDEX_ON_DEMAND.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("filtered_log_processing", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBClientLogConfigurationFiltered_log_processing? Filtered_log_processing { get; set; } = SDKGenerator.ALBClientLogConfigurationFiltered_log_processing.LOGS_PROCESSING_SYNC_AND_INDEX_ON_DEMAND;
    
    
    }
    
    /// <summary>Advanced load balancer HSMAwsCloudHsm object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHSMAwsCloudHsm 
    {
        /// <summary>AWS CloudHSM Cluster Certificate.</summary>
        [Newtonsoft.Json.JsonProperty("cluster_cert", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cluster_cert { get; set; }
    
        /// <summary>Username of the Crypto User.
        /// This will be used to access the keys on the HSM .
        /// </summary>
        [Newtonsoft.Json.JsonProperty("crypto_user_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Crypto_user_name { get; set; }
    
        /// <summary>client_config of HSMAwsCloudHsm.</summary>
        [Newtonsoft.Json.JsonProperty("client_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Client_config { get; set; }
    
        /// <summary>Password of the Crypto User.
        /// This will be used to access the keys on the HSM .
        /// </summary>
        [Newtonsoft.Json.JsonProperty("crypto_user_password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Crypto_user_password { get; set; }
    
        /// <summary>IP address of the HSM in the cluster.
        /// If there are more than one HSMs, only one is sufficient.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hsm_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Hsm_ip { get; set; }
    
        /// <summary>mgmt_config of HSMAwsCloudHsm.</summary>
        [Newtonsoft.Json.JsonProperty("mgmt_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Mgmt_config { get; set; }
    
    
    }
    
    /// <summary>Binding of a LbPoolAccess and Group to a PolicyLbVirtualServer
    /// used to route application traffic passing through load balancers.
    /// PolicyLbRule uses match conditions to match application traffic passing
    /// through a PolicyLbVirtualServer using HTTP or HTTPS. Can bind
    /// multiple PolicyLbVirtualServers to a Group. Each PolicyLbRule
    /// consists of two optional match conditions, each match contidion defines a
    /// criterion for application traffic.  If no match conditions are
    /// specified, then the PolicyLbRule will always match and it is used
    /// typically to define default rules. If more than one match condition is
    /// specified, then matching strategy determines if all conditions should
    /// match or any one condition should match for the PolicyLbRule to be
    /// considered a match.  A match indicates that the PolicyLbVirtualServer
    /// should route the request to the Group (parent of PolicyLbRule).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyLbRule : PolicyConfigResource
    {
        /// <summary>This condition is used to match URIs(Uniform Resource Identifier) of
        /// HTTP request messages. The URI field can be specified as a regluar
        /// expression. If an HTTP request message is requesting an URI which
        /// matches specified regular expression, it matches the condition. The
        /// syntax of whole URI looks like this:
        /// scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]
        /// This condition matches only the path part of entire URI. The path_match
        /// field is used as a regular expression to match URI path of HTTP
        /// requests. For example, to match any URI that has "/image/" or
        /// "/images/", uri field can be specified as: "/image[s]?/". The regular
        ///  expressions in load balancer rules use the features common to both
        ///  Java regular expressions and Perl Compatible Regular Expressions
        ///  (PCREs) with some restrictions. Reference http://www.pcre .org for
        ///  PCRE and the NSX-T Administrator's Guide for the restrictions.
        ///  Please note, when regular expressions are used in JSON (JavaScript
        ///  Object Notation) string, every backslash character (\) needs to be
        ///  escaped by one additional backslash character.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path_match", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path_match { get; set; }
    
        /// <summary>This condition is used to match HTTP request messages by the
        /// specific HTTP header field, Host.  The Host request header specifies
        /// the domain name of the server. The supplied Host HTTP header match
        /// condition will be matched as a regular expression.
        /// The regular expressions in load balancer rules use the features
        /// common to both Java regular expressions and Perl Compatible Regular
        /// Expressions (PCREs) with some restrictions. Reference http://www.pcre
        /// .org for PCRE and the NSX-T Administrator's Guide for the
        /// restrictions. Please note, when regular expressions are used in JSON
        /// (JavaScript Object Notation) string, every backslash character (\)
        /// needs to be escaped by one additional backslash character.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("host_match", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Host_match { get; set; }
    
        /// <summary>The path of PolicyLbVirtualServer to bind to this PolicyLbRule and its
        /// Group
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lb_virtual_server", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lb_virtual_server { get; set; }
    
        /// <summary>This field is used to resolve conflicts between multiple
        /// PolicyLbRules associated with a single PolicyLbVirtualServer and will
        /// be applied numerically or low to high
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sequence_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Sequence_number { get; set; }
    
        /// <summary>If more than one match condition is specified, then
        /// matching strategy determines if all conditions should match or any
        /// one condition should match for the LB Rule to be considered a match.
        /// - ALL indicates that both host_match and path_match must match for
        /// this PolicyLbRule to be considered a match
        /// - ANY indicates that either host_match or patch match may match for
        /// this PolicyLbRule to be considered a match
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_strategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyLbRuleMatch_strategy? Match_strategy { get; set; } = SDKGenerator.PolicyLbRuleMatch_strategy.ANY;
    
    
    }
    
    /// <summary>This action is used to redirect HTTP request messages to a new URL. The
    /// reply_status value specified in this action is used as the status code of
    /// HTTP response message which is sent back to client (Normally a browser).
    /// The HTTP status code for redirection is 3xx, for example, 301, 302, 303,
    /// 307, etc. The redirect_url is the new URL that the HTTP request message is
    /// redirected to. Normally browser will send another HTTP request to the new
    /// URL after receiving a redirection response message.
    /// Captured variables and built-in variables can be used in redirect_url field.
    /// For example, to redirect all HTTP requests to HTTPS requests for a virtual
    /// server. We create an LBRule without any conditions, add an
    /// LBHttpRedirectAction to the rule. Set the
    /// redirect_url field of the LBHttpRedirectAction to:
    ///   https://$_host$_request_uri
    /// And set redirect_status to "302", which means found. This rule will
    /// redirect all HTTP requests to HTTPS server port on the same host.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBHttpRedirectAction : LBRuleAction
    {
        /// <summary>HTTP response status code.</summary>
        [Newtonsoft.Json.JsonProperty("redirect_status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Redirect_status { get; set; }
    
        /// <summary>The URL that the HTTP request is redirected to.</summary>
        [Newtonsoft.Json.JsonProperty("redirect_url", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Redirect_url { get; set; }
    
    
    }
    
    /// <summary>Contains type specific properties of generic realized entity</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AttributeVal 
    {
        /// <summary>List of attribute values</summary>
        [Newtonsoft.Json.JsonProperty("values", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Values { get; set; }
    
        /// <summary>If attribute has a single value or collection of values</summary>
        [Newtonsoft.Json.JsonProperty("multivalue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Multivalue { get; set; }
    
        /// <summary>Attribute key</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }
    
        /// <summary>Datatype of the property</summary>
        [Newtonsoft.Json.JsonProperty("data_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AttributeValData_type? Data_type { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FeaturePermissionListResult : ListResult
    {
        /// <summary>List results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FeaturePermission> Results { get; set; } = new System.Collections.ObjectModel.Collection<FeaturePermission>();
    
    
    }
    
    /// <summary>Advanced load balancer WafPSMLocation object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWafPSMLocation 
    {
        /// <summary>A list of rules which should be applied on this location.
        /// Maximum of 1024 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBWafPSMRule> Rules { get; set; }
    
        /// <summary>Location index, this is used to determine the order of the
        /// locations.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public long Index { get; set; }
    
        /// <summary>Free-text comment about this location.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Apply these rules only if the request is matching this
        /// description.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBWafPSMLocationMatch Match { get; set; }
    
        /// <summary>User defined name for this location, it must be unique in
        /// the group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsRuleActionGslbSiteSelection object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsRuleActionGslbSiteSelection 
    {
        /// <summary>When set to true, GSLB site is a preferred site.
        /// This setting comes into play when the site is down, as well
        /// as no configured fallback site is available (all fallback
        /// sites are also down), then any one available site is
        /// selected based on the default algorithm for GSLB pool member
        /// selection.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_site_preferred", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_site_preferred { get; set; } = true;
    
        /// <summary>GSLB site name.</summary>
        [Newtonsoft.Json.JsonProperty("site_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Site_name { get; set; }
    
        /// <summary>GSLB fallback sites to use in case the desired site is
        /// down.
        /// Maximum of 64 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fallback_site_names", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Fallback_site_names { get; set; }
    
    
    }
    
    /// <summary>A ServiceInsertionServiceProfile can be part of multiple ServiceChains. ServiceChainMapping for a particular profile will contain a list of all the ServiceChains it's part of. Each Mapping will also contain some metadata to uniquely identify a profile from other profiles.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServiceChainMapping 
    {
        /// <summary>A unique id generated for every ServiceChain. This is not a uuid.</summary>
        [Newtonsoft.Json.JsonProperty("service_chain_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Service_chain_id { get; set; }
    
        /// <summary>Each ServiceChain has forward_path_service_profiles and reverse_path_service_profiles. This property will indicate which of them being used. FORWARD - forward_path_service_profiles REVERSE - reverse_path_service_profiles</summary>
        [Newtonsoft.Json.JsonProperty("direction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ServiceChainMappingDirection? Direction { get; set; }
    
        /// <summary>Service Index represents a numerical position of a ServiceInsertionServiceProfile in a ServiceChain. It will be in reverse order. Service Index can point to either forward_path_service_profiles or reverse_path_service_profiles indicated by direction property. Example - For a ServiceChain A-B-C, A will have index of 3, B will have index of 2 and C will have index of 1.</summary>
        [Newtonsoft.Json.JsonProperty("service_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Service_index { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregatedDataCounter 
    {
        [Newtonsoft.Json.JsonProperty("tx_bytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DataCounter Tx_bytes { get; set; }
    
        [Newtonsoft.Json.JsonProperty("rx_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DataCounter Rx_packets { get; set; }
    
        [Newtonsoft.Json.JsonProperty("tx_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DataCounter Tx_packets { get; set; }
    
        [Newtonsoft.Json.JsonProperty("rx_bytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DataCounter Rx_bytes { get; set; }
    
    
    }
    
    /// <summary>VsVipApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBVsVipApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of VsVip
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBVsVip> Results { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer FailActionHTTPRedirect object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBFailActionHTTPRedirect 
    {
        /// <summary>path of FailActionHTTPRedirect.</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>host of FailActionHTTPRedirect.</summary>
        [Newtonsoft.Json.JsonProperty("host", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Host { get; set; }
    
        /// <summary>Enum options - HTTP, HTTPS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as HTTPS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBFailActionHTTPRedirectProtocol? Protocol { get; set; } = SDKGenerator.ALBFailActionHTTPRedirectProtocol.HTTPS;
    
        /// <summary>Enum options - HTTP_REDIRECT_STATUS_CODE_301,
        /// HTTP_REDIRECT_STATUS_CODE_302,
        /// HTTP_REDIRECT_STATUS_CODE_307.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// HTTP_REDIRECT_STATUS_CODE_302.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBFailActionHTTPRedirectStatus_code? Status_code { get; set; } = SDKGenerator.ALBFailActionHTTPRedirectStatus_code.HTTP_REDIRECT_STATUS_CODE_302;
    
        /// <summary>query of FailActionHTTPRedirect.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Query { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for LBPersistenceProfile, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildLBPersistenceProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual LBPersistenceProfile object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("LBPersistenceProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public LBPersistenceProfile LBPersistenceProfile { get; set; }
    
    
    }
    
    /// <summary>NSX specific configuration for tier-0</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier0AdvancedConfig : ConnectivityAdvancedConfig
    {
        /// <summary>Extra time in seconds the router must wait before sending the UP
        /// notification after the peer routing session is established. Default
        /// means forward immediately. VRF logical router will set it same as parent
        /// logical router.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("forwarding_up_timer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 300D)]
        public long? Forwarding_up_timer { get; set; } = 0L;
    
    
    }
    
    /// <summary>Service interface configuration for internal connectivity.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServiceInterface : BaseTier0Interface
    {
    
    }
    
    /// <summary>ApplicationProfileApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBApplicationProfileApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of ApplicationProfile
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBApplicationProfile> Results { get; set; }
    
    
    }
    
    /// <summary>Describes usage summary of virtual servers, pools and pool members for
    /// all load balancer services.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBServiceUsageSummary 
    {
        /// <summary>Overall pool usage percentage for all load balancer services.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_usage_percentage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Pool_usage_percentage { get; set; }
    
        /// <summary>Pool capacity means maximum number of pools which can be configured
        /// for all load balancer services.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_capacity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Pool_capacity { get; set; }
    
        /// <summary>The severity calculation is based on the overall usage percentage of
        /// pool members for all load balancer services.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_member_severity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBServiceUsageSummaryPool_member_severity? Pool_member_severity { get; set; }
    
        /// <summary>Pool capacity means maximum number of pool members which can be
        /// configured for all load balancer services.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_member_capacity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Pool_member_capacity { get; set; }
    
        /// <summary>Overall pool member usage percentage for all load balancer services.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_member_usage_percentage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Pool_member_usage_percentage { get; set; }
    
        /// <summary>The current count of virtual servers configured for all load balancer
        /// services.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_virtual_server_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Current_virtual_server_count { get; set; }
    
        /// <summary>The current count of pools configured for all load balancer services.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_pool_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Current_pool_count { get; set; }
    
        /// <summary>The current count of pool members configured for all load balancer
        /// services.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_pool_member_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Current_pool_member_count { get; set; }
    
        /// <summary>The severity calculation is based on the overall usage percentage of
        /// pools for all load balancer services.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_severity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBServiceUsageSummaryPool_severity? Pool_severity { get; set; }
    
        /// <summary>The property identifies all lb service usages. By default, it is not
        /// included in response. It exists when parameter ?include_usages=true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service_usages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBServiceUsage> Service_usages { get; set; }
    
        /// <summary>Overall virtual server usage percentage for all load balancer services.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("virtual_server_usage_percentage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Virtual_server_usage_percentage { get; set; }
    
        /// <summary>The severity calculation is based on the overall usage percentage of
        /// virtual servers for all load balancer services.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("virtual_server_severity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBServiceUsageSummaryVirtual_server_severity? Virtual_server_severity { get; set; }
    
        /// <summary>The service count for each load balancer usage severity.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service_counts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBServiceCountPerSeverity> Service_counts { get; set; }
    
        /// <summary>Virtual server capacity means maximum number of virtual servers which
        /// can be configured for all load balancer services.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("virtual_server_capacity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Virtual_server_capacity { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IgmpMembershipsInCsvFormat : CsvListResult
    {
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IgmpMembershipCsvRecord> Results { get; set; }
    
    
    }
    
    /// <summary>An anchor object representing the intent to consume a given 3rd party service.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServiceReference : PolicyConfigResource
    {
        /// <summary>Unique name of Partner Service to be consumed for redirection.</summary>
        [Newtonsoft.Json.JsonProperty("partner_service_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Partner_service_name { get; set; }
    
        /// <summary>A Service's operational state can be enabled or disabled. Note that would work only for NetX type of services and would not work for Guest Introsp- ection type of Services. TRUE - The Service should be enabled FALSE - The Service should be disabled</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
    
    }
    
    /// <summary>Realized Firewall section</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedFirewallSection : RealizedFirewall
    {
        /// <summary>List of firewall rules in the section.</summary>
        [Newtonsoft.Json.JsonProperty("rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RealizedFirewallRule> Rules { get; set; }
    
        /// <summary>Number of rules in this section.</summary>
        [Newtonsoft.Json.JsonProperty("rule_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Rule_count { get; set; }
    
        /// <summary>Type of the rules which a section can contain.</summary>
        [Newtonsoft.Json.JsonProperty("section_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RealizedFirewallSectionSection_type? Section_type { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of IDS Security Policy statistics</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsSecurityPolicyStatisticsListResult : ListResult
    {
        /// <summary>IDS Security Policy statistics list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IdsSecurityPolicyStatisticsForEnforcementPoint> Results { get; set; } = new System.Collections.ObjectModel.Collection<IdsSecurityPolicyStatisticsForEnforcementPoint>();
    
    
    }
    
    /// <summary>Represents configuration of a statistic for an entity. Example, number of logical switches and their admin states.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class StatsConfiguration : WidgetConfiguration
    {
        /// <summary>Hyperlink of the specified UI page that provides details.</summary>
        [Newtonsoft.Json.JsonProperty("navigation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Navigation { get; set; }
    
        /// <summary>Expression that fetches statistic. It can be used to show the characteristics of entities such as Logical Switches, Firewall Rules, and so on. For example, number of logical switches and their admin states. If stat is not provided, then it will not be displayed.</summary>
        [Newtonsoft.Json.JsonProperty("stat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StatItem Stat { get; set; }
    
        /// <summary>Sections</summary>
        [Newtonsoft.Json.JsonProperty("sections", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<DonutSection> Sections { get; set; }
    
        /// <summary>A sub-type of StatsConfiguration. If sub-type is not specified the parent type is rendered. The COMPACT sub_type, conserves the space for the widget. The statistic is placed on the right side on top of the status bar and the title of the widget is placed on the left side on the top of the status bar. The COMPACT style aligns itself horizontally as per the width of the container. If multiple widgets are placed insided the container then the widgets are placed one below the other to conserve the space.</summary>
        [Newtonsoft.Json.JsonProperty("sub_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public StatsConfigurationSub_type? Sub_type { get; set; }
    
        /// <summary>Displayed at the sections, by default. It labels the entities of sections. If label is not provided, the sections are not labelled.</summary>
        [Newtonsoft.Json.JsonProperty("label", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Label Label { get; set; }
    
    
    }
    
    /// <summary>Pool member.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBPoolMember 
    {
        /// <summary>To ensure members are not overloaded, connections to a member can be
        /// capped by the load balancer. When a member reaches this limit, it is
        /// skipped during server selection.
        /// If it is not specified, it means that connections are unlimited.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_concurrent_connections", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long? Max_concurrent_connections { get; set; }
    
        /// <summary>Member admin state.</summary>
        [Newtonsoft.Json.JsonProperty("admin_state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBPoolMemberAdmin_state? Admin_state { get; set; } = SDKGenerator.LBPoolMemberAdmin_state.ENABLED;
    
        /// <summary>Backup servers are typically configured with a sorry page indicating to
        /// the user that the application is currently unavailable. While the pool
        /// is active (a specified minimum number of pool members are active)
        /// BACKUP members are skipped during server selection. When the pool is
        /// inactive, incoming connections are sent to only the BACKUP member(s).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("backup_member", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Backup_member { get; set; } = false;
    
        /// <summary>Pool member weight is used for WEIGHTED_ROUND_ROBIN balancing
        /// algorithm. The weight value would be ignored in other algorithms.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("weight", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 256D)]
        public long? Weight { get; set; } = 1L;
    
        /// <summary>Pool member name.</summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Display_name { get; set; }
    
        /// <summary>Pool member IP address.</summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ip_address { get; set; }
    
        /// <summary>If port is specified, all connections will be sent to this port. Only
        /// single port is supported.
        /// If unset, the same port the client connected to will be used, it could
        /// be overrode by default_pool_member_port setting in virtual server.
        /// The port should not specified for port range case.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Port { get; set; }
    
    
    }
    
    /// <summary>configuration parameters for Bridge Profile</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BridgeProfileConfig 
    {
        /// <summary>The name of the switching uplink teaming policy for the bridge endpoint. This name corresponds to one fot he switching uplink teaming policy names listed in teh transport zone. When this property is not specified, the teaming policy is assigned by MP.</summary>
        [Newtonsoft.Json.JsonProperty("uplink_teaming_policy_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uplink_teaming_policy_name { get; set; }
    
        /// <summary>VLAN specification for bridge endpoint. Either VLAN ID or VLAN ranges can be specified. Not both.</summary>
        [Newtonsoft.Json.JsonProperty("vlan_ids", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Vlan_ids { get; set; }
    
        /// <summary>Same bridge profile can be configured on different segments. Each bridge profile on a segment must unique.</summary>
        [Newtonsoft.Json.JsonProperty("bridge_profile_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Bridge_profile_path { get; set; }
    
        /// <summary>VLAN transport zone should belong to the enforcment-point as the transport zone specified in the segment.</summary>
        [Newtonsoft.Json.JsonProperty("vlan_transport_zone_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Vlan_transport_zone_path { get; set; }
    
    
    }
    
    /// <summary>Static routes configuration on Tier-0 or Tier-1.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class StaticRoutes : PolicyConfigResource
    {
        /// <summary>Specify next hop routes for network.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("next_hops", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<RouterNexthop> Next_hops { get; set; } = new System.Collections.ObjectModel.Collection<RouterNexthop>();
    
        /// <summary>Specify network address in CIDR format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("network", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Network { get; set; }
    
        /// <summary>When false or by default northbound routes are configured only on the primary
        /// location and not on secondary location. When true, the static route will also be
        /// configured on a secondary location. Secondary location prefers route learned from
        /// the primary location and enabling this flag secondary location can override this.
        /// This flag is not applicable if all sites are primary.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled_on_secondary", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled_on_secondary { get; set; } = false;
    
    
    }
    
    /// <summary>Advanced load balancer ServerAutoScalePolicy object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBServerAutoScalePolicy : PolicyConfigResource
    {
        /// <summary>No scale-in happens once number of operationally up servers
        /// reach min_servers.
        /// Allowed values are 0-400.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("min_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 400D)]
        public long? Min_size { get; set; }
    
        /// <summary>Use predicted load rather than current load.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("use_predicted_load", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Use_predicted_load { get; set; } = false;
    
        /// <summary>Use Avi intelligent autoscale algorithm where autoscale is
        /// performed by comparing load on the pool against estimated
        /// capacity of all the servers.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("intelligent_autoscale", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Intelligent_autoscale { get; set; } = false;
    
        /// <summary>Maximum extra capacity as percentage of load used by the
        /// intelligent scheme.
        /// Scalein is triggered when available capacity is more than
        /// this margin.
        /// Allowed values are 1-99.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 40.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("intelligent_scalein_margin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 99D)]
        public long? Intelligent_scalein_margin { get; set; } = 40L;
    
        /// <summary>Maximum number of servers to scalein simultaneously.
        /// The actual number of servers to scalein is chosen such that
        /// target number of servers is always more than or equal to the
        /// min_size.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_scalein_adjustment_step", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Max_scalein_adjustment_step { get; set; } = 1L;
    
        /// <summary>Maximum number of servers to scaleout simultaneously.
        /// The actual number of servers to scaleout is chosen such
        /// that target number of servers is always less than or equal
        /// to the max_size.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_scaleout_adjustment_step", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Max_scaleout_adjustment_step { get; set; } = 1L;
    
        /// <summary>Minimum extra capacity as percentage of load used by the
        /// intelligent scheme.
        /// Scaleout is triggered when available capacity is less than
        /// this margin.
        /// Allowed values are 1-99.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 20.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("intelligent_scaleout_margin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 99D)]
        public long? Intelligent_scaleout_margin { get; set; } = 20L;
    
        /// <summary>Cooldown period during which no new scaleout is triggered
        /// to allow previous scaleout to successfully complete.
        /// Unit is SEC.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 300.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scaleout_cooldown", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Scaleout_cooldown { get; set; } = 300L;
    
        /// <summary>Maximum number of servers after scaleout.
        /// Allowed values are 0-400.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 400D)]
        public long? Max_size { get; set; }
    
        /// <summary>Cooldown period during which no new scalein is triggered to
        /// allow previous scalein to successfully complete.
        /// Unit is SEC.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 300.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scalein_cooldown", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Scalein_cooldown { get; set; } = 300L;
    
    
    }
    
    /// <summary>LBServiceStatistics on specific Enforcement Point</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("LBServiceStatistics", typeof(LBServiceStatistics))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBServiceStatisticsPerEP : PolicyRuntimeInfoPerEP
    {
    
    }
    
    /// <summary>Paged Collection of DnsSecurityProfile</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DnsSecurityProfileListResult : ListResult
    {
        /// <summary>DnsSecurityProfile list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<DnsSecurityProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<DnsSecurityProfile>();
    
    
    }
    
    /// <summary>Child wrapper for ALBSecurityPolicy, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBSecurityPolicy : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBSecurityPolicy object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBSecurityPolicy", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBSecurityPolicy ALBSecurityPolicy { get; set; }
    
    
    }
    
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("BaseCountObservation", typeof(BaseCountObservation))]
    [JsonInheritanceAttribute("PolicyCountObservation", typeof(PolicyCountObservation))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CountObservation 
    {
    
    }
    
    /// <summary>Gives the collection of NAT rule statistics per logical router on
    /// specified enforcement point.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyNatRuleStatisticsPerLogicalRouterListResult : ListResult
    {
        /// <summary>NAT rules statistics per logical router</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyNatRuleStatisticsPerLogicalRouter> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyNatRuleStatisticsPerLogicalRouter>();
    
    
    }
    
    /// <summary>Paged Collection of IPFIX DFW Profile</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPFIXDFWProfileListResult : ListResult
    {
        /// <summary>IPFIX DFW Profile list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IPFIXDFWProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<IPFIXDFWProfile>();
    
    
    }
    
    /// <summary>Advanced load balancer SSLClientCertificateAction object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSSLClientCertificateAction 
    {
        /// <summary>Placeholder for description of property headers of obj type
        /// SSLClientCertificateAction field type str  type array.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("headers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBSSLClientRequestHeader> Headers { get; set; }
    
        /// <summary>Placeholder for description of property close_connection of
        /// obj type SSLClientCertificateAction field type str  type
        /// boolean.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("close_connection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Close_connection { get; set; } = false;
    
    
    }
    
    /// <summary>Tag and resource information on which tag to be applied or removed.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TagBulkOperation : PolicyConfigResource
    {
        /// <summary>List of resources on which tag needs to be applied
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apply_to", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ResourceInfo> Apply_to { get; set; }
    
        /// <summary>Tag</summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Tag Tag { get; set; } = new Tag();
    
        /// <summary>List of resources from which tag needs to be removed
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remove_from", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ResourceInfo> Remove_from { get; set; }
    
    
    }
    
    /// <summary>This action is used to rewrite URIs in matched HTTP request messages.
    /// Specify the uri and uri_arguments fields in this condition to rewrite the
    /// matched HTTP request message's URI and URI arguments to the new values.
    /// Full URI scheme of HTTP messages have following syntax:
    /// scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]
    /// The uri field of this action is used to rewrite the /path part in above
    /// scheme. And the uri_arguments field is used to rewrite the query part.
    /// Captured variables and built-in variables can be used in the uri and
    /// uri_arguments fields.
    /// Check the example in LBRuleAction to see how to use variables in this
    /// action.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBHttpRequestUriRewriteAction : LBRuleAction
    {
        /// <summary>Query string of URI, typically contains key value pairs, for example:
        /// foo1=bar1&amp;foo2=bar2.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uri_arguments", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uri_arguments { get; set; }
    
        /// <summary>URI of HTTP request.</summary>
        [Newtonsoft.Json.JsonProperty("uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Uri { get; set; }
    
    
    }
    
    /// <summary>IDS configuration to enable/disable IDS on standalone host level.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsStandaloneHostConfig : PolicyConfigResource
    {
        /// <summary>If set to true, IDS is enabled on standalone hosts.</summary>
        [Newtonsoft.Json.JsonProperty("ids_enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Ids_enabled { get; set; }
    
    
    }
    
    /// <summary>The GlobalCollectorConfig is the base class for global collector configurations for
    /// different types in a NSX domain.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "collector_type")]
    [JsonInheritanceAttribute("VrniGlobalCollector", typeof(VrniGlobalCollector))]
    [JsonInheritanceAttribute("WaveFrontGlobalCollector", typeof(WaveFrontGlobalCollector))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GlobalCollectorConfig 
    {
        /// <summary>Port for the global collector.</summary>
        [Newtonsoft.Json.JsonProperty("collector_port", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long Collector_port { get; set; }
    
        /// <summary>IP address for the global collector.</summary>
        [Newtonsoft.Json.JsonProperty("collector_ip", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Collector_ip { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for PolicyFirewallScheduler, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyFirewallScheduler : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyFirewallScheduler objects
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyFirewallScheduler", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyFirewallScheduler PolicyFirewallScheduler { get; set; }
    
    
    }
    
    /// <summary>Base type for resources that are managed by API clients</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ManagedResource : RevisionedResource
    {
        /// <summary>Indicates system owned resource</summary>
        [Newtonsoft.Json.JsonProperty("_system_owned", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? _system_owned { get; set; }
    
        /// <summary>Defaults to ID if not set</summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string Display_name { get; set; }
    
        /// <summary>Description of this resource</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Description { get; set; }
    
        /// <summary>Opaque identifiers meaningful to the API user</summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(30)]
        public System.Collections.Generic.ICollection<Tag> Tags { get; set; }
    
        /// <summary>ID of the user who created this resource</summary>
        [Newtonsoft.Json.JsonProperty("_create_user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string _create_user { get; set; }
    
        /// <summary>Protection status is one of the following:
        /// PROTECTED - the client who retrieved the entity is not allowed
        ///             to modify it.
        /// NOT_PROTECTED - the client who retrieved the entity is allowed
        ///                 to modify it
        /// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
        ///                    user and can modify it, but only when providing
        ///                    the request header X-Allow-Overwrite=true.
        /// UNKNOWN - the _protection field could not be determined for this
        ///           entity.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("_protection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string _protection { get; set; }
    
        /// <summary>Timestamp of resource creation</summary>
        [Newtonsoft.Json.JsonProperty("_create_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? _create_time { get; set; }
    
        /// <summary>Timestamp of last modification</summary>
        [Newtonsoft.Json.JsonProperty("_last_modified_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? _last_modified_time { get; set; }
    
        /// <summary>ID of the user who last modified this resource</summary>
        [Newtonsoft.Json.JsonProperty("_last_modified_user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string _last_modified_user { get; set; }
    
        /// <summary>Unique identifier of this resource</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
        /// <summary>The type of this resource.</summary>
        [Newtonsoft.Json.JsonProperty("resource_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Resource_type { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of Constraints</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConstraintListResult : ListResult
    {
        /// <summary>Constraint list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Constraint> Results { get; set; } = new System.Collections.ObjectModel.Collection<Constraint>();
    
    
    }
    
    /// <summary>Child wrapper object for L2VPNService, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildL2VPNService : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual L2VPNService object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("L2VPNService", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public L2VPNService L2VPNService { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyEdgeClusterMemberInterSiteStatus 
    {
        /// <summary>Total number of current established inter-site IBGP sessions.</summary>
        [Newtonsoft.Json.JsonProperty("established_bgp_sessions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Established_bgp_sessions { get; set; }
    
        /// <summary>Edge node IBGP status</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyEdgeClusterMemberInterSiteStatusStatus? Status { get; set; }
    
        /// <summary>Inter-site BGP neighbor status.</summary>
        [Newtonsoft.Json.JsonProperty("neighbor_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyBgpNeighborStatus> Neighbor_status { get; set; }
    
        /// <summary>Total number of inter-site IBGP sessions.</summary>
        [Newtonsoft.Json.JsonProperty("total_bgp_sessions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total_bgp_sessions { get; set; }
    
        /// <summary>Edge node details from where the status is being retrived.</summary>
        [Newtonsoft.Json.JsonProperty("edge_node_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceReference Edge_node_path { get; set; }
    
    
    }
    
    /// <summary>Identity Firewall NSGorup to user mapping to link DirGroup to user session data.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdfwDirGroupUserSessionMapping 
    {
        /// <summary>User ID.</summary>
        [Newtonsoft.Json.JsonProperty("user_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User_id { get; set; }
    
        /// <summary>Directory Group ID.</summary>
        [Newtonsoft.Json.JsonProperty("dir_group_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dir_group_id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CountActionConfig 
    {
        /// <summary>The count action argument</summary>
        [Newtonsoft.Json.JsonProperty("action_argument", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public CountActionArgument Action_argument { get; set; } = new CountActionArgument();
    
    
    }
    
    /// <summary>Static IPv4 multicast address and assciated multicast group ranges.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RpAddressMulticastRanges 
    {
        /// <summary>Assciated multicast group ranges configuration.</summary>
        [Newtonsoft.Json.JsonProperty("multicast_ranges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Multicast_ranges { get; set; }
    
        /// <summary>Static IPv4 multicast address configuration.</summary>
        [Newtonsoft.Json.JsonProperty("rp_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Rp_address { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for IdsSecurityPolicy, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIdsSecurityPolicy : ChildPolicyConfigResource
    {
        /// <summary>Contains the IdsSecurityPolicy object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IdsSecurityPolicy", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IdsSecurityPolicy IdsSecurityPolicy { get; set; }
    
    
    }
    
    /// <summary>This entity will be used to establish association between Flood Protection
    /// profile and Logical Routers.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FloodProtectionProfileBindingMap : ProfileBindingMap
    {
    
    }
    
    /// <summary>BGP routes per transport node.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RoutesPerTransportNode 
    {
        /// <summary>Array of BGP neighbor route details for this transport node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("routes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RouteDetails> Routes { get; set; }
    
        /// <summary>BGP neighbor source address.</summary>
        [Newtonsoft.Json.JsonProperty("source_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source_address { get; set; }
    
        /// <summary>Transport node id</summary>
        [Newtonsoft.Json.JsonProperty("transport_node_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_node_id { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for LBVirtualServer, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildLBVirtualServer : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual LBVirtualServer object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("LBVirtualServer", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public LBVirtualServer LBVirtualServer { get; set; }
    
    
    }
    
    /// <summary>This entity will be used to establish association between General Security
    /// profile and Logical Routers.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GeneralSecurityProfileBindingMap : ProfileBindingMap
    {
    
    }
    
    /// <summary>Contains the binding relationship between segment and security profile.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentSecurityProfileBindingMap : SecurityProfileBindingMap
    {
        /// <summary>The policy path of the asscociated SpoofGuard profile</summary>
        [Newtonsoft.Json.JsonProperty("spoofguard_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Spoofguard_profile_path { get; set; }
    
        /// <summary>The policy path of the asscociated Segment Security profile</summary>
        [Newtonsoft.Json.JsonProperty("segment_security_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Segment_security_profile_path { get; set; }
    
    
    }
    
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("DirectoryAdGroup", typeof(DirectoryAdGroup))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DirectoryGroup : ManagedResource
    {
        /// <summary>Domain sync node under which this directory group is located. We currently sync only from Root node and hence this attribute doesn't have a specific value set.</summary>
        [Newtonsoft.Json.JsonProperty("domain_sync_node_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Domain_sync_node_id { get; set; }
    
        /// <summary>Directory group distinguished name</summary>
        [Newtonsoft.Json.JsonProperty("distinguished_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Distinguished_name { get; set; }
    
        /// <summary>Domain ID this directory group belongs to.</summary>
        [Newtonsoft.Json.JsonProperty("domain_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Domain_id { get; set; }
    
        /// <summary>Each active directory domain has a domain naming context (NC), which contains domain-specific data. The root of this naming context is represented by a domain's distinguished name (DN) and is typically referred to as the NC head.</summary>
        [Newtonsoft.Json.JsonProperty("domain_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Domain_name { get; set; }
    
    
    }
    
    /// <summary>Binding of Tier-0 to the enforcement point.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier0DeploymentMap : PolicyConfigResource
    {
        /// <summary>Path of enforcement point on which Tier-0 shall be deployed.</summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Enforcement_point { get; set; }
    
    
    }
    
    /// <summary>Tier-1 interface configuration for attaching services.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier1Interface : BaseTier0Interface
    {
        /// <summary>Unicast Reverse Path Forwarding mode</summary>
        [Newtonsoft.Json.JsonProperty("urpf_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Tier1InterfaceUrpf_mode? Urpf_mode { get; set; } = SDKGenerator.Tier1InterfaceUrpf_mode.STRICT;
    
        /// <summary>Maximum transmission unit (MTU) specifies the size of the largest
        /// packet that a network protocol can transmit.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mtu", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(64D, int.MaxValue)]
        public long? Mtu { get; set; }
    
        /// <summary>Configrue IPv6 NDRA profile. Only one
        /// NDRA profile can be configured.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipv6_profile_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Ipv6_profile_paths { get; set; }
    
        /// <summary>Policy path of Segment to which interface is connected to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("segment_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Segment_path { get; set; }
    
    
    }
    
    /// <summary>IGMP Memberships.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IgmpMemberships 
    {
        /// <summary>Policy path to Tier0 or Tier1 gateway.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gateway_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Gateway_path { get; set; }
    
        [Newtonsoft.Json.JsonProperty("igmp_memberships_per_edge", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IgmpMembershipsPerEdge> Igmp_memberships_per_edge { get; set; }
    
    
    }
    
    /// <summary>Some applications maintain state and require all relevant connections
    /// to be sent to the same server as the application state is not
    /// synchronized among servers. Persistence is enabled on a
    /// PolicyLbVirtualServer by binding a persistence profile to it.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L4PolicyLbPersistenceProfile : PolicyLbPersistenceProfile
    {
        /// <summary>This field indicates the persistence method used for the
        /// PolicyLbVirtualServer.
        /// - SOURCE_IP persistence ensures all connections from a client
        /// (identified by IP address) are sent to the same backend server for a
        /// specified period.
        /// - This object is not required and persistence is disabled by
        /// default
        /// </summary>
        [Newtonsoft.Json.JsonProperty("persistence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public L4PolicyLbPersistenceProfilePersistence? Persistence { get; set; } = SDKGenerator.L4PolicyLbPersistenceProfilePersistence.SOURCE_IP;
    
    
    }
    
    /// <summary>Collection of vitual endpoints under a Tier0</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VirtualEndpointListResult : ListResult
    {
        /// <summary>All virtual endpoints under a Tier0</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<VirtualEndpoint> Results { get; set; } = new System.Collections.ObjectModel.Collection<VirtualEndpoint>();
    
    
    }
    
    /// <summary>Guest virtual machine details include OS name and computer name of guest VM.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GuestInfo 
    {
        /// <summary>OS name of guest virtual machine. Currently this is supported for guests
        /// on ESXi that have VMware Tools installed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("os_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Os_name { get; set; }
    
        /// <summary>Computer name of guest virtual machine, which is set inside guest OS.
        /// Currently this is supported for guests on ESXi that have VMware Tools installed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("computer_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Computer_name { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for ByodPolicyServiceInstance used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildByodPolicyServiceInstance : ChildPolicyConfigResource
    {
        /// <summary>Contains actual ByodPolicyServiceInstance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ByodPolicyServiceInstance", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ByodPolicyServiceInstance ByodPolicyServiceInstance { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ManagementConfig : RevisionedResource
    {
        /// <summary>True if Management nodes publish their fqdns(instead of default IP addresses) across NSX for its reachability.</summary>
        [Newtonsoft.Json.JsonProperty("publish_fqdns", Required = Newtonsoft.Json.Required.Always)]
        public bool Publish_fqdns { get; set; }
    
    
    }
    
    /// <summary>All the types of LBVirtualServer extend from this abstract class. This
    /// is present for extensibility.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBVirtualServer : PolicyConfigResource
    {
        /// <summary>Path to optional object that enables persistence on a virtual server
        /// allowing related client connections to be sent to the same backend
        /// server. Persistence is disabled by default.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lb_persistence_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lb_persistence_profile_path { get; set; }
    
        /// <summary>Specifies the access list control to define how to filter the
        /// connections from clients.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("access_list_control", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LBAccessListControl Access_list_control { get; set; }
    
        /// <summary>The server pool(LBPool) contains backend servers. Server pool
        /// consists of one or more servers, also referred to as pool members, that
        /// are similarly configured and are running the same application.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pool_path { get; set; }
    
        /// <summary>The property log_significant_event_only can take effect only when
        /// access_log_enabled is true. If log_significant_event_only is true,
        /// significant events are logged in access log.
        /// For L4 virtual server, significant event means unsuccessful(error or
        /// dropped) TCP/UDP connections.
        /// For L7 virtual server, significant event means unsuccessful connections
        /// or HTTP/HTTPS requests which have error response code(e.g. 4xx, 5xx).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("log_significant_event_only", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Log_significant_event_only { get; set; } = false;
    
        /// <summary>Load balancer rules allow customization of load balancing behavior using
        /// match/action rules. Currently, load balancer rules are supported for
        /// only layer 7 virtual servers with LBHttpProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(4000)]
        public System.Collections.Generic.ICollection<LBRule> Rules { get; set; }
    
        /// <summary>Default pool member ports when member port is not defined.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("default_pool_member_ports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(14)]
        public System.Collections.Generic.ICollection<string> Default_pool_member_ports { get; set; }
    
        /// <summary>The setting is used when load balancer acts as an SSL client and
        /// establishing a connection to the backend server.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server_ssl_profile_binding", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LBServerSslProfileBinding Server_ssl_profile_binding { get; set; }
    
        /// <summary>The application profile defines the application protocol characteristics.
        /// It is used to influence how load balancing is performed. Currently,
        /// LBFastTCPProfile, LBFastUDPProfile and
        /// LBHttpProfile, etc are supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("application_profile_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Application_profile_path { get; set; }
    
        /// <summary>If access log is enabled, all HTTP requests sent to L7 virtual server
        /// are logged to the access log file. Both successful returns information
        /// responses(1xx), successful responses(2xx), redirection messages(3xx) and
        /// unsuccessful requests, backend server returns 4xx or 5xx, are logged to
        /// access log, if enabled. All L4 virtual server connections are also
        /// logged to the access log if enabled. The non-significant events such as
        /// successful requests are not logged if log_significant_event_only is set
        /// to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("access_log_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Access_log_enabled { get; set; } = false;
    
        /// <summary>To ensure one virtual server does not over consume resources,
        /// affecting other applications hosted on the same LBS, connections
        /// to a virtual server can be capped.
        /// If it is not specified, it means that connections are unlimited.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_concurrent_connections", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long? Max_concurrent_connections { get; set; }
    
        /// <summary>To ensure one virtual server does not over consume resources,
        /// connections to a member can be rate limited.
        /// If it is not specified, it means that connection rate is unlimited.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_new_connection_rate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long? Max_new_connection_rate { get; set; }
    
        /// <summary>virtual servers can be associated to LBService(which is
        /// similar to physical/virtual load balancer), LB virtual servers,
        /// pools and other entities could be defined independently, the LBService
        /// identifier list here would be used to maintain the relationship of
        /// LBService and other LB entities.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lb_service_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lb_service_path { get; set; }
    
        /// <summary>The setting is used when load balancer acts as an SSL server and
        /// terminating the client SSL connection
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_ssl_profile_binding", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LBClientSslProfileBinding Client_ssl_profile_binding { get; set; }
    
        /// <summary>When load balancer can not select a backend server to serve the
        /// request in default pool or pool in rules, the request would be served
        /// by sorry server pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sorry_pool_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sorry_pool_path { get; set; }
    
        /// <summary>Configures the IP address of the LBVirtualServer where it
        /// receives all client connections and distributes them among the
        /// backend servers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ip_address { get; set; }
    
        /// <summary>Ports contains a list of at least one port or port range such as "80",
        /// "1234-1236". Each port element in the list should be a single port or a
        /// single port range.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ports", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Ports { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Flag to enable the load balancer virtual server.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
    
    }
    
    /// <summary>Child wrapper object for PolicyFirewallCpuMemThresholdsProfile, used in
    /// hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyFirewallCpuMemThresholdsProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyFirewallCpuMemThresholdsProfile object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyFirewallCpuMemThresholdsProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyFirewallCpuMemThresholdsProfile PolicyFirewallCpuMemThresholdsProfile { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for FloodProtectionProfileBindingMap,
    /// used in hierarchical API
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildFloodProtectionProfileBindingMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual FloodProtectionProfileBindingMap object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("FloodProtectionProfileBindingMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public FloodProtectionProfileBindingMap FloodProtectionProfileBindingMap { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for L3Vpn, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildL3Vpn : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual L3Vpn object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("L3Vpn", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public L3Vpn L3Vpn { get; set; }
    
    
    }
    
    /// <summary>This object holds auto assigned route distinguishers for Layer 2 and Layer 3 configurations.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AutoRds 
    {
        /// <summary>This field is auto assigned by the system.
        /// The auto RD seed is populated when user does not assign a
        /// route_distinguisher field in the gateway.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("l3_auto_rd", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string L3_auto_rd { get; set; }
    
        /// <summary>List of layer 2 Auto assigned Route Distinguisher</summary>
        [Newtonsoft.Json.JsonProperty("l2_auto_rds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<L2AutoRD> L2_auto_rds { get; set; }
    
    
    }
    
    /// <summary>Short name or alias of a url. It is used to represent the url.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class UrlAlias 
    {
        /// <summary>Url to fetch data from.</summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Url { get; set; }
    
        /// <summary>Short name or alias of url, if any. If not specified, the url can be referenced by its index in the array of urls of the datasource instance as $&lt;index&gt; (for example, $0).</summary>
        [Newtonsoft.Json.JsonProperty("alias", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string Alias { get; set; }
    
        /// <summary>Search query to be applied, if any. If query string is not provided, it will be ignored.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Query { get; set; }
    
    
    }
    
    /// <summary>Realized Logical Switch</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedLogicalSwitch : PolicyRealizedResource
    {
        /// <summary>Transport zone identifier</summary>
        [Newtonsoft.Json.JsonProperty("transport_zone_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_zone_id { get; set; }
    
        /// <summary>Id of the logical switch</summary>
        [Newtonsoft.Json.JsonProperty("logical_switch_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Logical_switch_id { get; set; }
    
    
    }
    
    /// <summary>Representing either forward or reverse service path for ingress or egress traffic respectively.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class UnidirectionalServicePath 
    {
        /// <summary>List of service path hops that constitutes the forward or reverse service path.</summary>
        [Newtonsoft.Json.JsonProperty("hops", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ServicePathHop> Hops { get; set; }
    
        /// <summary>Is forward or revserse service path in maintenance mode or not.</summary>
        [Newtonsoft.Json.JsonProperty("in_maintenance_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? In_maintenance_mode { get; set; }
    
        /// <summary>The number of times the traffic needs to cross hosts for the given forward or reverse service path.</summary>
        [Newtonsoft.Json.JsonProperty("host_cross_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Host_cross_count { get; set; }
    
        /// <summary>Is forward or revserse service path active or not.</summary>
        [Newtonsoft.Json.JsonProperty("is_active", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_active { get; set; }
    
        /// <summary>Unique identifier of one directional service path.</summary>
        [Newtonsoft.Json.JsonProperty("unidir_service_path_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Unidir_service_path_id { get; set; }
    
    
    }
    
    /// <summary>A ServiceInstanceEndpoint belongs to one ByodPolicyServiceInstance and is attached to one ServiceInterface. A ServiceInstanceEndpoint represents a redirection target for a RedirectionPolicy.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServiceInstanceEndpoint : BaseEndpoint
    {
        /// <summary>Path of Service Interface to which this ServiceInstanceEndpoint is connected.</summary>
        [Newtonsoft.Json.JsonProperty("service_interface_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Service_interface_path { get; set; }
    
    
    }
    
    /// <summary>Represents a column of the Grid</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ColumnItem 
    {
        /// <summary>Sorting on column is based on the sort_key. sort_key represents the field in the output data on which sort is requested.</summary>
        [Newtonsoft.Json.JsonProperty("sort_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string Sort_key { get; set; }
    
        /// <summary>Data type of the field.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ColumnItemType Type { get; set; } = SDKGenerator.ColumnItemType.String;
    
        /// <summary>Multi-line text to be shown on tooltip while hovering over a cell in the grid.</summary>
        [Newtonsoft.Json.JsonProperty("tooltip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Tooltip> Tooltip { get; set; }
    
        /// <summary>Label of the column.</summary>
        [Newtonsoft.Json.JsonProperty("label", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Label Label { get; set; } = new Label();
    
        /// <summary>Field from which values of the column will be derived.</summary>
        [Newtonsoft.Json.JsonProperty("field", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Field { get; set; }
    
        /// <summary>If true, the value of the column are sorted in ascending order. Otherwise, in descending order.</summary>
        [Newtonsoft.Json.JsonProperty("sort_ascending", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Sort_ascending { get; set; } = true;
    
        /// <summary>Id of drilldown widget, if any. Id should be a valid id of an existing widget.</summary>
        [Newtonsoft.Json.JsonProperty("drilldown_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string Drilldown_id { get; set; }
    
        /// <summary>If set to true, hides the column</summary>
        [Newtonsoft.Json.JsonProperty("hidden", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Hidden { get; set; } = false;
    
        /// <summary>Hyperlink of the specified UI page that provides details. If drilldown_id is provided, then navigation cannot be used.</summary>
        [Newtonsoft.Json.JsonProperty("navigation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Navigation { get; set; }
    
        /// <summary>Identifies the column and used for fetching content upon an user click or drilldown. If column identifier is not provided, the column's data will not participate in searches and drilldowns.</summary>
        [Newtonsoft.Json.JsonProperty("column_identifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Column_identifier { get; set; }
    
        /// <summary>Render configuration to be applied, if any.</summary>
        [Newtonsoft.Json.JsonProperty("render_configuration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RenderConfiguration> Render_configuration { get; set; }
    
    
    }
    
    /// <summary>Routing table.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RoutingTable 
    {
        /// <summary>Entry count.</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Route entries.</summary>
        [Newtonsoft.Json.JsonProperty("route_entries", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<RoutingEntry> Route_entries { get; set; } = new System.Collections.ObjectModel.Collection<RoutingEntry>();
    
        /// <summary>Transport node ID.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_node", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Edge_node { get; set; }
    
    
    }
    
    /// <summary>Paged collection of QoS profiles</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class QoSProfileListResult : ListResult
    {
        /// <summary>QoS profiles list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<QoSProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<QoSProfile>();
    
    
    }
    
    /// <summary>Provides upgrade summary for a specific site.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FederationUpgradeSummary 
    {
        /// <summary>This is NSX target version for the site, if it is undergoing upgrade.</summary>
        [Newtonsoft.Json.JsonProperty("target_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Target_version { get; set; }
    
        /// <summary>Type of this site.</summary>
        [Newtonsoft.Json.JsonProperty("site_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FederationUpgradeSummarySite_type? Site_type { get; set; }
    
        /// <summary>Indicates the time when the site was upgraded.</summary>
        [Newtonsoft.Json.JsonProperty("last_upgrade_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_upgrade_timestamp { get; set; }
    
        /// <summary>List of component statuses</summary>
        [Newtonsoft.Json.JsonProperty("component_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FederationComponentUpgradeStatus> Component_status { get; set; }
    
        /// <summary>This is the Site Manager generated UUID for every NSX deployment.</summary>
        [Newtonsoft.Json.JsonProperty("site_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Site_id { get; set; }
    
        /// <summary>Status of upgrade</summary>
        [Newtonsoft.Json.JsonProperty("overall_upgrade_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FederationUpgradeSummaryOverall_upgrade_status? Overall_upgrade_status { get; set; }
    
        /// <summary>Name of the global manager if present.</summary>
        [Newtonsoft.Json.JsonProperty("gpm_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Gpm_name { get; set; }
    
        /// <summary>IP address of the site.</summary>
        [Newtonsoft.Json.JsonProperty("site_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Site_ip { get; set; }
    
        /// <summary>This is NSX version for the site.</summary>
        [Newtonsoft.Json.JsonProperty("current_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Current_version { get; set; }
    
        /// <summary>Unique identifier of this resource.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
        /// <summary>Name of the site.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
    
    }
    
    /// <summary>Client SSL profile.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBClientSslProfile : LBSslProfile
    {
        /// <summary>SSL session caching allows SSL client and server to reuse previously
        /// negotiated security parameters avoiding the expensive public key
        /// operation during handshake.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("session_cache_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Session_cache_enabled { get; set; } = true;
    
        /// <summary>Session cache timeout specifies how long the SSL session parameters
        /// are held on to and can be reused.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("session_cache_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 86400D)]
        public long? Session_cache_timeout { get; set; } = 300L;
    
        /// <summary>It is a label of cipher group which is mostly consumed by GUI.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cipher_group_label", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBClientSslProfileCipher_group_label? Cipher_group_label { get; set; }
    
        /// <summary>This flag is set to true when all the ciphers and protocols are FIPS
        /// compliant. It is set to false when one of the ciphers or protocols are
        /// not FIPS compliant..
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_fips", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_fips { get; set; }
    
        /// <summary>This flag is set to true when all the ciphers and protocols are secure.
        /// It is set to false when one of the ciphers or protocols is insecure.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_secure", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_secure { get; set; }
    
        /// <summary>During SSL handshake as part of the SSL client Hello client sends an
        /// ordered list of ciphers that it can support (or prefers) and typically
        /// server selects the first one from the top of that list it can also
        /// support. For Perfect Forward Secrecy(PFS), server could override the
        /// client's preference.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("prefer_server_ciphers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Prefer_server_ciphers { get; set; } = true;
    
        /// <summary>Supported SSL cipher list to client side.</summary>
        [Newtonsoft.Json.JsonProperty("ciphers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Ciphers2> Ciphers { get; set; }
    
        /// <summary>SSL versions TLS1.1 and TLS1.2 are supported and enabled by default.
        /// SSLv2, SSLv3, and TLS1.0 are supported, but disabled by default.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocols", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Protocols2> Protocols { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer URIParam object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBURIParam 
    {
        /// <summary>Token config either for the URI components or a constant
        /// string.
        /// Minimum of 1 items required.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokens", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ALBURIParamToken> Tokens { get; set; } = new System.Collections.ObjectModel.Collection<ALBURIParamToken>();
    
        /// <summary>URI param type.
        /// Enum options - URI_PARAM_TYPE_TOKENIZED.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBURIParamType Type { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer ApplicationPersistenceProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBApplicationPersistenceProfile : PolicyConfigResource
    {
        /// <summary>Specifies the HTTP Cookie Persistence profile parameters.</summary>
        [Newtonsoft.Json.JsonProperty("http_cookie_persistence_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHttpCookiePersistenceProfile Http_cookie_persistence_profile { get; set; }
    
        /// <summary>Specifies the Client IP Persistence profile parameters.</summary>
        [Newtonsoft.Json.JsonProperty("ip_persistence_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIPPersistenceProfile Ip_persistence_profile { get; set; }
    
        /// <summary>Specifies the Application Cookie Persistence profile
        /// parameters.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("app_cookie_persistence_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBAppCookiePersistenceProfile App_cookie_persistence_profile { get; set; }
    
        /// <summary>Specifies the custom HTTP Header Persistence profile
        /// parameters.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hdr_persistence_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHdrPersistenceProfile Hdr_persistence_profile { get; set; }
    
        /// <summary>Method used to persist clients to the same server for a
        /// duration of time or a session.
        /// Enum options - PERSISTENCE_TYPE_CLIENT_IP_ADDRESS,
        /// PERSISTENCE_TYPE_HTTP_COOKIE, PERSISTENCE_TYPE_TLS,
        /// PERSISTENCE_TYPE_CLIENT_IPV6_ADDRESS,
        /// PERSISTENCE_TYPE_CUSTOM_HTTP_HEADER,
        /// PERSISTENCE_TYPE_APP_COOKIE, PERSISTENCE_TYPE_GSLB_SITE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// PERSISTENCE_TYPE_CLIENT_IP_ADDRESS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("persistence_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBApplicationPersistenceProfilePersistence_type Persistence_type { get; set; } = SDKGenerator.ALBApplicationPersistenceProfilePersistence_type.PERSISTENCE_TYPE_CLIENT_IP_ADDRESS;
    
        /// <summary>This field describes the object's replication scope.
        /// If the field is set to false, then the object is visible
        /// within the controller-cluster and its associated
        /// service-engines.
        /// If the field is set to true, then the object is replicated
        /// across the federation.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_federated", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_federated { get; set; } = false;
    
        /// <summary>Specifies behavior when a persistent server has been marked
        /// down by a health monitor.
        /// Enum options - HM_DOWN_PICK_NEW_SERVER,
        /// HM_DOWN_ABORT_CONNECTION,
        /// HM_DOWN_CONTINUE_PERSISTENT_SERVER.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as HM_DOWN_PICK_NEW_SERVER.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server_hm_down_recovery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBApplicationPersistenceProfileServer_hm_down_recovery? Server_hm_down_recovery { get; set; } = SDKGenerator.ALBApplicationPersistenceProfileServer_hm_down_recovery.HM_DOWN_PICK_NEW_SERVER;
    
    
    }
    
    /// <summary>Represents an instance of partner's service whose wiring will be done by partner itself.
    /// As partner does all the wiring, we call it as Byod - Bring your own device.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ByodPolicyServiceInstance : BasePolicyServiceInstance
    {
    
    }
    
    /// <summary>The key is used to specify the symmetric key which is used to verify the
    /// signature of JWT tokens.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBJwtSymmetricKey : LBJwtKey
    {
    
    }
    
    /// <summary>Configuration field to hold BGP restart mode and timer.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BgpGracefulRestartConfig 
    {
        /// <summary>If mode is DISABLE, then graceful restart and helper modes are disabled.
        /// If mode is GR_AND_HELPER, then both graceful restart and helper modes are enabled.
        /// If mode is HELPER_ONLY, then helper mode is enabled.
        /// HELPER_ONLY mode is the ability for a BGP speaker to indicate its ability
        /// to preserve forwarding state during BGP restart.
        /// GRACEFUL_RESTART mode is the ability of a BGP speaker to advertise its restart
        /// to its peers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BgpGracefulRestartConfigMode? Mode { get; set; } = SDKGenerator.BgpGracefulRestartConfigMode.HELPER_ONLY;
    
        /// <summary>Configuration field to hold BGP restart timers.</summary>
        [Newtonsoft.Json.JsonProperty("timer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public BgpGracefulRestartTimer Timer { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer ProtocolParser object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBProtocolParser : PolicyConfigResource
    {
        /// <summary>Command script provided inline.</summary>
        [Newtonsoft.Json.JsonProperty("parser_code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Parser_code { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyEdgeNodeInterSiteBgpSummary 
    {
        /// <summary>Timestamp when the inter-site IBGP neighbors status was last updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>Status of all inter-site IBGP neighbors.</summary>
        [Newtonsoft.Json.JsonProperty("neighbor_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyBgpNeighborStatus> Neighbor_status { get; set; }
    
        /// <summary>Edge node path whose status is being reported.</summary>
        [Newtonsoft.Json.JsonProperty("edge_node_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Edge_node_path { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PacketsDroppedBySecurity 
    {
        /// <summary>The packets dropped by "Spoof Guard"; supported packet types are IPv4, IPv6, ARP, ND, non-IP.</summary>
        [Newtonsoft.Json.JsonProperty("spoof_guard_dropped", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PacketTypeAndCounter> Spoof_guard_dropped { get; set; }
    
        /// <summary>The number of IPv4 packets dropped by "DHCP server block".</summary>
        [Newtonsoft.Json.JsonProperty("dhcp_server_dropped_ipv4", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dhcp_server_dropped_ipv4 { get; set; }
    
        /// <summary>The number of IPv6 packets dropped by "DHCP server block".</summary>
        [Newtonsoft.Json.JsonProperty("dhcp_server_dropped_ipv6", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dhcp_server_dropped_ipv6 { get; set; }
    
        /// <summary>The number of IPv4 packets dropped by "DHCP client block".</summary>
        [Newtonsoft.Json.JsonProperty("dhcp_client_dropped_ipv4", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dhcp_client_dropped_ipv4 { get; set; }
    
        /// <summary>The number of packets dropped by "BPDU filter".</summary>
        [Newtonsoft.Json.JsonProperty("bpdu_filter_dropped", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bpdu_filter_dropped { get; set; }
    
        /// <summary>The number of IPv6 packets dropped by "DHCP client block".</summary>
        [Newtonsoft.Json.JsonProperty("dhcp_client_dropped_ipv6", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dhcp_client_dropped_ipv6 { get; set; }
    
    
    }
    
    /// <summary>Resource Operation is an Event Source that represents a resource that
    /// is being changed at very specific points of time, with regard to
    /// its interaction with dao layer.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ResourceOperation : Source
    {
        /// <summary>Regex path representing a regex expression on resources. This regex is used
        /// to identify the object(s) that is/are the source of the Event. For instance:
        /// specifying "Lb* | /infra/tier-0s/vmc/ipsec-vpn-services/default" as a source
        /// means that ANY resource starting with Lb or ANY resource with
        /// "/infra/tier-0s/vmc/ipsec-vpn-services/default" as path would be the source
        /// of the event in question.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resource_pointer", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Resource_pointer { get; set; }
    
        /// <summary>Operation types.</summary>
        [Newtonsoft.Json.JsonProperty("operation_types", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<Operation_types> Operation_types { get; set; } = new System.Collections.ObjectModel.Collection<Operation_types>();
    
    
    }
    
    /// <summary>Each revoked certificate is identified in a CRL by its certificate serial number.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class X509CrlEntry 
    {
        /// <summary>Revocation date.</summary>
        [Newtonsoft.Json.JsonProperty("revocation_date", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Revocation_date { get; set; }
    
        /// <summary>The revoked certificate's serial number.</summary>
        [Newtonsoft.Json.JsonProperty("serial_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Serial_number { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer GeoLocation object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBGeoLocation 
    {
        /// <summary>Latitude of the location.
        /// This is represented as degrees.minutes.
        /// The range is from -90.0 (south) to +90.0 (north).
        /// Allowed values are -90.0-+90.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("latitude", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Latitude { get; set; }
    
        /// <summary>Location tag string - example  USEast.</summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tag { get; set; }
    
        /// <summary>Location name in the format Country/State/City.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Longitude of the location.
        /// This is represented as degrees.minutes.
        /// The range is from -180.0 (west) to +180.0 (east).
        /// Allowed values are -180.0-+180.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("longitude", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Longitude { get; set; }
    
    
    }
    
    /// <summary>List of errors with their metadata</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ErrorResolverMetadataList 
    {
        /// <summary>List of errors with their corresponding metadata.</summary>
        [Newtonsoft.Json.JsonProperty("errors", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ErrorResolverMetadata> Errors { get; set; } = new System.Collections.ObjectModel.Collection<ErrorResolverMetadata>();
    
    
    }
    
    /// <summary>Child wrapper for ALBWafPolicyPSMGroup, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBWafPolicyPSMGroup : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBWafPolicyPSMGroup object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBWafPolicyPSMGroup", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBWafPolicyPSMGroup ALBWafPolicyPSMGroup { get; set; }
    
    
    }
    
    /// <summary>Consolidated Realized Status Per Enforcement Point.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("ConsolidatedStatusPerEnforcementPoint", typeof(ConsolidatedStatusPerEnforcementPoint))]
    [JsonInheritanceAttribute("ConsolidatedStatusNsxT", typeof(ConsolidatedStatusNsxT))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BaseConsolidatedStatusPerEnforcementPoint : PolicyRuntimeInfoPerEP
    {
        /// <summary>The site where this enforcement point resides.</summary>
        [Newtonsoft.Json.JsonProperty("site_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Site_path { get; set; }
    
        /// <summary>Consolidated Realized Status of an Intent object per enforcement point.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("consolidated_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConsolidatedStatus Consolidated_status { get; set; }
    
        /// <summary>Enforcement Point Id.</summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enforcement_point_id { get; set; }
    
    
    }
    
    /// <summary>Traceflow configuration</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceflowConfig : PolicyConfigResource
    {
        /// <summary>Maximum time in seconds the management plane will wait for observation
        /// result to be sent by opsAgent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(5D, 15D)]
        public long? Timeout { get; set; } = 10L;
    
        /// <summary>This field indicates if intent is transient and will be cleaned up by the system if set to true</summary>
        [Newtonsoft.Json.JsonProperty("is_transient", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_transient { get; set; } = true;
    
        /// <summary>Configuration of packet data</summary>
        [Newtonsoft.Json.JsonProperty("packet", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PacketData Packet { get; set; } = new PacketData();
    
        /// <summary>Segment Port Path or UUID</summary>
        [Newtonsoft.Json.JsonProperty("segment_port_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Segment_port_path { get; set; }
    
    
    }
    
    /// <summary>A Policy-based L3Vpn session is a configuration in which a specific vpn tunnel is
    /// referenced in a policy whose action is set as tunnel.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyBasedL3VpnSession : L3VpnSession
    {
        /// <summary>L3Vpn rules that are specific to the L3Vpn. Only L3Vpn rules with PROTECT action
        /// are supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<L3VpnRule> Rules { get; set; }
    
    
    }
    
    /// <summary>Paged collection of Domain Deployment Map.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DomainDeploymentMapListResult : ListResult
    {
        /// <summary>Domain Deployment Map list result.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<DomainDeploymentMap> Results { get; set; } = new System.Collections.ObjectModel.Collection<DomainDeploymentMap>();
    
    
    }
    
    /// <summary>Collection of Igmp Profile.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyIgmpProfileListResult : ListResult
    {
        /// <summary>Igmp Profile list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyIgmpProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyIgmpProfile>();
    
    
    }
    
    /// <summary>User/Group's role binding</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RoleBinding : ManagedResource
    {
        /// <summary>Identity source type</summary>
        [Newtonsoft.Json.JsonProperty("identity_source_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RoleBindingIdentity_source_type? Identity_source_type { get; set; } = SDKGenerator.RoleBindingIdentity_source_type.VIDM;
    
        /// <summary>Local user's numeric id on the system.</summary>
        [Newtonsoft.Json.JsonProperty("user_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User_id { get; set; }
    
        /// <summary>User/Group's name</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Roles</summary>
        [Newtonsoft.Json.JsonProperty("roles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Role> Roles { get; set; }
    
        /// <summary>Type</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RoleBindingType? Type { get; set; }
    
        /// <summary>Property 'stale' can be considered to have these values - absent  - This type of rolebinding does not support stale property TRUE    - Rolebinding is stale in vIDM meaning the user is no longer present in vIDM FALSE   - Rolebinding is available in vIDM UNKNOWN - Rolebinding's state of staleness in unknown Once rolebindings become stale, they can be deleted using the API POST /aaa/role-bindings?action=delete_stale_bindings</summary>
        [Newtonsoft.Json.JsonProperty("stale", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RoleBindingStale? Stale { get; set; }
    
        /// <summary>The ID of the external identity source that holds the referenced external entity. Currently, only external LDAP and OIDC servers are allowed.</summary>
        [Newtonsoft.Json.JsonProperty("identity_source_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Identity_source_id { get; set; }
    
    
    }
    
    /// <summary>Security features extended by policy operations for securing logical segments.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentSecurityProfile : PolicyConfigResource
    {
        /// <summary>Indicates whether BPDU filter is enabled. BPDU filtering is enabled by default.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bpdu_filter_enable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Bpdu_filter_enable { get; set; } = true;
    
        /// <summary>Enable or disable Router Advertisement Guard.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ra_guard_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Ra_guard_enabled { get; set; } = false;
    
        /// <summary>Filters DHCP server and/or client IPv6 traffic. DHCP server
        /// blocking is enabled and client blocking is disabled by default.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dhcp_client_block_v6_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Dhcp_client_block_v6_enabled { get; set; } = false;
    
        /// <summary>A flag to block all traffic except IP/(G)ARP/BPDU.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("non_ip_traffic_block_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Non_ip_traffic_block_enabled { get; set; } = false;
    
        /// <summary>Pre-defined list of allowed MAC addresses to be excluded from BPDU filtering.
        /// List of allowed MACs - 01:80:c2:00:00:00, 01:80:c2:00:00:01, 01:80:c2:00:00:02, 01:80:c2:00:00:03,
        ///                        01:80:c2:00:00:04, 01:80:c2:00:00:05, 01:80:c2:00:00:06, 01:80:c2:00:00:07,
        ///                        01:80:c2:00:00:08, 01:80:c2:00:00:09, 01:80:c2:00:00:0a, 01:80:c2:00:00:0b,
        ///                        01:80:c2:00:00:0c, 01:80:c2:00:00:0d, 01:80:c2:00:00:0e, 01:80:c2:00:00:0f,
        ///                        00:e0:2b:00:00:00, 00:e0:2b:00:00:04, 00:e0:2b:00:00:06, 01:00:0c:00:00:00,
        ///                        01:00:0c:cc:cc:cc, 01:00:0c:cc:cc:cd, 01:00:0c:cd:cd:cd, 01:00:0c:cc:cc:c0,
        ///                        01:00:0c:cc:cc:c1, 01:00:0c:cc:cc:c2, 01:00:0c:cc:cc:c3, 01:00:0c:cc:cc:c4,
        ///                        01:00:0c:cc:cc:c5, 01:00:0c:cc:cc:c6, 01:00:0c:cc:cc:c7
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bpdu_filter_allow", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(32)]
        public System.Collections.Generic.ICollection<string> Bpdu_filter_allow { get; set; }
    
        /// <summary>Filters DHCP server and/or client traffic. DHCP server
        /// blocking is enabled and client blocking is disabled by default.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dhcp_server_block_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Dhcp_server_block_enabled { get; set; } = true;
    
        /// <summary>Enable or disable Rate Limits
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rate_limits_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Rate_limits_enabled { get; set; } = false;
    
        /// <summary>Allows configuration of rate limits for broadcast and multicast traffic. Rate limiting is disabled by default</summary>
        [Newtonsoft.Json.JsonProperty("rate_limits", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TrafficRateLimits Rate_limits { get; set; }
    
        /// <summary>Filters DHCP server and/or client traffic. DHCP server
        /// blocking is enabled and client blocking is disabled by default.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dhcp_client_block_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Dhcp_client_block_enabled { get; set; } = false;
    
        /// <summary>Filters DHCP server and/or client IPv6 traffic. DHCP server
        /// blocking is enabled and client blocking is disabled by default.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dhcp_server_block_v6_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Dhcp_server_block_v6_enabled { get; set; } = true;
    
    
    }
    
    /// <summary>Child wrapper object for PolicyTransportZone, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyTransportZone : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyTransportZone object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyTransportZone", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyTransportZone PolicyTransportZone { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceflowObservationReceived : TraceflowObservation
    {
        /// <summary>The virtual tunnel endpoint label</summary>
        [Newtonsoft.Json.JsonProperty("vtep_label", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Vtep_label { get; set; }
    
        /// <summary>The name of the uplink the traceflow packet is received on</summary>
        [Newtonsoft.Json.JsonProperty("uplink_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uplink_name { get; set; }
    
        /// <summary>IP address of the destination end of the tunnel</summary>
        [Newtonsoft.Json.JsonProperty("local_ip_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Local_ip_address { get; set; }
    
        /// <summary>IP address of the source end of the tunnel</summary>
        [Newtonsoft.Json.JsonProperty("remote_ip_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Remote_ip_address { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedSecurityGroupListResult : ListResult
    {
        /// <summary>Paged Collection of realized Security Groups</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RealizedSecurityGroup> Results { get; set; }
    
    
    }
    
    /// <summary>IPSec VPN policy traffic statistics
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IpSecVpnPolicyTrafficStatistics 
    {
        /// <summary>Policy path referencing the IPSec VPN Tunnel Interface.</summary>
        [Newtonsoft.Json.JsonProperty("tunnel_interface_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tunnel_interface_path { get; set; }
    
        /// <summary>Aggregate traffic statistics across all IPSec tunnels.</summary>
        [Newtonsoft.Json.JsonProperty("aggregate_traffic_counters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IPSecVpnTrafficCounters Aggregate_traffic_counters { get; set; }
    
        /// <summary>Tunnel statistics.</summary>
        [Newtonsoft.Json.JsonProperty("tunnel_statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IpSecVpnTunnelTrafficStatistics> Tunnel_statistics { get; set; }
    
        /// <summary>Policy path referencing the IPSec VPN Rule.</summary>
        [Newtonsoft.Json.JsonProperty("rule_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rule_path { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of IDS rule statistics</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsRuleStatisticsListResult : ListResult
    {
        /// <summary>IdsRuleStatistics list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IdsRuleStatisticsForEnforcementPoint> Results { get; set; } = new System.Collections.ObjectModel.Collection<IdsRuleStatisticsForEnforcementPoint>();
    
    
    }
    
    /// <summary>This action is used to rewrite header fields of matched HTTP request
    /// messages to specified new values. One action can be used to rewrite one
    /// header field. To rewrite multiple header fields, multiple actions must be
    /// defined.
    /// Captured variables and built-in variables can be used in the header_value
    /// field, header_name field does not support variables.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBHttpRequestHeaderRewriteAction : LBRuleAction
    {
        /// <summary>Value of HTTP request header.</summary>
        [Newtonsoft.Json.JsonProperty("header_value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Header_value { get; set; }
    
        /// <summary>Name of HTTP request header.</summary>
        [Newtonsoft.Json.JsonProperty("header_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Header_name { get; set; }
    
    
    }
    
    /// <summary>Rule statistics for a specfic enforcement point.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RuleStatisticsForEnforcementPoint 
    {
        /// <summary>Rule statistics for a single enforcement point</summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enforcement_point { get; set; }
    
        /// <summary>Statistics for the specified enforcement point</summary>
        [Newtonsoft.Json.JsonProperty("statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RuleStatistics Statistics { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer IpAddrRange object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBIpAddrRange 
    {
        /// <summary>Starting IP address of the range.</summary>
        [Newtonsoft.Json.JsonProperty("begin", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBIpAddr Begin { get; set; } = new ALBIpAddr();
    
        /// <summary>Ending IP address of the range.</summary>
        [Newtonsoft.Json.JsonProperty("end", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBIpAddr End { get; set; } = new ALBIpAddr();
    
    
    }
    
    /// <summary>ErrorPageProfileApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBErrorPageProfileApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of ErrorPageProfile
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBErrorPageProfile> Results { get; set; }
    
    
    }
    
    /// <summary>Paged collection of port mirroring profiles</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PortMirroringProfileListResult : ListResult
    {
        /// <summary>Port Mirroring Profiles list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PortMirroringProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<PortMirroringProfile>();
    
    
    }
    
    /// <summary>Icon to be applied at dashboard for widgets and UI elements.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Icon 
    {
        /// <summary>If specified as PRE, the icon appears before the UI element. If set as POST, the icon appears after the UI element.</summary>
        [Newtonsoft.Json.JsonProperty("placement", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IconPlacement? Placement { get; set; } = SDKGenerator.IconPlacement.PRE;
    
        /// <summary>Icon will be rendered based on its type. For example, if ERROR is chosen, then icon representing error will be rendered.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IconType? Type { get; set; }
    
        /// <summary>Multi-line text to be shown on tooltip while hovering over the icon.</summary>
        [Newtonsoft.Json.JsonProperty("tooltip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Tooltip> Tooltip { get; set; }
    
    
    }
    
    /// <summary>List of same type members to either add or remove from a group.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GroupMemberList 
    {
        /// <summary>This array contains group members of similar types.</summary>
        [Newtonsoft.Json.JsonProperty("members", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(4000)]
        public System.Collections.Generic.ICollection<string> Members { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Ipv6DadProfileListResult : ListResult
    {
        /// <summary>Paginated list of Ipv6DadProfile</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Ipv6DadProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<Ipv6DadProfile>();
    
    
    }
    
    /// <summary>Segment state on specific Enforcement Point.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentConfigurationState : ConfigurationState
    {
        /// <summary>Segment path</summary>
        [Newtonsoft.Json.JsonProperty("segment_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Segment_path { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer L4ConnectionPolicy object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBL4ConnectionPolicy 
    {
        /// <summary>Rules to apply when a new transport connection is setup.</summary>
        [Newtonsoft.Json.JsonProperty("rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBL4Rule> Rules { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VirtualMachine : DiscoveredResource
    {
        /// <summary>Reference of the Host or Public Cloud Gateway that reported the VM</summary>
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceReference Source { get; set; }
    
        /// <summary>Id of the vm unique within the host.</summary>
        [Newtonsoft.Json.JsonProperty("local_id_on_host", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Local_id_on_host { get; set; }
    
        /// <summary>Virtual Machine type; Edge, Service VM or other.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public VirtualMachineType? Type { get; set; }
    
        /// <summary>Guest virtual machine details include OS name, computer name of guest VM. Currently
        /// this is supported for guests on ESXi that have VMware Tools installed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("guest_info", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GuestInfo Guest_info { get; set; }
    
        /// <summary>Current power state of this virtual machine in the system.</summary>
        [Newtonsoft.Json.JsonProperty("power_state", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public VirtualMachinePower_state Power_state { get; set; }
    
        /// <summary>List of external compute ids of the virtual machine in the format 'id-type-key:value' , list of external compute ids ['uuid:xxxx-xxxx-xxxx-xxxx', 'moIdOnHost:moref-11', 'instanceUuid:xxxx-xxxx-xxxx-xxxx']</summary>
        [Newtonsoft.Json.JsonProperty("compute_ids", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Compute_ids { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Id of the host in which this virtual machine exists.</summary>
        [Newtonsoft.Json.JsonProperty("host_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Host_id { get; set; }
    
        /// <summary>Current external id of this virtual machine in the system.</summary>
        [Newtonsoft.Json.JsonProperty("external_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string External_id { get; set; }
    
    
    }
    
    /// <summary>Task properties</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TaskProperties : Resource
    {
        /// <summary>Current status of the task</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TaskPropertiesStatus? Status { get; set; }
    
        /// <summary>True if response for asynchronous request is available</summary>
        [Newtonsoft.Json.JsonProperty("async_response_available", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Async_response_available { get; set; }
    
        /// <summary>Description of the task</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>The start time of the task in epoch milliseconds</summary>
        [Newtonsoft.Json.JsonProperty("start_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Start_time { get; set; }
    
        /// <summary>True if this task can be canceled</summary>
        [Newtonsoft.Json.JsonProperty("cancelable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Cancelable { get; set; }
    
        /// <summary>HTTP request method</summary>
        [Newtonsoft.Json.JsonProperty("request_method", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Request_method { get; set; }
    
        /// <summary>Name of the user who created this task</summary>
        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User { get; set; }
    
        /// <summary>Task progress if known, from 0 to 100</summary>
        [Newtonsoft.Json.JsonProperty("progress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 100D)]
        public long? Progress { get; set; }
    
        /// <summary>A message describing the disposition of the task</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        /// <summary>URI of the method invocation that spawned this task</summary>
        [Newtonsoft.Json.JsonProperty("request_uri", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Request_uri { get; set; }
    
        /// <summary>Identifier for this task</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
        /// <summary>The end time of the task in epoch milliseconds</summary>
        [Newtonsoft.Json.JsonProperty("end_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? End_time { get; set; }
    
    
    }
    
    /// <summary>Consolidated Realized Status Per Enforcement Point.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConsolidatedStatusPerEnforcementPoint : BaseConsolidatedStatusPerEnforcementPoint
    {
    
    }
    
    /// <summary>Active healthchecks are disabled by default and can be enabled for a
    /// server pool by binding a health monitor to the Group through the PolicyLbRule
    /// object. This represents active health monitoring over ICMP.
    /// Active healthchecks are initiated periodically, at a configurable
    /// interval, to each member of the Group. Only if a healthcheck fails
    /// consecutively for a specified number of times (fall_count) to a member will
    /// the member status be marked DOWN. Once a member is DOWN, a specified
    /// number of consecutive successful healt hchecks (rise_count) will bring the
    /// member back to UP state. After a healthcheck is initiated, if it does not
    /// complete within a certain period, then also the healthcheck is considered
    /// to be unsuccessful. Completing a healthcheck within timeout means establishing
    /// a connection (TCP or SSL), if applicable, sending the request and
    /// receiving the response, all within the configured timeout.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IcmpPolicyLbMonitorProfile : PolicyLbMonitorProfile
    {
    
    }
    
    /// <summary>Vrf Route Targets for import/export.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VrfRouteTargets 
    {
        /// <summary>Address family.</summary>
        [Newtonsoft.Json.JsonProperty("address_family", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public VrfRouteTargetsAddress_family? Address_family { get; set; } = SDKGenerator.VrfRouteTargetsAddress_family.L2VPN_EVPN;
    
        /// <summary>Import route targets with format in ASN:&lt;number&gt;.</summary>
        [Newtonsoft.Json.JsonProperty("import_route_targets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Import_route_targets { get; set; }
    
        /// <summary>Export route targets with format in ASN:&lt;number&gt;.</summary>
        [Newtonsoft.Json.JsonProperty("export_route_targets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Export_route_targets { get; set; }
    
    
    }
    
    /// <summary>This entity will be used to establish association between discovery profile and
    /// Group. With this entity, user can specify intent for applying discovery profile
    /// profile to particular Group.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GroupDiscoveryProfileBindingMap : ProfileBindingMap
    {
        /// <summary>Sequence number used to resolve conflicts betweeen two profiles applied on
        /// the same group. Lower sequence number takes higher precedence. Two binding
        /// maps applied to the same profile must have the same sequence number.
        /// User defined sequence numbers range from 1 through 100,000.
        /// System defined sequence numbers range from 100,001 through 200,000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sequence_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 100000D)]
        public long? Sequence_number { get; set; }
    
    
    }
    
    /// <summary>Deployment Template holds the attributes specific to partner for which the service is created. These attributes are opaque to NSX.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DeploymentTemplate 
    {
        /// <summary>List of attributes specific to a partner for which the service is created. There attributes are passed on to the partner appliance and is opaque to the NSX Manager.</summary>
        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<Attribute> Attributes { get; set; }
    
        /// <summary>Deployment Template name.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
    
    }
    
    /// <summary>Describes status of configuration of an entity</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConfigurationStateElement 
    {
        /// <summary>URI of backing resource on sub system</summary>
        [Newtonsoft.Json.JsonProperty("sub_system_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sub_system_address { get; set; }
    
        /// <summary>State of configuration on this sub system</summary>
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConfigurationStateElementState? State { get; set; }
    
        /// <summary>Error code</summary>
        [Newtonsoft.Json.JsonProperty("failure_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Failure_code { get; set; }
    
        /// <summary>Name of backing resource on sub system</summary>
        [Newtonsoft.Json.JsonProperty("sub_system_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sub_system_name { get; set; }
    
        /// <summary>Error message in case of failure</summary>
        [Newtonsoft.Json.JsonProperty("failure_message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Failure_message { get; set; }
    
        /// <summary>Type of backing resource on sub system</summary>
        [Newtonsoft.Json.JsonProperty("sub_system_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sub_system_type { get; set; }
    
        /// <summary>Identifier of backing resource on sub system</summary>
        [Newtonsoft.Json.JsonProperty("sub_system_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sub_system_id { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer PKIProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBPKIProfile : PolicyConfigResource
    {
        /// <summary>Certificate Revocation Lists.</summary>
        [Newtonsoft.Json.JsonProperty("crls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBCRL> Crls { get; set; }
    
        /// <summary>When enabled, Avi will only validate the revocation status
        /// of the leaf certificate using CRL.
        /// To enable validation for the entire chain, disable this
        /// option and provide all the relevant CRLs.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("validate_only_leaf_crl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Validate_only_leaf_crl { get; set; } = true;
    
        /// <summary>List of Certificate Authorities (Root and Intermediate)
        /// trusted that is used for certificate validation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ca_certs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBSSLCertificate> Ca_certs { get; set; }
    
        /// <summary>When enabled, Avi will verify via CRL checks that
        /// certificates in the trust chain have not been revoked.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("crl_check", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Crl_check { get; set; } = true;
    
        /// <summary>When enabled, Avi will not trust Intermediate and Root
        /// certs presented by a client.
        /// Instead, only the chain certs configured in the Certificate
        /// Authority section will be used to verify trust of the
        /// client's cert.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ignore_peer_chain", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Ignore_peer_chain { get; set; } = false;
    
        /// <summary>This field describes the object's replication scope.
        /// If the field is set to false, then the object is visible
        /// within the controller-cluster and its associated
        /// service-engines.
        /// If the field is set to true, then the object is replicated
        /// across the federation.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_federated", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_federated { get; set; } = false;
    
        /// <summary>Creator name.</summary>
        [Newtonsoft.Json.JsonProperty("created_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_by { get; set; }
    
    
    }
    
    /// <summary>Gives the statistics count of a NAT rule.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyNATRuleCounters 
    {
        /// <summary>Gives the total number of packets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("total_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total_packets { get; set; }
    
        /// <summary>Gives the total number of active sessions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("active_sessions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Active_sessions { get; set; }
    
        /// <summary>Gives the total number of bytes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("total_bytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total_bytes { get; set; }
    
    
    }
    
    /// <summary>Peer config per Enforcement Point to configure the other side of the tunnel.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("L2VpnPeerCodes", typeof(L2VpnPeerCodes))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VpnPeerConfigPerEnforcementPoint 
    {
        /// <summary>Policy Path referencing the enforcement point to which the config belongs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enforcement_point_path { get; set; }
    
    
    }
    
    /// <summary>Community list for BGP routing configuration</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CommunityList : PolicyConfigResource
    {
        /// <summary>List of BGP community entries. Both standard and large communities
        /// are supported. Standard community format: aa:nn where aa and nn must
        /// be within the range [1 - 65536]. Large BGP Community format: aa:bb:nn
        /// where aa (Global Administrator), bb  (Local Data Part 1) and nn (Local
        /// Data Part 2) must be within the range [1 - 4294967295]. In additon to
        /// numbered communites (e.g. 3356:2040), predefined communities (NO_EXPORT,
        /// NO_ADVERTISE, NO_EXPORT_SUBCONFED) are supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("communities", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<string> Communities { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AcceptableComponentVersionList 
    {
        /// <summary>Acceptable version whitelist for different components</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<AcceptableComponentVersion> Results { get; set; } = new System.Collections.ObjectModel.Collection<AcceptableComponentVersion>();
    
    
    }
    
    /// <summary>Paged Collection of IPSecVpnService.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnServiceListResult : ListResult
    {
        /// <summary>IPSecVpnService list results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IPSecVpnService> Results { get; set; } = new System.Collections.ObjectModel.Collection<IPSecVpnService>();
    
    
    }
    
    /// <summary>Cluster backup details</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ClusterBackupInfo 
    {
        /// <summary>timestamp of the cluster backup file</summary>
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Timestamp { get; set; }
    
        /// <summary>ID of the node from which the backup was taken</summary>
        [Newtonsoft.Json.JsonProperty("node_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Node_id { get; set; }
    
        /// <summary>IP address or FQDN of the node from which the backup was taken</summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ip_address { get; set; }
    
        /// <summary>Type of restore allowed</summary>
        [Newtonsoft.Json.JsonProperty("restore_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Restore_type> Restore_type { get; set; }
    
    
    }
    
    /// <summary>Represents the Intrusion Detection System settings.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsSettings : PolicyConfigResource
    {
        /// <summary>Parameter to let the user decide whether to update the IDS Signatures
        /// automatically or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("auto_update", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Auto_update { get; set; } = false;
    
        /// <summary>Flag which tells whether IDS was ever enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ids_ever_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Ids_ever_enabled { get; set; }
    
    
    }
    
    /// <summary>Infra space related policy.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Infra : AbstractSpace
    {
        /// <summary>This field is used while creating or updating the infra space.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("domains", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Domain> Domains { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Ipv6NdraProfileListResult : ListResult
    {
        /// <summary>Paginated list of Ipv6NdraProfile</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Ipv6NdraProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<Ipv6NdraProfile>();
    
    
    }
    
    /// <summary>Paged Collection of ForwardingPolicy objects</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ForwardingPolicyListResult : PolicyListResult
    {
        /// <summary>ForwardingPolicy list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ForwardingPolicy> Results { get; set; } = new System.Collections.ObjectModel.Collection<ForwardingPolicy>();
    
    
    }
    
    /// <summary>LBServiceUsage on specific Enforcement Point</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("LBServiceUsage", typeof(LBServiceUsage))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBServiceUsagePerEP : PolicyRuntimeInfoPerEP
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyCapacityUsageResponse : ManagedResource
    {
        /// <summary>List of capacity usage for NSX Objects</summary>
        [Newtonsoft.Json.JsonProperty("capacity_usage", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyCapacityDashboardUsage> Capacity_usage { get; set; } = new System.Collections.ObjectModel.Collection<PolicyCapacityDashboardUsage>();
    
    
    }
    
    /// <summary>Child wrapper for ALBVSDataScriptSet, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBVSDataScriptSet : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBVSDataScriptSet object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBVSDataScriptSet", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBVSDataScriptSet ALBVSDataScriptSet { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for IPFIXL2CollectorProfile, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIPFIXL2CollectorProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual IPFIXL2CollectorProfile object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IPFIXL2CollectorProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IPFIXL2CollectorProfile IPFIXL2CollectorProfile { get; set; }
    
    
    }
    
    /// <summary>A named list of prefixes for routing purposes.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PrefixList : PolicyConfigResource
    {
        /// <summary>Specify ordered list of network prefixes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("prefixes", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<PrefixEntry> Prefixes { get; set; } = new System.Collections.ObjectModel.Collection<PrefixEntry>();
    
    
    }
    
    /// <summary>Information about a single LDAP server endpoint.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdentitySourceLdapServerEndpoint 
    {
        /// <summary>The URL for the LDAP server. Supported URL schemes are LDAP and LDAPS. Either a hostname or an IP address may be given, and the port number is optional and defaults to 389 for the LDAP scheme and 636 for the LDAPS scheme.</summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Url { get; set; }
    
        /// <summary>If set to true, Use the StartTLS extended operation to upgrade
        /// the connection to TLS before sending any sensitive information.
        /// The LDAP server must support the StartTLS extended operation
        /// in order for this protocol to operate correctly. This option
        /// is ignored if the URL scheme is LDAPS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("use_starttls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Use_starttls { get; set; } = false;
    
    
    }
    
    /// <summary>BGP neighbor learned/advertised route details.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BgpNeighborRouteDetailsCsvRecord : CsvRecord
    {
        /// <summary>BGP Multi Exit Discriminator attribute.</summary>
        [Newtonsoft.Json.JsonProperty("med", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Med { get; set; }
    
        /// <summary>CIDR network address.</summary>
        [Newtonsoft.Json.JsonProperty("network", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Network { get; set; }
    
        /// <summary>BGP Weight attribute.</summary>
        [Newtonsoft.Json.JsonProperty("weight", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Weight { get; set; }
    
        /// <summary>Transport node id</summary>
        [Newtonsoft.Json.JsonProperty("transport_node_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_node_id { get; set; }
    
        /// <summary>BGP AS path attribute.</summary>
        [Newtonsoft.Json.JsonProperty("as_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string As_path { get; set; }
    
        /// <summary>Next hop IP address.</summary>
        [Newtonsoft.Json.JsonProperty("next_hop", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Next_hop { get; set; }
    
        /// <summary>Logical router id</summary>
        [Newtonsoft.Json.JsonProperty("logical_router_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Logical_router_id { get; set; }
    
        /// <summary>BGP Local Preference attribute.</summary>
        [Newtonsoft.Json.JsonProperty("local_pref", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Local_pref { get; set; }
    
        /// <summary>BGP neighbor source address.</summary>
        [Newtonsoft.Json.JsonProperty("source_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source_address { get; set; }
    
        /// <summary>BGP neighbor id</summary>
        [Newtonsoft.Json.JsonProperty("neighbor_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Neighbor_id { get; set; }
    
        /// <summary>BGP neighbor peer IP address.</summary>
        [Newtonsoft.Json.JsonProperty("neighbor_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Neighbor_address { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer CookieMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBCookieMatch 
    {
        /// <summary>Case sensitivity to use for the match.
        /// Enum options - SENSITIVE, INSENSITIVE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as INSENSITIVE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_case", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBCookieMatchMatch_case? Match_case { get; set; } = SDKGenerator.ALBCookieMatchMatch_case.INSENSITIVE;
    
        /// <summary>Name of the cookie.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>String value in the cookie.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }
    
        /// <summary>Criterion to use for matching the cookie in the HTTP
        /// request.
        /// Enum options - HDR_EXISTS, HDR_DOES_NOT_EXIST,
        /// HDR_BEGINS_WITH, HDR_DOES_NOT_BEGIN_WITH, HDR_CONTAINS,
        /// HDR_DOES_NOT_CONTAIN, HDR_ENDS_WITH, HDR_DOES_NOT_END_WITH,
        /// HDR_EQUALS, HDR_DOES_NOT_EQUAL.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBCookieMatchMatch_criteria Match_criteria { get; set; }
    
    
    }
    
    /// <summary>Paged collection of Firewall CPU Memory Thresholds Profile Binding Maps</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyFirewallCPUMemThresholdsProfileBindingMapListResult : ListResult
    {
        /// <summary>Firewall CPU Memory Thresholds Profile Binding Map list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyFirewallCPUMemThresholdsProfileBindingMap> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyFirewallCPUMemThresholdsProfileBindingMap>();
    
    
    }
    
    /// <summary>Domain.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Domain : PolicyConfigResource
    {
    
    }
    
    /// <summary>DnsPolicyApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsPolicyApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of DnsPolicy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDnsPolicy> Results { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HTTPHdrValue object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPHdrValue 
    {
        /// <summary>Variable.
        /// Enum options - HTTP_POLICY_VAR_CLIENT_IP,
        /// HTTP_POLICY_VAR_VS_PORT, HTTP_POLICY_VAR_VS_IP,
        /// HTTP_POLICY_VAR_HTTP_HDR,
        /// HTTP_POLICY_VAR_SSL_CLIENT_FINGERPRINT,
        /// HTTP_POLICY_VAR_SSL_CLIENT_SERIAL,
        /// HTTP_POLICY_VAR_SSL_CLIENT_ISSUER,
        /// HTTP_POLICY_VAR_SSL_CLIENT_SUBJECT,
        /// HTTP_POLICY_VAR_SSL_CLIENT_RAW,
        /// HTTP_POLICY_VAR_SSL_PROTOCOL,
        /// HTTP_POLICY_VAR_SSL_SERVER_NAME, HTTP_POLICY_VAR_USER_NAME,
        /// HTTP_POLICY_VAR_SSL_CIPHER, HTTP_POLICY_VAR_REQUEST_ID.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("var", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHTTPHdrValueVar? Var { get; set; }
    
        /// <summary>HTTP header value or variable representing an HTTP header.</summary>
        [Newtonsoft.Json.JsonProperty("val", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Val { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FederationNodeSummary : Resource
    {
        /// <summary>Number of nodes of the type and at the component version.</summary>
        [Newtonsoft.Json.JsonProperty("node_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Node_count { get; set; }
    
        /// <summary>Component version</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }
    
    
    }
    
    /// <summary>Global Manager.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GlobalManager : PolicyConfigResource
    {
        /// <summary>Fail onboarding if maximum RTT exceeded.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fail_if_rtt_exceeded", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Fail_if_rtt_exceeded { get; set; } = true;
    
        /// <summary>Internally generated UUID to the federation of Global Manager.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("federation_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Federation_id { get; set; }
    
        /// <summary>There can be at most one ACTIVE global manager and one STANDBY global manager.
        /// In order to add a STANDBY manager, there must be an ACTIVE manager defined.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public GlobalManagerMode Mode { get; set; }
    
        /// <summary>To create a standby GM, the connection information (username, password,
        /// and API thumbprint) for at least one NSX manager node in the remote
        /// site must be provided. Once the GM has been successfully onboarded,
        /// the connection_info is discarded and authentication to the
        /// standby GM occurs using an X.509 client certificate.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("connection_info", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(3)]
        public System.Collections.Generic.ICollection<SiteNodeConnectionInfo> Connection_info { get; set; }
    
        /// <summary>If provided and fail_if_rtt_exceeded is true, onboarding of the site will
        /// fail if measured RTT is greater than this value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maximum_rtt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 1000D)]
        public long? Maximum_rtt { get; set; } = 250L;
    
        /// <summary>UUID of the site where Global manager is running. This is the
        /// Site Manager generated UUID for every NSX deployment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("site_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Site_id { get; set; }
    
    
    }
    
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("BinaryPacketData", typeof(BinaryPacketData))]
    [JsonInheritanceAttribute("FieldsPacketData", typeof(FieldsPacketData))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PacketData 
    {
        /// <summary>A flag, when set true, indicates that the traceflow packet is of L3 routing.</summary>
        [Newtonsoft.Json.JsonProperty("routed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Routed { get; set; }
    
        /// <summary>transport type of the traceflow packet</summary>
        [Newtonsoft.Json.JsonProperty("transport_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PacketDataTransport_type? Transport_type { get; set; } = SDKGenerator.PacketDataTransport_type.UNICAST;
    
        /// <summary>If the requested frame_size is too small (given the payload and traceflow metadata requirement of 16 bytes), the traceflow request will fail with an appropriate message.  The frame will be zero padded to the requested size.</summary>
        [Newtonsoft.Json.JsonProperty("frame_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(60D, 1000D)]
        public long? Frame_size { get; set; } = 128L;
    
    
    }
    
    /// <summary>Paged Collection of LBVirtualServerStatisticsPerEP</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregateLBVirtualServerStatistics : AggregatePolicyRuntimeInfo
    {
        /// <summary>LBVirtualServerStatisticsPerEP list results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBVirtualServerStatisticsPerEP> Results { get; set; }
    
    
    }
    
    /// <summary>List result of PolicyContextProfiles</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyContextProfileListResult : ListResult
    {
        /// <summary>Paged collection of PolicyContextProfiles</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyContextProfile> Results { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LogicalRouterPortStatisticsSummary : AggregatedLogicalRouterPortCounters
    {
        /// <summary>The ID of the logical router port</summary>
        [Newtonsoft.Json.JsonProperty("logical_router_port_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Logical_router_port_id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OspfDatabaseStatus 
    {
        /// <summary>array of nssa external link of OSPF database</summary>
        [Newtonsoft.Json.JsonProperty("nssa_external_link_states", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MpOspfExternalLinkState> Nssa_external_link_states { get; set; }
    
        /// <summary>array of external link of OSPF database</summary>
        [Newtonsoft.Json.JsonProperty("external_link_states", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MpOspfExternalLinkState> External_link_states { get; set; }
    
        /// <summary>OSPF area id to filter the the OSPF database.</summary>
        [Newtonsoft.Json.JsonProperty("area_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Area_id { get; set; }
    
        /// <summary>array of link state of OSPF database</summary>
        [Newtonsoft.Json.JsonProperty("router_link_states", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MpOspfRouterLinkStates> Router_link_states { get; set; }
    
        /// <summary>array of network link state of OSPF database</summary>
        [Newtonsoft.Json.JsonProperty("net_link_states", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MpOspfNetworkLinkStates> Net_link_states { get; set; }
    
        /// <summary>array of summary link state of OSPF database</summary>
        [Newtonsoft.Json.JsonProperty("summary_link_states", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MpOspfSummaryLinkStates> Summary_link_states { get; set; }
    
        /// <summary>array of ASBR summary link state of OSPF database</summary>
        [Newtonsoft.Json.JsonProperty("asbr_summary_link_states", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MpOspfSummaryLinkStates> Asbr_summary_link_states { get; set; }
    
        /// <summary>Policy path to edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Edge_path { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of L2VPNSession</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VPNSessionListResult : ListResult
    {
        /// <summary>L2VPNSession list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<L2VPNSession> Results { get; set; } = new System.Collections.ObjectModel.Collection<L2VPNSession>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class InterfaceArpProxy : ListResult
    {
        /// <summary>Array of ARP proxy table entries</summary>
        [Newtonsoft.Json.JsonProperty("arp_proxy_entries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyArpProxyEntry> Arp_proxy_entries { get; set; }
    
        /// <summary>Policy path of gateway interface</summary>
        [Newtonsoft.Json.JsonProperty("interface_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Interface_path { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HTTPSecurityAction object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPSecurityAction 
    {
        /// <summary>Type of the security action to perform.
        /// Enum options - HTTP_SECURITY_ACTION_CLOSE_CONN,
        /// HTTP_SECURITY_ACTION_SEND_RESPONSE,
        /// HTTP_SECURITY_ACTION_ALLOW,
        /// HTTP_SECURITY_ACTION_REDIRECT_TO_HTTPS,
        /// HTTP_SECURITY_ACTION_RATE_LIMIT,
        /// HTTP_SECURITY_ACTION_REQUEST_CHECK_ICAP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHTTPSecurityActionAction Action { get; set; }
    
        /// <summary>HTTP status code to use for local response.
        /// Enum options - HTTP_LOCAL_RESPONSE_STATUS_CODE_200,
        /// HTTP_LOCAL_RESPONSE_STATUS_CODE_204,
        /// HTTP_LOCAL_RESPONSE_STATUS_CODE_403,
        /// HTTP_LOCAL_RESPONSE_STATUS_CODE_404,
        /// HTTP_LOCAL_RESPONSE_STATUS_CODE_429,
        /// HTTP_LOCAL_RESPONSE_STATUS_CODE_501.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHTTPSecurityActionStatus_code? Status_code { get; set; }
    
        /// <summary>Rate limiting configuration for this action.</summary>
        [Newtonsoft.Json.JsonProperty("rate_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPSecurityActionRateProfile Rate_profile { get; set; }
    
        /// <summary>Secure SSL/TLS port to redirect the HTTP request to.
        /// Allowed values are 1-65535.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("https_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long? Https_port { get; set; }
    
        /// <summary>File to be used for generating HTTP local response.</summary>
        [Newtonsoft.Json.JsonProperty("file", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPLocalFile File { get; set; }
    
    
    }
    
    /// <summary>All the types of PolicyLbMonitorProfile extend from this abstract class.
    /// This is present for extensibility.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("HttpPolicyLbMonitorProfile", typeof(HttpPolicyLbMonitorProfile))]
    [JsonInheritanceAttribute("UdpPolicyLbMonitorProfile", typeof(UdpPolicyLbMonitorProfile))]
    [JsonInheritanceAttribute("TcpPolicyLbMonitorProfile", typeof(TcpPolicyLbMonitorProfile))]
    [JsonInheritanceAttribute("HttpsPolicyLbMonitorProfile", typeof(HttpsPolicyLbMonitorProfile))]
    [JsonInheritanceAttribute("IcmpPolicyLbMonitorProfile", typeof(IcmpPolicyLbMonitorProfile))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyLbMonitorProfile : PolicyConfigResource
    {
        /// <summary>Typically, monitors perform healthchecks to Group members using the
        /// member IP address and pool_port.
        /// However, in some cases, customers prefer to run healthchecks against a
        /// different port than the pool member port which handles actual
        /// application traffic. In such cases, the port to run healthchecks
        /// against can be specified in the monitor_port value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("monitor_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Monitor_port { get; set; }
    
        /// <summary>Timeout specified in seconds.  After a healthcheck is initiated, if it
        /// does not complete within a certain period, then also the healthcheck
        /// is considered to be unsuccessful. Completing a healthcheck within
        /// timeout means establishing a connection (TCP or SSL), if applicable,
        /// sending the request and receiving the response, all within the
        /// configured timeout.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Timeout { get; set; } = 15L;
    
        /// <summary>Only if a healthcheck fails consecutively for a specified number of
        /// times, given with fall_count, to a member will the member status be
        /// marked DOWN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fall_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Fall_count { get; set; } = 3L;
    
        /// <summary>Active healthchecks are initiated periodically, at a configurable
        /// interval (in seconds), to each member of the Group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Interval { get; set; } = 5L;
    
        /// <summary>Once a member is DOWN, a specified number of consecutive successful
        /// healthchecks specified by rise_count will bring the member back to UP
        /// state.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rise_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Rise_count { get; set; } = 3L;
    
    
    }
    
    /// <summary>Logical grouping of enforcement points.
    /// This is a deprecated type. DeploymentZone has been renamed to Site.
    /// Use Site.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DeploymentZone : PolicyConfigResource
    {
        /// <summary>Logical grouping of enforcement points</summary>
        [Newtonsoft.Json.JsonProperty("enforcement_points", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<EnforcementPoint> Enforcement_points { get; set; }
    
    
    }
    
    /// <summary>Index for cross site allocation for edge cluster
    /// and its members referred by gateway.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SiteAllocationIndexForEdge 
    {
        /// <summary>Unqiue edge cluster node index across sites based on stretch of the
        /// Gateway. For example, if a Gateway is streched to sites S1 with one
        /// edge cluster of 3 nodes and site S2 with one edge cluster of 2 nodes,
        /// the in the Global Manager will allocate the index for 5 edge nodes
        /// and 2 cluster in the rage 0 to 7.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Index { get; set; }
    
        /// <summary>Edge cluster or edge node path</summary>
        [Newtonsoft.Json.JsonProperty("target_resource_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Target_resource_path { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyComplianceStatus 
    {
        /// <summary>Timestamp of last update</summary>
        [Newtonsoft.Json.JsonProperty("last_updated_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_updated_time { get; set; }
    
        /// <summary>List of non compliant configuration and impacted services</summary>
        [Newtonsoft.Json.JsonProperty("non_compliant_configs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyNonCompliantConfig> Non_compliant_configs { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PimRpMappingsInCsvFormat : CsvListResult
    {
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PimRpMappingCsvRecord> Results { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of BfdProfile.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BfdProfileListResult : ListResult
    {
        /// <summary>Bfd Profile list results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<BfdProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<BfdProfile>();
    
    
    }
    
    /// <summary>Parameters to let the admin specify a relative position of a communication
    /// map or communication entry w.r.t to another one.
    /// This type is deprecated. Use the type RuleInsertParameters instead.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CommunicationInsertParameters 
    {
        /// <summary>The communication map/communication entry path if operation is
        /// 'insert_after' or 'insert_before'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("anchor_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Anchor_path { get; set; }
    
        /// <summary>Operation</summary>
        [Newtonsoft.Json.JsonProperty("operation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CommunicationInsertParametersOperation? Operation { get; set; } = SDKGenerator.CommunicationInsertParametersOperation.Insert_top;
    
    
    }
    
    /// <summary>Collection of Vni Pool Configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VniPoolConfigListResult : ListResult
    {
        /// <summary>Vni Pool Config list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<VniPoolConfig> Results { get; set; } = new System.Collections.ObjectModel.Collection<VniPoolConfig>();
    
    
    }
    
    /// <summary>Displayed as a single number. It can be used to show the characteristics of entities such as Logical Switches, Firewall Rules, and so on. For example, number of logical switches and their admin states.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class StatItem 
    {
        /// <summary>Id of drilldown widget, if any. Id should be a valid id of an existing widget.</summary>
        [Newtonsoft.Json.JsonProperty("drilldown_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Drilldown_id { get; set; }
    
        /// <summary>If expression for total is specified, it evaluates it. Total can be omitted if not needed to be shown.</summary>
        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Total { get; set; }
    
        /// <summary>Multi-line text to be shown on tooltip while hovering over the stat.</summary>
        [Newtonsoft.Json.JsonProperty("tooltip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Tooltip> Tooltip { get; set; }
    
        /// <summary>Expression for stat to be displayed.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Value { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for GlobalConfig, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildGlobalConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual GlobalConfig object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("GlobalConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public GlobalConfig GlobalConfig { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer TCPFastPathProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBTCPFastPathProfile 
    {
        /// <summary>DSR profile information.</summary>
        [Newtonsoft.Json.JsonProperty("dsr_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBDsrProfile Dsr_profile { get; set; }
    
        /// <summary>When enabled, Avi will complete the 3-way handshake with
        /// the client before forwarding any packets to the server.
        /// This will protect the server from SYN flood and half open
        /// SYN connections.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_syn_protection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_syn_protection { get; set; } = false;
    
        /// <summary>The amount of time (in sec) for which a connection needs to
        /// be idle before it is eligible to be deleted.
        /// Allowed values are 5-14400.
        /// Special values are 0 - 'infinite'.
        /// Unit is SEC.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 300.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("session_idle_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 14400D)]
        public long? Session_idle_timeout { get; set; } = 300L;
    
    
    }
    
    /// <summary>Advanced load balancer DnsTxtRdata object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsTxtRdata 
    {
        /// <summary>Text data associated with the FQDN.</summary>
        [Newtonsoft.Json.JsonProperty("text_str", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Text_str { get; set; }
    
    
    }
    
    /// <summary>Credential info to connect to an NSX-T type of enforcement point.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class NSXTConnectionInfo : EnforcementPointConnectionInfo
    {
        /// <summary>Username.</summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Username { get; set; }
    
        /// <summary>Transport Zone UUIDs on enforcement point. Transport zone information is
        /// required for creating logical L2, L3 constructs on enforcement point.
        /// Max 1 transport zone ID.
        /// This is a deprecated property. The transport zone id is now auto
        /// populated from enforcement point and its value can be read using APIs
        /// GET /infra/sites/site-id/enforcement-points/enforcementpoint-id/transport-zones and
        /// GET /infra/sites/site-id/enforcement-points/enforcementpoint-id/transport-zones/transport-zone-id.
        /// The value passed through this property will be ignored.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transport_zone_ids", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Transport_zone_ids { get; set; }
    
        /// <summary>Password.</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Password { get; set; }
    
        /// <summary>Edge Cluster UUIDs on enforcement point. Edge cluster information is
        /// required for creating logical L2, L3 constructs on enforcement point.
        /// Max 1 edge cluster ID.
        /// This is a deprecated property. The edge cluster id is now auto
        /// populated from enforcement point and its value can be read using APIs
        /// GET /infra/sites/site-id/enforcement-points/enforcementpoint-id/edge-clusters and
        /// GET /infra/sites/site-id/enforcement-points/enforcementpoint-1/edge-clusters/edge-cluster-id.
        /// The value passed through this property will be ignored.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_cluster_ids", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Edge_cluster_ids { get; set; }
    
        /// <summary>Thumbprint of EnforcementPoint in the form of a SHA-256 hash represented in lower case HEX.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thumbprint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Thumbprint { get; set; }
    
    
    }
    
    /// <summary>DHCP option 121 to define classless static route.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DhcpOption121 
    {
        /// <summary>Classless static route of DHCP option 121.</summary>
        [Newtonsoft.Json.JsonProperty("static_routes", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(27)]
        public System.Collections.Generic.ICollection<ClasslessStaticRoute> Static_routes { get; set; } = new System.Collections.ObjectModel.Collection<ClasslessStaticRoute>();
    
    
    }
    
    /// <summary>Advanced load balancer SSOPolicy object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSSOPolicy : PolicyConfigResource
    {
        /// <summary>Authorization Policy Settings.</summary>
        [Newtonsoft.Json.JsonProperty("authorization_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBAuthorizationPolicy Authorization_policy { get; set; }
    
        /// <summary>SSO Policy Type.
        /// Enum options - SSO_TYPE_SAML, SSO_TYPE_PINGACCESS,
        /// SSO_TYPE_JWT.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as SSO_TYPE_SAML.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBSSOPolicyType? Type { get; set; } = SDKGenerator.ALBSSOPolicyType.SSO_TYPE_SAML;
    
        /// <summary>Authentication Policy Settings.</summary>
        [Newtonsoft.Json.JsonProperty("authentication_policy", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBAuthenticationPolicy Authentication_policy { get; set; } = new ALBAuthenticationPolicy();
    
    
    }
    
    /// <summary>Attribute specific to a partner. There attributes are passed on to the partner appliance and is opaque to the NSX Manager. The Attributes used by the partner applicance.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Attribute 
    {
        /// <summary>Read only Attribute cannot be overdidden by service instance/deployment.</summary>
        [Newtonsoft.Json.JsonProperty("read_only", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Read_only { get; set; } = false;
    
        /// <summary>Attribute Type can be of any of the allowed enum type.</summary>
        [Newtonsoft.Json.JsonProperty("attribute_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Attribute_type? Attribute_type { get; set; }
    
        /// <summary>Attribute display name string value.</summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Display_name { get; set; }
    
        /// <summary>Attribute value string value.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }
    
        /// <summary>Attribute key string value.</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }
    
    
    }
    
    /// <summary>Base class for resources that are discovered and automatically updated</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("VirtualMachine", typeof(VirtualMachine))]
    [JsonInheritanceAttribute("VirtualNetworkInterface", typeof(VirtualNetworkInterface))]
    [JsonInheritanceAttribute("ContainerIngressPolicy", typeof(ContainerIngressPolicy))]
    [JsonInheritanceAttribute("DistributedVirtualSwitch", typeof(DistributedVirtualSwitch))]
    [JsonInheritanceAttribute("VirtualSwitch", typeof(VirtualSwitch))]
    [JsonInheritanceAttribute("DiscoveredNode", typeof(DiscoveredNode))]
    [JsonInheritanceAttribute("DistributedVirtualPortgroup", typeof(DistributedVirtualPortgroup))]
    [JsonInheritanceAttribute("VirtualPortgroup", typeof(VirtualPortgroup))]
    [JsonInheritanceAttribute("ContainerNetworkPolicy", typeof(ContainerNetworkPolicy))]
    [JsonInheritanceAttribute("VmToolsInfo", typeof(VmToolsInfo))]
    [JsonInheritanceAttribute("ContainerApplication", typeof(ContainerApplication))]
    [JsonInheritanceAttribute("ContainerApplicationInstance", typeof(ContainerApplicationInstance))]
    [JsonInheritanceAttribute("ContainerClusterNode", typeof(ContainerClusterNode))]
    [JsonInheritanceAttribute("ContainerProject", typeof(ContainerProject))]
    [JsonInheritanceAttribute("ContainerCluster", typeof(ContainerCluster))]
    [JsonInheritanceAttribute("ComputeCollection", typeof(ComputeCollection))]
    [JsonInheritanceAttribute("CloudNativeServiceInstance", typeof(CloudNativeServiceInstance))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DiscoveredResource : Resource
    {
        /// <summary>Timestamp of last modification</summary>
        [Newtonsoft.Json.JsonProperty("_last_sync_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? _last_sync_time { get; set; }
    
        /// <summary>Defaults to ID if not set</summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string Display_name { get; set; }
    
        /// <summary>Description of this resource</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Description { get; set; }
    
        /// <summary>Opaque identifiers meaningful to the API user</summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(30)]
        public System.Collections.Generic.ICollection<Tag> Tags { get; set; }
    
    
    }
    
    /// <summary>It represents the version information corresponding to which the
    /// signatures will be available.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsSignatureVersion : PolicyConfigResource
    {
        /// <summary>This flag tells the status of the signatures under a version.
        /// OUTDATED: It means the signatures under this version are outdated and new version is available.
        /// LATEST: It means the signatures of this version are up to date.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IdsSignatureVersionStatus? Status { get; set; }
    
        /// <summary>Represents the version's change log.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("change_log", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Change_log { get; set; }
    
        /// <summary>Time when this version was downloaded and saved.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("update_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Update_time { get; set; }
    
        /// <summary>Flag which tells whether the Signature version is uploaded by user or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("user_uploaded", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? User_uploaded { get; set; }
    
        /// <summary>This flag tells which Version is currently active.
        /// ACTIVE: It means the signatures under this version is currently been used
        ///  under IDS Profiles.
        /// NOTACTIVE: It means signatures of this version are available but not
        ///  being used in IDS Profiles.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IdsSignatureVersionState? State { get; set; }
    
        /// <summary>Represents the version id.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version_id { get; set; }
    
    
    }
    
    /// <summary>Paged collection of Tier-0 Deployment Map.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier0DeploymentMapListResult : ListResult
    {
        /// <summary>Tier-0 Deployment Maps.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Tier0DeploymentMap> Results { get; set; } = new System.Collections.ObjectModel.Collection<Tier0DeploymentMap>();
    
    
    }
    
    /// <summary>Advanced load balancer HdrMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHdrMatch 
    {
        /// <summary>Case sensitivity to use for the match.
        /// Enum options - SENSITIVE, INSENSITIVE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as INSENSITIVE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_case", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHdrMatchMatch_case? Match_case { get; set; } = SDKGenerator.ALBHdrMatchMatch_case.INSENSITIVE;
    
        /// <summary>Name of the HTTP header whose value is to be matched.</summary>
        [Newtonsoft.Json.JsonProperty("hdr", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Hdr { get; set; }
    
        /// <summary>String values to match in the HTTP header.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Value { get; set; }
    
        /// <summary>Criterion to use for matching headers in the HTTP request.
        /// Enum options - HDR_EXISTS, HDR_DOES_NOT_EXIST,
        /// HDR_BEGINS_WITH, HDR_DOES_NOT_BEGIN_WITH, HDR_CONTAINS,
        /// HDR_DOES_NOT_CONTAIN, HDR_ENDS_WITH, HDR_DOES_NOT_END_WITH,
        /// HDR_EQUALS, HDR_DOES_NOT_EQUAL.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHdrMatchMatch_criteria Match_criteria { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for IPDiscoveryProfile, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIPDiscoveryProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual IPDiscoveryProfile object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IPDiscoveryProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IPDiscoveryProfile IPDiscoveryProfile { get; set; }
    
    
    }
    
    /// <summary>SecurityPolicyApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSecurityPolicyApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of SecurityPolicy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBSecurityPolicy> Results { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for Ipv6NdraProfile, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIpv6NdraProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual Ipv6NdraProfile objects
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Ipv6NdraProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Ipv6NdraProfile Ipv6NdraProfile { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsAttack object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsAttack 
    {
        /// <summary>Threshold, in terms of DNS packet per second, for the DNS
        /// attack vector.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("threshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Threshold { get; set; }
    
        /// <summary>Time in minutes after which mitigation will be deactivated.
        /// Allowed values are 1-4294967295.
        /// Special values are 0- 'blocked for ever'.
        /// Unit is MIN.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 60.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_mitigation_age", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? Max_mitigation_age { get; set; } = 60L;
    
        /// <summary>Mitigation action to perform for this DNS attack vector.</summary>
        [Newtonsoft.Json.JsonProperty("mitigation_action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBAttackMitigationAction Mitigation_action { get; set; }
    
        /// <summary>Enable or disable the mitigation of the attack vector.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
        /// <summary>The DNS attack vector.
        /// Enum options - DNS_REFLECTION, DNS_NXDOMAIN,
        /// DNS_AMPLIFICATION_EGRESS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("attack_vector", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBDnsAttackAttack_vector Attack_vector { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for BfdProfile, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildBfdProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual BfdProfile object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("BfdProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BfdProfile BfdProfile { get; set; }
    
    
    }
    
    /// <summary>Segment extra config is intended for supporting vendor specific configuration on the
    /// data path, it can be set as key value string pairs on either segment or segment port.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentExtraConfig 
    {
        /// <summary>Key value pair in string for the configuration</summary>
        [Newtonsoft.Json.JsonProperty("config_pair", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public UnboundedKeyValuePair Config_pair { get; set; } = new UnboundedKeyValuePair();
    
    
    }
    
    /// <summary>OSPF summary link state details.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MpOspfSummaryLinkStates 
    {
        /// <summary>LSA age</summary>
        [Newtonsoft.Json.JsonProperty("up_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Up_time { get; set; }
    
        /// <summary>Sequence number</summary>
        [Newtonsoft.Json.JsonProperty("sequence_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sequence_number { get; set; }
    
        /// <summary>OSPF advertised router</summary>
        [Newtonsoft.Json.JsonProperty("advertised_router", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Advertised_router { get; set; }
    
        /// <summary>OSPF link id</summary>
        [Newtonsoft.Json.JsonProperty("link_state_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Link_state_id { get; set; }
    
        /// <summary>Cost of the route</summary>
        [Newtonsoft.Json.JsonProperty("checksum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Checksum { get; set; }
    
        /// <summary>OSPF summary address</summary>
        [Newtonsoft.Json.JsonProperty("summary_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Summary_address { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of LBServiceStatusPerEP</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregateLBServiceStatus : AggregatePolicyRuntimeInfo
    {
        /// <summary>LBServiceStatusPerEP list results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBServiceStatusPerEP> Results { get; set; }
    
    
    }
    
    /// <summary>This contains fields that captures state of Trackable entities.
    /// Edge and VPN state entities extend this object.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EdgeConfigurationState : ConfigurationState
    {
        /// <summary>Request identifier of the API which modified the entity.</summary>
        [Newtonsoft.Json.JsonProperty("pending_change_list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Pending_change_list { get; set; }
    
    
    }
    
    /// <summary>This entity will be used to establish association between discovery
    /// profile and Port. Using this entity, user can specify intent for applying
    /// discovery profile to particular Port. Port here is Logical Port.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PortDiscoveryProfileBindingMap : DiscoveryProfileBindingMap
    {
        /// <summary>PolicyPath of associated IP Discovery Profile</summary>
        [Newtonsoft.Json.JsonProperty("ip_discovery_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ip_discovery_profile_path { get; set; }
    
        /// <summary>PolicyPath of associated Mac Discovery Profile</summary>
        [Newtonsoft.Json.JsonProperty("mac_discovery_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Mac_discovery_profile_path { get; set; }
    
    
    }
    
    /// <summary>Global configuration</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GlobalConfig : PolicyConfigResource
    {
        /// <summary>Global configuration of maximum number of ARP entries per transport
        /// node at each Tier0/Tier1 gateway.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("arp_limit_per_gateway", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(5000D, 50000D)]
        public long? Arp_limit_per_gateway { get; set; }
    
        /// <summary>This value defines the upper threshold for the Maximum Transmission Unit (MTU) value that can be configured at a physical uplink level or a logical routing uplink level in a NSX domain. All Uplink profiles validate against this value so that the MTU specified in an Uplink profile does not exceed this global upper threshold. Similarly, when this value is modified, the new value must be greater than or equal to any existing Uplink profile's MTU.</summary>
        [Newtonsoft.Json.JsonProperty("uplink_mtu_threshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Uplink_mtu_threshold { get; set; } = 9000L;
    
        /// <summary>Contains the FIPSGlobalConfig object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fips", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FIPSGlobalConfig Fips { get; set; }
    
        /// <summary>Configure forwarding mode for routing. This setting does not
        /// restrict configuration for other modes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("l3_forwarding_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public GlobalConfigL3_forwarding_mode? L3_forwarding_mode { get; set; } = SDKGenerator.GlobalConfigL3_forwarding_mode.IPV4_ONLY;
    
        /// <summary>This is the global default MAC address for all VDRs in all transport nodes in a NSX system. It can be changed only when there is no transport node in the NSX system. This value cannot be same as vdr_mac_nested. When the property "allow_changing_vdr_mac_in_use" is false, it can not be changed if the current VDR MAC is being used by any transport node. A transport node uses this VDR MAC if any host switch in the node is in OVERLAY transport zone(s) but none of the transport zone(s) has "nested_nsx" property being true.</summary>
        [Newtonsoft.Json.JsonProperty("vdr_mac", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Vdr_mac { get; set; } = "02:50:56:56:44:52";
    
        /// <summary>This is the global default MAC address for all VDRs in all transport nodes in a NSX system nested in another NSX system. It can be changed only when there is no transport node in the NSX system. All transport zones in such a nested NSX system will have the "nested_nsx" property being true so that all transport nodes will use this MAC for the VDR ports to avoid conflict with the VDR MAC in the outer NSX system. When the property "allow_changing_vdr_mac_in_use" is false, it can not be changed if the current VDR MAC is being used by any transport node in a nested NSX environment. A transport node uses this VDR MAC if any host switch in the node is in an OVERLAY transport zone whose "nested_nsx" property is true.</summary>
        [Newtonsoft.Json.JsonProperty("vdr_mac_nested", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Vdr_mac_nested { get; set; } = "02:50:56:56:44:53";
    
        /// <summary>When this flag is set to true, it is allowed to change the VDR MAC being used by existing transport nodes in a NSX system. The VDR MAC used by a host switch in a transport node is decided by the OVERLAY transport zone(s) which the host switch joins. If any of the OVERLAY transport zone(s) has "nested_nsx" property set to true, the MAC in "vdr_mac_nested" is used; otherwise the MAC in "vdr_mac" is used. Thus the VDR MAC being used by a host switch in a transport node can be changed in below ways. If the host switch is not in any OVERLAY transport zone whose "nested_nsx" property is true but is in an OVERLAY transport zone, the first way is updating the "vdr_mac" property. The 2nd way is updating one of the OVERLAY tranport zones joined by the host switch to set "nested_nsx" property true which will make the host switch use the VDR MAC in "vdr_mac_nested". The third way is directly updating the transport node to add an OVERLAY transport zone whose "nested_nsx" property is true into the host switch which will also make the host switch use the VDR MAC in "vdr_mac_nested". If the host switch is in some OVERLAY transport zone(s) whose "nested_nsx" property is true, the first way is updating the "vdr_mac_nested" property. The 2nd way is updating all those OVERLAY tranport zones to set "nested_nsx" property false which will make the host switch use the VDR MAC in "vdr_mac". The third way is directly updating the transport node to remove all those OVERLAY transport zones from the host switch which will also make the host switch use the VDR MAC in "vdr_mac". Please note that changing the VDR MAC being used by existing transport nodes will most likely cause traffic disruption and network outage!</summary>
        [Newtonsoft.Json.JsonProperty("allow_changing_vdr_mac_in_use", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Allow_changing_vdr_mac_in_use { get; set; } = false;
    
        /// <summary>The operation collector is defined to receive stats from hosts.
        /// The VRNI and WAVE_FRONT collector type can be defined to collect the metric data.
        /// The WAVE_FRONT collector type can only be used in VMC mode.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("operation_collectors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<GlobalCollectorConfig> Operation_collectors { get; set; }
    
        /// <summary>Maximum transmission unit (MTU) specifies the size of the largest
        /// packet that a network protocol can transmit.
        /// This is the global default MTU for all the EXTERNAL (uplink) and
        /// SERVICE (CSP) interfaces in the NSX domain. There is no option to
        /// override this value at the transport zone level or transport node
        /// level.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mtu", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1280D, int.MaxValue)]
        public long? Mtu { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PlainFilterData : LiveTraceFilterData
    {
        /// <summary>Extended RCF rule for packet filter</summary>
        [Newtonsoft.Json.JsonProperty("extend_filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Extend_filter { get; set; }
    
        /// <summary>Basic RCF rule for packet filter</summary>
        [Newtonsoft.Json.JsonProperty("basic_filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Basic_filter { get; set; }
    
    
    }
    
    /// <summary>Paged collection of IDS signature versions</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsSignatureVersionListResult : ListResult
    {
        /// <summary>IDS signature version list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IdsSignatureVersion> Results { get; set; } = new System.Collections.ObjectModel.Collection<IdsSignatureVersion>();
    
    
    }
    
    /// <summary>This action is performed in HTTP response rewrite phase. It is used to
    /// learn the value of variable from the HTTP response, and insert an entry
    /// into the persistence table if the entry doesn't exist.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBVariablePersistenceLearnAction : LBRuleAction
    {
        /// <summary>The property is used to enable a hash operation for variable value
        /// when composing the persistence key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("variable_hash_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Variable_hash_enabled { get; set; } = false;
    
        /// <summary>The property is the name of variable to be learnt. It is used to
        /// identify which variable's value is learnt from HTTP response.
        /// The variable can be a built-in variable such as "_cookie_JSESSIONID",
        /// a customized variable defined in LBVariableAssignmentAction or a
        /// captured variable in regular expression such as "article".
        /// For the full list of built-in variables, please reference the NSX-T
        /// Administrator's Guide.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("variable_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Variable_name { get; set; }
    
        /// <summary>If the persistence profile path is not specified, a default
        /// persistence table is created per virtual server. Currently, only
        /// LBGenericPersistenceProfile is supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("persistence_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Persistence_profile_path { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for ServiceEntry, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildServiceEntry : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ServiceEntry object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ServiceEntry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ServiceEntry ServiceEntry { get; set; }
    
        /// <summary>This is a deprecated property, Please use 'ServiceEntry' instead.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Service", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ServiceEntry Service { get; set; }
    
    
    }
    
    /// <summary>Remote server authentication details</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FileTransferAuthenticationScheme 
    {
        /// <summary>User name to authenticate with</summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Username { get; set; }
    
        /// <summary>Authentication scheme name</summary>
        [Newtonsoft.Json.JsonProperty("scheme_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FileTransferAuthenticationSchemeScheme_name Scheme_name { get; set; }
    
        /// <summary>Password to authenticate with</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Password { get; set; }
    
    
    }
    
    /// <summary>An entity that encapsulates attributes and sub-attributes of various
    /// network services (eg. L7 services, domain name, encryption algorithm)
    /// The entity will be consumed in firewall rules and can be added in new
    /// tuple called profile in firewall rules. To get a list of supported
    /// attributes and sub-attributes fire the following REST API
    /// GET https://&amp;lt;policy-mgr&amp;gt;/policy/api/v1/infra/context-profiles/attributes
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyContextProfile : PolicyConfigResource
    {
        /// <summary>Property containing attributes/sub-attributes for Policy Context Profile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("attributes", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyAttributes> Attributes { get; set; } = new System.Collections.ObjectModel.Collection<PolicyAttributes>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ArpHeader 
    {
        /// <summary>This field specifies the nature of the Arp message being sent.</summary>
        [Newtonsoft.Json.JsonProperty("op_code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ArpHeaderOp_code Op_code { get; set; } = SDKGenerator.ArpHeaderOp_code.ARP_REQUEST;
    
        /// <summary>This field specifies the IP address of the sender. If omitted, the src_ip is set to 0.0.0.0.</summary>
        [Newtonsoft.Json.JsonProperty("src_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Src_ip { get; set; }
    
        /// <summary>The destination IP address</summary>
        [Newtonsoft.Json.JsonProperty("dst_ip", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Dst_ip { get; set; }
    
    
    }
    
    /// <summary>Represents high level logical grouping of portions or segments of a donut / stats chart.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DonutSection 
    {
        /// <summary>Field of the root of the api result set for forming parts.</summary>
        [Newtonsoft.Json.JsonProperty("row_list_field", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Row_list_field { get; set; }
    
        /// <summary>Array of portions or parts of the donut or stats chart.</summary>
        [Newtonsoft.Json.JsonProperty("parts", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<DonutPart> Parts { get; set; } = new System.Collections.ObjectModel.Collection<DonutPart>();
    
        /// <summary>If true, the section will be appled as template for forming parts. Only one part will be formed from each element of 'row_list_field'.</summary>
        [Newtonsoft.Json.JsonProperty("template", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Template { get; set; } = false;
    
    
    }
    
    /// <summary>Advanced load balancer HTTPStatusRange object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPStatusRange 
    {
        /// <summary>Starting HTTP response status code.</summary>
        [Newtonsoft.Json.JsonProperty("begin", Required = Newtonsoft.Json.Required.Always)]
        public long Begin { get; set; }
    
        /// <summary>Ending HTTP response status code.</summary>
        [Newtonsoft.Json.JsonProperty("end", Required = Newtonsoft.Json.Required.Always)]
        public long End { get; set; }
    
    
    }
    
    /// <summary>Request parameters that represents a an intent path.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IntentRuntimeRequestParameters 
    {
        /// <summary>Policy Path referencing a site. This is applicable only on a GlobalManager. If no
        /// site_path is specified, then based on the span of the intent the response will be
        /// fetched from the respective sites
        /// </summary>
        [Newtonsoft.Json.JsonProperty("site_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Site_path { get; set; }
    
        /// <summary>Policy Path referencing an intent object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("intent_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Intent_path { get; set; }
    
    
    }
    
    /// <summary>Identity Firewall user login/session data for a single VM.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdfwVmStats 
    {
        /// <summary>Virtual machine (external ID or BIOS UUID) where login/logout event occurred.</summary>
        [Newtonsoft.Json.JsonProperty("vm_ext_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Vm_ext_id { get; set; }
    
        /// <summary>List of active (still logged in) user login/sessions data (no limit)</summary>
        [Newtonsoft.Json.JsonProperty("active_sessions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IdfwUserSessionData> Active_sessions { get; set; } = new System.Collections.ObjectModel.Collection<IdfwUserSessionData>();
    
        /// <summary>Optional list of up to 5 most recent archived (previously logged in) user login/session data.</summary>
        [Newtonsoft.Json.JsonProperty("archived_sessions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IdfwUserSessionData> Archived_sessions { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyExcludeList : PolicyConfigResource
    {
        /// <summary>List of the members in the exclude list</summary>
        [Newtonsoft.Json.JsonProperty("members", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(100)]
        public System.Collections.Generic.ICollection<string> Members { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>Represents an instance of partner Service and its configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BasePolicyServiceInstance : PolicyConfigResource
    {
        /// <summary>Unique name of Partner Service in the Marketplace</summary>
        [Newtonsoft.Json.JsonProperty("partner_service_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Partner_service_name { get; set; }
    
        /// <summary>Transport to be used while deploying Service-VM.</summary>
        [Newtonsoft.Json.JsonProperty("transport_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BasePolicyServiceInstanceTransport_type? Transport_type { get; set; } = SDKGenerator.BasePolicyServiceInstanceTransport_type.L2_BRIDGE;
    
        /// <summary>Deployment mode specifies how the partner appliance will be deployed i.e. in HA or standalone mode.</summary>
        [Newtonsoft.Json.JsonProperty("deployment_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BasePolicyServiceInstanceDeployment_mode? Deployment_mode { get; set; } = SDKGenerator.BasePolicyServiceInstanceDeployment_mode.ACTIVE_STANDBY;
    
    
    }
    
    /// <summary>Child wrapper object for ServiceInstanceEndpoint used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildServiceInstanceEndpoint : ChildPolicyConfigResource
    {
        /// <summary>Contains actual ServiceInstanceEndpoint.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ServiceInstanceEndpoint", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ServiceInstanceEndpoint ServiceInstanceEndpoint { get; set; }
    
    
    }
    
    /// <summary>List of compute collection ids and status connected to VC.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdfwComputeCollectionListResult : ListResult
    {
        /// <summary>Array of IDFW compute collection Ids and status connected to VC.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IdfwComputeCollectionStatus> Results { get; set; } = new System.Collections.ObjectModel.Collection<IdfwComputeCollectionStatus>();
    
    
    }
    
    /// <summary>Active healthchecks are disabled by default and can be enabled for a
    /// server pool by binding a health monitor to the Group through the LBRule
    /// object. This represents active health monitoring over ICMP.
    /// Active healthchecks are initiated periodically, at a configurable
    /// interval, to each member of the Group. Only if a healthcheck fails
    /// consecutively for a specified number of times (fall_count) to a member will
    /// the member status be marked DOWN. Once a member is DOWN, a specified
    /// number of consecutive successful healt hchecks (rise_count) will bring the
    /// member back to UP state. After a healthcheck is initiated, if it does not
    /// complete within a certain period, then also the healthcheck is considered
    /// to be unsuccessful. Completing a healthcheck within timeout means establishing
    /// a connection (TCP or SSL), if applicable, sending the request and
    /// receiving the response, all within the configured timeout.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBIcmpMonitorProfile : LBActiveMonitor
    {
        /// <summary>The data size (in byte) of the ICMP healthcheck packet</summary>
        [Newtonsoft.Json.JsonProperty("data_length", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65507D)]
        public long? Data_length { get; set; } = 56L;
    
    
    }
    
    /// <summary>Paged collection of CommunityLists</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CommunityListListResult : ListResult
    {
        /// <summary>CommunityList results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<CommunityList> Results { get; set; } = new System.Collections.ObjectModel.Collection<CommunityList>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RoleListResult : ListResult
    {
        /// <summary>List results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Role> Results { get; set; } = new System.Collections.ObjectModel.Collection<Role>();
    
    
    }
    
    /// <summary>Local egress routing policy</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LocalEgressRoutingEntry 
    {
        /// <summary>Next hop address for proximity routing.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nexthop_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Nexthop_address { get; set; }
    
        /// <summary>The destination address of traffic matching a prefix-list is forwarded
        /// to the nexthop_address. Traffic matching a prefix list with Action
        /// DENY will be dropped.
        /// Individual prefix-lists specified could have different actions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("prefix_list_paths", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Prefix_list_paths { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>Active healthchecks are disabled by default and can be enabled for a
    /// server pool by binding a health monitor to the Group through the LBRule
    /// object. This represents active health monitoring over HTTPS. Active
    /// healthchecks are initiated periodically, at a configurable interval, to
    /// each member of the Group. Only if a healthcheck fails consecutively for a
    /// specified number of times (fall_count) to a member will the member status
    /// be marked DOWN. Once a member is DOWN, a specified number of consecutive
    /// successful healthchecks (rise_count) will bring the member back to UP
    /// state. After a healthcheck is initiated, if it does not complete within a
    /// certain period, then also the healthcheck is considered to be
    /// unsuccessful. Completing a healthcheck within timeout means establishing
    /// a connection (TCP or SSL), if applicable, sending the request and
    /// receiving the response, all within the configured timeout.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBHttpsMonitorProfile : LBActiveMonitor
    {
        /// <summary>The HTTP response status code should be a valid HTTP status code.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("response_status_codes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(64)]
        public System.Collections.Generic.ICollection<long> Response_status_codes { get; set; }
    
        /// <summary>The health check method for HTTP monitor type.</summary>
        [Newtonsoft.Json.JsonProperty("request_method", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBHttpsMonitorProfileRequest_method? Request_method { get; set; } = SDKGenerator.LBHttpsMonitorProfileRequest_method.GET;
    
        /// <summary>String to send as part of HTTP health check request body. Valid only
        /// for certain HTTP methods like POST.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("request_body", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Request_body { get; set; }
    
        /// <summary>If HTTP response body match string (regular expressions not supported)
        /// is specified (using LBHttpMonitor.response_body) then the
        /// healthcheck HTTP response body is matched against the specified string
        /// and server is considered healthy only if there is a match.
        /// If the response body string is not specified, HTTP healthcheck is
        /// considered successful if the HTTP response status code is 2xx, but it
        /// can be configured to accept other status codes as successful.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("response_body", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Response_body { get; set; }
    
        /// <summary>For HTTPS active healthchecks, the HTTPS request url sent can be
        /// customized and can include query parameters.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("request_url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Request_url { get; set; } = "/";
    
        /// <summary>The setting is used when the monitor acts as an SSL client and
        /// establishing a connection to the backend server.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server_ssl_profile_binding", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LBServerSslProfileBinding Server_ssl_profile_binding { get; set; }
    
        /// <summary>HTTP request version.</summary>
        [Newtonsoft.Json.JsonProperty("request_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBHttpsMonitorProfileRequest_version? Request_version { get; set; } = SDKGenerator.LBHttpsMonitorProfileRequest_version.HTTP_VERSION_1_1;
    
        /// <summary>Array of HTTP request headers.</summary>
        [Newtonsoft.Json.JsonProperty("request_headers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LbHttpRequestHeader> Request_headers { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OspfDabtabaseCsvRecord : CsvRecord
    {
        [Newtonsoft.Json.JsonProperty("col8", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Col8 { get; set; }
    
        [Newtonsoft.Json.JsonProperty("col6", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Col6 { get; set; }
    
        [Newtonsoft.Json.JsonProperty("col7", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Col7 { get; set; }
    
        [Newtonsoft.Json.JsonProperty("col4", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Col4 { get; set; }
    
        [Newtonsoft.Json.JsonProperty("col5", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Col5 { get; set; }
    
        [Newtonsoft.Json.JsonProperty("col2", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Col2 { get; set; }
    
        [Newtonsoft.Json.JsonProperty("col3", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Col3 { get; set; }
    
        [Newtonsoft.Json.JsonProperty("col1", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Col1 { get; set; }
    
    
    }
    
    /// <summary>Paged collection of port mirroring instances</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PortMirroringInstanceListResult : ListResult
    {
        /// <summary>Port Mirroring Instances list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PortMirroringInstance> Results { get; set; } = new System.Collections.ObjectModel.Collection<PortMirroringInstance>();
    
    
    }
    
    /// <summary>L2VPNSessionPeerCodes represents an array of peer code for each
    /// tunnel. The peer code is necessary to configure the remote end
    /// of the tunnel. Currently only stand-along/unmanaged edge is
    /// supported on the remote end of the tunnel.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VPNSessionPeerConfigNsxT : L2VPNSessionPeerConfigPerEP
    {
        /// <summary>List of peer codes per transport tunnel.</summary>
        [Newtonsoft.Json.JsonProperty("peer_codes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<L2VPNSessionTransportTunnelPeerCode> Peer_codes { get; set; }
    
    
    }
    
    /// <summary>BGP route details.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RouteDetails 
    {
        /// <summary>BGP Multi Exit Discriminator attribute.</summary>
        [Newtonsoft.Json.JsonProperty("med", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Med { get; set; }
    
        /// <summary>Next hop IP address.</summary>
        [Newtonsoft.Json.JsonProperty("next_hop", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Next_hop { get; set; }
    
        /// <summary>CIDR network address.</summary>
        [Newtonsoft.Json.JsonProperty("network", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Network { get; set; }
    
        /// <summary>BGP Weight attribute.</summary>
        [Newtonsoft.Json.JsonProperty("weight", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Weight { get; set; }
    
        /// <summary>BGP Local Preference attribute.</summary>
        [Newtonsoft.Json.JsonProperty("local_pref", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Local_pref { get; set; }
    
        /// <summary>BGP AS path attribute.</summary>
        [Newtonsoft.Json.JsonProperty("as_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string As_path { get; set; }
    
    
    }
    
    /// <summary>Contains dupliacte IP detection related discovery options.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DuplicateIPDetectionOptions 
    {
        /// <summary>Indicates whether duplicate IP detection should be enabled</summary>
        [Newtonsoft.Json.JsonProperty("duplicate_ip_detection_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Duplicate_ip_detection_enabled { get; set; } = false;
    
    
    }
    
    /// <summary>Advanced load balancer WafApplicationSignatures object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWafApplicationSignatures 
    {
        /// <summary>The active application specific rules.
        /// You can change attributes like enabled, waf mode and
        /// exclusions, but not the rules itself.
        /// To change the rules, you can change the tags or the rule
        /// provider.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBWafRule> Rules { get; set; }
    
        /// <summary>The version in use of the provided ruleset.</summary>
        [Newtonsoft.Json.JsonProperty("ruleset_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ruleset_version { get; set; }
    
        /// <summary>List of applications for which we use the rules from the
        /// WafApplicationSignatureProvider.
        /// Maximum of 8 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selected_applications", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Selected_applications { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for PolicyServiceInstance used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyServiceInstance : ChildPolicyConfigResource
    {
        /// <summary>Contains actual PolicyServiceInstance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyServiceInstance", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyServiceInstance PolicyServiceInstance { get; set; }
    
    
    }
    
    /// <summary>Credential info to connect to a AVI type of enforcement point.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AviConnectionInfo : EnforcementPointConnectionInfo
    {
        /// <summary>Username.</summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Username { get; set; }
    
        /// <summary>Avi supports API versioning for backward compatibility with automation scripts written for an object model older than the current one.
        /// Such scripts need not be updated to keep up with object model changes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Version { get; set; }
    
        /// <summary>A tenant is an isolated instance of Avi Controller.
        /// Each Avi user account is associated with one or more tenants.
        /// The tenant associated with a user account defines the resources that user can access within Avi Vantage.
        /// When a user logs in, Avi restricts their access to only those resources that are in the same tenant
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tenant", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Tenant { get; set; }
    
        /// <summary>Thumbprint of EnforcementPoint in the form of a SHA-256 hash represented in lower case HEX.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thumbprint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Thumbprint { get; set; }
    
        /// <summary>Password.</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Password { get; set; }
    
        /// <summary>Clouds are containers for the environment that Avi Vantage is installed or operating within.
        /// During initial setup of Vantage, a default cloud, named Default-Cloud, is created.
        /// This is where the first Controller is deployed, into Default-Cloud. Additional clouds may be added,
        /// containing SEs and virtual services.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cloud", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Cloud { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for SegmentSecurityProfileBindingMap, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildSegmentSecurityProfileBindingMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual SegmentSecurityProfileBindingMap object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("SegmentSecurityProfileBindingMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SegmentSecurityProfileBindingMap SegmentSecurityProfileBindingMap { get; set; }
    
    
    }
    
    /// <summary>A set of operations to be performed in a single batch</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BatchRequest 
    {
        [Newtonsoft.Json.JsonProperty("requests", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<BatchRequestItem> Requests { get; set; }
    
        /// <summary>Flag to decide if we will continue processing subsequent requests in case of current error for atomic = false.</summary>
        [Newtonsoft.Json.JsonProperty("continue_on_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Continue_on_error { get; set; } = true;
    
    
    }
    
    /// <summary>ServiceDeployment Spec consists of information required to deploy and configure the partner appliances. viz. Deployment template, deployment spec and NIC metatdata.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServiceDeploymentSpec 
    {
        /// <summary>Deployment Specs holds information required to deploy the Service-VMs. i.e. OVF url where the partner Service-VM OVF is hosted. The host type on which the OVF can be deployed, Form factor to name a few.</summary>
        [Newtonsoft.Json.JsonProperty("deployment_specs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<SVMDeploymentSpec> Deployment_specs { get; set; }
    
        /// <summary>NIC metadata associated with the deployment spec.</summary>
        [Newtonsoft.Json.JsonProperty("nic_metadata_list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<NicMetadata> Nic_metadata_list { get; set; }
    
        /// <summary>Deployment Template holds the attributes specific to partner for which the service is created. These attributes are opaque to NSX Manager.</summary>
        [Newtonsoft.Json.JsonProperty("deployment_template", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<DeploymentTemplate> Deployment_template { get; set; } = new System.Collections.ObjectModel.Collection<DeploymentTemplate>();
    
        /// <summary>Partner needs to specify the Service VM version which will get deployed.</summary>
        [Newtonsoft.Json.JsonProperty("svm_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Svm_version { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer IPPersistenceProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBIPPersistenceProfile 
    {
        /// <summary>Mask to be applied on client IP.
        /// This may be used to persist clients from a subnet to the
        /// same server.
        /// When set to 0, all requests are sent to the same server.
        /// Allowed values are 0-128.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip_mask", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 128D)]
        public long? Ip_mask { get; set; }
    
        /// <summary>The length of time after a client's connections have closed
        /// before expiring the client's persistence to a server.
        /// Allowed values are 1-720.
        /// Unit is MIN.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 5.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip_persistent_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 720D)]
        public long? Ip_persistent_timeout { get; set; } = 5L;
    
    
    }
    
    /// <summary>Child wrapper object for PolicyContextProfile, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyContextProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyContextProfile objects
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyContextProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyContextProfile PolicyContextProfile { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for IdsClusterConfig, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIdsClusterConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains the IdsClusterConfig object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IdsClusterConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IdsClusterConfig IdsClusterConfig { get; set; }
    
    
    }
    
    /// <summary>GenericPolicyRealizedResource list result</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GenericPolicyRealizedResourceListResult : ListResult
    {
        /// <summary>List of realized resources</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<GenericPolicyRealizedResource> Results { get; set; }
    
    
    }
    
    /// <summary>Metadata Proxy Configuration</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MetadataProxyConfig : PolicyConfigResource
    {
        /// <summary>Secret word or phrase to access metadata server.</summary>
        [Newtonsoft.Json.JsonProperty("secret", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Secret { get; set; }
    
        /// <summary>Valid certificates should be configured. The validity of certificates is not checked. Certificates are managed through /infra/certificates API on Policy.</summary>
        [Newtonsoft.Json.JsonProperty("server_certificates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Server_certificates { get; set; }
    
        /// <summary>Edge clusters configured on MP are auto-discovered by Policy and create corresponding read-only intent objects.</summary>
        [Newtonsoft.Json.JsonProperty("edge_cluster_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Edge_cluster_path { get; set; }
    
        /// <summary>Edge nodes should be members of edge cluster configured in edge_cluster_path.</summary>
        [Newtonsoft.Json.JsonProperty("preferred_edge_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(2)]
        public System.Collections.Generic.ICollection<string> Preferred_edge_paths { get; set; }
    
        /// <summary>The cryptographic protocols listed here are supported by the metadata proxy. TLSv1.1 and TLSv1.2 are supported by default</summary>
        [Newtonsoft.Json.JsonProperty("crypto_protocols", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Crypto_protocols> Crypto_protocols { get; set; }
    
        /// <summary>This field is a URL. Example formats - http://1.2.3.4:3888/path, http://text-md-proxy:5001/. Port number should be between 3000-9000.</summary>
        [Newtonsoft.Json.JsonProperty("server_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Server_address { get; set; }
    
        /// <summary>Only auto-placed metadata proxies are considered for relocation. Must be FALSE, when the preferred_edge_paths property is configured.</summary>
        [Newtonsoft.Json.JsonProperty("enable_standby_relocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_standby_relocation { get; set; } = false;
    
    
    }
    
    /// <summary>Child wrapper for LBServerSslProfile, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildLBServerSslProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual LBServerSslProfile object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("LBServerSslProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public LBServerSslProfile LBServerSslProfile { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for IPSecVpnIkeProfile, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIPSecVpnIkeProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual IPSecVpnIkeProfile object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IPSecVpnIkeProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IPSecVpnIkeProfile IPSecVpnIkeProfile { get; set; }
    
    
    }
    
    /// <summary>App profile.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("LBHttpProfile", typeof(LBHttpProfile))]
    [JsonInheritanceAttribute("LBFastUdpProfile", typeof(LBFastUdpProfile))]
    [JsonInheritanceAttribute("LBFastTcpProfile", typeof(LBFastTcpProfile))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBAppProfile : PolicyConfigResource
    {
    
    }
    
    /// <summary>Paged Collection of LBPool.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBPoolListResult : ListResult
    {
        /// <summary>LBPool list results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<LBPool> Results { get; set; } = new System.Collections.ObjectModel.Collection<LBPool>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OspfRoute 
    {
        /// <summary>Type to cost of the route.</summary>
        [Newtonsoft.Json.JsonProperty("type_to_cost", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Type_to_cost { get; set; }
    
        /// <summary>Learned route prefix.</summary>
        [Newtonsoft.Json.JsonProperty("route_prefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Route_prefix { get; set; }
    
        /// <summary>Cost of the route.</summary>
        [Newtonsoft.Json.JsonProperty("cost", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Cost { get; set; }
    
        /// <summary>OSPF area.</summary>
        [Newtonsoft.Json.JsonProperty("area", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Area { get; set; }
    
        /// <summary>Type of route.</summary>
        [Newtonsoft.Json.JsonProperty("route_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Route_type { get; set; }
    
        /// <summary>Type of router.</summary>
        [Newtonsoft.Json.JsonProperty("router_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Router_type { get; set; }
    
        /// <summary>request counter.</summary>
        [Newtonsoft.Json.JsonProperty("next_hops", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OspfRouteNextHopResult> Next_hops { get; set; }
    
    
    }
    
    /// <summary>Paged collection of Segment Monitoring Profile Binding Maps</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentMonitoringProfileBindingMapListResult : ListResult
    {
        /// <summary>Segment Monitoring Profile Binding Map list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SegmentMonitoringProfileBindingMap> Results { get; set; } = new System.Collections.ObjectModel.Collection<SegmentMonitoringProfileBindingMap>();
    
    
    }
    
    /// <summary>Advanced load balancer LdapUserBindSettings object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBLdapUserBindSettings 
    {
        /// <summary>LDAP user DN pattern is used to bind LDAP user after
        /// replacing the user token with real username.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dn_template", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dn_template { get; set; }
    
        /// <summary>LDAP user attributes to fetch on a successful user bind.</summary>
        [Newtonsoft.Json.JsonProperty("user_attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> User_attributes { get; set; }
    
        /// <summary>LDAP token is replaced with real user name in the user DN
        /// pattern.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as &lt;user&gt;.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("token", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Token { get; set; } = "<user>";
    
        /// <summary>LDAP user id attribute is the login attribute that uniquely
        /// identifies a single user record.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("user_id_attribute", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User_id_attribute { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBVirtualServerStatistics : LBVirtualServerStatisticsPerEP
    {
        /// <summary>Timestamp when the data was last updated.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>Virtual server statistics counter.</summary>
        [Newtonsoft.Json.JsonProperty("statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LBStatisticsCounter Statistics { get; set; }
    
        /// <summary>load balancer virtual server object path.</summary>
        [Newtonsoft.Json.JsonProperty("virtual_server_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Virtual_server_path { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer LdapDirectorySettings object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBLdapDirectorySettings 
    {
        /// <summary>LDAP Admin User Password.</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Password { get; set; }
    
        /// <summary>LDAP user search DN is the root of search for a given user
        /// in the LDAP directory.
        /// Only user records present in this LDAP directory sub-tree
        /// will be validated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("user_search_dn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User_search_dn { get; set; }
    
        /// <summary>Group member entries contain full DNs instead of just user
        /// id attribute values.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("group_member_is_full_dn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Group_member_is_full_dn { get; set; } = true;
    
        /// <summary>LDAP user search scope defines how deep to search for the
        /// user starting from user search DN.
        /// Enum options - AUTH_LDAP_SCOPE_BASE, AUTH_LDAP_SCOPE_ONE,
        /// AUTH_LDAP_SCOPE_SUBTREE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as AUTH_LDAP_SCOPE_ONE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("user_search_scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBLdapDirectorySettingsUser_search_scope? User_search_scope { get; set; } = SDKGenerator.ALBLdapDirectorySettingsUser_search_scope.AUTH_LDAP_SCOPE_ONE;
    
        /// <summary>LDAP user id attribute is the login attribute that uniquely
        /// identifies a single user record.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("user_id_attribute", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User_id_attribute { get; set; }
    
        /// <summary>LDAP group attribute that identifies each of the group
        /// members.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as member.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("group_member_attribute", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group_member_attribute { get; set; } = "member";
    
        /// <summary>Group filter is used to identify groups during search.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as (objectClass=(STAR)).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("group_filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group_filter { get; set; } = "(objectClass=*)";
    
        /// <summary>LDAP group search DN is the root of search for a given
        /// group in the LDAP directory.
        /// Only matching groups present in this LDAP directory
        /// sub-tree will be checked for user membership.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("group_search_dn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group_search_dn { get; set; }
    
        /// <summary>LDAP user attributes to fetch on a successful user bind.</summary>
        [Newtonsoft.Json.JsonProperty("user_attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> User_attributes { get; set; }
    
        /// <summary>During user or group search, ignore searching referrals.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ignore_referrals", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Ignore_referrals { get; set; } = false;
    
        /// <summary>LDAP group search scope defines how deep to search for the
        /// group starting from the group search DN.
        /// Enum options - AUTH_LDAP_SCOPE_BASE, AUTH_LDAP_SCOPE_ONE,
        /// AUTH_LDAP_SCOPE_SUBTREE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as AUTH_LDAP_SCOPE_SUBTREE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("group_search_scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBLdapDirectorySettingsGroup_search_scope? Group_search_scope { get; set; } = SDKGenerator.ALBLdapDirectorySettingsGroup_search_scope.AUTH_LDAP_SCOPE_SUBTREE;
    
        /// <summary>LDAP Admin User DN.
        /// Administrator credentials are required to search for users
        /// under user search DN or groups under group search DN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("admin_bind_dn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Admin_bind_dn { get; set; }
    
    
    }
    
    /// <summary>TAP (Terminal access point) traffic statistics for L2Vpn.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VpnTapTrafficStatistics 
    {
        /// <summary>Total number of outgoing packets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_out { get; set; }
    
        /// <summary>Total number of incoming bytes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bytes_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_in { get; set; }
    
        /// <summary>Total number of packets dropped while sending for any reason.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_sent_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_sent_error { get; set; }
    
        /// <summary>Total number of incoming packets dropped.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_receive_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_receive_error { get; set; }
    
        /// <summary>Total number of incoming packets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_in { get; set; }
    
        /// <summary>Total number of outgoing bytes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bytes_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_out { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer Server object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBServer 
    {
        /// <summary>If statically learned.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_static", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_static { get; set; } = false;
    
        /// <summary>UID of server in external orchestration systems.</summary>
        [Newtonsoft.Json.JsonProperty("external_orchestration_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string External_orchestration_id { get; set; }
    
        /// <summary>(internal-use) Discovered networks providing reachability
        /// for server IP.
        /// This field is used internally by Avi, not editable by the
        /// user.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("discovered_networks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDiscoveredNetwork> Discovered_networks { get; set; }
    
        /// <summary>Header value for custom header persistence.</summary>
        [Newtonsoft.Json.JsonProperty("prst_hdr_val", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Prst_hdr_val { get; set; }
    
        /// <summary>A description of the Server.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Availability-zone of the server VM.</summary>
        [Newtonsoft.Json.JsonProperty("availability_zone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Availability_zone { get; set; }
    
        /// <summary>Name of autoscaling group this server belongs to.</summary>
        [Newtonsoft.Json.JsonProperty("autoscaling_group_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Autoscaling_group_name { get; set; }
    
        /// <summary>IP Address of the server.
        /// Required if there is no resolvable host name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBIpAddr Ip { get; set; } = new ALBIpAddr();
    
        /// <summary>DNS resolvable name of the server.
        /// May be used in place of the IP address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hostname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Hostname { get; set; }
    
        /// <summary>Enable, Disable or Graceful Disable determine if new or
        /// existing connections to the server are allowed.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
        /// <summary>MAC address of server.</summary>
        [Newtonsoft.Json.JsonProperty("mac_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Mac_address { get; set; }
    
        /// <summary>Verify server belongs to a discovered network or reachable
        /// via a discovered network.
        /// Verify reachable network isn't the OpenStack management
        /// network.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("verify_network", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Verify_network { get; set; } = false;
    
        /// <summary>Hostname of the node where the server VM or container
        /// resides.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server_node", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Server_node { get; set; }
    
        /// <summary>UUID identifying VM in OpenStack and other external
        /// compute.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("external_uuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string External_uuid { get; set; }
    
        /// <summary>(internal-use) Geographic location of the server.Currently
        /// only for internal usage.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("location", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBGeoLocation Location { get; set; }
    
        /// <summary>Auto resolve server's IP using DNS name.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resolve_server_by_dns", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Resolve_server_by_dns { get; set; } = false;
    
        /// <summary>Ratio of selecting eligible servers in the pool.
        /// Allowed values are 1-20.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ratio", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 20D)]
        public long? Ratio { get; set; } = 1L;
    
        /// <summary>Rewrite incoming Host Header to server name.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rewrite_host_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Rewrite_host_header { get; set; } = false;
    
        /// <summary>Optionally specify the servers port number.
        /// This will override the pool's default server port
        /// attribute.
        /// Allowed values are 1-65535.
        /// Special values are 0- 'use backend port in pool'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Port { get; set; }
    
    
    }
    
    /// <summary>Summarized view of all selected IPSec VPN sessions.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyIpsecVpnSessionSummary 
    {
        /// <summary>Traffic summary per session.</summary>
        [Newtonsoft.Json.JsonProperty("traffic_summary_per_session", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IPSecVPNSessionTrafficSummary> Traffic_summary_per_session { get; set; }
    
        /// <summary>Timestamp when the data was last updated.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>Session summary for number of total, established, failed and degraded IPSec VPN sessions.</summary>
        [Newtonsoft.Json.JsonProperty("session_summary", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IPsecVPNIKESessionSummary Session_summary { get; set; }
    
        /// <summary>Aggregate traffic statistics across all selected sessions.</summary>
        [Newtonsoft.Json.JsonProperty("aggregate_traffic_counters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IPSecVPNTrafficCounters Aggregate_traffic_counters { get; set; }
    
    
    }
    
    /// <summary>The setting is used to add, update or remove pool members from pool.
    /// For static pool members, admin_state, display_name and weight can be
    /// updated.
    /// For dynamic pool members, only admin_state can be updated.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PoolMemberSetting 
    {
        /// <summary>Member admin state</summary>
        [Newtonsoft.Json.JsonProperty("admin_state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PoolMemberSettingAdmin_state? Admin_state { get; set; } = SDKGenerator.PoolMemberSettingAdmin_state.ENABLED;
    
        /// <summary>Pool member IP address</summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ip_address { get; set; }
    
        /// <summary>Pool member port number</summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Port { get; set; }
    
        /// <summary>Only applicable to static pool members. If supplied for a pool defined
        /// by a grouping object, update API would fail.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("weight", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 255D)]
        public long? Weight { get; set; }
    
        /// <summary>Only applicable to static pool members. If supplied for a pool defined
        /// by a grouping object, update API would fail.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Display_name { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of NAT Rules</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyNatRuleListResult : ListResult
    {
        /// <summary>NAT Rules list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyNatRule> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyNatRule>();
    
    
    }
    
    /// <summary>Tier-1 instance configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier1 : PolicyConfigResource
    {
        /// <summary>Additional config for federation.</summary>
        [Newtonsoft.Json.JsonProperty("federation_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FederationGatewayConfig Federation_config { get; set; }
    
        /// <summary>Indicates if logging should be enabled for the default whitelisting rule. This field is
        /// deprecated and recommended to change Rule logging field. Note that this
        /// field is not synchronized with default logging field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("default_rule_logging", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Default_rule_logging { get; set; } = false;
    
        /// <summary>Route advertisement rules and filtering</summary>
        [Newtonsoft.Json.JsonProperty("route_advertisement_rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RouteAdvertisementRule> Route_advertisement_rules { get; set; }
    
        /// <summary>Supports edge node allocation at different sizes for routing and
        /// load balancer service to meet performance and scalability requirements.
        ///   ROUTING: Allocate edge node to provide routing services.
        ///   LB_SMALL, LB_MEDIUM, LB_LARGE, LB_XLARGE: Specify size of load balancer
        /// service that will be configured on TIER1 gateway.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_allocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Tier1Pool_allocation? Pool_allocation { get; set; } = SDKGenerator.Tier1Pool_allocation.ROUTING;
    
        /// <summary>Specify Tier-1 connectivity to Tier-0 instance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tier0_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tier0_path { get; set; }
    
        /// <summary>Flag to enable standby service router relocation.
        /// Standby relocation is not enabled until edge cluster is configured
        /// for Tier1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_standby_relocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_standby_relocation { get; set; } = false;
    
        /// <summary>Disable or enable gateway fiewall.</summary>
        [Newtonsoft.Json.JsonProperty("disable_firewall", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Disable_firewall { get; set; } = false;
    
        /// <summary>Determines the behavior when a Tier-1 instance restarts after a
        /// failure. If set to PREEMPTIVE, the preferred node will take over,
        /// even if it causes another failure. If set to NON_PREEMPTIVE,
        /// then the instance that restarted will remain secondary.
        /// Only applicable when edge cluster is configured in Tier1
        /// locale-service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("failover_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Tier1Failover_mode? Failover_mode { get; set; } = SDKGenerator.Tier1Failover_mode.NON_PREEMPTIVE;
    
        /// <summary>Maximum number of ARP entries per transport node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("arp_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(5000D, 50000D)]
        public long? Arp_limit { get; set; }
    
        /// <summary>This field is deprecated and recommended to change Rule action field.
        /// Note that this field is not synchornied with default rule field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("force_whitelisting", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Force_whitelisting { get; set; } = false;
    
        /// <summary>Inter site routing configuration when the gateway is streched.</summary>
        [Newtonsoft.Json.JsonProperty("intersite_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IntersiteGatewayConfig Intersite_config { get; set; }
    
        /// <summary>DHCP configuration for Segments connected to Tier-1. DHCP service is
        /// enabled in relay mode.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dhcp_config_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Dhcp_config_paths { get; set; }
    
        /// <summary>Configuration IPv6 NDRA and DAD profiles. Either or both
        /// NDRA and/or DAD profiles can be configured.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipv6_profile_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(2)]
        public System.Collections.Generic.ICollection<string> Ipv6_profile_paths { get; set; }
    
        /// <summary>QoS Profile configuration for Tier1 router link connected to Tier0 gateway.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("qos_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GatewayQosProfileConfig Qos_profile { get; set; }
    
        /// <summary>Tier1 connectivity type for reference. Property value is not validated
        /// with Tier1 configuration.
        ///   ROUTED: Tier1 is connected to Tier0 gateway and routing is enabled.
        ///   ISOLATED: Tier1 is not connected to any Tier0 gateway.
        ///   NATTED: Tier1 is in ROUTED type with NAT configured locally.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Tier1Type? Type { get; set; }
    
        /// <summary>Enable different types of route advertisements.
        /// When not specified, routes to IPSec VPN local-endpoint subnets
        /// (TIER1_IPSEC_LOCAL_ENDPOINT) are automatically advertised.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("route_advertisement_types", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Route_advertisement_types2> Route_advertisement_types { get; set; }
    
    
    }
    
    /// <summary>Tier-0 configuration for external connectivity.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier0 : PolicyConfigResource
    {
        /// <summary>Additional config for federation.</summary>
        [Newtonsoft.Json.JsonProperty("federation_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FederationGatewayConfig Federation_config { get; set; }
    
        /// <summary>Indicates if logging should be enabled for the default whitelisting rule. This field is
        /// deprecated and recommended to change Rule logging field. Note that this
        /// field is not synchronized with default logging field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("default_rule_logging", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Default_rule_logging { get; set; } = false;
    
        /// <summary>Determines the behavior when a Tier-0 instance in ACTIVE-STANDBY
        /// high-availability mode restarts after a failure. If set to
        /// PREEMPTIVE, the preferred node will take over, even if it causes
        /// another failure. If set to NON_PREEMPTIVE, then the instance that
        /// restarted will remain secondary. This property is not used when
        /// the ha_mode property is set to ACTIVE_ACTIVE.
        /// Only applicable when edge cluster is configured in Tier0
        /// locale-service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("failover_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Tier0Failover_mode? Failover_mode { get; set; } = SDKGenerator.Tier0Failover_mode.NON_PREEMPTIVE;
    
        /// <summary>NSX specific configuration for tier-0</summary>
        [Newtonsoft.Json.JsonProperty("advanced_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Tier0AdvancedConfig Advanced_config { get; set; }
    
        /// <summary>Maximum number of ARP entries per transport node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("arp_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(5000D, 50000D)]
        public long? Arp_limit { get; set; }
    
        /// <summary>VRF config, required for VRF Tier0.</summary>
        [Newtonsoft.Json.JsonProperty("vrf_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Tier0VrfConfig Vrf_config { get; set; }
    
        /// <summary>Specify subnets that are used to assign addresses to logical links
        /// connecting service routers and distributed routers. Only IPv4
        /// addresses are supported.
        /// When not specified, subnet 169.254.0.0/24 is assigned by default
        /// in ACTIVE_ACTIVE HA mode or 169.254.0.0/28 in ACTIVE_STANDBY mode.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("internal_transit_subnets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Internal_transit_subnets { get; set; }
    
        /// <summary>Specify transit subnets that are used to assign addresses to logical links
        /// connecting tier-0 and tier-1s. Both IPv4 and IPv6 addresses are supported.
        /// When not specified, subnet 100.64.0.0/16 is configured by default.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transit_subnets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Transit_subnets { get; set; }
    
        /// <summary>Specify high-availability mode for Tier-0. Default is ACTIVE_ACTIVE.
        /// When ha_mode is changed from ACTIVE_ACTIVE to ACTIVE_STANDBY,
        /// inter SR iBGP (in BGP) is disabled.
        /// Changing ha_mode from ACTIVE_STANDBY to ACTIVE_ACTIVE will enable
        /// inter SR iBGP (in BGP) and previously configured preferred edge nodes
        /// (in Tier0 locale-service) are removed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ha_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Tier0Ha_mode? Ha_mode { get; set; } = SDKGenerator.Tier0Ha_mode.ACTIVE_ACTIVE;
    
        /// <summary>This field is deprecated and recommended to change Rule action field.
        /// Note that this field is not synchronized with default rule field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("force_whitelisting", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Force_whitelisting { get; set; } = false;
    
        /// <summary>Inter site routing configuration when the gateway is streched.</summary>
        [Newtonsoft.Json.JsonProperty("intersite_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IntersiteGatewayConfig Intersite_config { get; set; }
    
        /// <summary>If you are using EVPN service, then route distinguisher administrator address
        /// should be defined if you need auto generation of route distinguisher on your
        /// VRF configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rd_admin_field", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rd_admin_field { get; set; }
    
        /// <summary>IPv6 NDRA and DAD profiles configuration on Tier0. Either or both
        /// NDRA and/or DAD profiles can be configured.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipv6_profile_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(2)]
        public System.Collections.Generic.ICollection<string> Ipv6_profile_paths { get; set; }
    
        /// <summary>Disable or enable gateway fiewall.</summary>
        [Newtonsoft.Json.JsonProperty("disable_firewall", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Disable_firewall { get; set; } = false;
    
        /// <summary>DHCP configuration for Segments connected to Tier-0. DHCP service is
        /// configured in relay mode.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dhcp_config_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Dhcp_config_paths { get; set; }
    
    
    }
    
    /// <summary>IP tunnel interface configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnTunnelInterface : PolicyConfigResource
    {
        /// <summary>IP Tunnel interface (commonly referred as VTI) subnet.</summary>
        [Newtonsoft.Json.JsonProperty("ip_subnets", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<TunnelInterfaceIPSubnet> Ip_subnets { get; set; } = new System.Collections.ObjectModel.Collection<TunnelInterfaceIPSubnet>();
    
    
    }
    
    /// <summary>Identity Firewall user session data list and Directory Group to user mappings.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdfwUserSessionDataAndMappings 
    {
        /// <summary>Archived user session data list</summary>
        [Newtonsoft.Json.JsonProperty("archived_user_sessions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IdfwUserSessionData> Archived_user_sessions { get; set; } = new System.Collections.ObjectModel.Collection<IdfwUserSessionData>();
    
        /// <summary>Active user session data list</summary>
        [Newtonsoft.Json.JsonProperty("active_user_sessions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IdfwUserSessionData> Active_user_sessions { get; set; } = new System.Collections.ObjectModel.Collection<IdfwUserSessionData>();
    
        /// <summary>Directory Group to user session data mappings</summary>
        [Newtonsoft.Json.JsonProperty("dir_group_to_user_session_data_mappings", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IdfwDirGroupUserSessionMapping> Dir_group_to_user_session_data_mappings { get; set; } = new System.Collections.ObjectModel.Collection<IdfwDirGroupUserSessionMapping>();
    
    
    }
    
    /// <summary>Advanced load balancer HSMThalesRFS object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHSMThalesRFS 
    {
        /// <summary>IP address of the RFS server from where to sync the Thales
        /// encrypted private key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBIpAddr Ip { get; set; } = new ALBIpAddr();
    
        /// <summary>Port at which the RFS server accepts the sync request from
        /// clients for Thales encrypted private key.
        /// Allowed values are 1-65535.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 9004.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long? Port { get; set; } = 9004L;
    
    
    }
    
    /// <summary>This condition is used to match variable's name and value at all
    /// phases. The variables could be captured from REGEX or assigned by
    /// LBVariableAssignmentAction or system embedded variable. Varialbe_name
    /// and variable_value should be matched at the same time.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBVariableCondition : LBRuleCondition
    {
        /// <summary>Value of variable to be matched</summary>
        [Newtonsoft.Json.JsonProperty("variable_value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Variable_value { get; set; }
    
        /// <summary>If true, case is significant when comparing variable value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("case_sensitive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Case_sensitive { get; set; } = true;
    
        /// <summary>Match type of variable value</summary>
        [Newtonsoft.Json.JsonProperty("match_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBVariableConditionMatch_type? Match_type { get; set; } = SDKGenerator.LBVariableConditionMatch_type.REGEX;
    
        /// <summary>Name of the variable to be matched</summary>
        [Newtonsoft.Json.JsonProperty("variable_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Variable_name { get; set; }
    
    
    }
    
    /// <summary>PoolGroupDeploymentPolicyApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBPoolGroupDeploymentPolicyApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of PoolGroupDeploymentPolicy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBPoolGroupDeploymentPolicy> Results { get; set; }
    
    
    }
    
    /// <summary>IDS Rule statistics for a specfic enforcement point.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsRuleStatisticsForEnforcementPoint 
    {
        /// <summary>IDS Rule statistics for a single enforcement point</summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enforcement_point { get; set; }
    
        /// <summary>Statistics for the specified enforcement point</summary>
        [Newtonsoft.Json.JsonProperty("statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IdsRuleStatistics Statistics { get; set; }
    
    
    }
    
    /// <summary>A Route Based L3Vpn is more flexible, more powerful and recommended over policy based.
    /// IP Tunnel subnet is created and all traffic routed through tunnel subnet is sent over
    /// tunnel. Routes can be learned through BGP. A route based L3Vpn is required when using
    /// redundant L3Vpn.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RouteBasedL3VpnSession : L3VpnSession
    {
        /// <summary>This is a deprecated field. Any specified value is not saved and will be ignored.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("routing_config_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Routing_config_path { get; set; }
    
        /// <summary>Virtual tunnel interface (VTI) port IP subnets to be used to configure
        /// route-based L3Vpn session. A max of one tunnel subnet is allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tunnel_subnets", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<TunnelSubnet> Tunnel_subnets { get; set; } = new System.Collections.ObjectModel.Collection<TunnelSubnet>();
    
        /// <summary>Indicates if logging should be enabled for the default whitelisting
        /// rule for the VTI interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("default_rule_logging", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Default_rule_logging { get; set; } = false;
    
        /// <summary>The default firewall rule Action is set to DROP if true otherwise set to ALLOW.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("force_whitelisting", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Force_whitelisting { get; set; } = false;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DirectoryAdGroup : DirectoryGroup
    {
        /// <summary>GUID is a 128-bit value that is unique not only in the enterprise but also across the world. GUIDs are assigned to every object created by Active Directory, not just User and Group objects.</summary>
        [Newtonsoft.Json.JsonProperty("object_guid", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Object_guid { get; set; }
    
        /// <summary>A security identifier (SID) is a unique value of variable length used to identify a trustee. A SID consists of the following components - The revision level of the SID structure; A 48-bit identifier authority value that identifies the authority that issued the SID; A variable number of subauthority or relative identifier (RID) values that uniquely identify the trustee relative to the authority that issued the SID.</summary>
        [Newtonsoft.Json.JsonProperty("secure_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Secure_id { get; set; }
    
    
    }
    
    /// <summary>Gives the Statistics of a NAT rule.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyNatRuleStatistics : PolicyNATRuleCounters
    {
        /// <summary>Timestamp when the data was last updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>The warning message about the NAT Rule Statistics.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("warning_message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Warning_message { get; set; }
    
    
    }
    
    /// <summary>Paged collection of Service Interfaces</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServiceInterfaceListResult : ListResult
    {
        /// <summary>Service Interface list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ServiceInterface> Results { get; set; } = new System.Collections.ObjectModel.Collection<ServiceInterface>();
    
    
    }
    
    /// <summary>Collection of tags used in a policy group listed per member type
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GroupTagsList 
    {
        /// <summary>Collection of tags used in a policy group listed per member type</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<GroupMemberTagsList> Results { get; set; } = new System.Collections.ObjectModel.Collection<GroupMemberTagsList>();
    
    
    }
    
    /// <summary>Paged Collection of L2Vpns</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VpnListResult : ListResult
    {
        /// <summary>L2Vpn list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<L2Vpn> Results { get; set; } = new System.Collections.ObjectModel.Collection<L2Vpn>();
    
    
    }
    
    /// <summary>Child wrapper object for DhcpServerConfig, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildDhcpServerConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual DhcpServerConfig object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("DhcpServerConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public DhcpServerConfig DhcpServerConfig { get; set; }
    
    
    }
    
    /// <summary>TrafficCloneProfileApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBTrafficCloneProfileApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of TrafficCloneProfile
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBTrafficCloneProfile> Results { get; set; }
    
    
    }
    
    /// <summary>ApplicationPersistenceProfileApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBApplicationPersistenceProfileApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of ApplicationPersistenceProfile
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBApplicationPersistenceProfile> Results { get; set; }
    
    
    }
    
    /// <summary>This condition is used to match URIs(Uniform Resource Identifier) of HTTP
    /// request messages. The URI field can be specified as a regular expression.
    /// If an HTTP request message is requesting an URI which matches specified
    /// regular expression, it matches the condition.
    /// The syntax of whole URI looks like this:
    /// scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]
    /// This condition matches only the path part of entire URI.
    /// When match_type field is specified as REGEX, the uri field is used as a
    /// regular expression to match URI path of HTTP requests. For example, to
    /// match any URI that has "/image/" or "/images/", uri field can be specified
    /// as: "/image[s]?/".
    /// Named capturing groups can be used in the uri field to capture substrings
    /// of matched URIs and store them in variables for use in LBRuleAction. For
    /// example, specify uri field as:
    /// "/news/(?&amp;lt;year&amp;gt;\d+)/(?&amp;lt;month&amp;gt;\d+)/(?&amp;lt;article&amp;gt;.*)"
    /// If the URI path is /articles/news/2017/06/xyz.html, then substring "2017"
    /// is captured in variable year, "06" is captured in variable month, and
    /// "xyz.html" is captured in variable article. These variables can then
    /// be used in an LBRuleAction field which supports variables, such as uri
    /// field of LBHttpRequestUriRewriteAction. For example, set the uri field
    /// of LBHttpRequestUriRewriteAction as:
    /// "/articles/news/$year-$month-$article"
    /// Then the URI path /articles/news/2017/06/xyz.html is rewritten to:
    /// "/articles/news/2017-06-xyz.html"
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBHttpRequestUriCondition : LBRuleCondition
    {
        /// <summary>Match type of URI</summary>
        [Newtonsoft.Json.JsonProperty("match_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBHttpRequestUriConditionMatch_type? Match_type { get; set; } = SDKGenerator.LBHttpRequestUriConditionMatch_type.REGEX;
    
        /// <summary>A string used to identify resource</summary>
        [Newtonsoft.Json.JsonProperty("uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Uri { get; set; }
    
        /// <summary>If true, case is significant when comparing URI.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("case_sensitive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Case_sensitive { get; set; } = true;
    
    
    }
    
    /// <summary>Child wrapper for ALBWafCRS, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBWafCRS : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBWafCRS object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBWafCRS", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBWafCRS ALBWafCRS { get; set; }
    
    
    }
    
    /// <summary>An identity source service that runs OpenLDAP. The service allows selected user accounts defined in OpenLDAP to log into and access NSX-T.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OpenLdapIdentitySource : LdapIdentitySource
    {
    
    }
    
    /// <summary>Patch Resources is an action to create/patch resources in response to an event.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PatchResources : Action
    {
        /// <summary>Injections holding keys (variables) and their corresponding values.</summary>
        [Newtonsoft.Json.JsonProperty("injections", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<Injection> Injections { get; set; }
    
        /// <summary>Patch body representing a Hierarchical Patch payload. The resources included in the body
        /// are patched replacing the injections' keys with their actual values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("body", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object Body { get; set; } = new object();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FieldsFilterData : LiveTraceFilterData
    {
        /// <summary>IP address information</summary>
        [Newtonsoft.Json.JsonProperty("ip_info", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IpInfo Ip_info { get; set; }
    
        /// <summary>Transport layer information</summary>
        [Newtonsoft.Json.JsonProperty("transport_info", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TransportInfo Transport_info { get; set; }
    
    
    }
    
    /// <summary>Multicast Routes.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyMulticastRoutes 
    {
        /// <summary>Policy path to Tier0 gateway.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gateway_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Gateway_path { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mcast_routes_per_edge", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MulticastRoutesPerEdge> Mcast_routes_per_edge { get; set; }
    
    
    }
    
    /// <summary>List of MAC Addresses.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MACAddressList 
    {
        /// <summary>The array contains MAC addresses.</summary>
        [Newtonsoft.Json.JsonProperty("mac_addresses", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(4000)]
        public System.Collections.Generic.ICollection<string> Mac_addresses { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>A draft which stores the system generated as well as user intended changes
    /// in a hierarchical body format.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyDraft : PolicyConfigResource
    {
        /// <summary>When specified, a manual draft will be created w.r.t. the specified
        /// draft. If not specified, manual draft will be created w.r.t. the
        /// current published configuration.
        /// For an auto draft, this will always be null.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ref_draft_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ref_draft_path { get; set; }
    
        /// <summary>Comments for a policy draft lock/unlock.</summary>
        [Newtonsoft.Json.JsonProperty("lock_comments", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lock_comments { get; set; }
    
        /// <summary>Indicates whether a draft should be locked. If the draft is locked by
        /// an user, then no other user would be able to modify or publish this
        /// draft. Once the user releases the lock, other users can then modify
        /// or publish this draft.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("locked", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Locked { get; set; } = false;
    
        /// <summary>These are user defined configuration changes, which are applicable only
        /// in case of manual drafts. During the publish of a draft, system_area
        /// changes gets applied first, and then these changes.
        /// The value must be in a hierarchical body format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("user_area", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Infra User_area { get; set; }
    
        /// <summary>ID of the user who last modified the lock for a policy draft.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lock_modified_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lock_modified_by { get; set; }
    
        /// <summary>In case of a large draft, wherein the size of user_area is so big
        /// that it can not be stored into one draft object, the data is then gets
        /// stored into multiple chunks in a draft data store.
        /// This value represents the ID of that data store.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("user_area_store_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User_area_store_id { get; set; }
    
        /// <summary>In case of a large draft, wherein the size of system_area is so big
        /// that it can not be stored into one draft object, the data is then gets
        /// stored into multiple chunks in a draft data store.
        /// This value represents the ID of that data store.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("system_area_store_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string System_area_store_id { get; set; }
    
        /// <summary>Policy draft locked/unlocked time in epoch milliseconds.</summary>
        [Newtonsoft.Json.JsonProperty("lock_modified_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Lock_modified_time { get; set; }
    
        /// <summary>Configuration changes against the current configuration,
        /// tracked by the system.
        /// The value is stored in a hierarchical body format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("system_area", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Infra System_area { get; set; }
    
        /// <summary>Flag to indicate whether draft is auto created.
        /// True indicates that the draft is an auto draft.
        /// False indicates that the draft is a manual draft.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_auto_draft", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_auto_draft { get; set; } = false;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentPortMacAddressListResult : ListResult
    {
        /// <summary>Timestamp when the data was last updated; unset if data source has never updated the data.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SegmentPortMacTableEntry> Results { get; set; }
    
        /// <summary>Transport node identifier</summary>
        [Newtonsoft.Json.JsonProperty("transport_node_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_node_id { get; set; }
    
    
    }
    
    /// <summary>Aggregate of L2Vpn peer config across Enforcement Points.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregateL2VpnPeerConfig 
    {
        /// <summary>List of L2Vpn peer config per Enforcement Point.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("l2vpn_peer_config_per_enforcement_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<L2VpnPeerConfigPerEnforcementPoint> L2vpn_peer_config_per_enforcement_point { get; set; }
    
        /// <summary>Policy path referencing the L2Vpn.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("l2vpn_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string L2vpn_path { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsRateLimiter object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsRateLimiter 
    {
        /// <summary>Action to perform upon rate limiting.</summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBDnsRuleRLAction Action { get; set; } = new ALBDnsRuleRLAction();
    
        /// <summary>Rate limiting object.</summary>
        [Newtonsoft.Json.JsonProperty("rate_limiter_object", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBRateLimiter Rate_limiter_object { get; set; } = new ALBRateLimiter();
    
    
    }
    
    /// <summary>Resource Field Pointer representing the exact value within a policy object.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ResourceFieldPointer 
    {
        /// <summary>Policy Path referencing a policy object. If not supplied, the field pointer will be applied
        /// to the event source.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Field Pointer referencing the exact field within the policy object.</summary>
        [Newtonsoft.Json.JsonProperty("field_pointer", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Field_pointer { get; set; }
    
    
    }
    
    /// <summary>A shaper that specifies ingress rate properties in kb/s</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IngressBroadcastRateLimiter : QoSBaseRateLimiter
    {
        /// <summary>Peak bandwidth in kb/s</summary>
        [Newtonsoft.Json.JsonProperty("peak_bandwidth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, int.MaxValue)]
        public long? Peak_bandwidth { get; set; } = 0L;
    
        /// <summary>Average bandwidth in kb/s</summary>
        [Newtonsoft.Json.JsonProperty("average_bandwidth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, int.MaxValue)]
        public long? Average_bandwidth { get; set; } = 0L;
    
        /// <summary>Burst size in bytes</summary>
        [Newtonsoft.Json.JsonProperty("burst_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, int.MaxValue)]
        public long? Burst_size { get; set; } = 0L;
    
    
    }
    
    /// <summary>Child wrapper object for SegmentQoSProfileBindingMap, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildSegmentQoSProfileBindingMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual SegmentQoSProfileBindingMap object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("SegmentQoSProfileBindingMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SegmentQoSProfileBindingMap SegmentQoSProfileBindingMap { get; set; }
    
    
    }
    
    /// <summary>Session statistics gives VPN session status and traffic statistics per segment.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VpnSessionStatistics : L2VpnStatisticsPerEnforcementPoint
    {
        /// <summary>Traffic statistics per segment.</summary>
        [Newtonsoft.Json.JsonProperty("traffic_statistics_per_segment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<L2VpnPerSegmentTrafficStatistics> Traffic_statistics_per_segment { get; set; }
    
        /// <summary>Tunnel port traffic counters.</summary>
        [Newtonsoft.Json.JsonProperty("tap_traffic_counters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<L2VpnTapTrafficStatistics> Tap_traffic_counters { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer URIParamQuery object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBURIParamQuery 
    {
        /// <summary>Use or drop the query of the incoming request URI in the
        /// request URI to the backend server.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keep_query", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Keep_query { get; set; } = true;
    
        /// <summary>Concatenate a string to the query of the incoming request
        /// URI and then use it in the request URI going to the backend
        /// server.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("add_string", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Add_string { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LiveTraceStatus : ManagedResource
    {
        /// <summary>Packet filter for flows of interest</summary>
        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LiveTraceFilterData Filter { get; set; }
    
        /// <summary>The operation state of live trace.
        /// IN_PROGRESS - collecting the session results.
        /// FINISHED - session results collect complete.
        /// PARTIAL_FINISHED - some ssession results may be lost.
        /// CANCELED - session cancelled by exception.
        /// TIMEOUT - session result is incomplete until timeout.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("operation_state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LiveTraceStatusOperation_state? Operation_state { get; set; }
    
        /// <summary>Timeout in seconds for livetrace session</summary>
        [Newtonsoft.Json.JsonProperty("timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(5D, 300D)]
        public long? Timeout { get; set; }
    
        /// <summary>The source logical port</summary>
        [Newtonsoft.Json.JsonProperty("source_lport", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source_lport { get; set; }
    
        /// <summary>The status of a live trace request.
        /// SUCCESS_DELIVERED - The request is delivered successfully.
        /// LCP_FAILURE - nsx-cfgagent fails to realize the request.
        /// INVALID_FILTER - filter data invalid.
        /// DATAPATH_FAILURE - DP fails to realize the request.
        /// TIMEOUT - The response to the request is not received within timeout.
        /// CONNECTION_ERROR - There is connection error with host component.
        /// UNKNOWN - The status of request cannot be determined.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("request_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LiveTraceStatusRequest_status? Request_status { get; set; }
    
        /// <summary>Action to the filtered packet</summary>
        [Newtonsoft.Json.JsonProperty("actions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LiveTraceActionConfig Actions { get; set; }
    
    
    }
    
    /// <summary>Neighbor discovery protocol header</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class NdpHeader 
    {
        /// <summary>The IP address of the destination of the solicitation. It MUST NOT be a multicast address.</summary>
        [Newtonsoft.Json.JsonProperty("dst_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dst_ip { get; set; }
    
        /// <summary>This field specifies the type of the Neighbor discover message being sent. NEIGHBOR_SOLICITATION - Neighbor Solicitation message to discover the link-layer address of an on-link IPv6 node or to confirm a previously determined link-layer address. NEIGHBOR_ADVERTISEMENT - Neighbor Advertisement message in response to a Neighbor Solicitation message.</summary>
        [Newtonsoft.Json.JsonProperty("msg_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public NdpHeaderMsg_type? Msg_type { get; set; } = SDKGenerator.NdpHeaderMsg_type.NEIGHBOR_SOLICITATION;
    
    
    }
    
    /// <summary>Wrapper object for FirewallConfiguration</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildDfwFirewallConfiguration : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual dfw firewall configuration list object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("DfwFirewallConfiguration", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public DfwFirewallConfiguration DfwFirewallConfiguration { get; set; }
    
    
    }
    
    /// <summary>Details of infrastructure hosting the container cluster
    /// e.g. vSphere, AWS, VMC etc..
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ContainerInfrastructureInfo 
    {
        /// <summary>Type of the infrastructure.</summary>
        [Newtonsoft.Json.JsonProperty("infra_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ContainerInfrastructureInfoInfra_type Infra_type { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AdvanceClusterRestoreRequest 
    {
        /// <summary>List of instructions and their associated data</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<AdvanceClusterRestoreInput> Data { get; set; } = new System.Collections.ObjectModel.Collection<AdvanceClusterRestoreInput>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class UdpHeader 
    {
        /// <summary>Source port of udp header</summary>
        [Newtonsoft.Json.JsonProperty("src_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Src_port { get; set; } = 0L;
    
        /// <summary>Destination port of udp header</summary>
        [Newtonsoft.Json.JsonProperty("dst_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Dst_port { get; set; } = 0L;
    
    
    }
    
    /// <summary>Service Chain Mapping List</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServiceChainMappingListResult : ListResult
    {
        /// <summary>List of the Service Chain Mappings. The list has to be homogenous.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ServiceChainMapping> Results { get; set; }
    
    
    }
    
    /// <summary>DNS forwarder nslookup answer per enforcement point.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("NsxTDnsAnswer", typeof(NsxTDnsAnswer))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyDnsAnswerPerEnforcementPoint 
    {
        /// <summary>Policy path referencing the enforcement point from where the
        /// DNS forwarder nslookup answer is fetched.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enforcement_point_path { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer AutoScaleLaunchConfig object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAutoScaleLaunchConfig : PolicyConfigResource
    {
        /// <summary>Unique ID of the Amazon Machine Image (AMI)  or OpenStack
        /// VM ID.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("image_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Image_id { get; set; }
    
        /// <summary>If set to True, ServerAutoscalePolicy will use the
        /// autoscaling group (external_autoscaling_groups) from Pool to
        /// perform scale up and scale down.
        /// Pool should have single autoscaling group configured.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("use_external_asg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Use_external_asg { get; set; } = true;
    
        /// <summary>Placeholder for description of property mesos of obj type
        /// AutoScaleLaunchConfig field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mesos", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBAutoScaleMesosSettings Mesos { get; set; }
    
        /// <summary>Placeholder for description of property openstack of obj
        /// type AutoScaleLaunchConfig field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("openstack", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBAutoScaleOpenStackSettings Openstack { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for L2BridgeEndpointProfile, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildL2BridgeEndpointProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual L2BridgeEndpointProfile object</summary>
        [Newtonsoft.Json.JsonProperty("L2BridgeEndpointProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public L2BridgeEndpointProfile L2BridgeEndpointProfile { get; set; }
    
    
    }
    
    /// <summary>DHCP server configuration.
    /// Please note, the realized-state of this entity returned by the
    /// "GET /policy/api/v1/infra/realized-state/realized-entity" with this entity
    /// policy-path is irrelevant with the application status of this entity.
    /// Please do not rely on this returned realized-state to determine how this
    /// dhcp-server-config was applied. The dhcp realization information was
    /// reflected in the realization states of the referencing Segment or T0/T1
    /// gateway.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DhcpServerConfig : PolicyConfigResource
    {
        /// <summary>DHCP server address in CIDR format. Both IPv4 and IPv6 address families
        /// are supported.
        /// Prefix length should be less than or equal to 30 for IPv4 address
        /// family and less than or equal to 126 for IPv6.
        /// When not specified, IPv4 value is auto-assigned to 100.96.0.1/30.
        /// Ignored when this object is configured at a Segment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server_addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(2)]
        public System.Collections.Generic.ICollection<string> Server_addresses { get; set; }
    
        /// <summary>Policy paths to edge nodes on which the DHCP servers run. The first edge node
        /// is assigned as active edge, and second one as stanby edge. If only one edge node
        /// is specified, the DHCP servers will run without HA support.
        /// When this property is not specified, edge nodes are auto-assigned during
        /// realization of the DHCP server.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preferred_edge_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(2)]
        public System.Collections.Generic.ICollection<string> Preferred_edge_paths { get; set; }
    
        /// <summary>DHCP server address in CIDR format. Prefix length should be less than
        /// or equal to 30. DHCP server is deployed as DHCP relay service.
        /// This property is deprecated, use server_addresses instead. Both
        /// properties cannot be specified together with different new values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Server_address { get; set; }
    
        /// <summary>Edge cluster path. Auto assigned if only one edge cluster is configured
        /// on enforcement-point.
        /// Modifying edge cluster will reallocate DHCP server to the new edge cluster.
        /// Please note that re-allocating edge-cluster will result in losing of all exisitng
        /// DHCP lease information.
        /// Change edge cluster only when losing DHCP leases is not a real problem,
        /// e.g. cross-site migration or failover and all client hosts will be reboot and
        /// get new IP addresses.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_cluster_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Edge_cluster_path { get; set; }
    
        /// <summary>IP address lease time in seconds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lease_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(60D, 4294967295D)]
        public long? Lease_time { get; set; } = 86400L;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CapacityDashboardUsage 
    {
        /// <summary>Indicate the current usage count of object type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_usage_count", Required = Newtonsoft.Json.Required.Always)]
        public long Current_usage_count { get; set; }
    
        /// <summary>This indicates the maximum threshold percentage for object type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_threshold_percentage", Required = Newtonsoft.Json.Required.Always)]
        public double Max_threshold_percentage { get; set; }
    
        /// <summary>Display name for NSX object type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Display_name { get; set; }
    
        /// <summary>Severity calculated from percentage usage
        /// </summary>
        [Newtonsoft.Json.JsonProperty("severity", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CapacityDashboardUsageSeverity Severity { get; set; }
    
        /// <summary>This is the maximum supported count for object type in consideration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_supported_count", Required = Newtonsoft.Json.Required.Always)]
        public long Max_supported_count { get; set; }
    
        /// <summary>Indicate the object type for which usage is calculated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("usage_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Usage_type { get; set; }
    
        /// <summary>This indicates the minimum threshold percentage for object type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("min_threshold_percentage", Required = Newtonsoft.Json.Required.Always)]
        public double Min_threshold_percentage { get; set; }
    
        /// <summary>Current usage percentage for object type
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_usage_percentage", Required = Newtonsoft.Json.Required.Always)]
        public double Current_usage_percentage { get; set; }
    
    
    }
    
    /// <summary>Ordered list of rules long with the path of PolicyServiceInstance
    /// to which the traffic needs to be redirected. |
    /// Please note that the scope property must be provided for NS redirection |
    /// policy if redirect to is a service chain. For NS, when redirect to is not |
    /// to the service chain, and scope is specified on RedirectionPolicy, it |
    /// will be ignored. The scope will be determined from redirect to path |
    /// instead. For EW policy, scope must not be  supplied in the request. |
    /// Path to either Tier0 or Tier1 is allowed as the scope. Only 1 path |
    /// can be specified as a scope. |
    /// Also, note that, if stateful flag is not sent, it will be treated as true.
    /// If statelessness is intended, false must be sent explicitly as the value |
    /// for stateful field.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RedirectionPolicy : Policy
    {
        /// <summary>Redirection rules that are a part of this RedirectionPolicy. At
        /// max, there can be 1000 rules in a given RedirectPolicy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1000)]
        public System.Collections.Generic.ICollection<RedirectionRule> Rules { get; set; }
    
        /// <summary>This is the read only flag which will state the direction of this |
        /// redirection policy. True denotes that it is NORTH-SOUTH and false |
        /// value means it is an EAST-WEST redirection policy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("north_south", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? North_south { get; set; }
    
        /// <summary>Paths to which traffic will be redirected to. As of now, only 1 is |
        /// supported. Paths allowed are |
        /// 1. Policy Service Instance |
        /// 2. Service Instance Endpoint |
        /// 3. Virtual Endpoint |
        /// 4. Policy Service Chain
        /// </summary>
        [Newtonsoft.Json.JsonProperty("redirect_to", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Redirect_to { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer WafDataFile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWafDataFile 
    {
        /// <summary>WAF data file type.
        /// Enum options - WAF_DATAFILE_PM_FROM_FILE, WAF_DATAFILE_DTD,
        /// WAF_DATAFILE_XSD.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as WAF_DATAFILE_PM_FROM_FILE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBWafDataFileType? Type { get; set; } = SDKGenerator.ALBWafDataFileType.WAF_DATAFILE_PM_FROM_FILE;
    
        /// <summary>Stringified WAF File Data.</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Data { get; set; }
    
        /// <summary>WAF Data File Name.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of security policies</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyListResult : ListResult
    {
    
    }
    
    /// <summary>Remote Macs of L2Vpn Session on NsxT.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VpnSessionRemoteMacNsxT : L2VpnSessionRemoteMacPerEP
    {
        /// <summary>Display name of L2Vpn session.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Display_name { get; set; }
    
        /// <summary>List of mac addresses of logical switches
        /// for an l2vpn session.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remote_macs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<L2VpnSessionRemoteMacForSegment> Remote_macs { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer PortRange object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBPortRange 
    {
        /// <summary>TCP/UDP port range start (inclusive).
        /// Allowed values are 1-65535.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long Start { get; set; }
    
        /// <summary>TCP/UDP port range end (inclusive).
        /// Allowed values are 1-65535.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("end", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long End { get; set; }
    
    
    }
    
    /// <summary>Details of the instructions displayed during restore process</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class InstructionInfo 
    {
        /// <summary>A list of fields that are displayable to users in a table</summary>
        [Newtonsoft.Json.JsonProperty("fields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Fields { get; set; }
    
        /// <summary>UUID of the instruction</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
        /// <summary>A list of actions that are to be applied to resources</summary>
        [Newtonsoft.Json.JsonProperty("actions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Actions { get; set; }
    
        /// <summary>Instruction name</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of LBVirtualServerStatusPerEP</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregateLBVirtualServerStatus : AggregatePolicyRuntimeInfo
    {
        /// <summary>LBVirtualServerStatusPerEP list results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBVirtualServerStatusPerEP> Results { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBPoolMemberStatus 
    {
        /// <summary>UP means that pool member is enabled and monitors have marked the pool
        /// member as UP. If the pool member has no monitor configured, it would
        /// be treated as UP.
        /// DOWN means that pool member is enabled and monitors have marked the
        /// pool member as DOWN.
        /// DISABLED means that admin state of pool member is set to DISABLED.
        /// GRACEFUL_DISABLED means that admin state of pool member is set to
        /// GRACEFUL_DISABLED.
        /// UNUSED means that the pool member is not used when the IP list size
        /// of member group exceeds the maximum setting. The remaining IP addresses
        /// would not be used as available backend servers, hence mark the status
        /// as UNUSED.
        /// UNKNOWN means that the related pool is not associated to any enabled
        /// virtual servers, or no status reported from transport-nodes, the
        /// associated load balancer service may be working(or not working).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBPoolMemberStatusStatus? Status { get; set; }
    
        /// <summary>If multiple active monitors are configured, the failure_cause contains
        /// failure cause for each monitors. Like "Monitor_1:failure_cause_1.
        /// Monitor_2:failure_cause_2."
        /// </summary>
        [Newtonsoft.Json.JsonProperty("failure_cause", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Failure_cause { get; set; }
    
        /// <summary>If multiple active monitors are configured, the property value is the
        /// latest last_check_time among all the monitors.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("last_check_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_check_time { get; set; }
    
        /// <summary>Pool member IP address.</summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ip_address { get; set; }
    
        /// <summary>If multiple active monitors are configured, the property value is the
        /// latest last_state_change_time among all the monitors.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("last_state_change_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_state_change_time { get; set; }
    
        /// <summary>The port is configured in pool member. For virtual server port range
        /// case, pool member port must be null.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Port { get; set; }
    
    
    }
    
    /// <summary>Ordered list of Rules. This object is created by default along with the Domain.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Policy : PolicyConfigResource
    {
        /// <summary>- Distributed Firewall -
        /// Policy framework provides five pre-defined categories for classifying
        /// a security policy. They are "Ethernet","Emergency", "Infrastructure"
        /// "Environment" and "Application". There is a pre-determined order in
        /// which the policy framework manages the priority of these security
        /// policies. Ethernet category is for supporting layer 2 firewall rules.
        /// The other four categories are applicable for layer 3 rules. Amongst
        /// them, the Emergency category has the highest priority followed by
        /// Infrastructure, Environment and then Application rules. Administrator
        /// can choose to categorize a security policy into the above categories
        /// or can choose to leave it empty. If empty it will have the least
        /// precedence w.r.t the above four categories.
        /// - Edge Firewall -
        /// Policy Framework for Edge Firewall provides six pre-defined categories
        /// "Emergency", "SystemRules", "SharedPreRules", "LocalGatewayRules",
        /// "AutoServiceRules" and "Default", in order of priority of rules.
        /// All categories are allowed for Gatetway Policies that belong
        /// to 'default' Domain. However, for user created domains, category is
        /// restricted to "SharedPreRules" or "LocalGatewayRules" only. Also, the
        /// users can add/modify/delete rules from only the "SharedPreRules" and
        /// "LocalGatewayRules" categories. If user doesn't specify the category
        /// then defaulted to "Rules". System generated category is used by NSX
        /// created rules, for example BFD rules. Autoplumbed category used by
        /// NSX verticals to autoplumb data path rules. Finally, "Default" category
        /// is the placeholder default rules with lowest in the order of priority.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Category { get; set; }
    
        /// <summary>A flag to indicate whether policy is a default policy.</summary>
        [Newtonsoft.Json.JsonProperty("is_default", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_default { get; set; }
    
        /// <summary>Indicates whether a security policy should be locked. If the
        /// security policy is locked by a user, then no other user would
        /// be able to modify this security policy. Once the user releases
        /// the lock, other users can update this security policy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("locked", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Locked { get; set; } = false;
    
        /// <summary>ID of the user who last modified the lock for the secruity policy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lock_modified_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lock_modified_by { get; set; }
    
        /// <summary>SecurityPolicy locked/unlocked time in epoch milliseconds.</summary>
        [Newtonsoft.Json.JsonProperty("lock_modified_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Lock_modified_time { get; set; }
    
        /// <summary>The count of rules in the policy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rule_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Rule_count { get; set; }
    
        /// <summary>Comments for security policy lock/unlock.</summary>
        [Newtonsoft.Json.JsonProperty("comments", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Comments { get; set; }
    
        /// <summary>This field is to indicate the internal sequence number of a policy
        /// with respect to the policies across categories.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("internal_sequence_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Internal_sequence_number { get; set; }
    
        /// <summary>Stateful or Stateless nature of security policy is enforced on all
        /// rules in this security policy. When it is stateful, the state of
        /// the network connects are tracked and a stateful packet inspection is
        /// performed.
        /// Layer3 security policies can be stateful or stateless. By default, they are stateful.
        /// Layer2 security policies can only be stateless.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stateful", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Stateful { get; set; }
    
        /// <summary>Provides a mechanism to apply the rules in this policy for a specified
        /// time duration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scheduler_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Scheduler_path { get; set; }
    
        /// <summary>Ensures that a 3 way TCP handshake is done before the data packets
        /// are sent.
        /// tcp_strict=true is supported only for stateful security policies.
        /// If the tcp_strict flag is not specified and the security policy
        /// is stateful, then tcp_strict will be set to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tcp_strict", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Tcp_strict { get; set; }
    
        /// <summary>The list of group paths where the rules in this policy will get
        /// applied. This scope will take precedence over rule level scope.
        /// Supported only for security and redirection policies. In case of
        /// RedirectionPolicy, it is expected only when the policy is NS and
        /// redirecting to service chain.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<string> Scope { get; set; }
    
        /// <summary>This field is used to resolve conflicts between security policies
        /// across domains. In order to change the sequence number of a policy
        /// one can fire a POST request on the policy entity with
        /// a query parameter action=revise
        /// The sequence number field will reflect the value of the computed
        /// sequence number upon execution of the above mentioned POST request.
        /// For scenarios where the administrator is using a template to update
        /// several security policies, the only way to set the sequence number is
        /// to explicitly specify the sequence number for each security policy.
        /// If no sequence number is specified in the payload, a value of 0 is
        /// assigned by default. If there are multiple policies with the same
        /// sequence number then their order is not deterministic. If a specific
        /// order of policies is desired, then one has to specify unique sequence
        /// numbers or use the POST request on the policy entity with
        /// a query parameter action=revise to let the framework assign a
        /// sequence number.
        /// The value of sequence number must be between 0 and 999,999.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sequence_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, int.MaxValue)]
        public long? Sequence_number { get; set; }
    
    
    }
    
    /// <summary>Aggregate statistics of all the rules in a security policy.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SecurityPolicyStatistics 
    {
        /// <summary>Realized id of the section on NSX MP. Policy Manager can create more than
        /// one section per SecurityPolicy, in which case this identifier helps to
        /// distinguish between the multiple sections created.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("internal_section_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Internal_section_id { get; set; }
    
        /// <summary>Total count for rule statistics</summary>
        [Newtonsoft.Json.JsonProperty("result_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Result_count { get; set; }
    
        /// <summary>List of rule statistics.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1000)]
        public System.Collections.Generic.ICollection<RuleStatistics> Results { get; set; }
    
        /// <summary>Path of the LR on which the section is applied in case of Gateway Firewall.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lr_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lr_path { get; set; }
    
    
    }
    
    /// <summary>HardwareSecurityModuleGroupApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHardwareSecurityModuleGroupApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of HardwareSecurityModuleGroup
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBHardwareSecurityModuleGroup> Results { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TlsTrustData : PolicyConfigResource
    {
        /// <summary>Key algorithm contained in this certificate.</summary>
        [Newtonsoft.Json.JsonProperty("key_algo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key_algo { get; set; }
    
        /// <summary>private key data</summary>
        [Newtonsoft.Json.JsonProperty("private_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Private_key { get; set; }
    
        /// <summary>Password for private key encryption.</summary>
        [Newtonsoft.Json.JsonProperty("passphrase", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Passphrase { get; set; }
    
        /// <summary>pem encoded certificate data.</summary>
        [Newtonsoft.Json.JsonProperty("pem_encoded", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Pem_encoded { get; set; }
    
    
    }
    
    /// <summary>Backup operation status</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BackupOperationStatus 
    {
        /// <summary>Unique identifier of a backup</summary>
        [Newtonsoft.Json.JsonProperty("backup_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Backup_id { get; set; }
    
        /// <summary>Time when operation was ended</summary>
        [Newtonsoft.Json.JsonProperty("end_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? End_time { get; set; }
    
        /// <summary>True if backup is successfully completed, else false</summary>
        [Newtonsoft.Json.JsonProperty("success", Required = Newtonsoft.Json.Required.Always)]
        public bool Success { get; set; }
    
        /// <summary>Time when operation was started</summary>
        [Newtonsoft.Json.JsonProperty("start_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Start_time { get; set; }
    
        /// <summary>Error code details</summary>
        [Newtonsoft.Json.JsonProperty("error_message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error_message { get; set; }
    
        /// <summary>Error code</summary>
        [Newtonsoft.Json.JsonProperty("error_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BackupOperationStatusError_code? Error_code { get; set; }
    
    
    }
    
    /// <summary>Identity Firewall user session data on a client machine (typically a VM).
    /// Multiple entries for the same user can be returned if the user logins to
    /// multiple sessions on the same VM.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdfwUserSessionData 
    {
        /// <summary>AD user ID (may not exist).</summary>
        [Newtonsoft.Json.JsonProperty("user_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User_id { get; set; }
    
        /// <summary>User session ID.  This also indicates whether this is VDI / RDSH.</summary>
        [Newtonsoft.Json.JsonProperty("user_session_id", Required = Newtonsoft.Json.Required.Always)]
        public long User_session_id { get; set; }
    
        /// <summary>Virtual machine (external ID or BIOS UUID) where login/logout events occurred.</summary>
        [Newtonsoft.Json.JsonProperty("vm_ext_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Vm_ext_id { get; set; }
    
        /// <summary>Identifier of user session data.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
        /// <summary>Login time.</summary>
        [Newtonsoft.Json.JsonProperty("login_time", Required = Newtonsoft.Json.Required.Always)]
        public long Login_time { get; set; }
    
        /// <summary>AD user name.</summary>
        [Newtonsoft.Json.JsonProperty("user_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string User_name { get; set; }
    
        /// <summary>Logout time if applicable.  An active user session has no logout time.
        /// Non-active user session is stored (up to last 5 most recent entries) per
        /// VM and per user.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("logout_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Logout_time { get; set; }
    
        /// <summary>AD Domain of user.</summary>
        [Newtonsoft.Json.JsonProperty("domain_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Domain_name { get; set; }
    
    
    }
    
    /// <summary>Contains IPv4 related discovery options.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPv4DiscoveryOptions 
    {
        /// <summary>Indicates whether fetching IP using vm-tools is enabled.
        /// This option is only supported on ESX where vm-tools is installed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vmtools_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Vmtools_enabled { get; set; } = true;
    
        /// <summary>Indicates whether DHCP snooping is enabled</summary>
        [Newtonsoft.Json.JsonProperty("dhcp_snooping_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Dhcp_snooping_enabled { get; set; } = true;
    
        /// <summary>Indicates ARP snooping options</summary>
        [Newtonsoft.Json.JsonProperty("arp_snooping_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ArpSnoopingConfig Arp_snooping_config { get; set; }
    
    
    }
    
    /// <summary>Service Segment configuration to attach Service Insertion VM.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServiceSegment : PolicyConfigResource
    {
        /// <summary>Policy path to transport zone. Only overlay transport zone is supported.</summary>
        [Newtonsoft.Json.JsonProperty("transport_zone_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Transport_zone_path { get; set; }
    
        /// <summary>Policy paths of logical routers or ports | to which this Service Segment can be connected.</summary>
        [Newtonsoft.Json.JsonProperty("lr_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Lr_paths { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentConfigurationStateListResult : ListResult
    {
        /// <summary>Paged Collection of Segment State on specific Enforcement Point</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SegmentConfigurationState> Results { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for GroupMonitoringProfileBindingMap, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildGroupMonitoringProfileBindingMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual GroupMonitoringProfileBindingMap object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("GroupMonitoringProfileBindingMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public GroupMonitoringProfileBindingMap GroupMonitoringProfileBindingMap { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBServiceInstanceDetail 
    {
        /// <summary>The path of the resource which the load balancer instance deploys on.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("attachment_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Attachment_path { get; set; }
    
        /// <summary>The display name of the resource which the load balancer instance
        /// deploys on.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("attachment_display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Attachment_display_name { get; set; }
    
        /// <summary>The error message for the load balancer instance. If the instance
        /// status is NOT_READY, error message will be attached.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("error_message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error_message { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TransportNodeIdParameters : DataSourceParameters
    {
        /// <summary>TransportNode Id</summary>
        [Newtonsoft.Json.JsonProperty("transport_node_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_node_id { get; set; }
    
    
    }
    
    /// <summary>Additional configuration required for federation at Site.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GmFederationSiteConfig 
    {
        /// <summary>IP Addresses to be allocated for transit segment when the gateway is
        /// stretched. Note that Global Manager will carve out the IP Pool for each
        /// site to be used for edge nodes when gateway is stretched based on the
        /// user provided subnet and maximum number of edge nodes allowed per site.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transit_subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transit_subnet { get; set; }
    
    
    }
    
    /// <summary>OSPF router link state details.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MpOspfExternalLinkState 
    {
        /// <summary>LSA age</summary>
        [Newtonsoft.Json.JsonProperty("up_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Up_time { get; set; }
    
        /// <summary>Tag</summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Tag { get; set; }
    
        /// <summary>OSPF advertised router</summary>
        [Newtonsoft.Json.JsonProperty("advertised_router", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Advertised_router { get; set; }
    
        /// <summary>OSPF link id</summary>
        [Newtonsoft.Json.JsonProperty("link_state_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Link_state_id { get; set; }
    
        /// <summary>Type of metric</summary>
        [Newtonsoft.Json.JsonProperty("metric_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Metric_type { get; set; }
    
        /// <summary>Cost of the route</summary>
        [Newtonsoft.Json.JsonProperty("checksum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Checksum { get; set; }
    
        /// <summary>Route with ip address and mask</summary>
        [Newtonsoft.Json.JsonProperty("route", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Route { get; set; }
    
        /// <summary>Sequence number</summary>
        [Newtonsoft.Json.JsonProperty("sequence_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sequence_number { get; set; }
    
    
    }
    
    /// <summary>Alarm associated with the PolicyRuntimeInfoPerEP that exposes
    /// potential errors when retrieving runtime information from the
    /// enforcement point.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyRuntimeAlarm 
    {
        /// <summary>Alarm error id.</summary>
        [Newtonsoft.Json.JsonProperty("error_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error_id { get; set; }
    
        /// <summary>Detailed information about errors from an API call made to the
        /// enforcement point, if any.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("error_details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PolicyApiError Error_details { get; set; }
    
        /// <summary>Error message describing the issue.</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
    
    }
    
    /// <summary>Detailed Realized Status of an Intent on a span of Transport Nodes.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TransportNodeSpanEnforcedStatus : EnforcedStatusPerScopeNsxT
    {
        /// <summary>List of Detailed Realized Status per Transport Node.</summary>
        [Newtonsoft.Json.JsonProperty("enforced_status_per_transport_node", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<EnforcedStatusPerTransportNode> Enforced_status_per_transport_node { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer PlacementNetwork object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBPlacementNetwork 
    {
        /// <summary>It is a reference to an object of type Network.</summary>
        [Newtonsoft.Json.JsonProperty("network_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Network_path { get; set; }
    
        /// <summary>Placeholder for description of property subnet of obj type
        /// PlacementNetwork field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnet", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBIpAddrPrefix Subnet { get; set; } = new ALBIpAddrPrefix();
    
    
    }
    
    /// <summary>Advanced load balancer HTTPApplicationProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPApplicationProfile 
    {
        /// <summary>Enable chunk body merge for chunked transfer encoding
        /// response.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_chunk_merge", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_chunk_merge { get; set; } = true;
    
        /// <summary>The max number of HTTP requests that can be sent over a
        /// Keep-Alive connection.
        /// '0' means unlimited.
        /// Allowed values are 0-1000000.
        /// Special values are 0- 'Unlimited requests on a connection'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 100.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_keepalive_requests", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 1000000D)]
        public long? Max_keepalive_requests { get; set; } = 100L;
    
        /// <summary>Maximum requests per second per URI.
        /// Allowed values are 10-1000.
        /// Special values are 0- 'unlimited'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_rps_uri", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 1000D)]
        public long? Max_rps_uri { get; set; } = 0L;
    
        /// <summary>Forward the Connection  Close header coming from backend
        /// server to the client if connection-switching is enabled,
        /// i.e.
        /// front-end and backend connections are bound together.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fwd_close_hdr_for_bound_connections", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Fwd_close_hdr_for_bound_connections { get; set; } = true;
    
        /// <summary>Send HTTP 'Keep-Alive' header to the client.
        /// By default, the timeout specified in the 'Keep-Alive
        /// Timeout' field will be used unless the 'Use App Keepalive
        /// Timeout' flag is set, in which case the timeout sent by the
        /// application will be honored.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keepalive_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Keepalive_header { get; set; } = false;
    
        /// <summary>Maximum requests per second per client IP and URI.
        /// Allowed values are 10-1000.
        /// Special values are 0- 'unlimited'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_rps_cip_uri", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 1000D)]
        public long? Max_rps_cip_uri { get; set; } = 0L;
    
        /// <summary>Insert an X-Forwarded-Proto header in the request sent to
        /// the server.
        /// When the client connects via SSL, Avi terminates the SSL,
        /// and then forwards the requests to the servers via HTTP, so
        /// the servers can determine the original protocol via this
        /// header.
        /// In this example, the value will be 'https'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("x_forwarded_proto_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? X_forwarded_proto_enabled { get; set; } = false;
    
        /// <summary>Allows HTTP requests, not just TCP connections, to be load
        /// balanced across servers.
        /// Proxied TCP connections to servers may be reused by
        /// multiple clients to improve performance.
        /// Not compatible with Preserve Client IP.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("connection_multiplexing_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Connection_multiplexing_enabled { get; set; } = true;
    
        /// <summary>Enable Websockets proxy for traffic from clients to the
        /// virtual service.
        /// Connections to this VS start in HTTP mode.
        /// If the client requests an Upgrade to Websockets, and the
        /// server responds back with success, then the connection is
        /// upgraded to WebSockets mode.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("websockets_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Websockets_enabled { get; set; } = true;
    
        /// <summary>Enable HTTP request body metrics.
        /// If enabled, requests from clients are parsed and relevant
        /// statistics about them are gathered.
        /// Currently, it processes HTTP POST requests with
        /// Content-Type application/x-www-form-urlencoded or
        /// multipart/form-data, and adds the number of detected
        /// parameters to the l7_client.http_params_count.
        /// This is an experimental feature and it may have performance
        /// impact.
        /// Use it when detailed information about the number of HTTP
        /// POST parameters is needed, e.g.
        /// for WAF sizing.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_request_body_metrics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_request_body_metrics { get; set; } = false;
    
        /// <summary>Enable request body buffering for POST requests.
        /// If enabled, max buffer size is set to lower of 32M or the
        /// value (non-zero) configured in client_max_body_size.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_request_body_buffering", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_request_body_buffering { get; set; } = false;
    
        /// <summary>Inserts HTTP Strict-Transport-Security header in the HTTPS
        /// response.
        /// HSTS can help mitigate man-in-the-middle attacks by telling
        /// browsers that support HSTS that they should only access this
        /// site via HTTPS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hsts_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Hsts_enabled { get; set; } = false;
    
        /// <summary>HTTP Compression settings to use with this HTTP Profile.</summary>
        [Newtonsoft.Json.JsonProperty("compression_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBCompressionProfile Compression_profile { get; set; }
    
        /// <summary>The client's original IP address is inserted into an HTTP
        /// request header sent to the server.
        /// Servers may use this address for logging or other purposes,
        /// rather than Avi's source NAT address used in the Avi to
        /// server IP connection.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("xff_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Xff_enabled { get; set; } = true;
    
        /// <summary>If enabled, an HTTP request on an SSL port will result in
        /// connection close instead of a 400 response.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reset_conn_http_on_ssl_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Reset_conn_http_on_ssl_port { get; set; } = false;
    
        /// <summary>Number of days for which the client should regard this
        /// virtual service as a known HSTS host.
        /// Allowed values are 0-10000.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 365.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hsts_max_age", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 10000D)]
        public long? Hsts_max_age { get; set; } = 365L;
    
        /// <summary>The max idle time allowed between HTTP requests over a
        /// Keep-alive connection.
        /// Allowed values are 10-100000000.
        /// Unit is MILLISECONDS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 30000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keepalive_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(10D, 100000000D)]
        public long? Keepalive_timeout { get; set; } = 30000L;
    
        /// <summary>Specifies whether the client side verification is set to
        /// none, request or require.
        /// Enum options - SSL_CLIENT_CERTIFICATE_NONE,
        /// SSL_CLIENT_CERTIFICATE_REQUEST,
        /// SSL_CLIENT_CERTIFICATE_REQUIRE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// SSL_CLIENT_CERTIFICATE_NONE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ssl_client_certificate_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHTTPApplicationProfileSsl_client_certificate_mode? Ssl_client_certificate_mode { get; set; } = SDKGenerator.ALBHTTPApplicationProfileSsl_client_certificate_mode.SSL_CLIENT_CERTIFICATE_NONE;
    
        /// <summary>When terminating client SSL sessions at Avi, servers may
        /// incorrectly send redirect to clients as HTTP.
        /// This option will rewrite the server's redirect responses
        /// for this virtual service from HTTP to HTTPS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server_side_redirect_to_https", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Server_side_redirect_to_https { get; set; } = false;
    
        /// <summary>Disable strict check between TLS servername and HTTP Host
        /// name.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disable_sni_hostname_check", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Disable_sni_hostname_check { get; set; } = false;
    
        /// <summary>Avi will respond with 100-Continue response if Expect 
        /// 100-Continue header received from client.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("respond_with_100_continue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Respond_with_100_continue { get; set; } = true;
    
        /// <summary>Maximum bad requests per second per client IP and URI.
        /// Allowed values are 10-1000.
        /// Special values are 0- 'unlimited'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_bad_rps_cip_uri", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 1000D)]
        public long? Max_bad_rps_cip_uri { get; set; } = 0L;
    
        /// <summary>The maximum length of time allowed between consecutive read
        /// operations for a client request body.
        /// The value '0' specifies no timeout.
        /// This setting generally impacts the length of time allowed
        /// for a client to send a POST.
        /// Allowed values are 0-100000000.
        /// Unit is MILLISECONDS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 30000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_body_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 100000000D)]
        public long? Client_body_timeout { get; set; } = 30000L;
    
        /// <summary>Mark HTTP cookies as HTTPonly.
        /// This helps mitigate cross site scripting attacks as
        /// browsers will not allow these cookies to be read by third
        /// parties, such as javascript.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("httponly_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Httponly_enabled { get; set; } = false;
    
        /// <summary>Disable keep-alive client side connections for older
        /// browsers based off MS Internet Explorer 6.0 (MSIE6).
        /// For some applications, this might break NTLM authentication
        /// for older clients based off MSIE6.
        /// For such applications, set this option to false to allow
        /// keep-alive connections.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disable_keepalive_posts_msie6", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Disable_keepalive_posts_msie6 { get; set; } = true;
    
        /// <summary>Maximum size in Kbytes of a single HTTP header in the
        /// client request.
        /// Allowed values are 1-64.
        /// Unit is KB.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 12.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_max_header_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 64D)]
        public long? Client_max_header_size { get; set; } = 12L;
    
        /// <summary>Client requests received via HTTP will be redirected to
        /// HTTPS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("http_to_https", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Http_to_https { get; set; } = false;
    
        /// <summary>Maximum bad requests per second per client IP.
        /// Allowed values are 10-1000.
        /// Special values are 0- 'unlimited'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_bad_rps_cip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 1000D)]
        public long? Max_bad_rps_cip { get; set; } = 0L;
    
        /// <summary>Set of match/action rules that govern what happens when the
        /// client certificate request is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ssl_client_certificate_action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBSSLClientCertificateAction Ssl_client_certificate_action { get; set; }
    
        /// <summary>Maximum size in Kbytes of all the client HTTP request
        /// headers.
        /// Allowed values are 1-256.
        /// Unit is KB.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 48.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_max_request_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 256D)]
        public long? Client_max_request_size { get; set; } = 48L;
    
        /// <summary>HTTP Caching config to use with this HTTP Profile.</summary>
        [Newtonsoft.Json.JsonProperty("cache_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHttpCacheConfig Cache_config { get; set; }
    
        /// <summary>Maximum unknown URIs per second.
        /// Allowed values are 10-1000.
        /// Special values are 0- 'unlimited'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_rps_unknown_uri", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 1000D)]
        public long? Max_rps_unknown_uri { get; set; } = 0L;
    
        /// <summary>Insert the 'includeSubdomains' directive in the HTTP
        /// Strict-Transport-Security header.
        /// Adding the includeSubdomains directive signals the
        /// User-Agent that the HSTS Policy applies to this HSTS Host as
        /// well as any subdomains of the host's domain name.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hsts_subdomains_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Hsts_subdomains_enabled { get; set; } = true;
    
        /// <summary>Size of HTTP buffer in kB.
        /// Allowed values are 1-256.
        /// Special values are 0- 'Auto compute the size of buffer'.
        /// Unit is KB.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("http_upstream_buffer_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 256D)]
        public long? Http_upstream_buffer_size { get; set; } = 0L;
    
        /// <summary>Specifies the HTTP/2 specific application profile
        /// parameters.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("http2_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTP2ApplicationProfile Http2_profile { get; set; }
    
        /// <summary>The max allowed length of time between a client
        /// establishing a TCP connection until Avi receives the first
        /// byte of the client's HTTP request.
        /// Allowed values are 10-100000000.
        /// Unit is MILLISECONDS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 30000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("post_accept_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(10D, 100000000D)]
        public long? Post_accept_timeout { get; set; } = 30000L;
    
        /// <summary>The maximum length of time allowed for a client to transmit
        /// an entire request header.
        /// This helps mitigate various forms of SlowLoris attacks.
        /// Allowed values are 10-100000000.
        /// Unit is MILLISECONDS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 10000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_header_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(10D, 100000000D)]
        public long? Client_header_timeout { get; set; } = 10000L;
    
        /// <summary>Mark server cookies with the 'Secure' attribute.
        /// Client browsers will not send a cookie marked as secure
        /// over an unencrypted connection.
        /// If Avi is terminating SSL from clients and passing it as
        /// HTTP to the server, the server may return cookies without
        /// the secure flag set.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secure_cookie_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Secure_cookie_enabled { get; set; } = false;
    
        /// <summary>Maximum size in Kbytes of all the HTTP response headers.
        /// Allowed values are 1-256.
        /// Unit is KB.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 48.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_response_headers_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 256D)]
        public long? Max_response_headers_size { get; set; } = 48L;
    
        /// <summary>Provide a custom name for the X-Forwarded-For header sent
        /// to the servers.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as X-Forwarded-For.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("xff_alternate_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Xff_alternate_name { get; set; } = "X-Forwarded-For";
    
        /// <summary>Maximum requests per second per client IP.
        /// Allowed values are 10-1000.
        /// Special values are 0- 'unlimited'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_rps_cip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 1000D)]
        public long? Max_rps_cip { get; set; } = 0L;
    
        /// <summary>Maximum size for the client request body.
        /// This limits the size of the client data that can be
        /// uploaded/posted as part of a single HTTP Request.
        /// Default 0 =&gt; Unlimited.
        /// Unit is KB.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_max_body_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Client_max_body_size { get; set; } = 0L;
    
        /// <summary>Enable support for fire and forget feature.
        /// If enabled, request from client is forwarded to server even
        /// if client prematurely closes the connection.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_fire_and_forget", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_fire_and_forget { get; set; } = false;
    
        /// <summary>Maximum unknown client IPs per second.
        /// Allowed values are 10-1000.
        /// Special values are 0- 'unlimited'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_rps_unknown_cip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 1000D)]
        public long? Max_rps_unknown_cip { get; set; } = 0L;
    
        /// <summary>Allow use of dot (.) in HTTP header names, for instance
        /// Header.app.special  PickAppVersionX.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allow_dots_in_header_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Allow_dots_in_header_name { get; set; } = false;
    
        /// <summary>Select the PKI profile to be associated with the Virtual
        /// Service.
        /// This profile defines the Certificate Authority and
        /// Revocation List.
        /// It is a reference to an object of type PKIProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pki_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pki_profile_path { get; set; }
    
        /// <summary>Maximum bad requests per second per URI.
        /// Allowed values are 10-1000.
        /// Special values are 0- 'unlimited'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_bad_rps_uri", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 1000D)]
        public long? Max_bad_rps_uri { get; set; } = 0L;
    
        /// <summary>Use 'Keep-Alive' header timeout sent by application instead
        /// of sending the HTTP Keep-Alive Timeout.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("use_app_keepalive_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Use_app_keepalive_timeout { get; set; } = false;
    
    
    }
    
    /// <summary>IPSec VPN session statistics represents statistics on an NSX-T type of enforcement
    /// point. It gives aggregated statistics of all policies for all the tunnels.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnSessionStatisticsNsxT : IPSecVpnSessionStatisticsPerEP
    {
        /// <summary>Traffic statistics for IPSec VPN Ike session.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ike_traffic_statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IPSecVpnIkeTrafficStatistics Ike_traffic_statistics { get; set; }
    
        /// <summary>Display Name of vpn session.</summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Display_name { get; set; }
    
        /// <summary>Gives aggregate traffic statistics across all ipsec tunnels and individual tunnel
        /// statistics.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("policy_statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IpSecVpnPolicyTrafficStatistics> Policy_statistics { get; set; }
    
        /// <summary>Timestamp when the data was last updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>Status for IPSec VPN Ike session UP/DOWN and fail reason if Ike session is down.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ike_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IPSecVpnIkeSessionStatus Ike_status { get; set; }
    
        /// <summary>Aggregate traffic statistics across all ipsec tunnels.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("aggregate_traffic_counters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IPSecVpnTrafficCounters Aggregate_traffic_counters { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for PolicyLbPersistenceProfile, used in hierarchical API
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyLbPersistenceProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyLbPersistenceProfile object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyLbPersistenceProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyLbPersistenceProfile PolicyLbPersistenceProfile { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of TlsCrl</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TlsCrlListResult : ListResult
    {
        /// <summary>TlsCrl list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<TlsCrl> Results { get; set; } = new System.Collections.ObjectModel.Collection<TlsCrl>();
    
    
    }
    
    /// <summary>Represents a list of identity group (Ad group SID) expressions.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdentityGroupExpression : Expression
    {
        /// <summary>This array consists of set of identity group object. All members within this array are implicitly OR'ed together.</summary>
        [Newtonsoft.Json.JsonProperty("identity_groups", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(500)]
        public System.Collections.Generic.ICollection<IdentityGroupInfo> Identity_groups { get; set; } = new System.Collections.ObjectModel.Collection<IdentityGroupInfo>();
    
    
    }
    
    /// <summary>The results of listing LDAP identity sources.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LdapIdentitySourceListResult : ListResult
    {
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LdapIdentitySource> Results { get; set; }
    
    
    }
    
    /// <summary>Pool member group.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBPoolMemberGroup 
    {
        /// <summary>Ip revision filter is used to filter IPv4 or IPv6 addresses from the
        /// grouping object.
        /// If the filter is not specified, both IPv4 and IPv6 addresses would be
        /// used as server IPs.
        /// The link local and loopback addresses would be always filtered out.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip_revision_filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBPoolMemberGroupIp_revision_filter? Ip_revision_filter { get; set; } = SDKGenerator.LBPoolMemberGroupIp_revision_filter.IPV4;
    
        /// <summary>The list is used to show the customized pool member settings. User can
        /// only user pool member action API to update the admin state for a specific
        /// IP address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customized_members", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PoolMemberSetting> Customized_members { get; set; }
    
        /// <summary>The size is used to define the maximum number of grouping object IP
        /// address list. These IP addresses would be used as pool members.
        /// If the grouping object includes more than certain number of
        /// IP addresses, the redundant parts would be ignored and those IP
        /// addresses would not be treated as pool members.
        /// If the size is not specified, one member is budgeted for this dynamic
        /// pool so that the pool has at least one member even if some other
        /// dynamic pools grow beyond the capacity of load balancer service. Other
        /// members are picked according to available dynamic capacity. The unused
        /// members would be set to DISABLED so that the load balancer system
        /// itself is not overloaded during runtime.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_ip_list_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 2147483647D)]
        public long? Max_ip_list_size { get; set; }
    
        /// <summary>Load balancer pool support Group as dynamic pool members.
        /// The IP list of the Group would be used as pool member IP setting.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("group_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Group_path { get; set; }
    
        /// <summary>If port is specified, all connections will be sent to this port.
        /// If unset, the same port the client connected to will be used, it could
        /// be overridden by default_pool_member_ports setting in virtual server.
        /// The port should not specified for multiple ports case.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long? Port { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GatewayQosProfileListResult : ListResult
    {
        /// <summary>Paginated list of GatewayQosProfile</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<GatewayQosProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<GatewayQosProfile>();
    
    
    }
    
    /// <summary>Paged Collection of Redirection Policies</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RedirectionPolicyListResult : PolicyListResult
    {
        /// <summary>Redirection policy list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<RedirectionPolicy> Results { get; set; } = new System.Collections.ObjectModel.Collection<RedirectionPolicy>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OspfRoutesListResultInCsvFormat : CsvListResult
    {
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OspfRouteDetailsInCsvRecord> Results { get; set; }
    
    
    }
    
    /// <summary>A VirtualEndpoint represents an IP (or nexthop) which is outside
    /// SDDC. It represents a redirection target for RedirectionPolicy.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VirtualEndpoint : BaseEndpoint
    {
        /// <summary>One VirtualEndpoint will be created per service name.</summary>
        [Newtonsoft.Json.JsonProperty("service_names", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Service_names { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyTraceflowObservationReceivedLogical : TraceflowObservationReceivedLogical
    {
        /// <summary>The path of the component that received the traceflow packet</summary>
        [Newtonsoft.Json.JsonProperty("component_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Component_path { get; set; }
    
        /// <summary>The path of the segment port or router port at which the traceflow packet was received</summary>
        [Newtonsoft.Json.JsonProperty("segment_port_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Segment_port_path { get; set; }
    
        /// <summary>The path of the source component from which the traceflow packet was received</summary>
        [Newtonsoft.Json.JsonProperty("src_component_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Src_component_path { get; set; }
    
    
    }
    
    /// <summary>Gives the collection of NAT rule statistics per enforcement point.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyNatRuleStatisticsListResult : ListResult
    {
        /// <summary>NAT rules statistics per enforcement point</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyNatRuleStatisticsPerEnforcementPoint> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyNatRuleStatisticsPerEnforcementPoint>();
    
    
    }
    
    /// <summary>Active healthchecks are disabled by default and can be enabled for a
    /// server pool by binding a health monitor to the Group through the LBRule
    /// object. This represents active health monitoring over HTTP.
    /// Active healthchecks are initiated periodically, at a configurable
    /// interval, to each member of the Group. Only if a healthcheck fails
    /// consecutively for a specified number of times (fall_count) to a member will
    /// the member status be marked DOWN. Once a member is DOWN, a specified
    /// number of consecutive successful healthchecks (rise_count) will bring the
    /// member back to UP state. After a healthcheck is initiated, if it does not
    /// complete within a certain period, then also the healthcheck is considered
    /// to be unsuccessful.
    /// Completing a healthcheck within timeout means establishing a connection
    /// (TCP or SSL), if applicable, sending the request and receiving the
    /// response, all within the configured timeout.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBHttpMonitorProfile : LBActiveMonitor
    {
        /// <summary>The HTTP response status code should be a valid HTTP status code.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("response_status_codes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(64)]
        public System.Collections.Generic.ICollection<long> Response_status_codes { get; set; }
    
        /// <summary>The health check method for HTTP monitor type.</summary>
        [Newtonsoft.Json.JsonProperty("request_method", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBHttpMonitorProfileRequest_method? Request_method { get; set; } = SDKGenerator.LBHttpMonitorProfileRequest_method.GET;
    
        /// <summary>String to send as part of HTTP health check request body. Valid only
        /// for certain HTTP methods like POST.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("request_body", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Request_body { get; set; }
    
        /// <summary>If HTTP response body match string (regular expressions not supported)
        /// is specified (using LBHttpMonitor.response_body) then the
        /// healthcheck HTTP response body is matched against the specified string
        /// and server is considered healthy only if there is a match.
        /// If the response body string is not specified, HTTP healthcheck is
        /// considered successful if the HTTP response status code is 2xx, but it
        /// can be configured to accept other status codes as successful.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("response_body", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Response_body { get; set; }
    
        /// <summary>For HTTP active healthchecks, the HTTP request url sent can be
        /// customized and can include query parameters.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("request_url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Request_url { get; set; } = "/";
    
        /// <summary>HTTP request version.</summary>
        [Newtonsoft.Json.JsonProperty("request_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBHttpMonitorProfileRequest_version? Request_version { get; set; } = SDKGenerator.LBHttpMonitorProfileRequest_version.HTTP_VERSION_1_1;
    
        /// <summary>Array of HTTP request headers.</summary>
        [Newtonsoft.Json.JsonProperty("request_headers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LbHttpRequestHeader> Request_headers { get; set; }
    
    
    }
    
    /// <summary>Represents list of features required to view the widget.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FeatureSet 
    {
        /// <summary>List of features required for to view widget.</summary>
        [Newtonsoft.Json.JsonProperty("feature_list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Feature_list { get; set; }
    
        /// <summary>Flag for specifying if permission to all features is required If set to false, then if there is permission for any of the feature from feature list, widget will be available.</summary>
        [Newtonsoft.Json.JsonProperty("require_all_permissions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Require_all_permissions { get; set; }
    
    
    }
    
    /// <summary>Paged collection of PrefixLists</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PrefixListResult : ListResult
    {
        /// <summary>PrefixList results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PrefixList> Results { get; set; } = new System.Collections.ObjectModel.Collection<PrefixList>();
    
    
    }
    
    /// <summary>This action is used to reject HTTP request messages. The specified
    /// reply_status value is used as the status code for the corresponding HTTP
    /// response message which is sent back to client (Normally a browser)
    /// indicating the reason it was rejected. Reference official HTTP status code
    /// list for your specific HTTP version to set the reply_status properly.
    /// LBHttpRejectAction does not support variables.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBHttpRejectAction : LBRuleAction
    {
        /// <summary>HTTP response status code.</summary>
        [Newtonsoft.Json.JsonProperty("reply_status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Reply_status { get; set; }
    
        /// <summary>Response message.</summary>
        [Newtonsoft.Json.JsonProperty("reply_message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Reply_message { get; set; }
    
    
    }
    
    /// <summary>Base QoS Profile Binding Map</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class QoSProfileBindingMap : PolicyConfigResource
    {
    
    }
    
    /// <summary>Advanced load balancer DnsCnameRdata object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsCnameRdata 
    {
        /// <summary>Canonical name.</summary>
        [Newtonsoft.Json.JsonProperty("cname", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Cname { get; set; }
    
    
    }
    
    /// <summary>Represents a service VM implementing a particular service in a service chain</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServicePathHop 
    {
        /// <summary>Indicating whether the corresponding service VM is active or not per DP.</summary>
        [Newtonsoft.Json.JsonProperty("is_active_from_dp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_active_from_dp { get; set; }
    
        /// <summary>Indicating whether the corresponding service VM is active or not per MP.</summary>
        [Newtonsoft.Json.JsonProperty("is_active_from_mp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_active_from_mp { get; set; }
    
        /// <summary>ID of the virtual network interface.</summary>
        [Newtonsoft.Json.JsonProperty("vif", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Vif { get; set; }
    
        /// <summary>MAC address of the virtual network interface.</summary>
        [Newtonsoft.Json.JsonProperty("mac_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Mac_address { get; set; }
    
        /// <summary>Action that will be taken by the corresponding service VM of the hop.</summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ServicePathHopAction? Action { get; set; }
    
        /// <summary>Indicating whether the corresponding service VM is active or not per CCP.</summary>
        [Newtonsoft.Json.JsonProperty("is_active_from_ccp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_active_from_ccp { get; set; }
    
        /// <summary>Indicating the maintenance mode of the corresponding service VM.</summary>
        [Newtonsoft.Json.JsonProperty("in_maintenance_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? In_maintenance_mode { get; set; }
    
        /// <summary>Indicating whether NSH liveness is supported or not by the corresponding service VM.</summary>
        [Newtonsoft.Json.JsonProperty("nsh_liveness_support", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Nsh_liveness_support { get; set; }
    
        /// <summary>Indicating whether service is configured to decrement SI field in NSH metadata.</summary>
        [Newtonsoft.Json.JsonProperty("can_decrement_si", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Can_decrement_si { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer VsVip object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBVsVip : PolicyConfigResource
    {
        /// <summary>Force placement on all Service Engines in the Service
        /// Engine Group (Container clouds only).
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("east_west_placement", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? East_west_placement { get; set; } = false;
    
        /// <summary>List of Virtual Service IPs and other shareable entities.</summary>
        [Newtonsoft.Json.JsonProperty("vip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBVip> Vip { get; set; }
    
        /// <summary>This sets the placement scope of virtualservice to given
        /// tier1 logical router in Nsx-t.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tier1_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tier1_path { get; set; }
    
        /// <summary>Checksum of cloud configuration for VsVip.
        /// Internally set by cloud connector.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vsvip_cloud_config_cksum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Vsvip_cloud_config_cksum { get; set; }
    
        /// <summary>Service discovery specific data including fully qualified
        /// domain name, type and Time-To-Live of the DNS record.
        /// Maximum of 1000 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dns_info", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDnsInfo> Dns_info { get; set; }
    
        /// <summary>This overrides the cloud level default and needs to match
        /// the SE Group value in which it will be used if the SE Group
        /// use_standard_alb value is set.
        /// This is only used when FIP is used for VS on Azure Cloud.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("use_standard_alb", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Use_standard_alb { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer FailAction object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBFailAction 
    {
        /// <summary>URL to redirect HTTP requests to when pool experiences a
        /// failure.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("redirect", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBFailActionHTTPRedirect Redirect { get; set; }
    
        /// <summary>Local response to HTTP requests when pool experiences a
        /// failure.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("local_rsp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBFailActionHTTPLocalResponse Local_rsp { get; set; }
    
        /// <summary>Enables a response to client when pool experiences a
        /// failure.
        /// By default TCP connection is closed.
        /// Enum options - FAIL_ACTION_HTTP_REDIRECT,
        /// FAIL_ACTION_HTTP_LOCAL_RSP, FAIL_ACTION_CLOSE_CONN,
        /// FAIL_ACTION_BACKUP_POOL.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as FAIL_ACTION_CLOSE_CONN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBFailActionType Type { get; set; } = SDKGenerator.ALBFailActionType.FAIL_ACTION_CLOSE_CONN;
    
    
    }
    
    /// <summary>Advanced load balancer HealthMonitorHttp object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHealthMonitorHttp 
    {
        /// <summary>Type of the authentication method.
        /// Enum options - AUTH_BASIC, AUTH_NTLM.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("auth_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHealthMonitorHttpAuth_type? Auth_type { get; set; }
    
        /// <summary>Send an HTTP request to the server.
        /// The default GET / HTTP/1.0 may be extended with additional
        /// headers or information.
        /// For instance, GET /index.htm HTTP/1.1 Host  www.site.com
        /// Connection  Close.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as GET / HTTP/1.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("http_request", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Http_request { get; set; } = "GET / HTTP/1.0";
    
        /// <summary>List of HTTP response codes to match as successful.
        /// Default is 2xx.
        /// Enum options - HTTP_ANY, HTTP_1XX, HTTP_2XX, HTTP_3XX,
        /// HTTP_4XX, HTTP_5XX.
        /// Minimum of 1 items required.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("http_response_code", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Http_response_code> Http_response_code { get; set; } = new System.Collections.ObjectModel.Collection<Http_response_code>();
    
        /// <summary>Expected http/https response page size.
        /// Allowed values are 2048-16384.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("response_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(2048D, 16384D)]
        public long? Response_size { get; set; }
    
        /// <summary>Match for a keyword in the first 2Kb of the server header
        /// and body response.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("http_response", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Http_response { get; set; }
    
        /// <summary>Use the exact http_request string as specified by user,
        /// without any automatic insert of headers like Host header.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exact_http_request", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exact_http_request { get; set; } = false;
    
        /// <summary>Match or look for this keyword in the first 2KB of server
        /// header and body response indicating server maintenance.
        /// A successful match results in the server being marked down.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maintenance_response", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Maintenance_response { get; set; }
    
        /// <summary>SSL attributes for HTTPS health monitor.</summary>
        [Newtonsoft.Json.JsonProperty("ssl_attributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHealthMonitorSSLAttributes Ssl_attributes { get; set; }
    
        /// <summary>HTTP request body.</summary>
        [Newtonsoft.Json.JsonProperty("http_request_body", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Http_request_body { get; set; }
    
        /// <summary>Match or look for this HTTP response code indicating server
        /// maintenance.
        /// A successful match results in the server being marked down.
        /// Allowed values are 101-599.
        /// Maximum of 4 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maintenance_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<long> Maintenance_code { get; set; }
    
    
    }
    
    /// <summary>Virtual server acts as a facade to an application, receives all client
    /// connections over UDP and distributes them among the backend servers.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class UdpPolicyLbVirtualServer : PolicyLbVirtualServer
    {
    
    }
    
    /// <summary>Paged Collection of Domains</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyLabelListResult : ListResult
    {
        /// <summary>Policy label list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyLabel> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyLabel>();
    
    
    }
    
    /// <summary>Paged Collection of IPFIX DFW Collector Profile</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPFIXDFWCollectorProfileListResult : ListResult
    {
        /// <summary>IPFIX DFW Collection Instances list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IPFIXDFWCollectorProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<IPFIXDFWCollectorProfile>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VirtualNetworkInterface : DiscoveredResource
    {
        /// <summary>MAC address of the virtual network interface.</summary>
        [Newtonsoft.Json.JsonProperty("mac_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Mac_address { get; set; }
    
        /// <summary>Owner virtual machine type; Edge, Service VM or other.</summary>
        [Newtonsoft.Json.JsonProperty("owner_vm_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public VirtualNetworkInterfaceOwner_vm_type? Owner_vm_type { get; set; }
    
        /// <summary>Device key of the virtual network interface.</summary>
        [Newtonsoft.Json.JsonProperty("device_key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Device_key { get; set; }
    
        /// <summary>Id of the host on which the vm exists.</summary>
        [Newtonsoft.Json.JsonProperty("host_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Host_id { get; set; }
    
        /// <summary>Id of the vm to which this virtual network interface belongs.</summary>
        [Newtonsoft.Json.JsonProperty("owner_vm_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Owner_vm_id { get; set; }
    
        /// <summary>Id of the vm unique within the host.</summary>
        [Newtonsoft.Json.JsonProperty("vm_local_id_on_host", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Vm_local_id_on_host { get; set; }
    
        /// <summary>External Id of the virtual network inferface.</summary>
        [Newtonsoft.Json.JsonProperty("external_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string External_id { get; set; }
    
        /// <summary>LPort Attachment Id of the virtual network interface.</summary>
        [Newtonsoft.Json.JsonProperty("lport_attachment_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lport_attachment_id { get; set; }
    
        /// <summary>IP Addresses of the the virtual network interface, from various sources.</summary>
        [Newtonsoft.Json.JsonProperty("ip_address_info", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IpAddressInfo> Ip_address_info { get; set; }
    
        /// <summary>Device name of the virtual network interface.</summary>
        [Newtonsoft.Json.JsonProperty("device_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Device_name { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for PolicyLbMonitorProfile, used in hierarchical API
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyLbMonitorProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyLbMonitorProfile object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyLbMonitorProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyLbMonitorProfile PolicyLbMonitorProfile { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FederationComponentUpgradeStatus 
    {
        /// <summary>Upgrade status of component</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FederationComponentUpgradeStatusStatus? Status { get; set; }
    
        /// <summary>Target component version</summary>
        [Newtonsoft.Json.JsonProperty("target_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Target_version { get; set; }
    
        /// <summary>Details about the upgrade status</summary>
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Details { get; set; }
    
        /// <summary>Component type for the upgrade status</summary>
        [Newtonsoft.Json.JsonProperty("component_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Component_type { get; set; }
    
        /// <summary>Indicator of upgrade progress in percentage</summary>
        [Newtonsoft.Json.JsonProperty("percent_complete", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Percent_complete { get; set; }
    
        /// <summary>Mapping of current versions of nodes and counts of nodes at the respective versions.</summary>
        [Newtonsoft.Json.JsonProperty("current_version_node_summary", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FederationNodeSummary> Current_version_node_summary { get; set; }
    
    
    }
    
    /// <summary>Ids signature status.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsSignatureStatus : PolicyConfigResource
    {
        /// <summary>READY means signatures were downloaded and parsed successfully.
        /// PENDING means that signatures download is in progress.
        /// ERROR means error occurred during signature processing.
        /// DISABLED means IDS is disabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("download_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IdsSignatureStatusDownload_status? Download_status { get; set; }
    
        /// <summary>AVAILABLE means the signatures are available for the version.
        /// UNAVAILABLE means there are no available signatures for the version.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("signature_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IdsSignatureStatusSignature_status? Signature_status { get; set; }
    
        /// <summary>Represents the version id.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version_id { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer PerformanceLimits object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBPerformanceLimits 
    {
        /// <summary>The maximum number of concurrent client conections allowed
        /// to the Virtual Service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_concurrent_connections", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Max_concurrent_connections { get; set; }
    
        /// <summary>The maximum throughput per second for all clients allowed
        /// through the client side of the Virtual Service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_throughput", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Max_throughput { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer ClientInsightsSampling object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBClientInsightsSampling 
    {
        /// <summary>URL patterns to avoid when inserting RUM script.</summary>
        [Newtonsoft.Json.JsonProperty("skip_uris", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBStringMatch Skip_uris { get; set; }
    
        /// <summary>Client IP addresses to check when inserting RUM script.</summary>
        [Newtonsoft.Json.JsonProperty("client_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddrMatch Client_ip { get; set; }
    
        /// <summary>URL patterns to check when inserting RUM script.</summary>
        [Newtonsoft.Json.JsonProperty("sample_uris", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBStringMatch Sample_uris { get; set; }
    
    
    }
    
    /// <summary>For policy-based IPsec VPNs, a security policy specifies as its action the VPN tunnel to be used for transit traffic that meets the policy’s match criteria.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnRule : PolicyConfigResource
    {
        /// <summary>List of local subnets. Specifying no value is interpreted
        /// as 0.0.0.0/0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<IPSecVpnSubnet> Sources { get; set; }
    
        /// <summary>PROTECT - Protect rules are defined per policy based
        /// IPSec VPN session.
        /// BYPASS - Bypass rules are defined per IPSec VPN
        /// service and affects all policy based IPSec VPN sessions.
        /// Bypass rules are prioritized over protect rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPSecVpnRuleAction? Action { get; set; } = SDKGenerator.IPSecVpnRuleAction.PROTECT;
    
        /// <summary>A flag to enable/disable the rule.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
        /// <summary>A flag to enable/disable the logging for the rule.</summary>
        [Newtonsoft.Json.JsonProperty("logged", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Logged { get; set; } = false;
    
        /// <summary>A sequence number is used to give a priority to an IPSecVpnRule.</summary>
        [Newtonsoft.Json.JsonProperty("sequence_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, int.MaxValue)]
        public long? Sequence_number { get; set; }
    
        /// <summary>List of peer subnets. Specifying no value is interpreted
        /// as 0.0.0.0/0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<IPSecVpnSubnet> Destinations { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer PoolServer object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBPoolServer 
    {
        /// <summary>IP address of the server in the poool.</summary>
        [Newtonsoft.Json.JsonProperty("ip", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBIpAddr Ip { get; set; } = new ALBIpAddr();
    
        /// <summary>DNS resolvable name of the server.
        /// May be used in place of the IP address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hostname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Hostname { get; set; }
    
        /// <summary>Port of the pool server listening for HTTP/HTTPS.
        /// Default value is the default port in the pool.
        /// Allowed values are 1-65535.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long? Port { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for LiveTraceConfig for Hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildLiveTraceConfig : ChildPolicyConfigResource
    {
        /// <summary>The actual LiveTraceConfig object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("LiveTraceConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public LiveTraceConfig LiveTraceConfig { get; set; }
    
    
    }
    
    /// <summary>Gateway QoS profile configuration</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GatewayQosProfileConfig 
    {
        /// <summary>Policy path to gateway QoS profile in ingress direction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ingress_qos_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ingress_qos_profile_path { get; set; }
    
        /// <summary>Policy path to gateway QoS profile in egress direction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("egress_qos_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Egress_qos_profile_path { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MulticastForwardingCsvRecord : CsvRecord
    {
        /// <summary>Transport node uuid or policy path.</summary>
        [Newtonsoft.Json.JsonProperty("transport_node", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_node { get; set; }
    
        /// <summary>Multicast source address.</summary>
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source { get; set; }
    
        /// <summary>Array of egress interfaces on whic multicast traffic is forwarded.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("outgoing_interfaces", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Outgoing_interfaces { get; set; }
    
        /// <summary>Ingress interface on whic multicast traffic is learned.</summary>
        [Newtonsoft.Json.JsonProperty("incoming_interface", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Incoming_interface { get; set; }
    
        /// <summary>Multicast group address.</summary>
        [Newtonsoft.Json.JsonProperty("multicast_group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Multicast_group { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for Ipv6DadProfile, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIpv6DadProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual Ipv6DadProfile objects
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Ipv6DadProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Ipv6DadProfile Ipv6DadProfile { get; set; }
    
    
    }
    
    /// <summary>Represents a list of widget configurations.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class WidgetConfigurationList 
    {
        /// <summary>Array of widget configurations</summary>
        [Newtonsoft.Json.JsonProperty("widgetconfigurations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<WidgetConfiguration> Widgetconfigurations { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBServiceInstanceDetailPerTransportNode 
    {
        /// <summary>Load balancer instances details for each load balancer instance
        /// status type from the given transport node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("instance_detail_per_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBServiceInstanceDetailPerStatus> Instance_detail_per_status { get; set; }
    
        /// <summary>The UUID of the transport node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transport_node_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_node_id { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer AuthAttributeMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAuthAttributeMatch 
    {
        /// <summary>Attribute Values used to determine access when
        /// authentication applies.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("attribute_value_list", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBStringMatch Attribute_value_list { get; set; } = new ALBStringMatch();
    
        /// <summary>Attribute name whose values will be looked up in the access
        /// lists.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("attribute_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Attribute_name { get; set; }
    
    
    }
    
    /// <summary>IPSec VPN session traffic summary.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVPNSessionTrafficSummary 
    {
        /// <summary>Traffic stastics.</summary>
        [Newtonsoft.Json.JsonProperty("traffic_counters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IPSecVPNTrafficCounters Traffic_counters { get; set; }
    
        /// <summary>VPN Session.</summary>
        [Newtonsoft.Json.JsonProperty("ipsec_vpn_session", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceReference Ipsec_vpn_session { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SIPacketTypeAndCounter 
    {
        /// <summary>The number of packets.</summary>
        [Newtonsoft.Json.JsonProperty("counter", Required = Newtonsoft.Json.Required.Always)]
        public long Counter { get; set; }
    
        /// <summary>The type of the packets</summary>
        [Newtonsoft.Json.JsonProperty("packet_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Packet_type { get; set; }
    
    
    }
    
    /// <summary>Idfw configuration for enable/disable idfw on standalone hosts.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class StandaloneHostIdfwConfiguration : PolicyConfigResource
    {
        /// <summary>If set to true, Idfw is enabled for standalone hosts</summary>
        [Newtonsoft.Json.JsonProperty("idfw_enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Idfw_enabled { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyOspfDatabaseListResult : ListResult
    {
        /// <summary>Timestamp when the data was last updated, unset if data source has never updated the data.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>Policy path for Tier0 gateway</summary>
        [Newtonsoft.Json.JsonProperty("tier0_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tier0_path { get; set; }
    
        /// <summary>array of OSPF database data</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OspfDatabaseStatus> Results { get; set; }
    
    
    }
    
    /// <summary>Dead peer detection (DPD) is a method that allows detection of unreachable internet key excahnge (IKE) peers. Any changes affects all IPSec VPN sessions consuming this profile.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnDpdProfile : PolicyConfigResource
    {
        /// <summary>Maximum number of DPD messages' retry attempts. This value is applicable
        /// for both dpd probe modes, periodic and on-demand.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("retry_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 100D)]
        public long? Retry_count { get; set; } = 10L;
    
        /// <summary>If true, enable dead peer detection.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
        /// <summary>DPD probe mode is used to query the liveliness of the peer. Two modes
        /// are possible:
        /// - PERIODIC: is used to query the liveliness of the peer at regular
        /// intervals (dpd_probe_interval). It does not take into consideration
        /// traffic coming from the peer.
        /// The benefit of this mode over the on-demand mode is earlier detection of
        /// dead peers. However, use of periodic DPD incurs extra overhead. When
        /// communicating to large numbers of peers, please consider using on-demand
        /// DPD instead.
        /// - ON_DEMAND: is used to query the liveliness of the peer by instructing
        /// the local endpoint to send DPD message to a peer if there is traffic to
        /// send to the peer AND the peer was idle for dpd_probe_interval seconds
        /// (i.e. there was no traffic from the peer for dpd_probe_interval seconds).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dpd_probe_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPSecVpnDpdProfileDpd_probe_mode? Dpd_probe_mode { get; set; } = SDKGenerator.IPSecVpnDpdProfileDpd_probe_mode.PERIODIC;
    
        /// <summary>DPD probe interval defines an interval for DPD probes (in seconds).
        /// - When the DPD probe mode is periodic, this interval is the number
        /// of seconds between DPD messages.
        /// - When the DPD probe mode is on-demand, this interval is the number
        /// of seconds during which traffic is not received from the peer before
        /// DPD retry messages are sent if there is IPSec traffic to send.
        /// For PERIODIC Mode:
        ///  Minimum: 3
        ///  Maximum: 360
        ///  Default: 60
        /// For ON_DEMAND Mode:
        ///  Minimum: 1
        ///  Maximum: 10
        ///  Default: 3
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dpd_probe_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dpd_probe_interval { get; set; }
    
    
    }
    
    /// <summary>Status of tag bulk operation
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TagBulkOperationStatus 
    {
        /// <summary>Overall status</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TagBulkOperationStatusStatus Status { get; set; }
    
        /// <summary>Intent path corresponding to tag operation</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Path { get; set; }
    
        /// <summary>Tag apply operation status per resource type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apply_to", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ResourceTypeTagStatus> Apply_to { get; set; }
    
        /// <summary>Tag</summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Tag Tag { get; set; } = new Tag();
    
        /// <summary>Tag remove operation status per resource type
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remove_from", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ResourceTypeTagStatus> Remove_from { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CapacityUsageMetaInfo 
    {
        /// <summary>Indicates the maximum global threshold percentage
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_global_threshold_percentage", Required = Newtonsoft.Json.Required.Always)]
        public double Max_global_threshold_percentage { get; set; }
    
        /// <summary>Indicates the minimum global threshold percentage
        /// </summary>
        [Newtonsoft.Json.JsonProperty("min_global_threshold_percentage", Required = Newtonsoft.Json.Required.Always)]
        public double Min_global_threshold_percentage { get; set; }
    
        /// <summary>Timestamp at which capacity usage was last calculated</summary>
        [Newtonsoft.Json.JsonProperty("last_updated_timestamp", Required = Newtonsoft.Json.Required.Always)]
        public long Last_updated_timestamp { get; set; }
    
    
    }
    
    /// <summary>Abstract base class for all the policy objects.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyResource : ManagedResource
    {
        /// <summary>Absolute path of this object</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Path of its parent</summary>
        [Newtonsoft.Json.JsonProperty("parent_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Parent_path { get; set; }
    
        /// <summary>This is a UUID generated by the GM/LM to uniquely identify
        /// entites in a federated environment. For entities that are
        /// stretched across multiple sites, the same ID will be used
        /// on all the stretched sites.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unique_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Unique_id { get; set; }
    
        /// <summary>Path relative from its parent</summary>
        [Newtonsoft.Json.JsonProperty("relative_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Relative_path { get; set; }
    
    
    }
    
    /// <summary>Represents the leaf level value constraint to constrain specified attribute
    /// value to the set of values to be allowed/not-allowed.
    /// Example - sourceGroups allowed to have only with list of groups.
    ///   {
    ///     "operator":"INCLUDES",
    ///     "values":["/infra/services/HTTP", "/infra/services/HTTPS"]
    ///   }
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ValueConstraintExpression : ConstraintExpression
    {
        /// <summary>Operation to check for value list for resource attribute of constraint.</summary>
        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ValueConstraintExpressionOperator Operator { get; set; }
    
        /// <summary>List of values.</summary>
        [Newtonsoft.Json.JsonProperty("values_with_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConstraintValue Values_with_type { get; set; }
    
        /// <summary>List of values.</summary>
        [Newtonsoft.Json.JsonProperty("values", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Values { get; set; }
    
    
    }
    
    /// <summary>Role</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RoleWithFeatures : ManagedResource
    {
        /// <summary>Short identifier for the role. Must be all lower case with no spaces.</summary>
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Role { get; set; }
    
        /// <summary>Features</summary>
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FeaturePermission> Features { get; set; } = new System.Collections.ObjectModel.Collection<FeaturePermission>();
    
    
    }
    
    /// <summary>Contains the details of resource field
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyFineTuningResourceInfoDetail 
    {
        /// <summary>It will represent resource with name and fields.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("field_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Field_name { get; set; }
    
        /// <summary>List of all field of any resource</summary>
        [Newtonsoft.Json.JsonProperty("sub_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyFineTuningResourceInfo Sub_type { get; set; } = new PolicyFineTuningResourceInfo();
    
    
    }
    
    /// <summary>Paged Collection of FullSync states.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FullSyncStateListResult : ListResult
    {
        /// <summary>FullSync states list.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FullSyncState> Results { get; set; } = new System.Collections.ObjectModel.Collection<FullSyncState>();
    
    
    }
    
    /// <summary>HTTPPolicySetApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPPolicySetApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of HTTPPolicySet
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBHTTPPolicySet> Results { get; set; }
    
    
    }
    
    /// <summary>Enables traffic limit for incoming/outgoing broadcast and multicast packets. Use 0 to disable rate limiting for a specific traffic type</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TrafficRateLimits 
    {
        /// <summary>Incoming multicast traffic limit in packets per second</summary>
        [Newtonsoft.Json.JsonProperty("rx_multicast", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, int.MaxValue)]
        public long? Rx_multicast { get; set; } = 0L;
    
        /// <summary>Outgoing multicast traffic limit in packets per second</summary>
        [Newtonsoft.Json.JsonProperty("tx_multicast", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, int.MaxValue)]
        public long? Tx_multicast { get; set; } = 0L;
    
        /// <summary>Outgoing broadcast traffic limit in packets per second</summary>
        [Newtonsoft.Json.JsonProperty("tx_broadcast", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, int.MaxValue)]
        public long? Tx_broadcast { get; set; } = 0L;
    
        /// <summary>Incoming broadcast traffic limit in packets per second</summary>
        [Newtonsoft.Json.JsonProperty("rx_broadcast", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, int.MaxValue)]
        public long? Rx_broadcast { get; set; } = 0L;
    
    
    }
    
    /// <summary>Paged list of IPFIX collector profiles.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPFIXL2CollectorProfileListResult : ListResult
    {
        /// <summary>IPFIX collector Profile list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IPFIXL2CollectorProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<IPFIXL2CollectorProfile>();
    
    
    }
    
    /// <summary>Tier0 gateway state</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier0GatewayState 
    {
        /// <summary>IPv6 DAD status for interfaces configured on Tier0
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipv6_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IPv6Status> Ipv6_status { get; set; }
    
        /// <summary>Object that holds auto assigned route distingushers for this gateway.</summary>
        [Newtonsoft.Json.JsonProperty("auto_rds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AutoRds Auto_rds { get; set; }
    
        /// <summary>Detailed realized state information for Tier0
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tier0_state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LogicalRouterState Tier0_state { get; set; }
    
        /// <summary>Detailed realized status information for Tier0
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tier0_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LogicalRouterStatus Tier0_status { get; set; }
    
        /// <summary>String Path of the enforcement point.
        /// When not specified, routes from all enforcement-points are returned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enforcement_point_path { get; set; }
    
    
    }
    
    /// <summary>List all the TNs spaned in L3PortMirrorSession mirror stack health status.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TnNodeStackSpanStatus 
    {
        /// <summary>For L3PortMirrorSession configured mirror stack, show the TN node friendly
        /// name which spaned in L3PortMirrorSession.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tn_node_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Tn_node_name { get; set; }
    
        /// <summary>Show the vmknic health status, if the vmknic has been bouned to mirror
        /// stack, it will show SUCCESS or it will show FAILED.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vmknic_status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TnNodeStackSpanStatusVmknic_status Vmknic_status { get; set; }
    
        /// <summary>Show the dedicated mirror stack health status, if the TN node has the mirror
        /// stack, it will show SUCCESS or it will show FAILED.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dedicated_stack_status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TnNodeStackSpanStatusDedicated_stack_status Dedicated_stack_status { get; set; }
    
        /// <summary>For L3PortMirrorSession configured mirror stack, show the TN node UUID
        /// which spaned in L3PortMirrorSession.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tn_node_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tn_node_id { get; set; }
    
        /// <summary>Give the detail info for mirror stack and vmknic health status.
        /// If the stack or vmknic is FAILED, detail info will tell user reason
        /// why the stauts is FAILED. So that user can correct their configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("detail", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Detail { get; set; }
    
        /// <summary>TN miror stack status will be updated periodically, this item
        /// indicates the lastest timestamp of TN node stack status is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("last_updated_time", Required = Newtonsoft.Json.Required.Always)]
        public long Last_updated_time { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for PortSecurityProfileBindingMap, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPortSecurityProfileBindingMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PortSecurityProfileBindingMap object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PortSecurityProfileBindingMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PortSecurityProfileBindingMap PortSecurityProfileBindingMap { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for IdsProfile, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIdsProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the IdsProfile object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IdsProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IdsProfile IdsProfile { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer PortMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBPortMatch 
    {
        /// <summary>Listening TCP port(s).
        /// Allowed values are 1-65535.
        /// Minimum of 1 items required.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ports", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<long> Ports { get; set; } = new System.Collections.ObjectModel.Collection<long>();
    
        /// <summary>Criterion to use for port matching the HTTP request.
        /// Enum options - IS_IN, IS_NOT_IN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBPortMatchMatch_criteria Match_criteria { get; set; }
    
    
    }
    
    /// <summary>A base class for types that track revisions</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RevisionedResource : Resource
    {
        /// <summary>The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected.</summary>
        [Newtonsoft.Json.JsonProperty("_revision", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? _revision { get; set; }
    
    
    }
    
    /// <summary>Network prefix entry</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PrefixEntry 
    {
        /// <summary>Action for the prefix list.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PrefixEntryAction? Action { get; set; } = SDKGenerator.PrefixEntryAction.PERMIT;
    
        /// <summary>Prefix length greater than or equal to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ge", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 128D)]
        public long? Ge { get; set; }
    
        /// <summary>Prefix length less than or equal to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("le", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 128D)]
        public long? Le { get; set; }
    
        /// <summary>Network prefix in CIDR format. "ANY" matches all networks.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("network", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Network { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer WafPSMMatchElement object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWafPSMMatchElement 
    {
        /// <summary>The name of the request collection element.
        /// This can be empty, if we address the whole collection or a
        /// scalar element.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sub_element", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sub_element { get; set; }
    
        /// <summary>Match_element index.</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public long Index { get; set; }
    
        /// <summary>The variable specification.
        /// For example ARGS or REQUEST_COOKIES.
        /// This can be a scalar like PATH_INFO.
        /// Enum options - WAF_VARIABLE_ARGS, WAF_VARIABLE_ARGS_GET,
        /// WAF_VARIABLE_ARGS_POST, WAF_VARIABLE_ARGS_NAMES,
        /// WAF_VARIABLE_REQUEST_COOKIES, WAF_VARIABLE_QUERY_STRING,
        /// WAF_VARIABLE_REQUEST_BASENAME, WAF_VARIABLE_REQUEST_URI,
        /// WAF_VARIABLE_PATH_INFO.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBWafPSMMatchElementName Name { get; set; }
    
        /// <summary>Mark this element excluded, like in '!ARGS password'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("excluded", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Excluded { get; set; } = false;
    
    
    }
    
    /// <summary>Advanced load balancer RateLimiter object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBRateLimiter 
    {
        /// <summary>Maximum number of connections, requests or packets
        /// permitted each period.
        /// Allowed values are 1-1000000000.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1000000000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 1000000000D)]
        public long? Count { get; set; } = 1000000000L;
    
        /// <summary>Maximum number of connections, requests or packets to be
        /// let through instantaneously.
        /// If this is less than count, it will have no effect.
        /// Allowed values are 0-1000000000.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("burst_sz", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 1000000000D)]
        public long? Burst_sz { get; set; } = 0L;
    
        /// <summary>Identifier for Rate Limit.
        /// Constructed according to context.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Time value in seconds to enforce rate count.
        /// Allowed values are 1-1000000000.
        /// Unit is SEC.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("period", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 1000000000D)]
        public long? Period { get; set; } = 1L;
    
    
    }
    
    /// <summary>Child wrapper for ALBErrorPageBody, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBErrorPageBody : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBErrorPageBody object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBErrorPageBody", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBErrorPageBody ALBErrorPageBody { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SslTrustObjectData : PolicyConfigResource
    {
        /// <summary>Key algorithm contained in this certificate</summary>
        [Newtonsoft.Json.JsonProperty("key_algo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key_algo { get; set; }
    
        /// <summary>private key data</summary>
        [Newtonsoft.Json.JsonProperty("private_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Private_key { get; set; }
    
        /// <summary>Password for private key encryption</summary>
        [Newtonsoft.Json.JsonProperty("passphrase", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Passphrase { get; set; }
    
        /// <summary>pem encoded certificate data</summary>
        [Newtonsoft.Json.JsonProperty("pem_encoded", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Pem_encoded { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for VniPoolConfig, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildVniPoolConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual VniPoolConfig object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("VniPoolConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public VniPoolConfig VniPoolConfig { get; set; }
    
    
    }
    
    /// <summary>Status of the Identity Firewall Compute Collection's transport node.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdfwTransportNodeCondition 
    {
        /// <summary>Transport node status for IDFW compute collection.</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IdfwTransportNodeConditionStatus Status { get; set; }
    
        /// <summary>IDFW Compute collection's transport node condition.</summary>
        [Newtonsoft.Json.JsonProperty("status_detail", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Status_detail { get; set; }
    
    
    }
    
    /// <summary>Identity Firewall user login/session data for a single VM</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdfwVmDetail 
    {
        /// <summary>Virtual machine (external ID or BIOS UUID) where login/logout event occurred.</summary>
        [Newtonsoft.Json.JsonProperty("vm_ext_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Vm_ext_id { get; set; }
    
        /// <summary>List of client machine IP addresses.</summary>
        [Newtonsoft.Json.JsonProperty("vm_ip_addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Vm_ip_addresses { get; set; }
    
        /// <summary>Record of the last logged in user session (if exists).</summary>
        [Newtonsoft.Json.JsonProperty("last_login_user_session", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceReference Last_login_user_session { get; set; }
    
        /// <summary>List of user session data.</summary>
        [Newtonsoft.Json.JsonProperty("user_sessions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IdfwUserSessionData> User_sessions { get; set; } = new System.Collections.ObjectModel.Collection<IdfwUserSessionData>();
    
    
    }
    
    /// <summary>Current backup operation status</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CurrentBackupOperationStatus 
    {
        /// <summary>Current step of operation</summary>
        [Newtonsoft.Json.JsonProperty("current_step", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CurrentBackupOperationStatusCurrent_step? Current_step { get; set; }
    
        /// <summary>Unique identifier of current backup</summary>
        [Newtonsoft.Json.JsonProperty("backup_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Backup_id { get; set; }
    
        /// <summary>Additional human-readable status information about current step</summary>
        [Newtonsoft.Json.JsonProperty("current_step_message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Current_step_message { get; set; }
    
        /// <summary>Time when operation is expected to end</summary>
        [Newtonsoft.Json.JsonProperty("end_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? End_time { get; set; }
    
        /// <summary>Type of operation that is in progress. Returns none if no operation is in progress, in which case
        /// none of the other fields will be set.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("operation_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CurrentBackupOperationStatusOperation_type Operation_type { get; set; }
    
        /// <summary>Time when operation was started</summary>
        [Newtonsoft.Json.JsonProperty("start_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Start_time { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DhcpServerStatistics : DhcpStatistics
    {
    
    }
    
    /// <summary>Segment statistics on specific Enforcement Point.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentStatistics : LogicalSwitchStatistics
    {
    
    }
    
    /// <summary>Detail about one error encountered during a probe.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LdapProbeError 
    {
        /// <summary>The cause of the error.
        /// 
        /// BASE_DN_NOT_FOUND: The configured base DN does not exist on the
        ///     LDAP server or is not readable.
        /// BIND_DN_AND_PASSWORD_REQUIRED: This server is configured to
        ///     require a bind DN and password. Please add these to your
        ///     LDAP server configuration.
        /// BIND_DN_INVALID: The bind DN or username provided is not valid
        ///     on the LDAP server. Check that the bind DN is correct.
        ///     This error may also indicate that the base DN in your
        ///     configuration is incorrect.
        /// CERTIFICATE_HOSTNAME_MISMATCH_ERROR: The hostname configured for
        ///     the LDAP server does not match the hostname in the server's
        ///     certificate subject or alternative subject names. Be sure
        ///     that the hostname you configure in NSX Manager matches one
        ///     of those names.
        /// CERTIFICATE_MISMATCH_ERROR: The certificate presented by the
        ///     LDAP server did not match the certificate in the configuration
        ///     on the NSX Manager.
        /// CONNECTION_REFUSED: The connection was refused when contacting the
        ///     LDAP server. Ensure that the LDAP server is running and that
        ///     you are using the correct ip/hostname.
        /// CONNECTION_TIMEOUT: The connection timed out when contacting
        ///     the LDAP server. Check the hostname/ip and any firewalls
        ///     between the NSX Manager and the LDAP server.
        /// GENERAL_ERROR: An undetermined error occurred.
        /// INVALID_CONFIGURED_CERTIFICATE: The certificate configured for
        ///     this LDAP server is invalid and could not be decoded. Check
        ///     that the PEM-formatted certificate you provided is correct.
        /// INVALID_CREDENTIALS: The username and/or password are incorrect.
        /// SSL_HANDSHAKE_ERROR: An error occurred while establishing a secure
        ///     connection with the LDAP server. Check that the LDAP server's
        ///     certificate is correct, and that it is using an SSL/TLS
        ///     cipher suite that is compatible with the NSX Manager.
        ///     This error can also occur if the hostname you have configured
        ///     for the LDAP server does not match any of the hostnames in
        ///     the Subject Alternative Name records in the server
        ///     certificate.
        /// STARTTLS_FAILED: Unable to use StartTLS to upgrade the connection
        ///     to use TLS. Ensure that the LDAP server supports TLS and if
        ///     not, use LDAP or LDAPS as the protocol.
        /// UNKNOWN_HOST: The hostname of the LDAP server could not be
        ///     resolved.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("error_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LdapProbeErrorError_type? Error_type { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HTTPPolicySet object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPPolicySet : PolicyConfigResource
    {
        /// <summary>Checksum of cloud configuration for Pool.
        /// Internally set by cloud connector.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cloud_config_cksum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cloud_config_cksum { get; set; }
    
        /// <summary>Creator name.</summary>
        [Newtonsoft.Json.JsonProperty("created_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_by { get; set; }
    
        /// <summary>HTTP request policy for the virtual service.</summary>
        [Newtonsoft.Json.JsonProperty("http_request_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPRequestPolicy Http_request_policy { get; set; }
    
        /// <summary>HTTP response policy for the virtual service.</summary>
        [Newtonsoft.Json.JsonProperty("http_response_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPResponsePolicy Http_response_policy { get; set; }
    
        /// <summary>HTTP security policy for the virtual service.</summary>
        [Newtonsoft.Json.JsonProperty("http_security_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPSecurityPolicy Http_security_policy { get; set; }
    
        /// <summary>Placeholder for description of property is_internal_policy
        /// of obj type HTTPPolicySet field type str  type boolean.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_internal_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_internal_policy { get; set; } = false;
    
    
    }
    
    /// <summary>A ServiceEntry that represents IGMP protocol</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IGMPTypeServiceEntry : ServiceEntry
    {
    
    }
    
    /// <summary>DFW Firewall related configurations</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DfwFirewallConfiguration : FirewallConfiguration
    {
        /// <summary>If set to true, identity firewall is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("idfw_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Idfw_enabled { get; set; } = false;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MacTableCsvRecord : CsvRecord
    {
        /// <summary>The virtual tunnel endpoint MAC address</summary>
        [Newtonsoft.Json.JsonProperty("vtep_mac_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Vtep_mac_address { get; set; }
    
        /// <summary>RTEP group id is applicable when the logical switch is stretched
        /// across multiple sites. When rtep_group_id is set, mac_address
        /// represents remote mac_address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rtep_group_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Rtep_group_id { get; set; }
    
        /// <summary>The virtual tunnel endpoint IP address</summary>
        [Newtonsoft.Json.JsonProperty("vtep_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Vtep_ip { get; set; }
    
        /// <summary>VTEP group id is applicable when the logical switch is stretched
        /// across multiple sites. When vtep_group_id is set, mac_address
        /// represents remote mac_address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vtep_group_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Vtep_group_id { get; set; }
    
        /// <summary>The MAC address</summary>
        [Newtonsoft.Json.JsonProperty("mac_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Mac_address { get; set; }
    
    
    }
    
    /// <summary>Status LDAP server of directory domain</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DirectoryLdapServerStatus 
    {
        /// <summary>Error ID of the directory LDAP server status maintained by the NSX directory service.</summary>
        [Newtonsoft.Json.JsonProperty("error_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Error_id { get; set; }
    
        /// <summary>Error message of the directory LDAP server status maintained by the NSX directory service.</summary>
        [Newtonsoft.Json.JsonProperty("error_message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error_message { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyCapacityDashboardUsage 
    {
        /// <summary>Indicate the current usage count of object type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_usage_count", Required = Newtonsoft.Json.Required.Always)]
        public long Current_usage_count { get; set; }
    
        /// <summary>Indicate the object type for which usage is calculated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("usage_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyCapacityDashboardUsageUsage_type Usage_type { get; set; }
    
        /// <summary>Display name for NSX object type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Display_name { get; set; }
    
        /// <summary>Current usage percentage for object type
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_usage_percentage", Required = Newtonsoft.Json.Required.Always)]
        public double Current_usage_percentage { get; set; }
    
        /// <summary>This is the maximum supported count for object type in consideration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_supported_count", Required = Newtonsoft.Json.Required.Always)]
        public long Max_supported_count { get; set; }
    
    
    }
    
    /// <summary>Details of container cluster node i.e. container host.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ContainerClusterNode : DiscoveredResource
    {
        /// <summary>Network status of container cluster node.</summary>
        [Newtonsoft.Json.JsonProperty("network_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ContainerClusterNodeNetwork_status? Network_status { get; set; }
    
        /// <summary>External identifier of the container cluster.</summary>
        [Newtonsoft.Json.JsonProperty("container_cluster_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Container_cluster_id { get; set; }
    
        /// <summary>List of IP addresses of container cluster node.</summary>
        [Newtonsoft.Json.JsonProperty("ip_addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Ip_addresses { get; set; }
    
        /// <summary>Array of additional specific properties of container cluster node
        /// in key-value format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("origin_properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyValuePair> Origin_properties { get; set; }
    
        /// <summary>External identifier of the container cluster node in K8S/PAS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("external_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string External_id { get; set; }
    
        /// <summary>List of network errors related to container cluster node.</summary>
        [Newtonsoft.Json.JsonProperty("network_errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<NetworkError> Network_errors { get; set; }
    
    
    }
    
    /// <summary>Details of the member belonging to a Group
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyGroupMemberDetails 
    {
        /// <summary>The path of the member, if relevant</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>The display name of the member on the enforcement point</summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Display_name { get; set; }
    
        /// <summary>The ID of the member on the enforcement point</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
    
    }
    
    /// <summary>Contains information about L3Vpn session.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("PolicyBasedL3VpnSession", typeof(PolicyBasedL3VpnSession))]
    [JsonInheritanceAttribute("RouteBasedL3VpnSession", typeof(RouteBasedL3VpnSession))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L3VpnSession 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DhcpLeasePerIP 
    {
        /// <summary>subnet of client network</summary>
        [Newtonsoft.Json.JsonProperty("subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Subnet { get; set; }
    
        /// <summary>lease time of the ip address, in seconds</summary>
        [Newtonsoft.Json.JsonProperty("lease_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lease_time { get; set; }
    
        /// <summary>mac address of client</summary>
        [Newtonsoft.Json.JsonProperty("mac_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Mac_address { get; set; }
    
        /// <summary>expire time of the lease</summary>
        [Newtonsoft.Json.JsonProperty("expire_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Expire_time { get; set; }
    
        /// <summary>start time of lease</summary>
        [Newtonsoft.Json.JsonProperty("start_time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Start_time { get; set; }
    
        /// <summary>ip address of client</summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ip_address { get; set; }
    
    
    }
    
    /// <summary>This configuration is distributed to all Sites participating in federation.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GlobalManagerConfig : PolicyConfigResource
    {
        /// <summary>Global Manager federation RTEP configuration. This configuration is distributed
        /// to all Sites participating in federation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rtep_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GmRtepConfig Rtep_config { get; set; }
    
    
    }
    
    /// <summary>This object allows enabling or disabling of partial patch functionality.
    /// Enabling partial patch allows patching of a subset of the fields of any object.
    /// After enabling partial patching, any object payload provided will be merged with the existing object payload.
    /// Note that while all mandatory fields are expected to be provided during the creation of any object,
    /// enabling partial patch will allow patching of existing objects with a subset of mandatory fields.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PartialPatchConfig 
    {
        /// <summary>boolean value used to enable/disable partial patch</summary>
        [Newtonsoft.Json.JsonProperty("enable_partial_patch", Required = Newtonsoft.Json.Required.Always)]
        public bool Enable_partial_patch { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HTTPSwitchingAction object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPSwitchingAction 
    {
        /// <summary>path of the pool of servers to serve the request.
        /// It is a reference to an object of type Pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pool_path { get; set; }
    
        /// <summary>File from which to serve local response to the request.</summary>
        [Newtonsoft.Json.JsonProperty("file", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPLocalFile File { get; set; }
    
        /// <summary>path of the pool group to serve the request.
        /// It is a reference to an object of type PoolGroup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_group_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pool_group_path { get; set; }
    
        /// <summary>Content switching action type.
        /// Enum options - HTTP_SWITCHING_SELECT_POOL,
        /// HTTP_SWITCHING_SELECT_LOCAL,
        /// HTTP_SWITCHING_SELECT_POOLGROUP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHTTPSwitchingActionAction Action { get; set; }
    
        /// <summary>HTTP status code to use when serving local response.
        /// Enum options - HTTP_LOCAL_RESPONSE_STATUS_CODE_200,
        /// HTTP_LOCAL_RESPONSE_STATUS_CODE_204,
        /// HTTP_LOCAL_RESPONSE_STATUS_CODE_403,
        /// HTTP_LOCAL_RESPONSE_STATUS_CODE_404,
        /// HTTP_LOCAL_RESPONSE_STATUS_CODE_429,
        /// HTTP_LOCAL_RESPONSE_STATUS_CODE_501.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHTTPSwitchingActionStatus_code? Status_code { get; set; }
    
        /// <summary>Specific pool server to select.</summary>
        [Newtonsoft.Json.JsonProperty("server", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBPoolServer Server { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyTraceflowObservationForwardedLogical : TraceflowObservationForwardedLogical
    {
        /// <summary>The path of the ACL rule that was applied to forward the traceflow packet</summary>
        [Newtonsoft.Json.JsonProperty("acl_rule_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Acl_rule_path { get; set; }
    
        /// <summary>The path of the NAT rule that was applied to forward the traceflow packet</summary>
        [Newtonsoft.Json.JsonProperty("nat_rule_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Nat_rule_path { get; set; }
    
        /// <summary>The path of the component that forwarded the traceflow packet</summary>
        [Newtonsoft.Json.JsonProperty("component_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Component_path { get; set; }
    
        /// <summary>The path of the segment port or router port through which the traceflow packet was forwarded</summary>
        [Newtonsoft.Json.JsonProperty("segment_port_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Segment_port_path { get; set; }
    
        /// <summary>The path of the destination component to which the traceflow packet was forwarded</summary>
        [Newtonsoft.Json.JsonProperty("dst_component_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dst_component_path { get; set; }
    
    
    }
    
    /// <summary>Represents the strech information for a federated entity
    /// available only on local manager.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Span : PolicyConfigResource
    {
        /// <summary>Policy resource type of the streached entity.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("span_resource_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Span_resource_type { get; set; }
    
        /// <summary>Represents Policy resource path of streached entity.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("span_resource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Span_resource { get; set; }
    
        /// <summary>List of SpanSiteInfos representing the strech of the entity.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sites", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SpanSiteInfo> Sites { get; set; }
    
        /// <summary>Represents Policy resource type streached entity's span leader.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("span_leader", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Span_leader { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RAConfig 
    {
        /// <summary>Router lifetime value in seconds. A value of 0 indicates the
        /// router is not a default router for the receiving end. Any other value
        /// in this field specifies the lifetime, in seconds, associated with
        /// this router as a default router.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("router_lifetime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65520D)]
        public long? Router_lifetime { get; set; } = 1800L;
    
        /// <summary>The maximum number of hops through which packets can
        /// pass before being discarded.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hop_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 255D)]
        public long? Hop_limit { get; set; } = 64L;
    
        /// <summary>Interval between 2 Router advertisement in seconds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ra_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(4D, 1800D)]
        public long? Ra_interval { get; set; } = 600L;
    
        /// <summary>The time interval in seconds, in which the prefix is advertised
        /// as preferred.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("prefix_preferred_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? Prefix_preferred_time { get; set; } = 604800L;
    
        /// <summary>The time interval in seconds, in which the prefix is advertised
        /// as valid.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("prefix_lifetime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? Prefix_lifetime { get; set; } = 2592000L;
    
    
    }
    
    /// <summary>Used to configure zones on DNS Forwarder</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyDnsForwarderZone : PolicyConfigResource
    {
        /// <summary>List of domain names on which conditional forwarding is based. This
        /// field is required if the DNS Zone is being used for a conditional
        /// forwarder. This field will also be used for conditional reverse lookup.
        /// Example 1, if for one of the zones, one of the entries in the fqdn is
        /// example.com, all the DNS requests under the domain example.com will
        /// be served by the corresponding upstream DNS server.
        /// Example 2, if for one of the zones, one of the entries in the fqdn
        /// list is "13.12.30.in-addr.arpa", reverse lookup for 30.12.13.0/24 will
        /// go to the corresponding DNS server.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dns_domain_names", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Dns_domain_names { get; set; }
    
        /// <summary>Max of 3 DNS servers can be configured</summary>
        [Newtonsoft.Json.JsonProperty("upstream_servers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(3)]
        public System.Collections.Generic.ICollection<string> Upstream_servers { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>The source IP used by the DNS Forwarder zone.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source_ip { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for IPSecVpnLocalEndpoint, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIPSecVpnLocalEndpoint : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual IPSecVpnLocalEndpoint object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IPSecVpnLocalEndpoint", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IPSecVpnLocalEndpoint IPSecVpnLocalEndpoint { get; set; }
    
    
    }
    
    /// <summary>Used to specify the local/peer subnets in IPSec VPN rule.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnSubnet 
    {
        /// <summary>Subnet used in policy rule.</summary>
        [Newtonsoft.Json.JsonProperty("subnet", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Subnet { get; set; }
    
    
    }
    
    /// <summary>Represents configuration for custom widget. For this widget the data source is not applicable. It defines ui identifer to identify UI component and render it on dashboard view. This configuration can only be used for system owned widgets.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CustomWidgetConfiguration : WidgetConfiguration
    {
        /// <summary>User defined component selector to be rendered inside view/container.</summary>
        [Newtonsoft.Json.JsonProperty("ui_component_identifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ui_component_identifier { get; set; }
    
    
    }
    
    /// <summary>Match criteria based on a community list</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CommunityMatchCriteria 
    {
        /// <summary>Match operator for community list entries. Not valid when a regular expression is specified for criteria.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_operator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CommunityMatchCriteriaMatch_operator? Match_operator { get; set; }
    
        /// <summary>Match criteria specified as a community list path or a regular
        /// expression.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Criteria { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CapacityUsageResponse : ManagedResource
    {
        /// <summary>List of capacity usage for NSX Objects</summary>
        [Newtonsoft.Json.JsonProperty("capacity_usage", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<CapacityDashboardUsage> Capacity_usage { get; set; } = new System.Collections.ObjectModel.Collection<CapacityDashboardUsage>();
    
        /// <summary>Meta data for capacity usage statistics</summary>
        [Newtonsoft.Json.JsonProperty("meta_info", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object Meta_info { get; set; } = new object();
    
        /// <summary>Types for which usage data was not reported</summary>
        [Newtonsoft.Json.JsonProperty("unreported_usage_types", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Unreported_usage_types { get; set; }
    
    
    }
    
    /// <summary>Service capabilities that will be inherited by service VMs created using a service definition that contains this service capability.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServiceCapability 
    {
        /// <summary>Indicating whether service supports NSH liveness detection.</summary>
        [Newtonsoft.Json.JsonProperty("nsh_liveness_support_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Nsh_liveness_support_enabled { get; set; } = false;
    
        /// <summary>Indicating whether service is configured to decrement SI field in NSH metadata.</summary>
        [Newtonsoft.Json.JsonProperty("can_decrement_si", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Can_decrement_si { get; set; } = false;
    
    
    }
    
    /// <summary>This action is performed in HTTP forwarding phase. It is used to inspect
    /// the variable of HTTP request, and look up the persistence entry with its
    /// value and pool uuid as key.
    /// If the persistence entry is found, the HTTP request is forwarded to the
    /// recorded backend server according to the persistence entry.
    /// If the persistence entry is not found, a new entry is created in the
    /// table after backend server is selected.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBVariablePersistenceOnAction : LBRuleAction
    {
        /// <summary>The property is used to enable a hash operation for variable value
        /// when composing the persistence key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("variable_hash_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Variable_hash_enabled { get; set; } = false;
    
        /// <summary>The property is the name of variable to be used. It specifies which
        /// variable's value of a HTTP Request will be used in the key of
        /// persistence entry. The variable can be a built-in variable such
        /// as "_cookie_JSESSIONID", a customized variable defined in
        /// LBVariableAssignmentAction or a captured variable in regular expression
        /// such as "article".
        /// For the full list of built-in variables, please reference the NSX-T
        /// Administrator's Guide.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("variable_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Variable_name { get; set; }
    
        /// <summary>If the persistence profile path is not specified, a default
        /// persistence table is created per virtual server. Currently, only
        /// LBGenericPersistenceProfile is supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("persistence_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Persistence_profile_path { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LogicalSwitchStatistics : AggregatedDataCounterEx
    {
        /// <summary>Timestamp when the data was last updated; unset if data source has never updated the data.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>The id of the logical Switch</summary>
        [Newtonsoft.Json.JsonProperty("logical_switch_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Logical_switch_id { get; set; }
    
    
    }
    
    /// <summary>Identity Firewall user login/session data for a single Group.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyIdfwGroupVmDetailListResult : ListResult
    {
        /// <summary>String Path of the group</summary>
        [Newtonsoft.Json.JsonProperty("group_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group_path { get; set; }
    
        /// <summary>List of user login/session data for a single VM</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IdfwVmDetail> Results { get; set; }
    
    
    }
    
    /// <summary>Paged collection of Global IDS signatures</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GlobalIdsSignatureListResult : ListResult
    {
        /// <summary>Global IDS signature list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<GlobalIdsSignature> Results { get; set; } = new System.Collections.ObjectModel.Collection<GlobalIdsSignature>();
    
    
    }
    
    /// <summary>The key is used to specify the public key content which is used to verify
    /// the signature of JWT tokens.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBJwtPublicKey : LBJwtKey
    {
        /// <summary>Content of public key</summary>
        [Newtonsoft.Json.JsonProperty("public_key_content", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Public_key_content { get; set; }
    
    
    }
    
    /// <summary>IDS Profile which contains the signatures and will be used in IDS rules.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsProfile : PolicyConfigResource
    {
        /// <summary>Represents the filtering criteria for the IDS Profile.
        /// 1. A non-empty criteria list, must be of odd size. In a list, with
        /// indices starting from 0, all IdsProfileFilterCriteria must be at even indices,
        /// separated by the IdsProfileConjunctionOperator AND at odd indices.
        /// 2. There may be at most 7 IdsProfileCriteria objects inside a list.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("criteria", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(7)]
        public System.Collections.Generic.ICollection<IdsProfileCriteria> Criteria { get; set; }
    
        /// <summary>Represents the severities of signatures which are part of this profile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("profile_severity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Profile_severity> Profile_severity { get; set; }
    
        /// <summary>Represents the severities of signatures which are part of this profile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("severities", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IdsProfileSeverity> Severities { get; set; }
    
        /// <summary>Represents the signatures that has been  overridden for this Profile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overridden_signatures", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IdsProfileLocalSignature> Overridden_signatures { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HealthMonitorSIP object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHealthMonitorSIP 
    {
        /// <summary>Specify the transport protocol TCP or UDP, to be used for
        /// SIP health monitor.
        /// The default transport is UDP.
        /// Enum options - SIP_UDP_PROTO, SIP_TCP_PROTO.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as SIP_UDP_PROTO.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sip_monitor_transport", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHealthMonitorSIPSip_monitor_transport? Sip_monitor_transport { get; set; } = SDKGenerator.ALBHealthMonitorSIPSip_monitor_transport.SIP_UDP_PROTO;
    
        /// <summary>Specify the SIP request to be sent to the server.
        /// By default, SIP OPTIONS request will be sent.
        /// Enum options - SIP_OPTIONS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as SIP_OPTIONS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sip_request_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHealthMonitorSIPSip_request_code? Sip_request_code { get; set; } = SDKGenerator.ALBHealthMonitorSIPSip_request_code.SIP_OPTIONS;
    
        /// <summary>Match for a keyword in the first 2KB of the server header
        /// and body response.
        /// By default, it matches for SIP/2.0.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as SIP/2.0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sip_response", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sip_response { get; set; } = "SIP/2.0";
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBStatisticsCounter 
    {
        /// <summary>Number of source IP persistence entries</summary>
        [Newtonsoft.Json.JsonProperty("source_ip_persistence_entry_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Source_ip_persistence_entry_size { get; set; }
    
        /// <summary>Number of packets out.</summary>
        [Newtonsoft.Json.JsonProperty("packets_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_out { get; set; }
    
        /// <summary>The total number of dropped TCP SYN or UDP packets by access list
        /// control.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dropped_packets_by_access_list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dropped_packets_by_access_list { get; set; }
    
        /// <summary>The average number of outbound bytes per second, the number is
        /// averaged over the last 5 one-second intervals.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bytes_out_rate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Bytes_out_rate { get; set; }
    
        /// <summary>Number of total sessions.</summary>
        [Newtonsoft.Json.JsonProperty("total_sessions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total_sessions { get; set; }
    
        /// <summary>The average number of http requests per second, the number is
        /// averaged over the last 5 one-second intervals.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("http_request_rate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Http_request_rate { get; set; }
    
        /// <summary>Number of bytes out.</summary>
        [Newtonsoft.Json.JsonProperty("bytes_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_out { get; set; }
    
        /// <summary>The average number of inbound packets per second, the number is
        /// averaged over the last 5 one-second intervals.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_in_rate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Packets_in_rate { get; set; }
    
        /// <summary>The average number of inbound bytes per second, the number is
        /// averaged over the last 5 one-second intervals.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bytes_in_rate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Bytes_in_rate { get; set; }
    
        /// <summary>Number of current sessions.</summary>
        [Newtonsoft.Json.JsonProperty("current_sessions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Current_sessions { get; set; }
    
        /// <summary>Number of maximum sessions.</summary>
        [Newtonsoft.Json.JsonProperty("max_sessions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Max_sessions { get; set; }
    
        /// <summary>The average number of outbound packets per second, the number is
        /// averaged over the last 5 one-second intervals.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_out_rate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Packets_out_rate { get; set; }
    
        /// <summary>The total number of http requests.</summary>
        [Newtonsoft.Json.JsonProperty("http_requests", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Http_requests { get; set; }
    
        /// <summary>Number of bytes in.</summary>
        [Newtonsoft.Json.JsonProperty("bytes_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_in { get; set; }
    
        /// <summary>The average number of current sessions per second, the number is
        /// averaged over the last 5 one-second intervals.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_session_rate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Current_session_rate { get; set; }
    
        /// <summary>The total number of dropped sessions by LB rule action.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dropped_sessions_by_lbrule_action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dropped_sessions_by_lbrule_action { get; set; }
    
        /// <summary>Number of packets in.</summary>
        [Newtonsoft.Json.JsonProperty("packets_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_in { get; set; }
    
    
    }
    
    /// <summary>Sampling parameter for a livetrace action</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LiveTraceSamplingConfig 
    {
        /// <summary>A packet is sampled for every given time interval in ms.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sampling_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 30000D)]
        public long? Sampling_interval { get; set; }
    
        /// <summary>First N packets are sampled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 50D)]
        public long? Match_number { get; set; }
    
        /// <summary>1 out of N packets is sampled on average.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sampling_rate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long? Sampling_rate { get; set; }
    
    
    }
    
    /// <summary>DHCP IPv4 and IPv6 configurations are extended from this abstract class.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("SegmentDhcpV4Config", typeof(SegmentDhcpV4Config))]
    [JsonInheritanceAttribute("SegmentDhcpV6Config", typeof(SegmentDhcpV6Config))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentDhcpConfig 
    {
        /// <summary>IP address of the DHCP server in CIDR format.
        /// The server_address is mandatory in case this segment has provided a
        /// dhcp_config_path and it represents a DHCP server config.
        /// If this SegmentDhcpConfig is a SegmentDhcpV4Config, the address must
        /// be an IPv4 address. If this is a SegmentDhcpV6Config, the address must
        /// be an IPv6 address.
        /// This address must not overlap the ip-ranges of the subnet, or the
        /// gateway address of the subnet, or the DHCP static-binding addresses
        /// of this segment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Server_address { get; set; }
    
        /// <summary>IP address of DNS servers for subnet. DNS server IP address must
        /// belong to the same address family as segment gateway_address
        /// property.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dns_servers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(2)]
        public System.Collections.Generic.ICollection<string> Dns_servers { get; set; }
    
        /// <summary>DHCP lease time in seconds. When specified, this property overwrites
        /// lease time configured DHCP server config.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lease_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(60D, 4294967295D)]
        public long? Lease_time { get; set; } = 86400L;
    
    
    }
    
    /// <summary>Advanced load balancer WafExclusionType object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWafExclusionType 
    {
        /// <summary>Case sensitivity to use for the matching.
        /// Enum options - SENSITIVE, INSENSITIVE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as SENSITIVE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_case", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBWafExclusionTypeMatch_case? Match_case { get; set; } = SDKGenerator.ALBWafExclusionTypeMatch_case.SENSITIVE;
    
        /// <summary>String Operation to use for matching the Exclusion.
        /// Enum options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS,
        /// DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS,
        /// DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as EQUALS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_op", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBWafExclusionTypeMatch_op? Match_op { get; set; } = SDKGenerator.ALBWafExclusionTypeMatch_op.EQUALS;
    
    
    }
    
    /// <summary>L2VPN session statistics gives session status and traffic statistics per segment.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VPNSessionStatisticsNsxT : L2VPNSessionStatisticsPerEP
    {
        /// <summary>Traffic statistics per segment.</summary>
        [Newtonsoft.Json.JsonProperty("traffic_statistics_per_segment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<L2VPNTrafficStatisticsPerSegment> Traffic_statistics_per_segment { get; set; }
    
        /// <summary>Display name of l2vpn session.</summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Display_name { get; set; }
    
        /// <summary>Tunnel port traffic counters.</summary>
        [Newtonsoft.Json.JsonProperty("tap_traffic_counters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<L2VPNTapStatistics> Tap_traffic_counters { get; set; }
    
    
    }
    
    /// <summary>Contains information necessary to configure a BGP neighbor.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BgpNeighborConfig : PolicyConfigResource
    {
        /// <summary>Specify path of prefix-list or route map to filter routes for OUT direction.
        /// When not specified, a built-in prefix-list named 'prefixlist-out-default'
        /// is automatically applied.
        /// This property is deprecated, use route_filtering instead. Specifying different
        /// values for both properties will result in error.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("out_route_filters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Out_route_filters { get; set; }
    
        /// <summary>If mode is DISABLE, then graceful restart and helper modes are disabled.
        /// If mode is GR_AND_HELPER, then both graceful restart and helper modes are enabled.
        /// If mode is HELPER_ONLY, then helper mode is enabled.
        /// HELPER_ONLY mode is the ability for a BGP speaker to indicate its ability
        /// to preserve forwarding state during BGP restart.
        /// GRACEFUL_RESTART mode is the ability of a BGP speaker to advertise its restart
        /// to its peers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("graceful_restart_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BgpNeighborConfigGraceful_restart_mode? Graceful_restart_mode { get; set; }
    
        /// <summary>BFD configuration for failure detection.
        /// BFD is enabled with default values when not configured.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bfd", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public BgpBfdConfig Bfd { get; set; }
    
        /// <summary>Interval (in seconds) between keep alive messages sent to peer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keep_alive_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long? Keep_alive_time { get; set; } = 60L;
    
        /// <summary>Maximum number of hops allowed to reach BGP neighbor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maximum_hop_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 255D)]
        public long? Maximum_hop_limit { get; set; } = 1L;
    
        /// <summary>Wait time in seconds before declaring peer dead.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hold_down_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65535D)]
        public long? Hold_down_time { get; set; } = 180L;
    
        /// <summary>Specify path of prefix-list or route map to filter routes for IN direction.
        /// This property is deprecated, use route_filtering instead. Specifying different
        /// values for both properties will result in error.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("in_route_filters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> In_route_filters { get; set; }
    
        /// <summary>4 Byte ASN of the neighbor in ASPLAIN Format</summary>
        [Newtonsoft.Json.JsonProperty("remote_as_num", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Remote_as_num { get; set; }
    
        /// <summary>Enable address families and route filtering in each direction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("route_filtering", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(2)]
        public System.Collections.Generic.ICollection<BgpRouteFiltering> Route_filtering { get; set; }
    
        /// <summary>Source addresses should belong to Tier0 external or loopback interface
        /// IP Addresses . BGP peering is formed from all these addresses.
        /// This property is mandatory when maximum_hop_limit is greater than 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source_addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(8)]
        public System.Collections.Generic.ICollection<string> Source_addresses { get; set; }
    
        /// <summary>Specify password for BGP neighbor authentication.
        /// Empty string ("") clears existing password.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(20)]
        public string Password { get; set; }
    
        /// <summary>Flag to enable allowas_in option for BGP neighbor</summary>
        [Newtonsoft.Json.JsonProperty("allow_as_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Allow_as_in { get; set; } = false;
    
        /// <summary>Neighbor IP Address</summary>
        [Newtonsoft.Json.JsonProperty("neighbor_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Neighbor_address { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for LBPool, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildLBPool : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual LBPool object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("LBPool", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public LBPool LBPool { get; set; }
    
    
    }
    
    /// <summary>IGMP profile.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyIgmpProfile : PolicyConfigResource
    {
        /// <summary>The query response interval(seconds) is the maximum amount of time that can elapse between
        /// when the querier router sends a host-query message and when it receives a response
        /// from a host. Configuring this interval allows admins to adjust the burstiness of
        /// IGMP messages on the subnet; larger values make the traffic less bursty, as host
        /// responses are spread out over a larger interval.
        /// 
        /// The number of seconds represented by the query_max_response_time must be less than the query_interval.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("query_max_response_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 25D)]
        public long? Query_max_response_time { get; set; } = 10L;
    
        /// <summary>Interval(seconds) between general IGMP host-query messages.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("query_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 1800D)]
        public long? Query_interval { get; set; } = 30L;
    
        /// <summary>The Robustness Variable allows tuning for the expected packet loss on a subnet.
        /// If a subnet is expected to be lossy, the Robustness Variable may be increased.
        /// IGMP is robust to (Robustness Variable-1) packet losses.
        /// The Robustness Variable must not be zero, and SHOULD NOT be one.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("robustness_variable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 255D)]
        public long? Robustness_variable { get; set; } = 2L;
    
        /// <summary>Max Response Time inserted into Group-Specific Queries sent in response to Leave Group messages,
        /// and is also the amount of time between Group-Specific Query messages. This value may be tuned to
        /// modify the "leave latency" of the network.
        /// A reduced value results in reduced time to detect the loss of the last member of a group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("last_member_query_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 25D)]
        public long? Last_member_query_interval { get; set; } = 1L;
    
    
    }
    
    /// <summary>Child wrapper for LBMonitorProfile, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildLBMonitorProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual LBMonitorProfile object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("LBMonitorProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public LBMonitorProfile LBMonitorProfile { get; set; }
    
    
    }
    
    /// <summary>DHCP classless static route option.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ClasslessStaticRoute 
    {
        /// <summary>IP address of next hop of the route.</summary>
        [Newtonsoft.Json.JsonProperty("next_hop", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Next_hop { get; set; }
    
        /// <summary>Destination network in CIDR format.</summary>
        [Newtonsoft.Json.JsonProperty("network", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Network { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBDnsPolicy, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBDnsPolicy : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBDnsPolicy object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBDnsPolicy", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBDnsPolicy ALBDnsPolicy { get; set; }
    
    
    }
    
    /// <summary>Wrapper object for MetadataProxyConfig</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildMetadataProxyConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual MetadataProxyConfig object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("MetadataProxyConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public MetadataProxyConfig MetadataProxyConfig { get; set; }
    
    
    }
    
    /// <summary>Policy Service Chain List</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyServiceChainListResult : ListResult
    {
        /// <summary>All PolicyServiceChain objects</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyServiceChain> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyServiceChain>();
    
    
    }
    
    /// <summary>Advanced load balancer UDPProxyProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBUDPProxyProfile 
    {
        /// <summary>The amount of time (in sec) for which a flow needs to be
        /// idle before it is deleted.
        /// Allowed values are 2-3600.
        /// Unit is SEC.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 10.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("session_idle_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(2D, 3600D)]
        public long? Session_idle_timeout { get; set; } = 10L;
    
    
    }
    
    /// <summary>Bidirectional Forwarding Detection configuration for BGP peers</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BfdProfile : PolicyConfigResource
    {
        /// <summary>Time interval between heartbeat packets in milliseconds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(50D, 60000D)]
        public long? Interval { get; set; } = 500L;
    
        /// <summary>Declare dead multiple.
        /// Number of times heartbeat packet is missed before BFD declares the
        /// neighbor is down.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("multiple", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(2D, 16D)]
        public long? Multiple { get; set; } = 3L;
    
    
    }
    
    /// <summary>Protocol to transfer backup file to remote server</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FileTransferProtocol 
    {
        /// <summary>Protocol name</summary>
        [Newtonsoft.Json.JsonProperty("protocol_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FileTransferProtocolProtocol_name Protocol_name { get; set; } = SDKGenerator.FileTransferProtocolProtocol_name.Sftp;
    
        /// <summary>The expected SSH fingerprint of the server. If the server's fingerprint
        /// does not match this fingerprint, the connection will be terminated.
        /// 
        /// Only ECDSA fingerprints hashed with SHA256 are supported. To obtain the
        /// host's ssh fingerprint, you should connect via some method other than
        /// SSH to obtain this information. You can use one of these commands to
        /// view the key's fingerprint:
        /// 1. ssh-keygen -l -E sha256 -f ssh_host_ecdsa_key.pub
        /// 2. awk '{print $2}' ssh_host_ecdsa_key.pub | base64 -d | sha256sum -b |
        ///    sed 's/ .*$//' | xxd -r -p | base64 | sed 's/.//44g' |
        ///    awk '{print "SHA256:"$1}'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ssh_fingerprint", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ssh_fingerprint { get; set; }
    
        /// <summary>Scheme to authenticate if required</summary>
        [Newtonsoft.Json.JsonProperty("authentication_scheme", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public FileTransferAuthenticationScheme Authentication_scheme { get; set; } = new FileTransferAuthenticationScheme();
    
    
    }
    
    /// <summary>Child wrapper object for PortDiscoveryProfileBindingMap, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPortDiscoveryProfileBindingMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PortDiscoveryProfileBindingMap object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PortDiscoveryProfileBindingMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PortDiscoveryProfileBindingMap PortDiscoveryProfileBindingMap { get; set; }
    
    
    }
    
    /// <summary>IPFIX packets from source will be sent to IPFIX DFW collector.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPFIXDFWProfile : PolicyConfigResource
    {
        /// <summary>Policy path for IPFIX collector profiles. IPFIX data from
        /// these logical segments will be sent to all specified IPFIX
        /// collectors.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipfix_dfw_collector_profile_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ipfix_dfw_collector_profile_path { get; set; }
    
        /// <summary>This priority field is used to resolve conflicts in Segment
        /// Ports which are covered by more than one IPFIX profiles. The IPFIX
        /// exporter will send records to Collectors in highest priority
        /// profile (lowest number) only.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 32000D)]
        public long? Priority { get; set; } = 0L;
    
        /// <summary>For long standing active flows, IPFIX records will be sent
        /// per timeout period in minutes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("active_flow_export_timeout", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1D, 60D)]
        public long Active_flow_export_timeout { get; set; } = 1L;
    
        /// <summary>An identifier that is unique to the exporting process
        /// and used to meter the flows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("observation_domain_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65536D)]
        public long? Observation_domain_id { get; set; } = 0L;
    
    
    }
    
    /// <summary>Advanced configuration for Policy connectivity</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConnectivityAdvancedConfig 
    {
        /// <summary>Connectivity configuration to manually connect (ON) or disconnect (OFF)
        /// a Tier1 segment from corresponding Tier1 gateway. Only valid for Tier1
        /// Segments.
        /// This property is ignored for L2 VPN extended segments when subnets
        /// property is not specified.
        /// This property does not apply to VLAN backed segments. VLAN backed segments
        /// with connectivity OFF does not affect its layer-2 connectivity.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("connectivity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConnectivityAdvancedConfigConnectivity? Connectivity { get; set; } = SDKGenerator.ConnectivityAdvancedConfigConnectivity.ON;
    
    
    }
    
    /// <summary>Policy Application Service data holder</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ApplicationServiceAttribute 
    {
        /// <summary>Key value pair that will be used while deploying application service template.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key_value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KeyValuePair Key_value { get; set; }
    
    
    }
    
    /// <summary>Traffic statistics for IPSec VPN Ike session.
    /// Note - Not supported in this release.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnIkeTrafficStatistics 
    {
        /// <summary>Number of packets out.</summary>
        [Newtonsoft.Json.JsonProperty("packets_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_out { get; set; }
    
        /// <summary>Fail count.</summary>
        [Newtonsoft.Json.JsonProperty("fail_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Fail_count { get; set; }
    
        /// <summary>Number of packets in.</summary>
        [Newtonsoft.Json.JsonProperty("packets_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_in { get; set; }
    
        /// <summary>Number of bytes out.</summary>
        [Newtonsoft.Json.JsonProperty("bytes_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_out { get; set; }
    
        /// <summary>Number of bytes in.</summary>
        [Newtonsoft.Json.JsonProperty("bytes_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_in { get; set; }
    
    
    }
    
    /// <summary>Represents legend that describes the entities of the widget.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Legend 
    {
        /// <summary>Describes the relative placement of legend. The legend of a widget can be placed either to the TOP or BOTTOM or LEFT or RIGHT relative to the widget. For example, if RIGHT is chosen then legend is placed to the right of the widget.</summary>
        [Newtonsoft.Json.JsonProperty("position", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LegendPosition? Position { get; set; } = SDKGenerator.LegendPosition.RIGHT;
    
        /// <summary>If set to true, it will display the counts in legend. If set to false, counts of entities are not displayed in the legend.</summary>
        [Newtonsoft.Json.JsonProperty("display_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Display_count { get; set; } = true;
    
        /// <summary>Describes the render type for the legend. The legend for an entity describes the entity in the widget. The supported legend type is a circle against which the entity's details such as display_name are shown. The color of the circle denotes the color of the entity shown inside the widget.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LegendType? Type { get; set; } = SDKGenerator.LegendType.CIRCLE;
    
        /// <summary>Show unit of entities in the legend.</summary>
        [Newtonsoft.Json.JsonProperty("unit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Unit { get; set; }
    
        /// <summary>Describes the alignment of legend. Alignment of a legend denotes how individual items of the legend are aligned in a container. For example, if VERTICAL is chosen then the items of the legend will appear one below the other and if HORIZONTAL is chosen then the items will appear side by side.</summary>
        [Newtonsoft.Json.JsonProperty("alignment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LegendAlignment? Alignment { get; set; } = SDKGenerator.LegendAlignment.VERTICAL;
    
    
    }
    
    /// <summary>L4PortSet can be specified in comma separated notation of parts. Parts of a
    /// L4PortSet includes single integer or range of port in hyphen notation.
    /// Example of a PortSet: "22, 33-70, 44".
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L4PortSetServiceEntry : ServiceEntry
    {
        /// <summary>Number of values should not exceed 15, ranges count as 2 values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destination_ports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(15)]
        public System.Collections.Generic.ICollection<string> Destination_ports { get; set; }
    
        [Newtonsoft.Json.JsonProperty("l4_protocol", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public L4PortSetServiceEntryL4_protocol L4_protocol { get; set; }
    
        /// <summary>Number of values should not exceed 15, ranges count as 2 values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source_ports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(15)]
        public System.Collections.Generic.ICollection<string> Source_ports { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HTTPSecurityPolicy object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPSecurityPolicy 
    {
        /// <summary>Add rules to the HTTP security policy.</summary>
        [Newtonsoft.Json.JsonProperty("rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBHTTPSecurityRule> Rules { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IgmpMembershipCsvRecord : CsvRecord
    {
        /// <summary>Transport node uuid or policy path.</summary>
        [Newtonsoft.Json.JsonProperty("transport_node", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transport_node { get; set; }
    
        /// <summary>Multicast group membership active time.</summary>
        [Newtonsoft.Json.JsonProperty("uptime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uptime { get; set; }
    
        /// <summary>Multicast group address.</summary>
        [Newtonsoft.Json.JsonProperty("group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group { get; set; }
    
        /// <summary>Interface on which multicast group membership is learned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("interface", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Interface { get; set; }
    
        /// <summary>Number of multicast sources.</summary>
        [Newtonsoft.Json.JsonProperty("no_of_sources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string No_of_sources { get; set; }
    
        /// <summary>IP address of multicast source.</summary>
        [Newtonsoft.Json.JsonProperty("source_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source_address { get; set; }
    
        /// <summary>IGMP version.</summary>
        [Newtonsoft.Json.JsonProperty("igmp_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Igmp_version { get; set; }
    
    
    }
    
    /// <summary>Certificate queries result</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TlsCertificateList : ListResult
    {
        /// <summary>TlsCertificate list.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TlsCertificate> Results { get; set; }
    
    
    }
    
    /// <summary>Statistics counters of the DNS forwarder zone.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class NsxTDNSForwarderZoneStatistics 
    {
        /// <summary>Statistics per upstream server.</summary>
        [Newtonsoft.Json.JsonProperty("upstream_statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(3)]
        public System.Collections.Generic.ICollection<NsxTUpstreamServerStatistics> Upstream_statistics { get; set; }
    
        /// <summary>Domain names configured for the forwarder. Empty if this is the
        /// default forwarder.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("domain_names", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(100)]
        public System.Collections.Generic.ICollection<string> Domain_names { get; set; }
    
    
    }
    
    /// <summary>Information related to Sites applicable for given VHC.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SiteInfo 
    {
        /// <summary>For the local manager this needs to be set to 'default'.
        /// This represents the path of the site which is managed by Global Manager.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("site_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Site_path { get; set; }
    
        /// <summary>The transport zone has to be set when creating VHC on Local manager.
        /// If not set for local manager, default transport zone will be used.
        /// For the Global Manager the transport zone path will be picked up from the site.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transport_zone_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Transport_zone_paths { get; set; }
    
        /// <summary>The edge cluster on which the networking elements for the VHC will be created.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_cluster_paths", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Edge_cluster_paths { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>Used to configure L2 Bridge endpoint profile</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2BridgeEndpointProfile : PolicyConfigResource
    {
        /// <summary>Failover mode for the edge bridge cluster</summary>
        [Newtonsoft.Json.JsonProperty("failover_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public L2BridgeEndpointProfileFailover_mode? Failover_mode { get; set; } = SDKGenerator.L2BridgeEndpointProfileFailover_mode.PREEMPTIVE;
    
        /// <summary>High avaialability mode can be active-active or active-standby. High availability mode cannot be modified after realization.</summary>
        [Newtonsoft.Json.JsonProperty("ha_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public L2BridgeEndpointProfileHa_mode? Ha_mode { get; set; } = SDKGenerator.L2BridgeEndpointProfileHa_mode.ACTIVE_STANDBY;
    
        /// <summary>List of policy paths to edge nodes. Edge allocation for L2 bridging.</summary>
        [Newtonsoft.Json.JsonProperty("edge_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(2)]
        public System.Collections.Generic.ICollection<string> Edge_paths { get; set; }
    
    
    }
    
    /// <summary>Paged collection of BGP Neighbor Configs</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BgpNeighborConfigListResult : ListResult
    {
        /// <summary>BGP neighbor configs list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<BgpNeighborConfig> Results { get; set; } = new System.Collections.ObjectModel.Collection<BgpNeighborConfig>();
    
    
    }
    
    /// <summary>Child wrapper object for PortMonitoringProfileBindingMap, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPortMonitoringProfileBindingMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PortMonitoringProfileBindingMap object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PortMonitoringProfileBindingMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PortMonitoringProfileBindingMap PortMonitoringProfileBindingMap { get; set; }
    
    
    }
    
    /// <summary>Details of org/namespace within a container cluster.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ContainerProject : DiscoveredResource
    {
        /// <summary>Network status of container project.</summary>
        [Newtonsoft.Json.JsonProperty("network_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ContainerProjectNetwork_status? Network_status { get; set; }
    
        /// <summary>Identifier of the container cluster to which this project/namespace belongs.</summary>
        [Newtonsoft.Json.JsonProperty("container_cluster_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Container_cluster_id { get; set; }
    
        /// <summary>Array of additional specific properties of container project
        /// in key-value format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("origin_properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyValuePair> Origin_properties { get; set; }
    
        /// <summary>External identifier of the container project.</summary>
        [Newtonsoft.Json.JsonProperty("external_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string External_id { get; set; }
    
        /// <summary>List of network errors related to container project.</summary>
        [Newtonsoft.Json.JsonProperty("network_errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<NetworkError> Network_errors { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyPktCapResource : PktCapResource
    {
        /// <summary>The path of segment port or router port where the packets are captured</summary>
        [Newtonsoft.Json.JsonProperty("logical_port_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Logical_port_path { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BgpNeighborRouteDetailsInCsvFormat : CsvListResult
    {
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<BgpNeighborRouteDetailsCsvRecord> Results { get; set; }
    
    
    }
    
    /// <summary>Multicast routing configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyMulticastConfig : PolicyConfigResource
    {
        /// <summary>Replication multicast range. Required when enabled.</summary>
        [Newtonsoft.Json.JsonProperty("replication_multicast_range", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Replication_multicast_range { get; set; }
    
        /// <summary>Updates to IGMP profile applied on all Tier0 gateways consuming the configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("igmp_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Igmp_profile_path { get; set; }
    
        /// <summary>Updates to PIM profile applied on all Tier0 gateways consuming the configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pim_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pim_profile_path { get; set; }
    
        /// <summary>Enable/disable Multicast Configuration.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = false;
    
    
    }
    
    /// <summary>Evpn Configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EvpnConfig : PolicyConfigResource
    {
        /// <summary>Encapsulation method for EVPN service that is used by the transport layer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("encapsulation_method", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EvpnEncapConfig Encapsulation_method { get; set; }
    
        /// <summary>In INLINE mode, edge nodes participate both in the BGP EVPN control
        /// plane route exchange and in data path tunneling between edge nodes
        /// and data center gateways. In ROUTE_SERVER mode, edge nodes participate
        /// in the BGP EVPN control plane route exchanges only and do not participate
        /// in the data forwarding, i.e., the data path tunnels are directly
        /// established between the hypervisors and the data center gateways.
        /// DISABLE mode disables EVPN service capability.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EvpnConfigMode? Mode { get; set; } = SDKGenerator.EvpnConfigMode.DISABLE;
    
    
    }
    
    /// <summary>Advanced load balancer NetworkProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBNetworkProfile : PolicyConfigResource
    {
        /// <summary>Placeholder for description of property profile of obj type
        /// NetworkProfile field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("profile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBNetworkProfileUnion Profile { get; set; } = new ALBNetworkProfileUnion();
    
        /// <summary>When enabled, Avi mirrors all TCP fastpath connections to
        /// standby.
        /// Applicable only in Legacy HA Mode.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("connection_mirror", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Connection_mirror { get; set; } = false;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SIAggregatedDataCounter 
    {
        [Newtonsoft.Json.JsonProperty("tx_bytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SIDataCounter Tx_bytes { get; set; }
    
        [Newtonsoft.Json.JsonProperty("rx_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SIDataCounter Rx_packets { get; set; }
    
        [Newtonsoft.Json.JsonProperty("tx_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SIDataCounter Tx_packets { get; set; }
    
        [Newtonsoft.Json.JsonProperty("rx_bytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SIDataCounter Rx_bytes { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for Segment, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildSegment : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual Segment object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Segment", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Segment Segment { get; set; }
    
    
    }
    
    /// <summary>The load balancer node usage summary for all nodes from specific
    /// enforcement point. Only edge node is supported. The summary contains all
    /// edge nodes which are configured in edge clusters.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBNodeUsageSummary : PolicyRuntimeInfoPerEP
    {
        /// <summary>Current load balancer credits in use for all nodes.
        /// For example, configuring a medium load balancer on a node consumes
        /// 10 credits. If there are 2 medium instances configured, the current
        /// load balancer credit number is 2 * 10 = 20.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_load_balancer_credits", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Current_load_balancer_credits { get; set; }
    
        /// <summary>The load balancer credit capacity means the maximum credits which can
        /// be used for load balancer service configuration for all nodes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("load_balancer_credit_capacity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Load_balancer_credit_capacity { get; set; }
    
        /// <summary>The property identifies all LB node usages. By default, it is not
        /// included in response. It exists when parameter ?include_usages=true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("node_usages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBNodeUsage> Node_usages { get; set; }
    
        /// <summary>The severity calculation is based on overall credit usage percentage
        /// of load balancer for all nodes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("severity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBNodeUsageSummarySeverity? Severity { get; set; }
    
        /// <summary>Pool member capacity means maximum number of pool members which can
        /// be configured on all nodes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_member_capacity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Pool_member_capacity { get; set; }
    
        /// <summary>The property identifies array of node count for each severity.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("node_counts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBNodeCountPerSeverity> Node_counts { get; set; }
    
        /// <summary>The overall count of pool members configured on all nodes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current_pool_member_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Current_pool_member_count { get; set; }
    
        /// <summary>The overall usage percentage of all nodes for load balancer.
        /// The value is the larger value between overall pool member usage
        /// percentage and overall load balancer credit usage percentage.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("usage_percentage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Usage_percentage { get; set; }
    
    
    }
    
    /// <summary>Match condition for client certficate issuer DN.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBClientCertificateIssuerDnCondition 
    {
        /// <summary>If true, case is significant when comparing issuer DN value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("case_sensitive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Case_sensitive { get; set; } = true;
    
        /// <summary>Match type of issuer DN.</summary>
        [Newtonsoft.Json.JsonProperty("match_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBClientCertificateIssuerDnConditionMatch_type? Match_type { get; set; } = SDKGenerator.LBClientCertificateIssuerDnConditionMatch_type.REGEX;
    
        /// <summary>Value of issuer DN.</summary>
        [Newtonsoft.Json.JsonProperty("issuer_dn", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Issuer_dn { get; set; }
    
    
    }
    
    /// <summary>Represents the filtering criteria of a IDS Profile.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsProfileFilterCriteria : IdsProfileCriteria
    {
        /// <summary>Represents the value of selected filter name.
        /// Note : The supported values for filter name CVSS are
        ///    NONE, LOW, MEDIUM, HIGH, CRITICAL.
        ///    NONE     means CVSS score as 0.0
        ///    LOW      means CVSS score as 0.1-3.9
        ///    MEDIUM   means CVSS score as 4.0-6.9
        ///    HIGH     means CVSS score as 7.0-8.9
        ///    CRITICAL means CVSS score as 9.0-10.0
        /// </summary>
        [Newtonsoft.Json.JsonProperty("filter_value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Filter_value { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Represents the filter for IDS Profile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("filter_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IdsProfileFilterCriteriaFilter_name Filter_name { get; set; }
    
    
    }
    
    /// <summary>Tier0 HA VIP Config</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier0HaVipConfig 
    {
        /// <summary>Policy paths to Tier0 external interfaces which are to be paired to provide redundancy. Floating IP will be owned by one of these interfaces depending upon which edge node is Active.</summary>
        [Newtonsoft.Json.JsonProperty("external_interface_paths", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(2)]
        public System.Collections.Generic.ICollection<string> External_interface_paths { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Array of IP address subnets which will be used as floating IP addresses.</summary>
        [Newtonsoft.Json.JsonProperty("vip_subnets", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(2)]
        public System.Collections.Generic.ICollection<InterfaceSubnet> Vip_subnets { get; set; } = new System.Collections.ObjectModel.Collection<InterfaceSubnet>();
    
        /// <summary>Flag to enable this HA VIP config.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
    
    }
    
    /// <summary>Advanced load balancer RateProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBRateProfile 
    {
        /// <summary>HTTP header name.</summary>
        [Newtonsoft.Json.JsonProperty("http_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Http_header { get; set; }
    
        /// <summary>HTTP cookie name.</summary>
        [Newtonsoft.Json.JsonProperty("http_cookie", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Http_cookie { get; set; }
    
        /// <summary>Action to perform upon rate limiting.</summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBRateLimiterAction Action { get; set; } = new ALBRateLimiterAction();
    
        /// <summary>Explicitly tracks an attacker across rate periods.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("explicit_tracking", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Explicit_tracking { get; set; } = false;
    
        /// <summary>The rate limiter configuration for this rate profile.</summary>
        [Newtonsoft.Json.JsonProperty("rate_limiter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBRateLimiter Rate_limiter { get; set; }
    
        /// <summary>Enable fine granularity.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fine_grain", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Fine_grain { get; set; } = false;
    
    
    }
    
    /// <summary>Paged Collection of OverriddenResource.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverriddenResourceListResult : ListResult
    {
        /// <summary>OverriddenResource list results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<OverriddenResource> Results { get; set; } = new System.Collections.ObjectModel.Collection<OverriddenResource>();
    
    
    }
    
    /// <summary>Advanced load balancer SSLVersion object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSSLVersion 
    {
        /// <summary>Enum options - SSL_VERSION_SSLV3, SSL_VERSION_TLS1,
        /// SSL_VERSION_TLS1_1, SSL_VERSION_TLS1_2, SSL_VERSION_TLS1_3.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as SSL_VERSION_TLS1_1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBSSLVersionType Type { get; set; } = SDKGenerator.ALBSSLVersionType.SSL_VERSION_TLS1_1;
    
    
    }
    
    /// <summary>Source that is logically deemed to be the "object" upon which the
    /// Event in question initially occurred upon. The Source is responsible
    /// for providing information of the occurred event. Some example sources
    /// include:
    /// - Resource.
    /// - API.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("ApiRequestBody", typeof(ApiRequestBody))]
    [JsonInheritanceAttribute("ResourceOperation", typeof(ResourceOperation))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Source 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyCountObservation : BaseCountObservation
    {
        /// <summary>The path of segment port or router port where the counter observation is populated</summary>
        [Newtonsoft.Json.JsonProperty("logical_port_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Logical_port_path { get; set; }
    
    
    }
    
    /// <summary>SSOPolicyApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSSOPolicyApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of SSOPolicy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBSSOPolicy> Results { get; set; }
    
    
    }
    
    /// <summary>Multicast forwarding entry.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MulticastForwarding 
    {
        /// <summary>Multicast source address.</summary>
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source { get; set; }
    
        /// <summary>Array of egress interfaces on whic multicast traffic is forwarded.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("outgoing_interfaces", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MulticastForwardingInterface> Outgoing_interfaces { get; set; }
    
        /// <summary>Ingress interface on whic multicast traffic is learned.</summary>
        [Newtonsoft.Json.JsonProperty("incoming_interface", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public MulticastForwardingInterface Incoming_interface { get; set; }
    
        /// <summary>Multicast group address.</summary>
        [Newtonsoft.Json.JsonProperty("multicast_group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Multicast_group { get; set; }
    
    
    }
    
    /// <summary>Snat Ip pool.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBSnatIpPool : LBSnatTranslation
    {
        /// <summary>If an IP range is specified, the range may contain no more than 64
        /// IP addresses.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip_addresses", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(64)]
        public System.Collections.Generic.ICollection<LBSnatIpElement> Ip_addresses { get; set; } = new System.Collections.ObjectModel.Collection<LBSnatIpElement>();
    
    
    }
    
    /// <summary>Child wrapper object for IdsSignature, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIdsSignature : ChildPolicyConfigResource
    {
        /// <summary>Contains the IdsSignature object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IdsSignature", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IdsSignature IdsSignature { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer VirtualService object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBVirtualService : PolicyConfigResource
    {
        /// <summary>HTTP authentication configuration for protected resources.</summary>
        [Newtonsoft.Json.JsonProperty("client_auth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPClientAuthenticationParams Client_auth { get; set; }
    
        /// <summary>The pool is an object that contains destination servers and
        /// related attributes such as load-balancing and persistence.
        /// It is a reference to an object of type Pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pool_path { get; set; }
    
        /// <summary>Select SSL Profile based on client IP address match.</summary>
        [Newtonsoft.Json.JsonProperty("ssl_profile_selectors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBSSLProfileSelector> Ssl_profile_selectors { get; set; }
    
        /// <summary>The pool group is an object that contains pools.
        /// It is a reference to an object of type PoolGroup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool_group_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pool_group_path { get; set; }
    
        /// <summary>Service discovery specific data including fully qualified
        /// domain name, type and Time-To-Live of the DNS record.
        /// Note that only one of fqdn and dns_info setting is allowed.
        /// Maximum of 1000 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dns_info", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDnsInfo> Dns_info { get; set; }
    
        /// <summary>Criteria for flow distribution among SEs.
        /// Enum options - LOAD_AWARE,
        /// CONSISTENT_HASH_SOURCE_IP_ADDRESS,
        /// CONSISTENT_HASH_SOURCE_IP_ADDRESS_AND_PORT.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as LOAD_AWARE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("flow_dist", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBVirtualServiceFlow_dist? Flow_dist { get; set; } = SDKGenerator.ALBVirtualServiceFlow_dist.LOAD_AWARE;
    
        /// <summary>Determines the set of SSL versions and ciphers to accept
        /// for SSL/TLS terminated connections.
        /// It is a reference to an object of type SSLProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ssl_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ssl_profile_path { get; set; }
    
        /// <summary>Profile used to match and rewrite strings in request and/or
        /// response body.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("content_rewrite", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBContentRewriteProfile Content_rewrite { get; set; }
    
        /// <summary>Select the algorithm for QoS fairness.
        /// This determines how multiple Virtual Services sharing the
        /// same Service Engines will prioritize traffic over a
        /// congested network.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("delay_fairness", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Delay_fairness { get; set; } = false;
    
        /// <summary>List of Virtual Service IPs.
        /// While creating a 'Shared VS',please use vsvip_ref to point
        /// to the shared entities.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBVip> Vip { get; set; }
    
        /// <summary>NAT'ted floating source IP Address(es) for upstream
        /// connection to servers.
        /// Maximum of 32 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("snat_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBIpAddr> Snat_ip { get; set; }
    
        /// <summary>Creator name.</summary>
        [Newtonsoft.Json.JsonProperty("created_by", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_by { get; set; }
    
        /// <summary>The name of the Contract/Graph associated with the Virtual
        /// Service.
        /// Should be in the &lt;Contract name&gt; &lt;Graph name&gt; format.
        /// This is applicable only for Service Integration mode with
        /// Cisco APIC Controller .
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apic_contract_graph", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Apic_contract_graph { get; set; }
    
        /// <summary>WAF policy for the Virtual Service.
        /// It is a reference to an object of type WafPolicy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("waf_policy_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Waf_policy_path { get; set; }
    
        /// <summary>Enable Route Health Injection for Source NAT'ted floating
        /// IP Address using the BGP Config in the vrf context.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_rhi_snat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_rhi_snat { get; set; }
    
        /// <summary>Determines network settings such as protocol, TCP or UDP,
        /// and related options for the protocol.
        /// It is a reference to an object of type NetworkProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("network_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Network_profile_path { get; set; }
    
        /// <summary>Metadata pertaining to the Service provided by this virtual
        /// service.
        /// In Openshift/Kubernetes environments, egress pod info is
        /// stored.
        /// Any user input to this field will be overwritten by Avi
        /// Vantage.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service_metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Service_metadata { get; set; }
    
        /// <summary>Sideband configuration to be used for this
        /// virtualservice.It can be used for sending traffic to
        /// sideband VIPs for external inspection etc.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sideband_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBSidebandProfile Sideband_profile { get; set; }
    
        /// <summary>Server network or list of servers for cloning traffic.
        /// It is a reference to an object of type TrafficCloneProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("traffic_clone_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Traffic_clone_profile_path { get; set; }
    
        /// <summary>Rate limit the incoming requests to this virtual service.</summary>
        [Newtonsoft.Json.JsonProperty("requests_rate_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBRateProfile Requests_rate_limit { get; set; }
    
        /// <summary>(This is a beta feature).
        /// Sync Key-Value cache to the new SEs when VS is scaled out.
        /// For ex  SSL sessions are stored using VS's Key-Value cache.
        /// When the VS is scaled out, the SSL session information is
        /// synced to the new SE, allowing existing SSL sessions to be
        /// reused on the new SE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bulk_sync_kvcache", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Bulk_sync_kvcache { get; set; } = false;
    
        /// <summary>The SSO Policy attached to the virtualservice.
        /// It is a reference to an object of type SSOPolicy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sso_policy_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sso_policy_path { get; set; }
    
        /// <summary>Enum options - CLOUD_NONE, CLOUD_VCENTER, CLOUD_OPENSTACK,
        /// CLOUD_AWS, CLOUD_VCA, CLOUD_APIC, CLOUD_MESOS,
        /// CLOUD_LINUXSERVER, CLOUD_DOCKER_UCP, CLOUD_RANCHER,
        /// CLOUD_OSHIFT_K8S, CLOUD_AZURE, CLOUD_GCP, CLOUD_NSXT.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as CLOUD_NONE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cloud_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBVirtualServiceCloud_type? Cloud_type { get; set; } = SDKGenerator.ALBVirtualServiceCloud_type.CLOUD_NONE;
    
        /// <summary>The Quality of Service weight to assign to traffic
        /// transmitted from this Virtual Service.
        /// A higher weight will prioritize traffic versus other
        /// Virtual Services sharing the same Service Engines.
        /// Allowed values are 1-128.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("weight", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 128D)]
        public long? Weight { get; set; } = 1L;
    
        /// <summary>The exact name requested from the client's SNI-enabled TLS
        /// hello domain name field.
        /// If this is a match, the parent VS will forward the
        /// connection to this child VS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vh_domain_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Vh_domain_name { get; set; }
    
        /// <summary>Keep advertising Virtual Service via BGP even if it is
        /// marked down by health monitor.
        /// This setting takes effect for future Virtual Service flaps.
        /// To advertise current VSes that are down, please disable and
        /// re-enable the Virtual Service.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("advertise_down_vs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Advertise_down_vs { get; set; } = false;
    
        /// <summary>Application-specific SAML config.</summary>
        [Newtonsoft.Json.JsonProperty("saml_sp_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBSAMLSPConfig Saml_sp_config { get; set; }
    
        /// <summary>Mostly used during the creation of Shared VS, this field
        /// refers to entities that can be shared across Virtual
        /// Services.
        /// It is a reference to an object of type VsVip.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vsvip_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Vsvip_path { get; set; }
    
        /// <summary>Ignore Pool servers network reachability constraints for
        /// Virtual Service placement.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ign_pool_net_reach", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Ign_pool_net_reach { get; set; } = false;
    
        /// <summary>Minimum number of UP pools to mark VS up.</summary>
        [Newtonsoft.Json.JsonProperty("min_pools_up", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Min_pools_up { get; set; }
    
        /// <summary>Maximum connections per second per client IP.
        /// Allowed values are 10-1000.
        /// Special values are 0- 'unlimited'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_cps_per_client", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 1000D)]
        public long? Max_cps_per_client { get; set; } = 0L;
    
        /// <summary>Network security policies for the Virtual Service.
        /// It is a reference to an object of type
        /// NetworkSecurityPolicy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("network_security_policy_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Network_security_policy_path { get; set; }
    
        /// <summary>Checksum of cloud configuration for VS.
        /// Internally set by cloud connector.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cloud_config_cksum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cloud_config_cksum { get; set; }
    
        /// <summary>Knob to enable the Virtual Service traffic on its assigned
        /// service engines.
        /// This setting is effective only when the enabled flag is set
        /// to True.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("traffic_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Traffic_enabled { get; set; } = true;
    
        /// <summary>(internal-use)Applicable for Azure only.
        /// Azure Availability set to which this VS is associated.
        /// Internally set by the cloud connector.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("azure_availability_set", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Azure_availability_set { get; set; }
    
        /// <summary>Expected number of SSL session cache entries (may be
        /// exceeded).
        /// Allowed values are 1024-16383.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1024.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ssl_sess_cache_avg_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1024D, 16383D)]
        public long? Ssl_sess_cache_avg_size { get; set; } = 1024L;
    
        /// <summary>Datascripts applied on the data traffic of the Virtual
        /// Service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vs_datascripts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBVSDataScripts> Vs_datascripts { get; set; }
    
        /// <summary>L4 Policies applied to the data traffic of the Virtual
        /// Service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("l4_policies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBL4Policies> L4_policies { get; set; }
    
        /// <summary>Use Bridge IP as VIP on each Host in Mesos deployments.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("use_bridge_ip_as_vip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Use_bridge_ip_as_vip { get; set; } = false;
    
        /// <summary>Process request even if invalid client certificate is
        /// presented.
        /// Datascript APIs need to be used for processing of such
        /// requests.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allow_invalid_client_cert", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Allow_invalid_client_cert { get; set; } = false;
    
        /// <summary>Optional settings that determine performance limits like
        /// max connections or bandwdith etc.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("performance_limits", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBPerformanceLimits Performance_limits { get; set; }
    
        /// <summary>HTTP Policies applied on the data traffic of the Virtual
        /// Service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("http_policies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBHTTPPolicies> Http_policies { get; set; }
    
        /// <summary>GSLB pools used to manage site-persistence functionality.
        /// Each site-persistence pool contains the virtualservices in
        /// all the other sites, that is auto-generated by the GSLB
        /// manager.
        /// This is a read-only field for the user.
        /// It is a reference to an object of type Pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sp_pool_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Sp_pool_paths { get; set; }
    
        /// <summary>This configuration only applies if the VirtualService is in
        /// Legacy Active Standby HA mode and Load Distribution among
        /// Active Standby is enabled.
        /// This field is used to tag the VirtualService so that
        /// VirtualServices with the same tag will share the same Active
        /// ServiceEngine.
        /// VirtualServices with different tags will have different
        /// Active ServiceEngines.
        /// If one of the ServiceEngine's in the ServiceEngineGroup
        /// fails, all VirtualServices will end up using the same Active
        /// ServiceEngine.
        /// Redistribution of the VirtualServices can be either manual
        /// or automated when the failed ServiceEngine recovers.
        /// Redistribution is based on the auto redistribute property
        /// of the ServiceEngineGroup.
        /// Enum options - ACTIVE_STANDBY_SE_1, ACTIVE_STANDBY_SE_2.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as ACTIVE_STANDBY_SE_1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("active_standby_se_tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBVirtualServiceActive_standby_se_tag? Active_standby_se_tag { get; set; } = SDKGenerator.ALBVirtualServiceActive_standby_se_tag.ACTIVE_STANDBY_SE_1;
    
        /// <summary>Select or create one or two certificates, EC and/or RSA,
        /// that will be presented to SSL/TLS terminated connections.
        /// It is a reference to an object of type
        /// SSLKeyAndCertificate.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ssl_key_and_certificate_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Ssl_key_and_certificate_paths { get; set; }
    
        /// <summary>Translate the host name sent to the servers to this value.
        /// Translate the host name sent from servers back to the value
        /// used by the client.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("host_name_xlate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Host_name_xlate { get; set; }
    
        /// <summary>Use the Virtual IP as the SNAT IP for health monitoring and
        /// sending traffic to the backend servers instead of the
        /// Service Engine interface IP.
        /// The caveat of enabling this option is that the
        /// VirtualService cannot be configued in an Active-Active HA
        /// mode.
        /// DNS based Multi VIP solution has to be used for HA &amp;
        /// Non-disruptive Upgrade purposes.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("use_vip_as_snat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Use_vip_as_snat { get; set; } = false;
    
        /// <summary>Enable application layer specific features for the Virtual
        /// Service.
        /// It is a reference to an object of type ApplicationProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("application_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Application_profile_path { get; set; }
    
        /// <summary>Specifies the Virtual Service acting as Virtual Hosting
        /// (SNI) parent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vh_parent_vs_uuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Vh_parent_vs_uuid { get; set; }
    
        /// <summary>Rate limit the incoming connections to this virtual
        /// service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("connections_rate_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBRateProfile Connections_rate_limit { get; set; }
    
        /// <summary>The Service Engine Group to use for this Virtual Service.
        /// Moving to a new SE Group is disruptive to existing
        /// connections for this VS.
        /// It is a reference to an object of type ServiceEngineGroup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("se_group_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Se_group_name { get; set; }
    
        /// <summary>Topology Policies applied on the dns traffic of the Virtual
        /// Service based onGSLB Topology algorithm.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("topology_policies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDnsPolicies> Topology_policies { get; set; }
    
        /// <summary>Force placement on all SE's in service group (Mesos mode
        /// only).
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("east_west_placement", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? East_west_placement { get; set; } = false;
    
        /// <summary>Error Page Profile to be used for this virtualservice.This
        /// profile is used to send the custom error page to the client
        /// generated by the proxy.
        /// It is a reference to an object of type ErrorPageProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("error_page_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error_page_profile_path { get; set; }
    
        /// <summary>Limit potential DoS attackers who exceed max_cps_per_client
        /// significantly to a fraction of max_cps_per_client for a
        /// while.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("limit_doser", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Limit_doser { get; set; } = false;
    
        /// <summary>Select pool based on destination port.</summary>
        [Newtonsoft.Json.JsonProperty("service_pool_select", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBServicePoolSelector> Service_pool_select { get; set; }
    
        /// <summary>close client connection on vs config update.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("close_client_conn_on_config_update", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Close_client_conn_on_config_update { get; set; } = false;
    
        /// <summary>Specify if this is a normal Virtual Service, or if it is
        /// the parent or child of an SNI-enabled virtual hosted Virtual
        /// Service.
        /// Enum options - VS_TYPE_NORMAL, VS_TYPE_VH_PARENT,
        /// VS_TYPE_VH_CHILD.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as VS_TYPE_NORMAL.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBVirtualServiceType? Type { get; set; } = SDKGenerator.ALBVirtualServiceType.VS_TYPE_NORMAL;
    
        /// <summary>Response traffic to clients will be sent back to the source
        /// MAC address of the connection, rather than statically sent
        /// to a default gateway.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_autogw", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_autogw { get; set; } = true;
    
        /// <summary>A list of NSX Groups representing the Clients which can
        /// access the Virtual IP of the Virtual Service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("group_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Group_paths { get; set; }
    
        /// <summary>Enable or disable the Virtual Service.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
        /// <summary>Remove listening port if VirtualService is down.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remove_listening_port_on_vs_down", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Remove_listening_port_on_vs_down { get; set; } = false;
    
        /// <summary>DNS resolvable, fully qualified domain name of the
        /// virtualservice.
        /// Only one of 'fqdn' and 'dns_info' configuration is allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fqdn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fqdn { get; set; }
    
        /// <summary>DNS Policies applied on the dns traffic of the Virtual
        /// Service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dns_policies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDnsPolicies> Dns_policies { get; set; }
    
        /// <summary>List of static DNS records applied to this Virtual Service.
        /// These are static entries and no health monitoring is
        /// performed against the IP addresses.
        /// Maximum of 1000 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("static_dns_records", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDnsRecord> Static_dns_records { get; set; }
    
        /// <summary>List of Services defined for this Virtual Service.
        /// Maximum of 2048 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("services", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBService> Services { get; set; }
    
        /// <summary>Determines analytics settings for the application.</summary>
        [Newtonsoft.Json.JsonProperty("analytics_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBAnalyticsPolicy Analytics_policy { get; set; }
    
        /// <summary>Enable Route Health Injection using the BGP Config in the
        /// vrf context.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_rhi", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_rhi { get; set; }
    
        /// <summary>Determines the network settings profile for the server side
        /// of TCP proxied connections.
        /// Leave blank to use the same settings as the client to VS
        /// side of the connection.
        /// It is a reference to an object of type NetworkProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server_network_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Server_network_profile_path { get; set; }
    
        /// <summary>Specifies settings related to analytics.
        /// It is a reference to an object of type AnalyticsProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("analytics_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Analytics_profile_path { get; set; }
    
        /// <summary>Security policy applied on the traffic of the Virtual
        /// Service.
        /// This policy is used to perform security actions such as
        /// Distributed Denial of Service (DDoS) attack mitigation, etc.
        /// It is a reference to an object of type SecurityPolicy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("security_policy_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Security_policy_path { get; set; }
    
        /// <summary>Criteria for flow labelling.
        /// Enum options - NO_LABEL, APPLICATION_LABEL, SERVICE_LABEL.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as NO_LABEL.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("flow_label_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBVirtualServiceFlow_label_type? Flow_label_type { get; set; } = SDKGenerator.ALBVirtualServiceFlow_label_type.NO_LABEL;
    
    
    }
    
    /// <summary>Wrapper object for ComputeClusterIdfwConfiguration</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildComputeClusterIdfwConfiguration : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual compute cluster idfw configuration object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ComputeClusterIdfwConfiguration", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ComputeClusterIdfwConfiguration ComputeClusterIdfwConfiguration { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentPortMacTableCsvEntry : CsvRecord
    {
        /// <summary>The type of the MAC address</summary>
        [Newtonsoft.Json.JsonProperty("mac_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SegmentPortMacTableCsvEntryMac_type Mac_type { get; set; }
    
        /// <summary>The MAC address</summary>
        [Newtonsoft.Json.JsonProperty("mac_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Mac_address { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for OspfRoutingConfig used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildOspfRoutingConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains actual OspfRoutingConfig.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("OspfRoutingConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OspfRoutingConfig OspfRoutingConfig { get; set; }
    
    
    }
    
    /// <summary>Duplicate address detection profile.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Ipv6DadProfile : PolicyConfigResource
    {
        /// <summary>The time duration in seconds, to wait for Neighbor advertisement
        /// after sending the Neighbor solicitation message.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wait_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 60D)]
        public long? Wait_time { get; set; } = 1L;
    
        /// <summary>Number of Neighbor solicitation packets generated before completing the
        /// Duplicate address detection process.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ns_retries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 10D)]
        public long? Ns_retries { get; set; } = 3L;
    
        /// <summary>DAD Mode</summary>
        [Newtonsoft.Json.JsonProperty("dad_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Ipv6DadProfileDad_mode? Dad_mode { get; set; } = SDKGenerator.Ipv6DadProfileDad_mode.LOOSE;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RoleWithFeaturesListResult : ListResult
    {
        /// <summary>List results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<RoleWithFeatures> Results { get; set; } = new System.Collections.ObjectModel.Collection<RoleWithFeatures>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SIMacLearningCounters 
    {
        /// <summary>Number of MACs learned</summary>
        [Newtonsoft.Json.JsonProperty("macs_learned", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Macs_learned { get; set; }
    
        /// <summary>The number of packets with unknown source MAC address that are dropped without learning the source MAC address. Applicable only when the MAC limit is reached and MAC Limit policy is MAC_LEARNING_LIMIT_POLICY_DROP.</summary>
        [Newtonsoft.Json.JsonProperty("mac_not_learned_packets_dropped", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Mac_not_learned_packets_dropped { get; set; }
    
        /// <summary>The number of packets with unknown source MAC address that are dispatched without learning the source MAC address. Applicable only when the MAC limit is reached and MAC Limit policy is MAC_LEARNING_LIMIT_POLICY_ALLOW.</summary>
        [Newtonsoft.Json.JsonProperty("mac_not_learned_packets_allowed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Mac_not_learned_packets_allowed { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer IpAddr object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBIpAddr 
    {
        /// <summary>Enum options - V4, DNS, V6.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBIpAddrType Type { get; set; }
    
        /// <summary>IP address.</summary>
        [Newtonsoft.Json.JsonProperty("addr", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Addr { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RoleBindingListResult : ListResult
    {
        /// <summary>List results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<RoleBinding> Results { get; set; } = new System.Collections.ObjectModel.Collection<RoleBinding>();
    
    
    }
    
    /// <summary>Child wrapper object for PolicyTier1MulticastConfig used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyTier1MulticastConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains actual PolicyTier1MulticastConfig.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyTier1MulticastConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyTier1MulticastConfig PolicyTier1MulticastConfig { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for TlsCertificate, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildTlsCertificate : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual TlsCertificate object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("TlsCertificate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public TlsCertificate TlsCertificate { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for TraceflowConfig, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildTraceflowConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual TraceflowConfig object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("TraceflowConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public TraceflowConfig TraceflowConfig { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of Transport Zone</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyTransportZoneListResult : ListResult
    {
        /// <summary>Transport Zone list result.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyTransportZone> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyTransportZone>();
    
    
    }
    
    /// <summary>Advanced load balancer HTTPClientAuthenticationParams object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPClientAuthenticationParams 
    {
        /// <summary>type of client authentication.
        /// Enum options - HTTP_BASIC_AUTH.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBHTTPClientAuthenticationParamsType? Type { get; set; }
    
        /// <summary>Basic authentication realm to present to a user along with
        /// the prompt for credentials.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("realm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Realm { get; set; }
    
        /// <summary>Rrequest URI path when the authentication applies.</summary>
        [Newtonsoft.Json.JsonProperty("request_uri_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBStringMatch Request_uri_path { get; set; }
    
        /// <summary>Auth Profile to use for validating users.
        /// It is a reference to an object of type AuthProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("auth_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Auth_profile_path { get; set; }
    
    
    }
    
    /// <summary>DNS forwarder statistics per enforcement point.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("NsxTDNSForwarderStatistics", typeof(NsxTDNSForwarderStatistics))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DNSForwarderStatisticsPerEnforcementPoint 
    {
        /// <summary>Policy path referencing the enforcement point from where the statistics are fetched.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enforcement_point_path { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer WafCRS object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBWafCRS : PolicyConfigResource
    {
        /// <summary>The release date of this version in RFC 3339 / ISO 8601
        /// format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("release_date", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Release_date { get; set; }
    
        /// <summary>The version of this ruleset object.</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Version { get; set; }
    
        /// <summary>Integrity protection value.</summary>
        [Newtonsoft.Json.JsonProperty("integrity", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Integrity { get; set; }
    
        /// <summary>WAF Rules are sorted in groups based on their
        /// characterization.
        /// Maximum of 64 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBWafRuleGroup> Groups { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HTTPReselectRespCode object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPReselectRespCode 
    {
        /// <summary>HTTP response code ranges to match.</summary>
        [Newtonsoft.Json.JsonProperty("ranges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBHTTPStatusRange> Ranges { get; set; }
    
        /// <summary>HTTP response code to be matched.
        /// Allowed values are 400-599.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("codes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<long> Codes { get; set; }
    
        /// <summary>Block of HTTP response codes to match for server reselect.
        /// Enum options - HTTP_RSP_4XX, HTTP_RSP_5XX.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resp_code_block", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Resp_code_block2> Resp_code_block { get; set; }
    
    
    }
    
    /// <summary>Status for IPSec VPN Ike session UP, DOWN, NEGOTIATING and fail reason if Ike session
    /// is down.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnIkeSessionStatus 
    {
        /// <summary>Reason for failure.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fail_reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fail_reason { get; set; }
    
        /// <summary>Ike session service status UP, DOWN and NEGOTIATING.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ike_session_state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPSecVpnIkeSessionStatusIke_session_state? Ike_session_state { get; set; }
    
    
    }
    
    /// <summary>Role</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class NsxRole 
    {
        /// <summary>This field represents the identifier of the role. With the introduction of custom roles, this field is no longer an enum.</summary>
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Role { get; set; }
    
        /// <summary>Please use the /user-info/permissions api to get the permission that the user has on each feature.</summary>
        [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Permissions> Permissions { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsQueryNameMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsQueryNameMatch 
    {
        /// <summary>path of the string group(s) for matching against DNS query
        /// domain name in the question section.
        /// It is a reference to an object of type StringGroup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("string_group_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> String_group_paths { get; set; }
    
        /// <summary>Domain name to match against that specified in the question
        /// section of the DNS query.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("query_domain_names", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Query_domain_names { get; set; }
    
        /// <summary>Criterion to use for string matching the DNS query domain
        /// name in the question section.
        /// Enum options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS,
        /// DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS,
        /// DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBDnsQueryNameMatchMatch_criteria Match_criteria { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DsrProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDsrProfile 
    {
        /// <summary>Encapsulation type to use when DSR is L3.
        /// Enum options - ENCAP_IPINIP.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as ENCAP_IPINIP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dsr_encap_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBDsrProfileDsr_encap_type? Dsr_encap_type { get; set; } = SDKGenerator.ALBDsrProfileDsr_encap_type.ENCAP_IPINIP;
    
        /// <summary>DSR type L2/L3.
        /// Enum options - DSR_TYPE_L2, DSR_TYPE_L3.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as DSR_TYPE_L3.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dsr_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBDsrProfileDsr_type? Dsr_type { get; set; } = SDKGenerator.ALBDsrProfileDsr_type.DSR_TYPE_L3;
    
    
    }
    
    /// <summary>Resource attribute on which constraint should be applied.
    /// Example - sourceGroups attribute of Edge CommunicationEntry to be
    ///   restricted, is given as:
    ///   {
    ///      "target_resource_type":"CommunicationEntry",
    ///      "attribute":"sourceGroups",
    ///      "path_prefix":"/infra/domains/vmc-domain/edge-communication-maps/default/communication-entries"
    ///   }
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConstraintTarget 
    {
        /// <summary>Attribute name of the target entity.</summary>
        [Newtonsoft.Json.JsonProperty("attribute", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Attribute { get; set; }
    
        /// <summary>Path prefix of the entity to apply constraint.
        /// This is required to further disambiguiate if multiple policy entities
        /// share the same resource type.
        /// Example - Edge FW and DFW use the same resource type CommunicationMap,
        /// CommunicationEntry, Group, etc.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path_prefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path_prefix { get; set; }
    
        /// <summary>Resource type of the target entity.</summary>
        [Newtonsoft.Json.JsonProperty("target_resource_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Target_resource_type { get; set; }
    
    
    }
    
    /// <summary>Additional configuration required for federation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FederationConnectivityConfig 
    {
        /// <summary>Global id for by Layer3 services for federation usecases.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("global_overlay_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Global_overlay_id { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer FailActionHTTPLocalResponse object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBFailActionHTTPLocalResponse 
    {
        /// <summary>Enum options - FAIL_HTTP_STATUS_CODE_200,
        /// FAIL_HTTP_STATUS_CODE_503.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as FAIL_HTTP_STATUS_CODE_503.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBFailActionHTTPLocalResponseStatus_code? Status_code { get; set; } = SDKGenerator.ALBFailActionHTTPLocalResponseStatus_code.FAIL_HTTP_STATUS_CODE_503;
    
        /// <summary>Placeholder for description of property file of obj type
        /// FailActionHTTPLocalResponse field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("file", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPLocalFile File { get; set; }
    
    
    }
    
    /// <summary>Paged collection of Service Segment</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServiceSegmentListResult : ListResult
    {
        /// <summary>Service Segment list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ServiceSegment> Results { get; set; } = new System.Collections.ObjectModel.Collection<ServiceSegment>();
    
    
    }
    
    /// <summary>Label that will be displayed for a UI element.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Label 
    {
        /// <summary>Text to be displayed at the label.</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string Text { get; set; }
    
        /// <summary>If true, displays the label only on hover</summary>
        [Newtonsoft.Json.JsonProperty("hover", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Hover { get; set; } = false;
    
        /// <summary>Hyperlink of the specified UI page that provides details.</summary>
        [Newtonsoft.Json.JsonProperty("navigation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Navigation { get; set; }
    
        /// <summary>If the condition is met then the label will be applied. Examples of expression syntax are provided under example_request section of CreateWidgetConfiguration API.</summary>
        [Newtonsoft.Json.JsonProperty("condition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Condition { get; set; }
    
        /// <summary>Icons to be applied at dashboard for the label</summary>
        [Newtonsoft.Json.JsonProperty("icons", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Icon> Icons { get; set; }
    
    
    }
    
    /// <summary>All the active types of LBMonitorProfile extend from this abstract class.
    /// This is present for extensibility.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBActiveMonitor : LBMonitorProfile
    {
        /// <summary>Typically, monitors perform healthchecks to Group members using the
        /// member IP address and pool_port.
        /// However, in some cases, customers prefer to run healthchecks against a
        /// different port than the pool member port which handles actual
        /// application traffic. In such cases, the port to run healthchecks
        /// against can be specified in the monitor_port value.
        /// For ICMP monitor, monitor_port is not required.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("monitor_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Monitor_port { get; set; }
    
        /// <summary>Only if a healthcheck fails consecutively for a specified number of
        /// times, given with fall_count, to a member will the member status be
        /// marked DOWN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fall_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long? Fall_count { get; set; } = 3L;
    
        /// <summary>Active healthchecks are initiated periodically, at a configurable
        /// interval (in seconds), to each member of the Group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long? Interval { get; set; } = 5L;
    
        /// <summary>Once a member is DOWN, a specified number of consecutive successful
        /// healthchecks specified by rise_count will bring the member back to UP
        /// state.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rise_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long? Rise_count { get; set; } = 3L;
    
        /// <summary>Timeout specified in seconds.  After a healthcheck is initiated, if it
        /// does not complete within a certain period, then also the healthcheck
        /// is considered to be unsuccessful. Completing a healthcheck within
        /// timeout means establishing a connection (TCP or SSL), if applicable,
        /// sending the request and receiving the response, all within the
        /// configured timeout.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long? Timeout { get; set; } = 5L;
    
    
    }
    
    /// <summary>Represents the Intrusion Detection System rule which indicates the action to be performed for the corresponding workload groups.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsRule : BaseRule
    {
        /// <summary>The action to be applied.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IdsRuleAction? Action { get; set; }
    
        /// <summary>collections of IDS profiles.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ids_profiles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Ids_profiles { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer SSLProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSSLProfile : PolicyConfigResource
    {
        /// <summary>The amount of time in seconds before an SSL session
        /// expires.
        /// Unit is SEC.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 86400.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ssl_session_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Ssl_session_timeout { get; set; } = 86400L;
    
        /// <summary>Ciphers suites represented as defined by U(http
        /// //www.openssl.org/docs/apps/ciphers.html).
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as AES:3DES:RC4.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accepted_ciphers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Accepted_ciphers { get; set; } = "AES:3DES:RC4";
    
        /// <summary>Prefer the SSL cipher ordering presented by the client
        /// during the SSL handshake over the one specified in the SSL
        /// Profile.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("prefer_client_cipher_ordering", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Prefer_client_cipher_ordering { get; set; } = false;
    
        /// <summary>Placeholder for description of property tags of obj type
        /// SSLProfile field type str  type array.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("avi_tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBTag> Avi_tags { get; set; }
    
        /// <summary>SSL Profile Type.
        /// Enum options - SSL_PROFILE_TYPE_APPLICATION,
        /// SSL_PROFILE_TYPE_SYSTEM.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// SSL_PROFILE_TYPE_APPLICATION.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBSSLProfileType? Type { get; set; } = SDKGenerator.ALBSSLProfileType.SSL_PROFILE_TYPE_APPLICATION;
    
        /// <summary>Set of versions accepted by the server.
        /// Minimum of 1 items required.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accepted_versions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ALBSSLVersion> Accepted_versions { get; set; } = new System.Collections.ObjectModel.Collection<ALBSSLVersion>();
    
        /// <summary>Enable SSL session re-use.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_ssl_session_reuse", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_ssl_session_reuse { get; set; } = true;
    
        /// <summary>Enum options - TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
        /// TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
        /// TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
        /// TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
        /// TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
        /// TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,
        /// TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
        /// TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,
        /// TLS_RSA_WITH_AES_128_GCM_SHA256,
        /// TLS_RSA_WITH_AES_256_GCM_SHA384,
        /// TLS_RSA_WITH_AES_128_CBC_SHA256,
        /// TLS_RSA_WITH_AES_256_CBC_SHA256,
        /// TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
        /// TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
        /// TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
        /// TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
        /// TLS_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_256_CBC_SHA,
        /// TLS_RSA_WITH_3DES_EDE_CBC_SHA, TLS_AES_256_GCM_SHA384...
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cipher_enums", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Cipher_enums> Cipher_enums { get; set; }
    
        /// <summary>Send 'close notify' alert message for a clean shutdown of
        /// the SSL connection.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("send_close_notify", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Send_close_notify { get; set; } = true;
    
        /// <summary>Enable early data processing for TLS1.3 connections.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_early_data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_early_data { get; set; } = false;
    
        /// <summary>Placeholder for description of property ssl_rating of obj
        /// type SSLProfile field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ssl_rating", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBSSLRating Ssl_rating { get; set; }
    
        /// <summary>TLS 1.3 Ciphers suites represented as defined by U(https
        /// //www.openssl.org/docs/manmaster/man1/ciphers.html).
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as
        /// TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ciphersuites", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ciphersuites { get; set; } = "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256";
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyTraceflowObservationDroppedLogical : TraceflowObservationDroppedLogical
    {
        /// <summary>The path of the ACL rule that was applied to forward the traceflow packet</summary>
        [Newtonsoft.Json.JsonProperty("acl_rule_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Acl_rule_path { get; set; }
    
        /// <summary>The path of the NAT rule that was applied to forward the traceflow packet</summary>
        [Newtonsoft.Json.JsonProperty("nat_rule_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Nat_rule_path { get; set; }
    
        /// <summary>The path of the component that dropped the traceflow packet</summary>
        [Newtonsoft.Json.JsonProperty("component_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Component_path { get; set; }
    
        /// <summary>The path of the segment port at which traceflow packet was dropped</summary>
        [Newtonsoft.Json.JsonProperty("segment_port_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Segment_port_path { get; set; }
    
    
    }
    
    /// <summary>Realized Network and Security Group</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedNSGroup : RealizedGroup
    {
        /// <summary>Reference to the evaluated members of the NSGroup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("evaluations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(500)]
        public System.Collections.Generic.ICollection<RealizedNSGroupMemberEvaluation> Evaluations { get; set; }
    
    
    }
    
    /// <summary>Client SSL profile binding.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBClientSslProfileBinding 
    {
        /// <summary>Client authentication mode.</summary>
        [Newtonsoft.Json.JsonProperty("client_auth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBClientSslProfileBindingClient_auth? Client_auth { get; set; } = SDKGenerator.LBClientSslProfileBindingClient_auth.IGNORE;
    
        /// <summary>A Certificate Revocation List (CRL) can be specified in the client-side
        /// SSL profile binding to disallow compromised client certificates.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_auth_crl_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Client_auth_crl_paths { get; set; }
    
        /// <summary>If client auth type is REQUIRED, client certificate must be signed by
        /// one of the trusted Certificate Authorities (CAs), also referred to as
        /// root CAs, whose self signed certificates are specified.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_auth_ca_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Client_auth_ca_paths { get; set; }
    
        /// <summary>Authentication depth is used to set the verification depth in the client
        /// certificates chain.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("certificate_chain_depth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long? Certificate_chain_depth { get; set; } = 3L;
    
        /// <summary>Client-side SSL profile binding allows multiple certificates, for
        /// different hostnames, to be bound to the same virtual server.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sni_certificate_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Sni_certificate_paths { get; set; }
    
        /// <summary>A default certificate should be specified which will be used if the
        /// server does not host multiple hostnames on the same IP address or if
        /// the client does not support SNI extension.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("default_certificate_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Default_certificate_path { get; set; }
    
        /// <summary>Client SSL profile defines reusable, application-independent client side
        /// SSL properties.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ssl_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ssl_profile_path { get; set; }
    
    
    }
    
    /// <summary>Restore step status</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PerStepRestoreStatus 
    {
        /// <summary>A description of the restore status</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Per step restore status value</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PerStepRestoreStatusValue? Value { get; set; }
    
    
    }
    
    /// <summary>Snat Ip element.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBSnatIpElement 
    {
        /// <summary>Ip address or ip range such as 1.1.1.1 or 1.1.1.101-1.1.1.160.</summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ip_address { get; set; }
    
        /// <summary>Subnet prefix length should be not specified if there is only one single
        /// IP address or IP range.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("prefix_length", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Prefix_length { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for Tier0DeploymentMap, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildTier0DeploymentMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual Tier0DeploymentMap object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Tier0DeploymentMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Tier0DeploymentMap Tier0DeploymentMap { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer L4RuleAction object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBL4RuleAction 
    {
        /// <summary>Indicates pool or pool-group selection on rule match.</summary>
        [Newtonsoft.Json.JsonProperty("select_pool", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBL4RuleActionSelectPool Select_pool { get; set; }
    
    
    }
    
    /// <summary>Paged collection of SpoofGuard profiles</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SpoofGuardProfileListResult : ListResult
    {
        /// <summary>SpoofGuard profile list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SpoofGuardProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<SpoofGuardProfile>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBServiceStatus : LBServiceStatusPerEP
    {
        /// <summary>Cpu usage in percentage.</summary>
        [Newtonsoft.Json.JsonProperty("cpu_usage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Cpu_usage { get; set; }
    
        /// <summary>Memory usage in percentage.</summary>
        [Newtonsoft.Json.JsonProperty("memory_usage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Memory_usage { get; set; }
    
        /// <summary>Timestamp when the data was last updated.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>Error message, if available.</summary>
        [Newtonsoft.Json.JsonProperty("error_message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error_message { get; set; }
    
        /// <summary>UP means the load balancer service is working fine on both
        /// transport-nodes(if have);
        /// PARTIALLY_UP means that some DLB instances on transport node are
        /// working successfully and some instances are not working successfully;
        /// DOWN means the load balancer service is down on both transport-nodes
        /// (if have), hence the load balancer will not respond to any requests;
        /// ERROR means error happens on transport-node(s) or no status is
        /// reported from transport-node(s). The load balancer service may be
        /// working (or not working);
        /// NO_STANDBY means load balancer service is working in one of the
        /// transport node while not in the other transport-node (if have). Hence
        /// if the load balancer service in the working transport-node goes down,
        /// the load balancer service will go down;
        /// DETACHED means that the load balancer service has no attachment setting
        /// and is not instantiated in any transport nodes;
        /// DISABLED means that admin state of load balancer service is DISABLED;
        /// UNKNOWN means that no status reported from transport-nodes.The load
        /// balancer service may be working(or not working).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBServiceStatusService_status? Service_status { get; set; }
    
        /// <summary>status of load balancer virtual servers.</summary>
        [Newtonsoft.Json.JsonProperty("virtual_servers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBVirtualServerStatus> Virtual_servers { get; set; }
    
        /// <summary>Ids of load balancer service related active transport nodes.</summary>
        [Newtonsoft.Json.JsonProperty("active_transport_nodes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Active_transport_nodes { get; set; }
    
        /// <summary>Details of load balancer service instance per transport node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("instance_detail_per_tn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBServiceInstanceDetailPerTransportNode> Instance_detail_per_tn { get; set; }
    
        /// <summary>status of load balancer pools.</summary>
        [Newtonsoft.Json.JsonProperty("pools", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LBPoolStatus> Pools { get; set; }
    
        /// <summary>Ids of load balancer service related standby transport nodes.</summary>
        [Newtonsoft.Json.JsonProperty("standby_transport_nodes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Standby_transport_nodes { get; set; }
    
        /// <summary>Load balancer service object path.</summary>
        [Newtonsoft.Json.JsonProperty("service_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Service_path { get; set; }
    
    
    }
    
    /// <summary>PIM Rendezvous Point Mappings Per Edge.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PimRpMappingsPerEdge 
    {
        [Newtonsoft.Json.JsonProperty("pim_rp_mappings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PimRpMapping> Pim_rp_mappings { get; set; }
    
        /// <summary>Policy path to edge node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Edge_path { get; set; }
    
    
    }
    
    /// <summary>Aggregate of L2VPN Session peer config across Enforcement Points.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AggregateL2VPNSessionPeerConfig : AggregatePolicyRuntimeInfo
    {
        /// <summary>List of L2VPN Session peer config per Enforcement Point.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<L2VPNSessionPeerConfigPerEP> Results { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HSMSafenetLunaServer object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHSMSafenetLunaServer 
    {
        /// <summary>Number of index.</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public long Index { get; set; }
    
        /// <summary>IP address of the Safenet/Gemalto HSM device.</summary>
        [Newtonsoft.Json.JsonProperty("remote_ip", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Remote_ip { get; set; }
    
        /// <summary>Serial number of the partition assigned to this client.</summary>
        [Newtonsoft.Json.JsonProperty("partition_serial_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Partition_serial_number { get; set; }
    
        /// <summary>CA certificate of the server.</summary>
        [Newtonsoft.Json.JsonProperty("server_cert", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Server_cert { get; set; }
    
        /// <summary>Password of the partition assigned to this client.</summary>
        [Newtonsoft.Json.JsonProperty("partition_passwd", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Partition_passwd { get; set; }
    
    
    }
    
    /// <summary>PoolGroupApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBPoolGroupApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of PoolGroup
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBPoolGroup> Results { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer Vip object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBVip 
    {
        /// <summary>Auto-allocate VIP from the provided subnet.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("auto_allocate_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Auto_allocate_ip { get; set; } = false;
    
        /// <summary>(internal-use) Network port assigned to the Vip IP address.</summary>
        [Newtonsoft.Json.JsonProperty("port_uuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Port_uuid { get; set; }
    
        /// <summary>Availability-zone to place the Virtual Service.</summary>
        [Newtonsoft.Json.JsonProperty("availability_zone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Availability_zone { get; set; }
    
        /// <summary>Manually override the network on which the Vip is placed.
        /// It is a reference to an object of type Network.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("network_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Network_path { get; set; }
    
        /// <summary>Floating IPv4 to associate with this Vip.</summary>
        [Newtonsoft.Json.JsonProperty("floating_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddr Floating_ip { get; set; }
    
        /// <summary>Auto-allocate floating/elastic IP from the Cloud
        /// infrastructure.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("auto_allocate_floating_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Auto_allocate_floating_ip { get; set; } = false;
    
        /// <summary>If auto_allocate_floating_ip is True and more than one
        /// floating-ip subnets exist, then the subnet for the floating
        /// IP address allocation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("floating_subnet_uuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Floating_subnet_uuid { get; set; }
    
        /// <summary>IPv6 Address of the Vip.</summary>
        [Newtonsoft.Json.JsonProperty("ip6_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddr Ip6_address { get; set; }
    
        /// <summary>(internal-use) VIP allocated by Avi in the Cloud
        /// infrastructure.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("avi_allocated_vip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Avi_allocated_vip { get; set; } = false;
    
        /// <summary>Specifies whether to auto-allocate only a V4 address, only
        /// a V6 address, or one of each type.
        /// Enum options - V4_ONLY, V6_ONLY, V4_V6.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as V4_ONLY.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("auto_allocate_ip_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBVipAuto_allocate_ip_type? Auto_allocate_ip_type { get; set; } = SDKGenerator.ALBVipAuto_allocate_ip_type.V4_ONLY;
    
        /// <summary>IPv4 Address of the VIP.</summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddr Ip_address { get; set; }
    
        /// <summary>If auto_allocate_ip is True, then the subnet for the Vip IP
        /// address allocation.
        /// This field is applicable only if the VirtualService belongs
        /// to an Openstack or AWS cloud, in which case it is mandatory,
        /// if auto_allocate is selected.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnet_uuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Subnet_uuid { get; set; }
    
        /// <summary>If auto_allocate_floating_ip is True and more than one
        /// floating-ip subnets exist, then the subnet for the floating
        /// IPv6 address allocation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("floating_subnet6_uuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Floating_subnet6_uuid { get; set; }
    
        /// <summary>Subnet providing reachability for client facing Vip IP.</summary>
        [Newtonsoft.Json.JsonProperty("subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddrPrefix Subnet { get; set; }
    
        /// <summary>If auto_allocate_ip is True, then the subnet for the Vip
        /// IPv6 address allocation.
        /// This field is applicable only if the VirtualService belongs
        /// to an Openstack or AWS cloud, in which case it is mandatory,
        /// if auto_allocate is selected.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnet6_uuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Subnet6_uuid { get; set; }
    
        /// <summary>Unique ID associated with the vip.</summary>
        [Newtonsoft.Json.JsonProperty("vip_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Vip_id { get; set; }
    
        /// <summary>Floating IPv6 address to associate with this Vip.</summary>
        [Newtonsoft.Json.JsonProperty("floating_ip6", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddr Floating_ip6 { get; set; }
    
        /// <summary>(internal-use) FIP allocated by Avi in the Cloud
        /// infrastructure.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("avi_allocated_fip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Avi_allocated_fip { get; set; } = false;
    
        /// <summary>Discovered networks providing reachability for client
        /// facing Vip IP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("discovered_networks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBDiscoveredNetwork> Discovered_networks { get; set; }
    
        /// <summary>Enable or disable the Vip.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
        /// <summary>Subnet and/or Network for allocating VirtualService IP by
        /// IPAM Provider module.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipam_network_subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIPNetworkSubnet Ipam_network_subnet { get; set; }
    
        /// <summary>Placement networks/subnets to use for vip placement.
        /// Maximum of 10 items allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("placement_networks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBVipPlacementNetwork> Placement_networks { get; set; }
    
        /// <summary>Mask applied for the Vip, non-default mask supported only
        /// for wildcard Vip.
        /// Allowed values are 0-32.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 32.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("prefix_length", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 32D)]
        public long? Prefix_length { get; set; } = 32L;
    
        /// <summary>Subnet providing reachability for client facing Vip IPv6.</summary>
        [Newtonsoft.Json.JsonProperty("subnet6", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddrPrefix Subnet6 { get; set; }
    
    
    }
    
    /// <summary>Statistics for data NICs on an instance runtime</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class InstanceRuntimeStatistic 
    {
        /// <summary>List of statistics for all data NICs on a runtime.</summary>
        [Newtonsoft.Json.JsonProperty("interface_statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RuntimeInterfaceStatistics> Interface_statistics { get; set; }
    
        /// <summary>Name of the instance runtime</summary>
        [Newtonsoft.Json.JsonProperty("runtime_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Runtime_name { get; set; }
    
        /// <summary>Specifies whether statistics are for primary runtime.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("primary_runtime_stats", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Primary_runtime_stats { get; set; }
    
        /// <summary>Id of the instance runtime</summary>
        [Newtonsoft.Json.JsonProperty("runtime_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Runtime_id { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for SecurityPolicy, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildSecurityPolicy : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual SecurityPolicy object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("SecurityPolicy", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SecurityPolicy SecurityPolicy { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer TrafficCloneProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBTrafficCloneProfile : PolicyConfigResource
    {
        /// <summary>Specifies if client IP needs to be preserved to clone
        /// destination.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preserve_client_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Preserve_client_ip { get; set; } = false;
    
        /// <summary>Maximum of 10 items allowed.</summary>
        [Newtonsoft.Json.JsonProperty("clone_servers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBCloneServer> Clone_servers { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OspfRouteDetailsInCsvRecord : CsvRecord
    {
        /// <summary>Type to cost of the route.</summary>
        [Newtonsoft.Json.JsonProperty("type_to_cost", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Type_to_cost { get; set; }
    
        /// <summary>route next hop result.</summary>
        [Newtonsoft.Json.JsonProperty("next_hop_neighbor_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Next_hop_neighbor_address { get; set; }
    
        /// <summary>Learned route prefix.</summary>
        [Newtonsoft.Json.JsonProperty("route_prefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Route_prefix { get; set; }
    
        /// <summary>Cost of the route.</summary>
        [Newtonsoft.Json.JsonProperty("cost", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Cost { get; set; }
    
        /// <summary>OSPF area.</summary>
        [Newtonsoft.Json.JsonProperty("area", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Area { get; set; }
    
        /// <summary>Type of route.</summary>
        [Newtonsoft.Json.JsonProperty("route_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Route_type { get; set; }
    
        /// <summary>Type of router.</summary>
        [Newtonsoft.Json.JsonProperty("router_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Router_type { get; set; }
    
        /// <summary>OSPF policy interface name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("next_hop_interface_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Next_hop_interface_name { get; set; }
    
        /// <summary>Check whether OSPF route is directly connected.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("next_hop_directly_attached", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Next_hop_directly_attached { get; set; }
    
        /// <summary>Policy edge path.</summary>
        [Newtonsoft.Json.JsonProperty("edge_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Edge_path { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBServiceStatisticsCounter 
    {
        /// <summary>Number of l4 total sessions.</summary>
        [Newtonsoft.Json.JsonProperty("l4_total_sessions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? L4_total_sessions { get; set; }
    
        /// <summary>Number of l7 current sessions.</summary>
        [Newtonsoft.Json.JsonProperty("l7_current_sessions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? L7_current_sessions { get; set; }
    
        /// <summary>L4 max sessions is used to show the peak L4 max session data since
        /// load balancer starts to provide service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("l4_max_sessions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? L4_max_sessions { get; set; }
    
        /// <summary>Number of l4 current sessions.</summary>
        [Newtonsoft.Json.JsonProperty("l4_current_sessions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? L4_current_sessions { get; set; }
    
        /// <summary>Number of l7 total sessions.</summary>
        [Newtonsoft.Json.JsonProperty("l7_total_sessions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? L7_total_sessions { get; set; }
    
        /// <summary>The average number of l4 current sessions per second, the number is
        /// averaged over the last 5 one-second intervals.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("l4_current_session_rate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? L4_current_session_rate { get; set; }
    
        /// <summary>The average number of l7 current requests per second, the number is
        /// averaged over the last 5 one-second intervals.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("l7_current_session_rate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? L7_current_session_rate { get; set; }
    
        /// <summary>L7 max sessions is used to show the peak L7 max session data since
        /// load balancer starts to provide service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("l7_max_sessions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? L7_max_sessions { get; set; }
    
    
    }
    
    /// <summary>An identity source service that runs Microsoft Active Directory. The service allows selected user accounts defined in Active Directory to log into and access NSX-T.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ActiveDirectoryIdentitySource : LdapIdentitySource
    {
    
    }
    
    /// <summary>The resource of packet capture per port, such as
    /// the downloading URL of packet capture file.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PktCapResource : BasePktCapResource
    {
        /// <summary>Packet capture file download URL</summary>
        [Newtonsoft.Json.JsonProperty("pktcap_file_download_url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pktcap_file_download_url { get; set; }
    
        /// <summary>The ID of logical port where packet capture action is performed</summary>
        [Newtonsoft.Json.JsonProperty("port_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Port_id { get; set; }
    
    
    }
    
    /// <summary>Query statistics counters to an upstream server including successfully
    /// forwarded queries and failed queries.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class NsxTUpstreamServerStatistics 
    {
        /// <summary>Queries failed to forward.</summary>
        [Newtonsoft.Json.JsonProperty("queries_failed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Queries_failed { get; set; }
    
        /// <summary>Upstream server ip</summary>
        [Newtonsoft.Json.JsonProperty("upstream_server", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Upstream_server { get; set; }
    
        /// <summary>Queries forwarded successfully</summary>
        [Newtonsoft.Json.JsonProperty("queries_succeeded", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Queries_succeeded { get; set; }
    
    
    }
    
    /// <summary>IPSec VPN Session Status represents status on an NSX-T type of enforcement point.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnSessionStatusNsxT : IPSecVpnSessionStatusPerEP
    {
        /// <summary>Gives session status consolidated using IKE status and tunnel status. It can
        /// be UP, DOWN, DEGRADED. If IKE and all tunnels are UP status will be UP, if
        /// all down it will be DOWN, otherwise it will be DEGRADED.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("runtime_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPSecVpnSessionStatusNsxTRuntime_status? Runtime_status { get; set; }
    
        /// <summary>Display Name of vpn session.</summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Display_name { get; set; }
    
        /// <summary>Number of failed tunnels.</summary>
        [Newtonsoft.Json.JsonProperty("failed_tunnels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Failed_tunnels { get; set; }
    
        /// <summary>Number of negotiated tunnels.</summary>
        [Newtonsoft.Json.JsonProperty("negotiated_tunnels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Negotiated_tunnels { get; set; }
    
        /// <summary>Timestamp when the data was last updated.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>Total number of tunnels.</summary>
        [Newtonsoft.Json.JsonProperty("total_tunnels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total_tunnels { get; set; }
    
        /// <summary>Status for IPSec VPN IKE session UP/DOWN and fail reason if IKE session is down.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ike_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IPSecVpnIkeSessionStatus Ike_status { get; set; }
    
        /// <summary>Aggregate traffic statistics across all ipsec tunnels.</summary>
        [Newtonsoft.Json.JsonProperty("aggregate_traffic_counters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IPSecVpnTrafficCounters Aggregate_traffic_counters { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for ApplicationService, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildApplicationService : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ApplicationService object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ApplicationService", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ApplicationService ApplicationService { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LiveTraceActionConfig 
    {
        /// <summary>The trace action config</summary>
        [Newtonsoft.Json.JsonProperty("trace_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TraceActionConfig Trace_config { get; set; }
    
        /// <summary>The packet capture action config</summary>
        [Newtonsoft.Json.JsonProperty("pktcap_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PktcapActionConfig Pktcap_config { get; set; }
    
        /// <summary>The count action config</summary>
        [Newtonsoft.Json.JsonProperty("count_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CountActionConfig Count_config { get; set; }
    
    
    }
    
    /// <summary>Binding of a LBPool and Group to a LBVirtualServer
    /// used to route application traffic passing through load balancers.
    /// LBRule uses match conditions to match application traffic passing
    /// through a LBVirtualServer using HTTP or HTTPS. Can bind
    /// multiple LBVirtualServers to a Group. Each LBRule
    /// consists of two optional match conditions, each match contidion defines a
    /// criterion for application traffic.  If no match conditions are
    /// specified, then the LBRule will always match and it is used
    /// typically to define default rules. If more than one match condition is
    /// specified, then matching strategy determines if all conditions should
    /// match or any one condition should match for the LBRule to be
    /// considered a match.  A match indicates that the LBVirtualServer
    /// should route the request to the Group (parent of LBRule).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBRule 
    {
        /// <summary>Each load balancer rule is used at a specific phase of load balancer
        /// processing. Currently five phases are supported, HTTP_REQUEST_REWRITE,
        /// HTTP_FORWARDING, HTTP_RESPONSE_REWRITE, HTTP_ACCESS and TRANSPORT.
        /// When an HTTP request message is received by load balancer, all
        /// HTTP_REQUEST_REWRITE rules, if present are executed in the order they
        /// are applied to virtual server. And then if HTTP_FORWARDING rules
        /// present, only first matching rule's action is executed, remaining rules
        /// are not checked. HTTP_FORWARDING rules can have only one action. If the
        /// request is forwarded to a backend server and the response goes back to
        /// load balancer, all HTTP_RESPONSE_REWRITE rules, if present, are executed
        /// in the order they are applied to the virtual server.
        /// In HTTP_ACCESS phase, user can define action to control access using
        /// JWT authentication.
        /// In TRANSPORT phase, user can define the condition to match SNI in TLS
        /// client hello and define the action to do SSL end-to-end, SSL offloading
        /// or SSL passthrough using a specific load balancer server pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("phase", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBRulePhase? Phase { get; set; } = SDKGenerator.LBRulePhase.HTTP_FORWARDING;
    
        /// <summary>A list of match conditions used to match application traffic. Multiple
        /// match conditions can be specified in one load balancer rule, each match
        /// condition defines a criterion to match application traffic.
        /// If no match conditions are specified, then the load balancer rule will
        /// always match and it is used typically to define default rules. If more
        /// than one match condition is specified, then match strategy determines
        /// if all conditions should match or any one condition should match for the
        /// load balancer rule to considered a match.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_conditions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(60)]
        public System.Collections.Generic.ICollection<LBRuleCondition> Match_conditions { get; set; }
    
        /// <summary>A display name useful for identifying an LBRule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Display_name { get; set; }
    
        /// <summary>A list of actions to be executed at specified phase when load balancer
        /// rule matches. The actions are used to manipulate application traffic,
        /// such as rewrite URI of HTTP messages, redirect HTTP messages, etc.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("actions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(60)]
        public System.Collections.Generic.ICollection<LBRuleAction> Actions { get; set; } = new System.Collections.ObjectModel.Collection<LBRuleAction>();
    
        /// <summary>If more than one match condition is specified, then
        /// matching strategy determines if all conditions should match or any
        /// one condition should match for the LB Rule to be considered a match.
        /// - ALL indicates that both host_match and path_match must match for
        /// this LBRule to be considered a match.
        /// - ANY indicates that either host_match or patch match may match for
        /// this LBRule to be considered a match.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_strategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBRuleMatch_strategy? Match_strategy { get; set; } = SDKGenerator.LBRuleMatch_strategy.ANY;
    
    
    }
    
    /// <summary>Child wrapper object for Tier0RouteMap, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildTier0RouteMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual Tier0RouteMap object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Tier0RouteMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Tier0RouteMap Tier0RouteMap { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBAuthProfile, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBAuthProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBAuthProfile object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBAuthProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBAuthProfile ALBAuthProfile { get; set; }
    
    
    }
    
    /// <summary>Some applications maintain state and require all relevant connections
    /// to be sent to the same server as the application state is not
    /// synchronized among servers. Persistence is enabled on a
    /// LBVirtualServer by binding a persistence profile to it.
    /// LBGenericPersistenceProfile cannot be attached to virtual server directly,
    /// it can be specified in LB rule actions. In HTTP forwarding phase,
    /// the profile can be specified in LBVariablePersistenceOnAction. In HTTP
    /// response rewriting phase, the profile can be specified in
    /// LBVariablePersistenceLearnAction.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBGenericPersistenceProfile : LBPersistenceProfile
    {
        /// <summary>The mirroring enabled flag is to synchronize persistence entries.
        /// Persistence entries are not synchronized to the HA peer by default.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ha_persistence_mirroring_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Ha_persistence_mirroring_enabled { get; set; } = false;
    
        /// <summary>When all connections complete (reference count reaches 0), persistence
        /// entry timer is started with the expiration time.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long? Timeout { get; set; } = 300L;
    
    
    }
    
    /// <summary>Child wrapper obejct for DnsSecurityProfileBindingMap used in hierarchical API
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildDnsSecurityProfileBindingMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual DnsSecurityProfileBindingMap object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("DnsSecurityProfileBindingMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public DnsSecurityProfileBindingMap DnsSecurityProfileBindingMap { get; set; }
    
    
    }
    
    /// <summary>It represent the resource with details of name and fields it owns.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyFineTuningResourceInfo 
    {
        /// <summary>List of all field of any resource</summary>
        [Newtonsoft.Json.JsonProperty("fields", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyFineTuningResourceInfoDetail> Fields { get; set; } = new System.Collections.ObjectModel.Collection<PolicyFineTuningResourceInfoDetail>();
    
        /// <summary>It will represent resource with name and fields.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resource_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Resource_name { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBPoolGroupDeploymentPolicy, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBPoolGroupDeploymentPolicy : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBPoolGroupDeploymentPolicy object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBPoolGroupDeploymentPolicy", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBPoolGroupDeploymentPolicy ALBPoolGroupDeploymentPolicy { get; set; }
    
    
    }
    
    /// <summary>PoolApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBPoolApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of Pool
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBPool> Results { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer StringMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBStringMatch 
    {
        /// <summary>path of the string group(s).
        /// It is a reference to an object of type StringGroup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("string_group_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> String_group_paths { get; set; }
    
        /// <summary>String value(s).</summary>
        [Newtonsoft.Json.JsonProperty("match_str", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Match_str { get; set; }
    
        /// <summary>Criterion to use for string matching the HTTP request.
        /// Enum options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS,
        /// DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS,
        /// DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBStringMatchMatch_criteria Match_criteria { get; set; }
    
    
    }
    
    /// <summary>Ordered list of Endpoint Rules ordered by sequence number of the entries.
    /// The maximum number of policies is 25.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EndpointPolicy : PolicyConfigResource
    {
        /// <summary>Endpoint Rules that are a part of this EndpointPolicy</summary>
        [Newtonsoft.Json.JsonProperty("endpoint_rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<EndpointRule> Endpoint_rules { get; set; }
    
        /// <summary>This field is used to resolve conflicts between maps
        /// across domains.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sequence_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 499D)]
        public long? Sequence_number { get; set; } = 0L;
    
    
    }
    
    /// <summary>Advanced load balancer Tag object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBTag 
    {
        /// <summary>Enum options - AVI_DEFINED, USER_DEFINED, VCENTER_DEFINED.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as USER_DEFINED.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBTagType? Type { get; set; } = SDKGenerator.ALBTagType.USER_DEFINED;
    
        /// <summary>value of Tag.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }
    
    
    }
    
    /// <summary>Base Monitoring Profile Binding Map</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MonitoringProfileBindingMap : PolicyConfigResource
    {
    
    }
    
    /// <summary>Base class for resources</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Resource 
    {
        /// <summary>Link to this resource</summary>
        [Newtonsoft.Json.JsonProperty("_self", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SelfResourceLink _self { get; set; }
    
        /// <summary>The server will populate this field when returing the resource. Ignored on PUT and POST.</summary>
        [Newtonsoft.Json.JsonProperty("_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ResourceLink> _links { get; set; }
    
        /// <summary>Schema for this resource</summary>
        [Newtonsoft.Json.JsonProperty("_schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string _schema { get; set; }
    
    
    }
    
    /// <summary>This entity will be used to establish association between profile
    /// and policy entities.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ProfileBindingMap : PolicyConfigResource
    {
        /// <summary>PolicyPath of associated Profile</summary>
        [Newtonsoft.Json.JsonProperty("profile_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Profile_path { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer DnsClientIpMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBDnsClientIpMatch 
    {
        /// <summary>Use the IP address from the EDNS client subnet option, if
        /// available, as the source IP address of the client.
        /// It should be noted that the edns subnet IP may not be a /32
        /// IP address.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("use_edns_client_subnet_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Use_edns_client_subnet_ip { get; set; } = true;
    
        /// <summary>IP addresses to match against client IP.</summary>
        [Newtonsoft.Json.JsonProperty("client_ip", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBIpAddrMatch Client_ip { get; set; } = new ALBIpAddrMatch();
    
    
    }
    
    /// <summary>Static filters</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class StaticFilter 
    {
        /// <summary>display name to be shown in the drop down for static filter.</summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(1024)]
        public string Display_name { get; set; }
    
        /// <summary>Value of static filter inside dropdown filter.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer AppLearningParams object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAppLearningParams 
    {
        /// <summary>Learn the params per URI path.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable_per_uri_learning", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable_per_uri_learning { get; set; } = true;
    
        /// <summary>Maximum number of URI paths to learn for an application.
        /// Allowed values are 10-10000.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 500.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_uris", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(10D, 10000D)]
        public long? Max_uris { get; set; } = 500L;
    
        /// <summary>Minimum number of occurances required for a Param to
        /// qualify for learning.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 10000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("min_hits_to_learn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Min_hits_to_learn { get; set; } = 10000L;
    
        /// <summary>Maximum number of params to learn for an application.
        /// Allowed values are 10-1000.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 100.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_params", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(10D, 1000D)]
        public long? Max_params { get; set; } = 100L;
    
        /// <summary>Frequency with which SE publishes Application learning data
        /// to controller.
        /// Allowed values are 1-60.
        /// Unit is MIN.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 30.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("update_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 60D)]
        public long? Update_interval { get; set; } = 30L;
    
        /// <summary>Percent of the requests subjected to Application learning.
        /// Allowed values are 1-100.
        /// Unit is PERCENT.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sampling_percent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 100D)]
        public long? Sampling_percent { get; set; } = 1L;
    
    
    }
    
    /// <summary>Child wrapper for ALBNetworkProfile, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBNetworkProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBNetworkProfile object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBNetworkProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBNetworkProfile ALBNetworkProfile { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer RateLimiterProfile object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBRateLimiterProfile 
    {
        /// <summary>Rate Limit all requests to a URI for a specified period of
        /// time once the count of failed requests to that URI crosses a
        /// threshold for that period.
        /// Count and time period are specified through the
        /// RateProfile.
        /// Requests are deemed failed based on client or server side
        /// error status codes, consistent with how Avi Logs and Metrics
        /// subsystems mark failed requests.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uri_failed_requests_rate_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBRateProfile Uri_failed_requests_rate_limit { get; set; }
    
        /// <summary>Automatically track clients and classify them into 3 groups
        /// - Good, Bad, Unknown.
        /// Clients are tracked based on their IP Address.
        /// Clients are added to the Good group when the Avi Scan
        /// Detection system builds history of requests from them that
        /// complete successfully.
        /// Clients are added to Unknown group when there is
        /// insufficient history about them.
        /// Requests from such clients are rate limited to the rate
        /// specified in the RateProfile.
        /// Finally, Clients with history of failed requests are added
        /// to Bad group and their requests are rate limited with
        /// stricter thresholds than the Unknown Clients group.
        /// The Avi Scan Detection system automatically tunes itself so
        /// that the Good, Bad, and Unknown client IPs group membership
        /// changes dynamically with the changes in traffic patterns
        /// through the ADC.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_ip_scanners_requests_rate_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBRateProfile Client_ip_scanners_requests_rate_limit { get; set; }
    
        /// <summary>Rate Limit all HTTP requests that map to any custom string.</summary>
        [Newtonsoft.Json.JsonProperty("custom_requests_rate_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBRateProfile Custom_requests_rate_limit { get; set; }
    
        /// <summary>Rate Limit all requests from a client to a URI for a
        /// specified period of time once the count of failed requests
        /// from that client to the URI crosses a threshold for that
        /// period.
        /// Clients are tracked based on their IP address.
        /// Count and time period are specified through the
        /// RateProfile.
        /// Requests are deemed failed based on client or server side
        /// error status codes, consistent with how Avi Logs and Metrics
        /// subsystems mark failed requests.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_ip_to_uri_failed_requests_rate_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBRateProfile Client_ip_to_uri_failed_requests_rate_limit { get; set; }
    
        /// <summary>Rate Limit all HTTP requests from any single client IP
        /// address to any single URL.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_ip_to_uri_requests_rate_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBRateProfile Client_ip_to_uri_requests_rate_limit { get; set; }
    
        /// <summary>Rate Limit all requests from a client for a specified
        /// period of time once the count of failed requests from that
        /// client crosses a threshold for that period.
        /// Clients are tracked based on their IP address.
        /// Count and time period are specified through the
        /// RateProfile.
        /// Requests are deemed failed based on client or server side
        /// error status codes, consistent with how Avi Logs and Metrics
        /// subsystems mark failed requests.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_ip_failed_requests_rate_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBRateProfile Client_ip_failed_requests_rate_limit { get; set; }
    
        /// <summary>Rate Limit all HTTP requests from all client IP addresses
        /// to any single URL.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uri_requests_rate_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBRateProfile Uri_requests_rate_limit { get; set; }
    
        /// <summary>Automatically track URIs and classify them into 3 groups -
        /// Good, Bad, Unknown.
        /// URIs are added to the Good group when the Avi Scan
        /// Detection system builds history of requests to URIs that
        /// complete successfully.
        /// URIs are added to Unknown group when there is insufficient
        /// history about them.
        /// Requests for such URIs are rate limited to the rate
        /// specified in the RateProfile.
        /// Finally, URIs with history of failed requests are added to
        /// Bad group and requests to them are rate limited with
        /// stricter thresholds than the Unknown URIs group.
        /// The Avi Scan Detection system automatically tunes itself so
        /// that the Good, Bad, and Unknown URIs group membership
        /// changes dynamically with the changes in traffic patterns
        /// through the ADC.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uri_scanners_requests_rate_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBRateProfile Uri_scanners_requests_rate_limit { get; set; }
    
        /// <summary>Rate Limit all HTTP requests from any single client IP
        /// address to all URLs of the Virtual Service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_ip_requests_rate_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBRateProfile Client_ip_requests_rate_limit { get; set; }
    
        /// <summary>Rate Limit all connections made from any single client IP
        /// address to the Virtual Service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_ip_connections_rate_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBRateProfile Client_ip_connections_rate_limit { get; set; }
    
        /// <summary>Rate Limit all HTTP requests from all client IP addresses
        /// that contain any single HTTP header value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("http_header_rate_limits", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBRateProfile> Http_header_rate_limits { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer PGDeploymentRule object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBPGDeploymentRule 
    {
        /// <summary>Enum options - CO_EQ, CO_GT, CO_GE, CO_LT, CO_LE, CO_NE.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as CO_GE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBPGDeploymentRuleOperator? Operator { get; set; } = SDKGenerator.ALBPGDeploymentRuleOperator.CO_GE;
    
        /// <summary>metric threshold that is used as the pass fail.
        /// If it is not provided then it will simply compare it with
        /// current pool vs new pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("threshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Threshold { get; set; }
    
        /// <summary>metric_id of PGDeploymentRule.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as health.health_score_value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("metric_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Metric_id { get; set; } = "health.health_score_value";
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LbSslCipherAndProtocolListResult : ListResult
    {
        /// <summary>List of SSL ciphers</summary>
        [Newtonsoft.Json.JsonProperty("ciphers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<LbSslCipherInfo> Ciphers { get; set; } = new System.Collections.ObjectModel.Collection<LbSslCipherInfo>();
    
        /// <summary>List of SSL protocols</summary>
        [Newtonsoft.Json.JsonProperty("protocols", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<LbSslProtocolInfo> Protocols { get; set; } = new System.Collections.ObjectModel.Collection<LbSslProtocolInfo>();
    
    
    }
    
    /// <summary>The current statistics counters of the DNS forwarder including cache usages
    /// and query numbers per forwarders, on an NSX-T type of enforcement point.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class NsxTDNSForwarderStatistics : DNSForwarderStatisticsPerEnforcementPoint
    {
        /// <summary>The total number of forwarded DNS queries</summary>
        [Newtonsoft.Json.JsonProperty("queries_forwarded", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Queries_forwarded { get; set; }
    
        /// <summary>The total number of cached entries</summary>
        [Newtonsoft.Json.JsonProperty("cached_entries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Cached_entries { get; set; }
    
        /// <summary>The statistics of default forwarder zone</summary>
        [Newtonsoft.Json.JsonProperty("default_forwarder_statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NsxTDNSForwarderZoneStatistics Default_forwarder_statistics { get; set; }
    
        /// <summary>The total number of queries answered from local cache</summary>
        [Newtonsoft.Json.JsonProperty("queries_answered_locally", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Queries_answered_locally { get; set; }
    
        /// <summary>The statistics of used cache</summary>
        [Newtonsoft.Json.JsonProperty("used_cache_statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(2)]
        public System.Collections.Generic.ICollection<NsxTPerNodeUsedCacheStatistics> Used_cache_statistics { get; set; }
    
        /// <summary>The configured cache size, in kb</summary>
        [Newtonsoft.Json.JsonProperty("configured_cache_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Configured_cache_size { get; set; }
    
        /// <summary>Time stamp of the current statistics, in ms</summary>
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Timestamp { get; set; }
    
        /// <summary>The statistics of conditional forwarder zones</summary>
        [Newtonsoft.Json.JsonProperty("conditional_forwarder_statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(5)]
        public System.Collections.Generic.ICollection<NsxTDNSForwarderZoneStatistics> Conditional_forwarder_statistics { get; set; }
    
        /// <summary>The total number of received DNS queries</summary>
        [Newtonsoft.Json.JsonProperty("total_queries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total_queries { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IntervalSampling : SamplingArgument
    {
        /// <summary>Time interval in ms between two sampling actions.</summary>
        [Newtonsoft.Json.JsonProperty("sampling_interval", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1D, 30000D)]
        public long Sampling_interval { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBSSLProfile, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBSSLProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBSSLProfile object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBSSLProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBSSLProfile ALBSSLProfile { get; set; }
    
    
    }
    
    /// <summary>Subnet configuration for segment</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentSubnet 
    {
        /// <summary>Additional DHCP configuration for current subnet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dhcp_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SegmentDhcpConfig Dhcp_config { get; set; }
    
        /// <summary>Gateway IP address in CIDR format for both IPv4 and IPv6.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gateway_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Gateway_address { get; set; }
    
        /// <summary>DHCP address ranges are used for dynamic IP allocation.
        /// Supports address range and CIDR formats. First valid
        /// host address from the first value is assigned to DHCP server
        /// IP address. Existing values cannot be deleted or modified,
        /// but additional DHCP ranges can be added.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dhcp_ranges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<string> Dhcp_ranges { get; set; }
    
        /// <summary>Network CIDR for this subnet calculated from gateway_addresses and
        /// prefix_len.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("network", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Network { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for IdsSignatureStatus, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIdsSignatureStatus : ChildPolicyConfigResource
    {
        /// <summary>Contains the IdsSignatureStatus object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IdsSignatureStatus", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IdsSignatureStatus IdsSignatureStatus { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of ServiceInstanceEndpoint</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ServiceInstanceEndpointListResult : ListResult
    {
        /// <summary>ServiceInstanceEndpoint list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ServiceInstanceEndpoint> Results { get; set; } = new System.Collections.ObjectModel.Collection<ServiceInstanceEndpoint>();
    
    
    }
    
    /// <summary>This condition is used to match TCP header fields of HTTP messages.
    /// Currently, only the TCP source port is supported. Ports can be expressed as
    /// a single port number like 80, or a port range like 1024-1030.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBTcpHeaderCondition : LBRuleCondition
    {
        /// <summary>TCP source port of HTTP message</summary>
        [Newtonsoft.Json.JsonProperty("source_port", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Source_port { get; set; }
    
    
    }
    
    /// <summary>IPFIX packets will be collected on collector.
    /// IP and port address should be provided for collector.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPFIXL2Collector : PolicyConfigResource
    {
        /// <summary>IP address for the IPFIX L2 collector.
        /// IP addresses such as 0.0.0.0, 127.0.0.1, 255.255.255.255 are invalid.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("collector_ip_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Collector_ip_address { get; set; }
    
        /// <summary>Port number for the IPFIX L2 collector.</summary>
        [Newtonsoft.Json.JsonProperty("collector_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 65535D)]
        public long? Collector_port { get; set; } = 4739L;
    
    
    }
    
    /// <summary>Http profile.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBHttpProfile : LBAppProfile
    {
        /// <summary>When buffering is disabled, the response is passed to a client
        /// synchronously, immediately as it is received.
        /// When buffering is enabled, LB receives a response from the backend
        /// server as soon as possible, saving it into the buffers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("response_buffering", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Response_buffering { get; set; } = false;
    
        /// <summary>If server doesn’t send any packet within this time, the connection is closed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("response_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long? Response_timeout { get; set; } = 60L;
    
        /// <summary>If it is not specified, it means that request body size is unlimited.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("request_body_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long? Request_body_size { get; set; }
    
        /// <summary>NTLM is an authentication protocol that can be used over HTTP. If the
        /// flag is set to true, LB will use NTLM challenge/response methodology.
        /// This property is deprecated. Please use the property server_keep_alive
        /// in order to keep the backend server connection alive for the client
        /// connection.
        /// When create a new profile, if both ntlm and server_keep_alive are set
        /// as different values, ERROR will be reported.
        /// When update an existing profile, if either ntlm or server_keep_alive
        /// value is changed, both of them are updated with the changed value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ntlm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Ntlm { get; set; }
    
        /// <summary>A request with header equal to or below this size is guaranteed to be
        /// processed. A request with header larger than request_header_size will
        /// be processed up to 32K bytes on best effort basis.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("request_header_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, int.MaxValue)]
        public long? Request_header_size { get; set; } = 1024L;
    
        /// <summary>Certain secure applications may want to force communication over SSL,
        /// but instead of rejecting non-SSL connections, they may choose to
        /// redirect the client automatically to use SSL.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("http_redirect_to_https", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Http_redirect_to_https { get; set; } = false;
    
        /// <summary>A response with header larger than response_header_size will be dropped.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("response_header_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 65536D)]
        public long? Response_header_size { get; set; } = 4096L;
    
        /// <summary>It is used to specify the HTTP application idle timeout, it means that
        /// how long the load balancer will keep the connection idle to wait for
        /// the client to send the next keep-alive request. It is not a TCP socket
        /// setting.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("idle_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 5400D)]
        public long? Idle_timeout { get; set; } = 15L;
    
        /// <summary>If server_keep_alive is true, it means the backend connection will keep
        /// alive for the client connection. Every client connection is tied 1:1
        /// with the corresponding server-side connection.
        /// If server_keep_alive is false, it means the backend connection won't
        /// keep alive for the client connection.
        /// If server_keep_alive is not specified for API input, its value in API
        /// output will be the same with the property ntlm.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server_keep_alive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Server_keep_alive { get; set; }
    
        /// <summary>If a website is temporarily down or has moved, incoming requests
        /// for that virtual server can be temporarily redirected to a URL.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("http_redirect_to", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Http_redirect_to { get; set; }
    
        /// <summary>When X-Forwareded-For is configured, X-Forwarded-Proto and
        /// X-Forwarded-Port information is added automatically. The two additional
        /// header information can be also modified or deleted in load balancer
        /// rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("x_forwarded_for", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBHttpProfileX_forwarded_for? X_forwarded_for { get; set; }
    
    
    }
    
    /// <summary>Mirrors Data from source to destination</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PortMirroringProfile : PolicyConfigResource
    {
        /// <summary>Port mirroring profile direction</summary>
        [Newtonsoft.Json.JsonProperty("direction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PortMirroringProfileDirection? Direction { get; set; } = SDKGenerator.PortMirroringProfileDirection.BIDIRECTIONAL;
    
        /// <summary>User can provide Mirror stack or Default stack to send mirror traffic. If profile type is REMOTE_L3_SPAN, tcp_ip_stack type is used else ignored.</summary>
        [Newtonsoft.Json.JsonProperty("tcp_ip_stack", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PortMirroringProfileTcp_ip_stack? Tcp_ip_stack { get; set; } = SDKGenerator.PortMirroringProfileTcp_ip_stack.Default;
    
        /// <summary>Allows user to select type of port mirroring session.</summary>
        [Newtonsoft.Json.JsonProperty("profile_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PortMirroringProfileProfile_type? Profile_type { get; set; } = SDKGenerator.PortMirroringProfileProfile_type.REMOTE_L3_SPAN;
    
        /// <summary>If this property is set, the packet will be truncated to the provided
        /// length. If this property is unset, entire packet will be mirrored.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("snap_length", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(60D, 65535D)]
        public long? Snap_length { get; set; }
    
        /// <summary>User can provide Mirror Destination type e.g GRE, ERSPAN_TWO or ERSPAN_THREE.If profile type is REMOTE_L3_SPAN, encapsulation type is used else ignored.</summary>
        [Newtonsoft.Json.JsonProperty("encapsulation_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PortMirroringProfileEncapsulation_type? Encapsulation_type { get; set; } = SDKGenerator.PortMirroringProfileEncapsulation_type.GRE;
    
        /// <summary>Used by physical switch for the mirror traffic forwarding.
        /// Must be provided and only effective when encapsulation type is
        /// ERSPAN type II or type III.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("erspan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 1023D)]
        public long? Erspan_id { get; set; } = 0L;
    
        /// <summary>User-configurable 32-bit key only for GRE</summary>
        [Newtonsoft.Json.JsonProperty("gre_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, int.MaxValue)]
        public long? Gre_key { get; set; } = 0L;
    
        /// <summary>Data from source group will be copied to members of
        /// destination group. Only IPSET group and group with
        /// membership criteria VM is supported. IPSET group allows only
        /// three ip's.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destination_group", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Destination_group { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for PolicyGroupReference, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyGroupReference : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyGroupReference object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyGroupReference", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyGroupReference PolicyGroupReference { get; set; }
    
    
    }
    
    /// <summary>Gives the statistics of a NAT rule per enforcement point.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyNatRuleStatisticsPerEnforcementPoint 
    {
        /// <summary>Gives NAT rule stats on an enforcement point.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rule_statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyNatRuleStatistics> Rule_statistics { get; set; }
    
        /// <summary>Path of NAT Rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rule_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rule_path { get; set; }
    
        /// <summary>Policy Path referencing the enforcement point from where the statistics are fetched.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enforcement_point_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enforcement_point_path { get; set; }
    
    
    }
    
    /// <summary>PIM (Protocol Independent Multicast) RP (Randezvous Point) mapping details.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PimRpMapping 
    {
        /// <summary>Value of this field will be true if this edge transport node
        /// acts as rendezvous point, otherwise false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("is_rp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_rp { get; set; }
    
        /// <summary>Outgoing/Egress interface for multicast traffic.</summary>
        [Newtonsoft.Json.JsonProperty("outgoing_interface", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Outgoing_interface { get; set; }
    
        /// <summary>Multicast group address.</summary>
        [Newtonsoft.Json.JsonProperty("group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group { get; set; }
    
        /// <summary>RP (Randezvous Point) address.</summary>
        [Newtonsoft.Json.JsonProperty("rp_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rp_address { get; set; }
    
        /// <summary>Source of learning RP information. Either Static RP configured or
        /// RP learned via BSR (Bootstrap Router).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source { get; set; }
    
    
    }
    
    /// <summary>The type contains information about the configuration of the FqdnAnalysis feature for a
    /// specific node.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FqdnAnalysisConfig : PolicyConfigResource
    {
        /// <summary>Property which specifies the enabling/disabling of the feature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = false;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentPortMacTableEntry 
    {
        /// <summary>The type of the MAC address</summary>
        [Newtonsoft.Json.JsonProperty("mac_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SegmentPortMacTableEntryMac_type Mac_type { get; set; }
    
        /// <summary>The MAC address</summary>
        [Newtonsoft.Json.JsonProperty("mac_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Mac_address { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of Rules</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BaseRuleListResult : ListResult
    {
    
    }
    
    /// <summary>Advanced load balancer EquivalentLabels object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBEquivalentLabels 
    {
        /// <summary>Equivalent labels.</summary>
        [Newtonsoft.Json.JsonProperty("labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Labels { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HTTPRequestRule object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPRequestRule 
    {
        /// <summary>Index of the rule.</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public long Index { get; set; }
    
        /// <summary>Enable or disable the rule.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable", Required = Newtonsoft.Json.Required.Always)]
        public bool Enable { get; set; } = true;
    
        /// <summary>Log HTTP request upon rule match.</summary>
        [Newtonsoft.Json.JsonProperty("log", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Log { get; set; }
    
        /// <summary>Log all HTTP headers upon rule match.</summary>
        [Newtonsoft.Json.JsonProperty("all_headers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? All_headers { get; set; }
    
        /// <summary>HTTP request URL rewrite action.</summary>
        [Newtonsoft.Json.JsonProperty("rewrite_url_action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPRewriteURLAction Rewrite_url_action { get; set; }
    
        /// <summary>Content switching action.</summary>
        [Newtonsoft.Json.JsonProperty("switching_action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPSwitchingAction Switching_action { get; set; }
    
        /// <summary>HTTP redirect action.</summary>
        [Newtonsoft.Json.JsonProperty("redirect_action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPRedirectAction Redirect_action { get; set; }
    
        /// <summary>Name of the rule.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>Add match criteria to the rule.</summary>
        [Newtonsoft.Json.JsonProperty("match", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBMatchTarget Match { get; set; }
    
        /// <summary>HTTP header rewrite action.</summary>
        [Newtonsoft.Json.JsonProperty("hdr_action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBHTTPHdrAction> Hdr_action { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer ClientLogFilter object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBClientLogFilter 
    {
        /// <summary>Number of index.</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public long Index { get; set; }
    
        /// <summary>Placeholder for description of property client_ip of obj
        /// type ClientLogFilter field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddrMatch Client_ip { get; set; }
    
        /// <summary>Name of the object.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>Special values are 0 - 'infinite'.
        /// Unit is MIN.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 30.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("duration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Duration { get; set; } = 30L;
    
        /// <summary>Placeholder for description of property all_headers of obj
        /// type ClientLogFilter field type str  type boolean.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("all_headers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? All_headers { get; set; } = false;
    
        /// <summary>Placeholder for description of property enabled of obj type
        /// ClientLogFilter field type str  type boolean.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; } = false;
    
        /// <summary>Placeholder for description of property uri of obj type
        /// ClientLogFilter field type str  type ref.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uri", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBStringMatch Uri { get; set; }
    
    
    }
    
    /// <summary>This entity will be used to establish association between discovery profile
    /// and Segment. Using this entity, user can specify intent for applying
    /// discovery profile to particular segments.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentDiscoveryProfileBindingMap : DiscoveryProfileBindingMap
    {
        /// <summary>PolicyPath of associated IP Discovery Profile</summary>
        [Newtonsoft.Json.JsonProperty("ip_discovery_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ip_discovery_profile_path { get; set; }
    
        /// <summary>PolicyPath of associated Mac Discovery Profile</summary>
        [Newtonsoft.Json.JsonProperty("mac_discovery_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Mac_discovery_profile_path { get; set; }
    
    
    }
    
    /// <summary>Represents the operators AND or OR.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConjunctionOperator : Expression
    {
        /// <summary>Conjunction Operator Node</summary>
        [Newtonsoft.Json.JsonProperty("conjunction_operator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConjunctionOperatorConjunction_operator Conjunction_operator { get; set; }
    
    
    }
    
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("PktCapResource", typeof(PktCapResource))]
    [JsonInheritanceAttribute("PolicyPktCapResource", typeof(PolicyPktCapResource))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BasePktCapResource 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MacAddressCsvListResult : CsvListResult
    {
        /// <summary>Timestamp when the data was last updated; unset if data source has never updated the data.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MacTableCsvRecord> Results { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HTTPServerReselect object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHTTPServerReselect 
    {
        /// <summary>Allow retry of non-idempotent HTTP requests.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("retry_nonidempotent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Retry_nonidempotent { get; set; } = false;
    
        /// <summary>Number of times to retry an HTTP request when server
        /// responds with configured status codes.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 4.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("num_retries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Num_retries { get; set; } = 4L;
    
        /// <summary>Timeout per retry attempt, for a given request.
        /// Value of 0 indicates default timeout.
        /// Allowed values are 0-3600000.
        /// Unit is MILLISECONDS.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("retry_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 3600000D)]
        public long? Retry_timeout { get; set; } = 0L;
    
        /// <summary>Enable HTTP request reselect when server responds with
        /// specific response codes.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; } = false;
    
        /// <summary>Server response codes which will trigger an HTTP request
        /// retry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("svr_resp_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBHTTPReselectRespCode Svr_resp_code { get; set; }
    
    
    }
    
    /// <summary>PIM Rendezvous Point Mappings.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PimRpMappings 
    {
        /// <summary>Policy path to Tier0 gateway.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gateway_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Gateway_path { get; set; }
    
        [Newtonsoft.Json.JsonProperty("pim_rp_mappings_per_edge", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PimRpMappingsPerEdge> Pim_rp_mappings_per_edge { get; set; }
    
    
    }
    
    /// <summary>A 'tier' is a set of workloads that share common networking and security
    /// services. Tiers provide a specific function for an application and are thus
    /// a collection of compute with their associated services.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ApplicationTier : PolicyConfigResource
    {
        /// <summary>This represents the subnet that is associated with tier.
        /// If this is specified, size property is ignored.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip_range", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ip_range { get; set; }
    
        /// <summary>There are three kinds of Access Types supported for an Application.
        /// Public  - Tier is accessible from external networks and its IP is picked up from public IP
        ///           addresses from VHC configuration unless specified explicitly by user.
        /// Private - Tier is accessbile only within the application and its IP is picked up from
        ///           private IP addresses from VHC configuration unless specified explicitly by user.
        /// Shared  - Tier is accessible within the scope of VHC and its IP is picked up from private
        ///           IP addresses from VHC configuration unless specified explicitly by user.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("access_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ApplicationTierAccess_type? Access_type { get; set; } = SDKGenerator.ApplicationTierAccess_type.Shared;
    
        /// <summary>ONE  - 1       XXS - 8
        /// XS   - 16        S - 32
        /// M    - 64        L - 128
        /// XL   - 256     XXL - 512
        /// XXXL - 1024
        /// </summary>
        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ApplicationTierSize? Size { get; set; } = SDKGenerator.ApplicationTierSize.XXS;
    
    
    }
    
    /// <summary>Paged Collection of L3Vpns</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L3VpnListResult : ListResult
    {
        /// <summary>L3Vpn list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<L3Vpn> Results { get; set; } = new System.Collections.ObjectModel.Collection<L3Vpn>();
    
    
    }
    
    /// <summary>All the types of value extend from this abstract class. This
    /// is present for extensibility.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("StringArrayConstraintValue", typeof(StringArrayConstraintValue))]
    [JsonInheritanceAttribute("CidrArrayConstraintValue", typeof(CidrArrayConstraintValue))]
    [JsonInheritanceAttribute("IntegerArrayConstraintValue", typeof(IntegerArrayConstraintValue))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConstraintValue 
    {
    
    }
    
    /// <summary>Child wrapper object for ChildRedirectionRule used in Hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildRedirectionRule : ChildPolicyConfigResource
    {
        /// <summary>Contains actual RedirectionRule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("RedirectionRule", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public RedirectionRule RedirectionRule { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DnsHeader 
    {
        /// <summary>This is used to specify the type of the address. V4 - The address provided is an IPv4 domain name/IP address, the Type in query or response will be A V6 - The address provided is an IPv6 domain name/IP address, the Type in query or response will be AAAA</summary>
        [Newtonsoft.Json.JsonProperty("address_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DnsHeaderAddress_type? Address_type { get; set; } = SDKGenerator.DnsHeaderAddress_type.V4;
    
        /// <summary>Specifies the message type whether it is a query or a response.</summary>
        [Newtonsoft.Json.JsonProperty("message_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DnsHeaderMessage_type? Message_type { get; set; } = SDKGenerator.DnsHeaderMessage_type.QUERY;
    
        /// <summary>This is used to define what is being asked or responded.</summary>
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Address { get; set; }
    
    
    }
    
    /// <summary>Every URL is classified into one or more of 83 pre-defined categories.
    /// Examples of categories are 'Shopping', 'Financial Services', 'Travel', etc.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyUrlCategory : PolicyConfigResource
    {
        /// <summary>The id of the category.</summary>
        [Newtonsoft.Json.JsonProperty("category_id", Required = Newtonsoft.Json.Required.Always)]
        public long Category_id { get; set; }
    
        /// <summary>The name of the category.</summary>
        [Newtonsoft.Json.JsonProperty("category_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Category_name { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer FullClientLogs object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBFullClientLogs 
    {
        /// <summary>How long should the system capture all logs, measured in
        /// minutes.
        /// Set to 0 for infinite.
        /// Special values are 0 - 'infinite'.
        /// Unit is MIN.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 30.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("duration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Duration { get; set; } = 30L;
    
        /// <summary>This setting limits the number of non-significant logs
        /// generated per second for this VS on each SE.
        /// Default is 10 logs per second.
        /// Set it to zero (0) to deactivate throttling.
        /// Unit is PER_SECOND.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 10.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("throttle", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Throttle { get; set; } = 10L;
    
        /// <summary>Capture all client logs including connections and requests.
        /// When deactivated, only errors will be logged.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; } = false;
    
    
    }
    
    /// <summary>Segment port statistics on specific Enforcement Point.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentPortStatistics : LogicalPortStatistics
    {
    
    }
    
    /// <summary>Details of container cluster.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ContainerCluster : DiscoveredResource
    {
        /// <summary>Network status of container cluster.</summary>
        [Newtonsoft.Json.JsonProperty("network_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ContainerClusterNetwork_status? Network_status { get; set; }
    
        /// <summary>Details of underlying infrastructure that hosts the container cluster.
        /// In case of creating container cluster first time, it is expected to
        /// pass the valid infrastructure.
        /// In case of update, if there is no change in cluster-type, then this
        /// field can be omitted in the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("infrastructure", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ContainerInfrastructureInfo Infrastructure { get; set; }
    
        /// <summary>Type of the container cluster. In case of creating container cluster
        /// first time, it is expected to pass the valid cluster-type.
        /// In case of update, if there is no change in cluster-type, then this
        /// field can be omitted in the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cluster_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ContainerClusterCluster_type? Cluster_type { get; set; }
    
        /// <summary>Array of additional specific properties of container cluster
        /// in key-value format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("origin_properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyValuePair> Origin_properties { get; set; }
    
        /// <summary>External identifier of the container cluster.</summary>
        [Newtonsoft.Json.JsonProperty("external_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string External_id { get; set; }
    
        /// <summary>List of network errors related to container cluster.</summary>
        [Newtonsoft.Json.JsonProperty("network_errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<NetworkError> Network_errors { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ComputeCollection : DiscoveredResource
    {
        /// <summary>Id of the compute manager from where this Compute Collection was discovered</summary>
        [Newtonsoft.Json.JsonProperty("origin_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Origin_id { get; set; }
    
        /// <summary>Key-Value map of additional specific properties of
        /// compute collection in the Compute Manager
        /// </summary>
        [Newtonsoft.Json.JsonProperty("origin_properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyValuePair> Origin_properties { get; set; }
    
        /// <summary>External ID of the ComputeCollection in the source Compute manager,
        /// e.g. mo-ref in VC
        /// </summary>
        [Newtonsoft.Json.JsonProperty("external_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string External_id { get; set; }
    
        /// <summary>Id of the owner of compute collection in the Compute Manager</summary>
        [Newtonsoft.Json.JsonProperty("owner_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Owner_id { get; set; }
    
        /// <summary>ComputeCollection type like VC_Cluster. Here the Compute Manager
        /// type prefix would help in differentiating similar named Compute
        /// Collection types from different Compute Managers
        /// </summary>
        [Newtonsoft.Json.JsonProperty("origin_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Origin_type { get; set; }
    
        /// <summary>Local Id of the compute collection in the Compute Manager</summary>
        [Newtonsoft.Json.JsonProperty("cm_local_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cm_local_id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DataCounter 
    {
        /// <summary>The total packets or bytes</summary>
        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Always)]
        public long Total { get; set; }
    
        /// <summary>The multicast and broadcast packets or bytes</summary>
        [Newtonsoft.Json.JsonProperty("multicast_broadcast", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Multicast_broadcast { get; set; }
    
        /// <summary>The dropped packets or bytes</summary>
        [Newtonsoft.Json.JsonProperty("dropped", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dropped { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer SensitiveFieldRule object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSensitiveFieldRule 
    {
        /// <summary>Action for the matched log field, for instance the matched
        /// field can be removed or masked off.
        /// Enum options - LOG_FIELD_REMOVE, LOG_FIELD_MASKOFF.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as LOG_FIELD_REMOVE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBSensitiveFieldRuleAction? Action { get; set; } = SDKGenerator.ALBSensitiveFieldRuleAction.LOG_FIELD_REMOVE;
    
        /// <summary>Index of the rule.</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Index { get; set; }
    
        /// <summary>Enable rule to match the sensitive fields.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = false;
    
        /// <summary>Name of the rule.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Criterion to use for matching in the Log.</summary>
        [Newtonsoft.Json.JsonProperty("match", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBStringMatch Match { get; set; }
    
    
    }
    
    /// <summary>Injection holding a key and a corresponding value.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Injection 
    {
        /// <summary>Injection value.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public InjectionValue Value { get; set; } = new InjectionValue();
    
        /// <summary>Injection key.</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }
    
    
    }
    
    /// <summary>IpAddrGroupApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBIpAddrGroupApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of IpAddrGroup
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBIpAddrGroup> Results { get; set; }
    
    
    }
    
    /// <summary>Configuration for taking manual/automated backup</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BackupConfiguration 
    {
        /// <summary>The server to which backups will be sent.</summary>
        [Newtonsoft.Json.JsonProperty("remote_file_server", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public RemoteFileServer Remote_file_server { get; set; } = new RemoteFileServer();
    
        /// <summary>true if automated backup is enabled</summary>
        [Newtonsoft.Json.JsonProperty("backup_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Backup_enabled { get; set; } = false;
    
        /// <summary>Passphrase used to encrypt backup files.
        /// The passphrase specified must be at least 8 characters in length and must
        /// contain at least one lowercase, one uppercase, one numeric character and one
        /// special character (any other non-space character).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("passphrase", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Passphrase { get; set; }
    
        /// <summary>Set when backups should be taken - on a weekly schedule or at regular intervals.</summary>
        [Newtonsoft.Json.JsonProperty("backup_schedule", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public BackupSchedule Backup_schedule { get; set; }
    
        /// <summary>A number of seconds after a last backup, that needs to pass, before a topology change will trigger a generation of a new cluster/node backups. If parameter is not provided, then changes in a topology will not trigger a generation of cluster/node backups.</summary>
        [Newtonsoft.Json.JsonProperty("after_inventory_update_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(300D, 86400D)]
        public long? After_inventory_update_interval { get; set; }
    
        /// <summary>The minimum number of seconds between each upload of the inventory summary to backup server.</summary>
        [Newtonsoft.Json.JsonProperty("inventory_summary_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(30D, 3600D)]
        public long? Inventory_summary_interval { get; set; } = 240L;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CountActionArgument 
    {
        /// <summary>Type of count</summary>
        [Newtonsoft.Json.JsonProperty("count_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CountActionArgumentCount_type? Count_type { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HealthMonitorUdp object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHealthMonitorUdp 
    {
        /// <summary>Match or look for this keyword in the first 2KB of server's
        /// response indicating server maintenance.
        /// A successful match results in the server being marked down.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maintenance_response", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Maintenance_response { get; set; }
    
        /// <summary>Send UDP request.</summary>
        [Newtonsoft.Json.JsonProperty("udp_request", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Udp_request { get; set; }
    
        /// <summary>Match for keyword in the UDP response.</summary>
        [Newtonsoft.Json.JsonProperty("udp_response", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Udp_response { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for ForwardingPolicy used in Hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildForwardingPolicy : ChildPolicyConfigResource
    {
        /// <summary>Contains actual ForwardingPolicy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ForwardingPolicy", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ForwardingPolicy ForwardingPolicy { get; set; }
    
    
    }
    
    /// <summary>For policy-based L3Vpn sessions, a rule specifies as its action the vpn tunnel to be used
    /// for transit traffic that meets the rule's match criteria.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L3VpnRule : PolicyConfigResource
    {
        /// <summary>Action to exchange data with or without protection.
        /// PROTECT - Allows to exchange data with ipsec protection. Protect rules are defined per
        /// L3Vpn.
        /// BYPASS - Allows to exchange data without ipsec protection. Bypass rules are defined per
        /// L3VpnContext and affects all policy based L3Vpns. Bypass rules are prioritized over
        /// protect rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public L3VpnRuleAction? Action { get; set; } = SDKGenerator.L3VpnRuleAction.PROTECT;
    
        /// <summary>List of local subnets used in policy-based L3Vpn.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sources", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<L3VpnSubnet> Sources { get; set; } = new System.Collections.ObjectModel.Collection<L3VpnSubnet>();
    
        /// <summary>This field is used to resolve conflicts between multiple L3VpnRules associated with a
        /// single L3Vpn or L3VpnContext.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sequence_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Sequence_number { get; set; }
    
        /// <summary>List of remote subnets used in policy-based L3Vpn.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinations", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(128)]
        public System.Collections.Generic.ICollection<L3VpnSubnet> Destinations { get; set; } = new System.Collections.ObjectModel.Collection<L3VpnSubnet>();
    
    
    }
    
    /// <summary>L2VPN Session Statistics Per Enforcement Point.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("L2VPNSessionStatisticsNsxT", typeof(L2VPNSessionStatisticsNsxT))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VPNSessionStatisticsPerEP : PolicyRuntimeInfoPerEP
    {
    
    }
    
    /// <summary>The current runtime status of the DNS forwarder.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class NsxTDNSForwarderStatus : DNSForwarderStatusPerEnforcementPoint
    {
        /// <summary>UP means the DNS forwarder is working correctly on the active transport
        /// node and the stand-by transport node (if present). Failover will occur
        /// if either node goes down.
        /// DOWN means the DNS forwarder is down on both active transport node and
        /// standby node (if present). The DNS forwarder does not function in this
        /// situation.
        /// Error means there is some error on one or both transport node, or no
        /// status was reported from one or both transport nodes. The DNS forwarder
        /// may be working (or not working).
        /// NO_BACKUP means DNS forwarder is working in only one transport node,
        /// either because it is down on the standby node, or no standby is configured.
        /// An forwarder outage will occur if the active node goes down.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public NsxTDNSForwarderStatusStatus? Status { get; set; }
    
        /// <summary>Time stamp of the current status, in ms</summary>
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Timestamp { get; set; }
    
        /// <summary>Extra message, if available</summary>
        [Newtonsoft.Json.JsonProperty("extra_message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Extra_message { get; set; }
    
    
    }
    
    /// <summary>This type is deprecated. Use the type RuleListResult instead.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CommunicationEntryListResult : ListResult
    {
        /// <summary>CommunicationEntry list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<CommunicationEntry> Results { get; set; } = new System.Collections.ObjectModel.Collection<CommunicationEntry>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DirectoryGroupMember : ManagedResource
    {
        /// <summary>Directory group id this group member belongs to</summary>
        [Newtonsoft.Json.JsonProperty("group_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Group_id { get; set; }
    
        /// <summary>Directory group name this group member owns</summary>
        [Newtonsoft.Json.JsonProperty("member_group_distinguished_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Member_group_distinguished_name { get; set; }
    
        /// <summary>Directory group id this group member owns</summary>
        [Newtonsoft.Json.JsonProperty("member_group_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Member_group_id { get; set; }
    
        /// <summary>Directory group distinguished name this group member belongs to.</summary>
        [Newtonsoft.Json.JsonProperty("group_distinguished_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Group_distinguished_name { get; set; }
    
        /// <summary>Whether this member group is a directory member of the parent group speicified by group_id or a nested member group which parent group is also member group of the parent group speicified by group_id.</summary>
        [Newtonsoft.Json.JsonProperty("nested", Required = Newtonsoft.Json.Required.Always)]
        public bool Nested { get; set; }
    
    
    }
    
    /// <summary>A profile holding CPU and memory thresholds configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyFirewallCpuMemThresholdsProfile : PolicyConfigResource
    {
        /// <summary>Heap memory thresholds percentage to monitor and report for
        /// distributed firewall.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mem_threshold_percentage", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(10D, 100D)]
        public long Mem_threshold_percentage { get; set; } = 90L;
    
        /// <summary>CPU utilization thresholds percentage to monitor and report for
        /// distributed firewall.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cpu_threshold_percentage", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(10D, 100D)]
        public long Cpu_threshold_percentage { get; set; } = 90L;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyTepTableCsvRecord : CsvRecord
    {
        /// <summary>The tunnel endpoint label</summary>
        [Newtonsoft.Json.JsonProperty("tep_label", Required = Newtonsoft.Json.Required.Always)]
        public long Tep_label { get; set; }
    
        /// <summary>This is the identifier of the TEP segment. This segment is NOT the same as logical segment or logical switch.</summary>
        [Newtonsoft.Json.JsonProperty("segment_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Segment_id { get; set; }
    
        /// <summary>The tunnel endpoint MAC address</summary>
        [Newtonsoft.Json.JsonProperty("tep_mac_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Tep_mac_address { get; set; }
    
        /// <summary>The tunnel endpoint IP address</summary>
        [Newtonsoft.Json.JsonProperty("tep_ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tep_ip { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for PolicyServiceProfile used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyServiceProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains actual PolicyServiceProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyServiceProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyServiceProfile PolicyServiceProfile { get; set; }
    
    
    }
    
    /// <summary>L2VPN Session Status represents status on an NSX-T type of enforcement point.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class L2VPNSessionStatusNsxT : L2VPNSessionStatusPerEP
    {
        /// <summary>Transport tunnels status.</summary>
        [Newtonsoft.Json.JsonProperty("transport_tunnels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<L2VPNSessionTransportTunnelStatus> Transport_tunnels { get; set; }
    
        /// <summary>Display name of l2vpn session.</summary>
        [Newtonsoft.Json.JsonProperty("display_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Display_name { get; set; }
    
        /// <summary>L2 VPN session status, specifies UP/DOWN.</summary>
        [Newtonsoft.Json.JsonProperty("runtime_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public L2VPNSessionStatusNsxTRuntime_status? Runtime_status { get; set; }
    
    
    }
    
    /// <summary>Idfw configuration for enable/disable idfw on cluster level.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ComputeClusterIdfwConfiguration : PolicyConfigResource
    {
        /// <summary>Contains actual policy resource reference object</summary>
        [Newtonsoft.Json.JsonProperty("member", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyResourceReference Member { get; set; }
    
        /// <summary>If set to true, idfw is enabled for this cluster</summary>
        [Newtonsoft.Json.JsonProperty("cluster_idfw_enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Cluster_idfw_enabled { get; set; }
    
    
    }
    
    /// <summary>The results of probing an individual LDAP server.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdentitySourceLdapServerProbeResult 
    {
        /// <summary>THe URL of the probed LDAP host.</summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }
    
        /// <summary>Detail about errors encountered during the probe.</summary>
        [Newtonsoft.Json.JsonProperty("errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LdapProbeError> Errors { get; set; }
    
        /// <summary>Overall result of the probe. If the probe was able to connect to the LDAP service, authenticate using the provided credentials, and perform searches of the configured user and group search bases without error, the result is SUCCESS. Otherwise, the result is FAILURE, and additional details may be found in the errors property.</summary>
        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IdentitySourceLdapServerProbeResultResult? Result { get; set; }
    
    
    }
    
    /// <summary>Credential info to connect to a CVX type of enforcement point.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CvxConnectionInfo : EnforcementPointConnectionInfo
    {
        /// <summary>Username.</summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Username { get; set; }
    
        /// <summary>Password.</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Password { get; set; }
    
        /// <summary>Thumbprint of EnforcementPoint in the form of a SHA-256 hash represented in lower case HEX.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thumbprint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Thumbprint { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer HttpCacheConfig object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBHttpCacheConfig 
    {
        /// <summary>Non-cacheable URI configuration with match criteria.</summary>
        [Newtonsoft.Json.JsonProperty("uri_non_cacheable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBPathMatch Uri_non_cacheable { get; set; }
    
        /// <summary>Whitelist string group of cacheable mime types.
        /// If both Cacheable Mime Types string list and string group
        /// are empty, this defaults to (STAR)/(STAR).
        /// It is a reference to an object of type StringGroup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mime_types_group_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Mime_types_group_paths { get; set; }
    
        /// <summary>Allow caching of objects whose URI included a query
        /// argument.
        /// When disabled, these objects are not cached.
        /// When enabled, the request must match the URI query to be
        /// considered a hit.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("query_cacheable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Query_cacheable { get; set; } = false;
    
        /// <summary>Blacklist string group of non-cacheable mime types.
        /// It is a reference to an object of type StringGroup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mime_types_black_group_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Mime_types_black_group_paths { get; set; }
    
        /// <summary>Add an Age header to content served from cache, which
        /// indicates to the client the number of seconds the object has
        /// been in the cache.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("age_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Age_header { get; set; } = true;
    
        /// <summary>Whitelist of cacheable mime types.
        /// If both Cacheable Mime Types string list and string group
        /// are empty, this defaults to (STAR)/(STAR).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mime_types_list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Mime_types_list { get; set; }
    
        /// <summary>Add an X-Cache header to content served from cache, which
        /// indicates to the client that the object was served from an
        /// intermediate cache.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("xcache_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Xcache_header { get; set; } = true;
    
        /// <summary>Enable/disable HTTP object caching.When enabling caching
        /// for the first time, SE Group app_cache_percent must beset to
        /// allocate shared memory required for caching (A service
        /// engine restart is needed after setting/resetting the SE
        /// group value).
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = false;
    
        /// <summary>Default expiration time of cache objects received from the
        /// server without a Cache-Control expiration header.
        /// This value may be overwritten by the Heuristic Expire
        /// setting.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 600.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("default_expire", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Default_expire { get; set; } = 600L;
    
        /// <summary>Max size, in bytes, of the cache.
        /// The default, zero, indicates auto configuration.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_cache_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Max_cache_size { get; set; } = 0L;
    
        /// <summary>Minimum size of an object to store in the cache.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 100.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("min_object_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Min_object_size { get; set; } = 100L;
    
        /// <summary>If a response object from the server does not include the
        /// Cache-Control header, but does include a Last-Modified
        /// header, the system will use this time to calculate the
        /// Cache-Control expiration.
        /// If unable to solicit an Last-Modified header, then the
        /// system will fall back to the Cache Expire Time value.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("heuristic_expire", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Heuristic_expire { get; set; } = false;
    
        /// <summary>If a Date header was not added by the server, add a Date
        /// header to the object served from cache.
        /// This indicates to the client when the object was originally
        /// sent by the server to the cache.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("date_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Date_header { get; set; } = true;
    
        /// <summary>Enable/disable caching objects without Cache-Control
        /// headers.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("aggressive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Aggressive { get; set; } = false;
    
        /// <summary>Maximum size of an object to store in the cache.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 4194304.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_object_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Max_object_size { get; set; } = 4194304L;
    
        /// <summary>Blacklist of non-cacheable mime types.</summary>
        [Newtonsoft.Json.JsonProperty("mime_types_black_list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Mime_types_black_list { get; set; }
    
        /// <summary>Ignore client's cache control headers when fetching or
        /// storing from and to the cache.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ignore_request_cache_control", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Ignore_request_cache_control { get; set; } = false;
    
    
    }
    
    /// <summary>Represents the Intrusion Detection System Security Policy, which contains
    ///  the list of IDS Rules.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsSecurityPolicy : Policy
    {
        /// <summary>IDS Rules that are a part of this SecurityPolicy</summary>
        [Newtonsoft.Json.JsonProperty("rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IdsRule> Rules { get; set; }
    
    
    }
    
    /// <summary>Realized Logical Port</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedLogicalPort : PolicyRealizedResource
    {
        /// <summary>The id of the logical port</summary>
        [Newtonsoft.Json.JsonProperty("logical_port_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Logical_port_id { get; set; }
    
        /// <summary>The Operational status of the logical port</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RealizedLogicalPortStatus? Status { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TlsCertificate : PolicyConfigResource
    {
        /// <summary>list of X509Certificates.</summary>
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<X509Certificate> Details { get; set; }
    
        /// <summary>pem encoded certificate data.</summary>
        [Newtonsoft.Json.JsonProperty("pem_encoded", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Pem_encoded { get; set; }
    
    
    }
    
    /// <summary>Realized firewalls</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RealizedFirewalls : PolicyRealizedResource
    {
        /// <summary>list of realized firewalls</summary>
        [Newtonsoft.Json.JsonProperty("realized_firewalls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RealizedFirewall> Realized_firewalls { get; set; }
    
    
    }
    
    /// <summary>Site specific configuration of Tier0 in multi-site scenario</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LocaleServices : PolicyConfigResource
    {
        /// <summary>Policy paths to edge nodes. For Tier1 gateway, the field is used to
        /// statically assign the ordered list of up to two edge nodes for
        /// stateful services. To enable auto allocation of nodes from the
        /// specified edge cluster the field must be left unset. The auto
        /// allocation of nodes is supported only for the Tier1 gateway.  For
        /// Tier0 gateway specified edge is used as a preferred edge node
        /// when failover mode is set to PREEMPTIVE, not applicable otherwise.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preferred_edge_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(2)]
        public System.Collections.Generic.ICollection<string> Preferred_edge_paths { get; set; }
    
        /// <summary>This configuration can be defined only for Active-Standby Tier0 gateway to provide redundancy. For mulitple external interfaces, multiple HA VIP configs must be defined and each config will pair exactly two external interfaces. The VIP will move and will always be owned by the Active node. When this property is configured, configuration of dynamic-routing is not allowed.</summary>
        [Newtonsoft.Json.JsonProperty("ha_vip_configs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Tier0HaVipConfig> Ha_vip_configs { get; set; }
    
        /// <summary>Configure all route redistribution properties like enable/disable redistributon, redistribution rule and so on.</summary>
        [Newtonsoft.Json.JsonProperty("route_redistribution_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Tier0RouteRedistributionConfig Route_redistribution_config { get; set; }
    
        /// <summary>Policy path to edge cluster. Auto-assigned on Tier0 if associated
        /// enforcement-point has only one edge cluster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_cluster_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Edge_cluster_path { get; set; }
    
        /// <summary>This profile is applied to all static route peers in this locale. BFD
        /// profile configured on static route peers takes precedence over global
        /// configuration. If this field is empty, a default profile is applied to
        /// all peers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bfd_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bfd_profile_path { get; set; }
    
        /// <summary>Enable redistribution of different types of routes on Tier-0.
        /// This property is only valid for locale-service under Tier-0.
        /// This property is deprecated, please use "route_redistribution_config"
        /// property to configure redistribution rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("route_redistribution_types", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Route_redistribution_types2> Route_redistribution_types { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyMulticastRoutesInCsvFormat : CsvListResult
    {
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MulticastRouteCsvRecord> Results { get; set; }
    
    
    }
    
    /// <summary>Paged collection of LocaleServices</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LocaleServicesListResult : ListResult
    {
        /// <summary>LocaleServices results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<LocaleServices> Results { get; set; } = new System.Collections.ObjectModel.Collection<LocaleServices>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceflowObservationListResult : ListResult
    {
        /// <summary>TraceflowObservation list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TraceflowObservation> Results { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer IPNetworkSubnet object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBIPNetworkSubnet 
    {
        /// <summary>Network for VirtualService IP allocation with Vantage as
        /// the IPAM provider.
        /// Network should be created before this is configured.
        /// It is a reference to an object of type Network.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("network_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Network_path { get; set; }
    
        /// <summary>Subnet for VirtualService IP allocation with Vantage or
        /// Infoblox as the IPAM provider.
        /// Only one of subnet or subnet_uuid configuration is allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddrPrefix Subnet { get; set; }
    
        /// <summary>Subnet UUID or Name or Prefix for VirtualService IPv6
        /// allocation with AWS or OpenStack as the IPAM provider.
        /// Only one of subnet or subnet_uuid configuration is allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnet6_uuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Subnet6_uuid { get; set; }
    
        /// <summary>Subnet for VirtualService IPv6 allocation with Vantage or
        /// Infoblox as the IPAM provider.
        /// Only one of subnet or subnet_uuid configuration is allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnet6", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBIpAddrPrefix Subnet6 { get; set; }
    
        /// <summary>Subnet UUID or Name or Prefix for VirtualService IP
        /// allocation with AWS or OpenStack as the IPAM provider.
        /// Only one of subnet or subnet_uuid configuration is allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnet_uuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Subnet_uuid { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MirrorStackStatusListResult : ListResult
    {
        /// <summary>SUCCESS if all the TN's stack status are SUCCESS,
        /// FAILED if some of the TN's stack status are FAILED.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overall_status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public MirrorStackStatusListResultOverall_status Overall_status { get; set; }
    
        /// <summary>List all TN nodes which spaned in remote L3 mirror session mirror
        /// stack health status detailed info, including mirror stack status,
        /// vmknic status, TN node ID, TN node name and last updated status timestamp.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<TnNodeStackSpanStatus> Results { get; set; } = new System.Collections.ObjectModel.Collection<TnNodeStackSpanStatus>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyEdgeClusterInterSiteStatus 
    {
        /// <summary>Timestamp when the edge cluster inter-site status was last updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>Overall status of all edge nodes IBGP status in the edge cluster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overall_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyEdgeClusterInterSiteStatusOverall_status? Overall_status { get; set; }
    
        /// <summary>Name of the edge cluster whose status is being reported.</summary>
        [Newtonsoft.Json.JsonProperty("edge_cluster_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Edge_cluster_name { get; set; }
    
        /// <summary>Per edge node inter-site status.</summary>
        [Newtonsoft.Json.JsonProperty("member_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PolicyEdgeClusterMemberInterSiteStatus> Member_status { get; set; }
    
        /// <summary>Policy path of the edge cluster whose status is being reported.</summary>
        [Newtonsoft.Json.JsonProperty("edge_cluster_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Edge_cluster_path { get; set; }
    
    
    }
    
    /// <summary>Collection of Pim Profile.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyPimProfileListResult : ListResult
    {
        /// <summary>PIM Profile list results.</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyPimProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyPimProfile>();
    
    
    }
    
    /// <summary>Advanced load balancer KeyValue object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBKeyValue 
    {
        /// <summary>Value.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }
    
        /// <summary>Key.</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }
    
    
    }
    
    /// <summary>IPSec VPN policy traffic statistics.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnPolicyTrafficStatistics 
    {
        /// <summary>Aggregate traffic statistics across all ipsec tunnels.</summary>
        [Newtonsoft.Json.JsonProperty("aggregate_traffic_counters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IPSecVpnTrafficCounters Aggregate_traffic_counters { get; set; }
    
        /// <summary>Tunnel statistics.</summary>
        [Newtonsoft.Json.JsonProperty("tunnel_statistics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IPSecVpnTunnelTrafficStatistics> Tunnel_statistics { get; set; }
    
        /// <summary>L3Vpn rule path.</summary>
        [Newtonsoft.Json.JsonProperty("rule_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rule_path { get; set; }
    
    
    }
    
    /// <summary>Tier-0 interface configuration for external connectivity.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Tier0Interface : BaseTier0Interface
    {
        /// <summary>OSPF configuration.</summary>
        [Newtonsoft.Json.JsonProperty("ospf", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PolicyInterfaceOspfConfig Ospf { get; set; }
    
        /// <summary>Specify association of interface with edge cluster member.
        /// This property is deprecated, use edge_path instead. When both
        /// properties are specifed, only edge_path property is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_cluster_member_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, int.MaxValue)]
        public long? Edge_cluster_member_index { get; set; }
    
        /// <summary>Unicast Reverse Path Forwarding mode</summary>
        [Newtonsoft.Json.JsonProperty("urpf_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Tier0InterfaceUrpf_mode? Urpf_mode { get; set; } = SDKGenerator.Tier0InterfaceUrpf_mode.STRICT;
    
        /// <summary>Array of prefix lists used to specify filtering for ARP proxy.
        /// Prefixes in this array are used to configure ARP proxy entries on Tier-0
        /// gateway (for uplinks).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("proxy_arp_filters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Proxy_arp_filters { get; set; }
    
        /// <summary>Policy path to edge node to handle external connectivity.
        /// Required when interface type is EXTERNAL.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("edge_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Edge_path { get; set; }
    
        /// <summary>Specify Segment to which this interface is connected to.
        /// Either segment_path or ls_id property is required.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("segment_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Segment_path { get; set; }
    
        /// <summary>Multicast PIM configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("multicast", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Tier0InterfacePimConfig Multicast { get; set; }
    
        /// <summary>Specify logical switch to which tier-0 interface is connected for
        /// external access.
        /// This property is deprecated, use segment_path instead. Both
        /// properties cannot be used together.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ls_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ls_id { get; set; }
    
        /// <summary>Configuration IPv6 NDRA profile. Only one
        /// NDRA profile can be configured.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipv6_profile_paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Ipv6_profile_paths { get; set; }
    
        /// <summary>IGMP local join groups configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("igmp_local_join_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Igmp_local_join_groups { get; set; }
    
        /// <summary>Vlan id.</summary>
        [Newtonsoft.Json.JsonProperty("access_vlan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Access_vlan_id { get; set; }
    
        /// <summary>Maximum transmission unit (MTU) specifies the size of the largest
        /// packet that a network protocol can transmit.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mtu", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(64D, int.MaxValue)]
        public long? Mtu { get; set; }
    
        /// <summary>Interface type
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Tier0InterfaceType? Type { get; set; } = SDKGenerator.Tier0InterfaceType.EXTERNAL;
    
    
    }
    
    /// <summary>Fast UDP profile.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBFastUdpProfile : LBAppProfile
    {
        /// <summary>Though UDP is a connectionless protocol, for the purposes of load
        /// balancing, all UDP packets with the same flow signature (source and
        /// destination IP/ports and IP protocol) received within the idle timeout
        /// period are considered to belong to the same connection and are sent to
        /// the same backend server. If no packets are received for idle timeout
        /// period, the connection (association between flow signature and the
        /// selected server) is cleaned up.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("idle_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long? Idle_timeout { get; set; } = 300L;
    
        /// <summary>If flow mirroring is enabled, all the flows to the bounded virtual
        /// server are mirrored to the standby node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("flow_mirroring_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Flow_mirroring_enabled { get; set; } = false;
    
    
    }
    
    /// <summary>Paged Collection of rule statistics</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RuleStatisticsListResult : ListResult
    {
        /// <summary>RuleStatistics list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<RuleStatisticsForEnforcementPoint> Results { get; set; } = new System.Collections.ObjectModel.Collection<RuleStatisticsForEnforcementPoint>();
    
    
    }
    
    /// <summary>Traffic counters for IPSec VPN session.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPSecVpnTrafficCounters 
    {
        /// <summary>Total number of packets sent.</summary>
        [Newtonsoft.Json.JsonProperty("packets_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_out { get; set; }
    
        /// <summary>Total number of outgoing packets dropped on outbound security association.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dropped_packets_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dropped_packets_out { get; set; }
    
        /// <summary>Total number of bytes recevied.</summary>
        [Newtonsoft.Json.JsonProperty("bytes_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_in { get; set; }
    
        /// <summary>Total number of bytes sent.</summary>
        [Newtonsoft.Json.JsonProperty("bytes_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_out { get; set; }
    
        /// <summary>Total number of incoming packets dropped on inbound security association.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dropped_packets_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dropped_packets_in { get; set; }
    
        /// <summary>Total number of packets received.</summary>
        [Newtonsoft.Json.JsonProperty("packets_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_in { get; set; }
    
    
    }
    
    /// <summary>All the types of PolicyLbVirtualServer extend from this abstract class. This
    /// is present for extensibility.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("HttpPolicyLbVirtualServer", typeof(HttpPolicyLbVirtualServer))]
    [JsonInheritanceAttribute("CustomPolicyLbVirtualServer", typeof(CustomPolicyLbVirtualServer))]
    [JsonInheritanceAttribute("TcpPolicyLbVirtualServer", typeof(TcpPolicyLbVirtualServer))]
    [JsonInheritanceAttribute("HttpsPolicyLbVirtualServer", typeof(HttpsPolicyLbVirtualServer))]
    [JsonInheritanceAttribute("UdpPolicyLbVirtualServer", typeof(UdpPolicyLbVirtualServer))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyLbVirtualServer : PolicyConfigResource
    {
        /// <summary>If access log is enabled, all HTTP requests sent to an L7 virtual
        /// server are logged to the access log file. Both successful requests
        /// (backend server returns 2xx) and unsuccessful requests (backend
        /// server returns 4xx or 5xx) are logged to access log, if enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("access_log_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Access_log_enabled { get; set; } = false;
    
        /// <summary>Path to router type object that PolicyLbVirtualServer connects to.
        /// The only supported router object is Network.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("router_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Router_path { get; set; }
    
        /// <summary>Path to optional object that enables persistence on a virtual server
        /// allowing related client connections to be sent to the same backend
        /// server. Persistence is disabled by default.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lb_persistence_profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lb_persistence_profile { get; set; }
    
        [Newtonsoft.Json.JsonProperty("traffic_source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Traffic_source { get; set; }
    
        /// <summary>Configures the IP address of the PolicyLbVirtualServer where it
        /// receives all client connections and distributes them among the
        /// backend servers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip_address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ip_address { get; set; }
    
        /// <summary>Ports contains a list of at least one port or port range such as "80",
        /// "1234-1236". Each port element in the list should be a single port or a
        /// single port range.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ports", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Ports { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>Child wrapper for DhcpStaticBindingConfig, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildDhcpStaticBindingConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual DhcpStaticBindingConfig object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("DhcpStaticBindingConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public DhcpStaticBindingConfig DhcpStaticBindingConfig { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer AuthenticationRule object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBAuthenticationRule 
    {
        /// <summary>Enable or disable authentication for matched targets.</summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBAuthenticationAction Action { get; set; }
    
        /// <summary>Index of the rule.</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public long Index { get; set; }
    
        /// <summary>Enable or disable the rule.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enable { get; set; } = true;
    
        /// <summary>Name of the rule.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>Add match criteria to the rule.</summary>
        [Newtonsoft.Json.JsonProperty("match", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ALBAuthenticationMatch Match { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer StreamingSyslogConfig object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBStreamingSyslogConfig 
    {
        /// <summary>Severity code, as defined in RFC5424, for non-significant
        /// logs.
        /// This must be between 0 and 7 inclusive.
        /// Allowed values are 0-7.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 6.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("non_significant_log_severity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 7D)]
        public long? Non_significant_log_severity { get; set; } = 6L;
    
        /// <summary>Severity code, as defined in RFC5424, for filtered logs.
        /// This must be between 0 and 7 inclusive.
        /// Allowed values are 0-7.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 5.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("filtered_log_severity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 7D)]
        public long? Filtered_log_severity { get; set; } = 5L;
    
        /// <summary>String to use as the hostname in the syslog messages.
        /// This string can contain only printable ASCII characters
        /// (hex 21 to hex 7E; no space allowed).
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as AviVantage.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hostname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Hostname { get; set; } = "AviVantage";
    
        /// <summary>Severity code, as defined in RFC5424, for significant logs.
        /// This must be between 0 and 7 inclusive.
        /// Allowed values are 0-7.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 4.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("significant_log_severity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 7D)]
        public long? Significant_log_severity { get; set; } = 4L;
    
        /// <summary>Facility value, as defined in RFC5424, must be between 0
        /// and 23 inclusive.
        /// Allowed values are 0-23.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 16.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("facility", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 23D)]
        public long? Facility { get; set; } = 16L;
    
    
    }
    
    /// <summary>Dscp value is ignored in case of 'TRUSTED' DscpTrustMode.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class QoSDscp 
    {
        /// <summary>Internal Forwarding Priority</summary>
        [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 63D)]
        public long? Priority { get; set; } = 0L;
    
        /// <summary>When you select the Trusted mode the inner header DSCP value is applied
        /// to the outer IP header for IP/IPv6 traffic. For non IP/IPv6 traffic,
        /// the outer IP header takes the default value.Untrusted mode is supported
        /// on overlay-based and VLAN-based logical port.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public QoSDscpMode? Mode { get; set; }
    
    
    }
    
    /// <summary>SSLKeyAndCertificateApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSSLKeyAndCertificateApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of SSLKeyAndCertificate
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBSSLKeyAndCertificate> Results { get; set; }
    
    
    }
    
    /// <summary>Represents the leaf level condition. Evaluation of the condition expression
    /// will be case insensitive.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Condition : Expression
    {
        /// <summary>operator</summary>
        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConditionOperator Operator { get; set; }
    
        /// <summary>Value</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public string Value { get; set; }
    
        /// <summary>Key</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConditionKey Key { get; set; }
    
        /// <summary>Group member type</summary>
        [Newtonsoft.Json.JsonProperty("member_type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConditionMember_type Member_type { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for PolicyFirewallSessionTimerProfileBindingMap,
    /// used in hierarchical API
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyFirewallSessionTimerProfileBindingMap : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyFirewallSessionTimerProfileBindingMap object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyFirewallSessionTimerProfileBindingMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyFirewallSessionTimerProfileBindingMap PolicyFirewallSessionTimerProfileBindingMap { get; set; }
    
    
    }
    
    /// <summary>Information about the realized status of the intent object on an NSX-T type of enforcement point.
    /// Some very recent changes may be excluded when preparing this information, which is indicated by
    /// Pending Changes Info. In addition to the realized status across all scopes, this information holds
    /// details about enforced realized status per scope.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EnforcedStatusInfoNsxT 
    {
        /// <summary>Consolidated Realized Status of an Intent object across all scopes of an NSX-T type of
        /// enforcement point.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enforced_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EnforcedStatusNsxT Enforced_status { get; set; }
    
        /// <summary>List of Enforced Realized Status per Scope.</summary>
        [Newtonsoft.Json.JsonProperty("enforced_status_per_scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<EnforcedStatusPerScopeNsxT> Enforced_status_per_scope { get; set; }
    
    
    }
    
    /// <summary>Past backup operation details</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BackupOperationHistory 
    {
        /// <summary>Statuses of previous inventory backups</summary>
        [Newtonsoft.Json.JsonProperty("inventory_backup_statuses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<BackupOperationStatus> Inventory_backup_statuses { get; set; }
    
        /// <summary>Statuses of previous cluser backups</summary>
        [Newtonsoft.Json.JsonProperty("cluster_backup_statuses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<BackupOperationStatus> Cluster_backup_statuses { get; set; }
    
        /// <summary>Statuses of previous node backups</summary>
        [Newtonsoft.Json.JsonProperty("node_backup_statuses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<BackupOperationStatus> Node_backup_statuses { get; set; }
    
    
    }
    
    /// <summary>ID and status of the VM on Identity Firewall compute collection.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdfwVirtualMachineStatus 
    {
        /// <summary>Status of the Identity Firewall compute collection's Virtual Machine.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vm_status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IdfwVirtualMachineCondition> Vm_status { get; set; } = new System.Collections.ObjectModel.Collection<IdfwVirtualMachineCondition>();
    
        /// <summary>VM ID of the VM on Identity Firewall compute collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vm_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Vm_id { get; set; }
    
    
    }
    
    /// <summary>The reponse to a batch operation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BatchResponse 
    {
        /// <summary>Indicates if any of the APIs failed</summary>
        [Newtonsoft.Json.JsonProperty("has_errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Has_errors { get; set; }
    
        /// <summary>Optional flag indicating that all items were rolled back even if succeeded initially</summary>
        [Newtonsoft.Json.JsonProperty("rolled_back", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Rolled_back { get; set; }
    
        /// <summary>Bulk list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<BatchResponseItem> Results { get; set; } = new System.Collections.ObjectModel.Collection<BatchResponseItem>();
    
    
    }
    
    /// <summary>NetworkSecurityPolicyApiResponse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBNetworkSecurityPolicyApiResponse : ListResult
    {
        /// <summary>count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }
    
        /// <summary>Array of NetworkSecurityPolicy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ALBNetworkSecurityPolicy> Results { get; set; }
    
    
    }
    
    /// <summary>Paged collection of Segment QoS Profile Binding Maps</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SegmentQoSProfileBindingMapListResult : ListResult
    {
        /// <summary>Segment QoS Profile Binding Map list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SegmentQoSProfileBindingMap> Results { get; set; } = new System.Collections.ObjectModel.Collection<SegmentQoSProfileBindingMap>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LogicalRouterPortCounters 
    {
        /// <summary>Number of no ARP packets dropped.</summary>
        [Newtonsoft.Json.JsonProperty("no_arp_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? No_arp_dropped_packets { get; set; }
    
        /// <summary>The total number of packets dropped.</summary>
        [Newtonsoft.Json.JsonProperty("dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dropped_packets { get; set; }
    
        /// <summary>Number of packets dropped due to insufficient memory.</summary>
        [Newtonsoft.Json.JsonProperty("no_mem_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? No_mem_dropped_packets { get; set; }
    
        /// <summary>Number of IPSec policy error packets dropped.</summary>
        [Newtonsoft.Json.JsonProperty("ipsec_pol_err_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Ipsec_pol_err_dropped_packets { get; set; }
    
        /// <summary>Number of packets dropped as no linked ports are present.</summary>
        [Newtonsoft.Json.JsonProperty("no_linked_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? No_linked_dropped_packets { get; set; }
    
        /// <summary>Number of DPDK kernal NIC interface packets dropped.</summary>
        [Newtonsoft.Json.JsonProperty("kni_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Kni_dropped_packets { get; set; }
    
        /// <summary>The total number of packets blocked.</summary>
        [Newtonsoft.Json.JsonProperty("blocked_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Blocked_packets { get; set; }
    
        /// <summary>Number of reverse-path forwarding check packets dropped.</summary>
        [Newtonsoft.Json.JsonProperty("rpf_check_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Rpf_check_dropped_packets { get; set; }
    
        /// <summary>Number of IPSec policy block packets dropped.</summary>
        [Newtonsoft.Json.JsonProperty("ipsec_pol_block_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Ipsec_pol_block_dropped_packets { get; set; }
    
        /// <summary>Number of duplicate address detected packets dropped.</summary>
        [Newtonsoft.Json.JsonProperty("dad_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dad_dropped_packets { get; set; }
    
        /// <summary>Number of packets dropped due to absence of receiver.</summary>
        [Newtonsoft.Json.JsonProperty("no_receiver_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? No_receiver_dropped_packets { get; set; }
    
        /// <summary>Number of packets dropped due to unsupported L4 port.</summary>
        [Newtonsoft.Json.JsonProperty("l4port_unsupported_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? L4port_unsupported_dropped_packets { get; set; }
    
        /// <summary>Number of fragmentation needed packets dropped.</summary>
        [Newtonsoft.Json.JsonProperty("frag_needed_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Frag_needed_dropped_packets { get; set; }
    
        /// <summary>Number of packtes dropped as destination is not supported.</summary>
        [Newtonsoft.Json.JsonProperty("destination_unsupported_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Destination_unsupported_dropped_packets { get; set; }
    
        /// <summary>Number of firewall packets dropped.</summary>
        [Newtonsoft.Json.JsonProperty("firewall_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Firewall_dropped_packets { get; set; }
    
        /// <summary>The number of no route packets dropped</summary>
        [Newtonsoft.Json.JsonProperty("no_route_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? No_route_dropped_packets { get; set; }
    
        /// <summary>Number of packtes dropped as they are malformed.</summary>
        [Newtonsoft.Json.JsonProperty("malformed_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Malformed_dropped_packets { get; set; }
    
        /// <summary>Number of non IP packets dropped.</summary>
        [Newtonsoft.Json.JsonProperty("non_ip_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Non_ip_dropped_packets { get; set; }
    
        /// <summary>Number of IPSec packets dropped</summary>
        [Newtonsoft.Json.JsonProperty("ipsec_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Ipsec_dropped_packets { get; set; }
    
        /// <summary>Number of redirect packets dropped.</summary>
        [Newtonsoft.Json.JsonProperty("redirect_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Redirect_dropped_packets { get; set; }
    
        /// <summary>Number of service insert packets dropped.</summary>
        [Newtonsoft.Json.JsonProperty("service_insert_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Service_insert_dropped_packets { get; set; }
    
        /// <summary>Number of IPSec packets dropped as no VTI is present.</summary>
        [Newtonsoft.Json.JsonProperty("ipsec_no_vti_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Ipsec_no_vti_dropped_packets { get; set; }
    
        /// <summary>The total number of packets transferred.</summary>
        [Newtonsoft.Json.JsonProperty("total_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total_packets { get; set; }
    
        /// <summary>Number of packets dropped as protocol is unsupported.</summary>
        [Newtonsoft.Json.JsonProperty("proto_unsupported_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Proto_unsupported_dropped_packets { get; set; }
    
        /// <summary>Number of time to live exceeded packets dropped.</summary>
        [Newtonsoft.Json.JsonProperty("ttl_exceeded_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Ttl_exceeded_dropped_packets { get; set; }
    
        /// <summary>Number of IPV6 packets dropped.</summary>
        [Newtonsoft.Json.JsonProperty("ipv6_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Ipv6_dropped_packets { get; set; }
    
        /// <summary>Number of IPSec no security association packets dropped.</summary>
        [Newtonsoft.Json.JsonProperty("ipsec_no_sa_dropped_packets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Ipsec_no_sa_dropped_packets { get; set; }
    
        /// <summary>The total number of bytes transferred.</summary>
        [Newtonsoft.Json.JsonProperty("total_bytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total_bytes { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for PolicyLabel, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyLabel : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual PolicyLabel object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyLabel", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyLabel PolicyLabel { get; set; }
    
    
    }
    
    /// <summary>Paged Collection of Security Policy statistics</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SecurityPolicyStatisticsListResult : ListResult
    {
        /// <summary>Security Policy statistics list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SecurityPolicyStatisticsForEnforcementPoint> Results { get; set; } = new System.Collections.ObjectModel.Collection<SecurityPolicyStatisticsForEnforcementPoint>();
    
    
    }
    
    /// <summary>Represents the field value constraint to constrain specified field
    /// value based on defined sanity checks.
    /// Example - For DNS.upstream_servers, all the IP addresses must either be
    /// public or private.
    ///   {
    ///     "target": {
    ///       "target_resource_type": "DnsForwarderZone",
    ///       "attribute": "upstreamServers",
    ///       "path_prefix": "/infra/dns-forwarder-zones/"
    ///      },
    ///      "constraint_expression": {
    ///        "resource_type": "FieldSanityConstraintExpression",
    ///        "operator": "OR",
    ///        "checks": ["ALL_PUBLIC_IPS", "ALL_PRIVATE_IPS"]
    ///      }
    ///   }
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FieldSanityConstraintExpression : ConstraintExpression
    {
        /// <summary>A conditional operator</summary>
        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FieldSanityConstraintExpressionOperator Operator { get; set; }
    
        /// <summary>List of sanity checks.</summary>
        [Newtonsoft.Json.JsonProperty("checks", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Checks> Checks { get; set; } = new System.Collections.ObjectModel.Collection<Checks>();
    
    
    }
    
    /// <summary>Advanced load balancer SamlServiceProviderNode object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBSamlServiceProviderNode 
    {
        /// <summary>Single Signon URL to be programmed on the IDP.</summary>
        [Newtonsoft.Json.JsonProperty("single_signon_url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Single_signon_url { get; set; }
    
        /// <summary>Globally unique entityID for this node.
        /// Entity ID on the IDP should match this.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("entity_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Entity_id { get; set; }
    
        /// <summary>Refers to the Cluster name identifier (Virtual IP or FQDN).</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }
    
        /// <summary>Service Engines will use this SSL certificate to sign
        /// assertions going to the IdP.
        /// It is a reference to an object of type
        /// SSLKeyAndCertificate.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("signing_ssl_key_and_certificate_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Signing_ssl_key_and_certificate_path { get; set; }
    
    
    }
    
    /// <summary>This action is used to control access to backend server resources using
    /// JSON Web Token(JWT) authentication. The JWT authentication is done before
    /// any HTTP manipulation if the HTTP request matches the given condition in
    /// LBRule. Any verification failed, the HTTP process will be terminated, and
    /// HTTP response with 401 status code and WWW-Authentication header will be
    /// returned to client.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBJwtAuthAction : LBRuleAction
    {
        /// <summary>JWT is an open standard that defines a compact and
        /// self-contained way for securely transmitting information between
        /// parties as a JSON object. Load balancer will search for every specified
        /// tokens one by one for the jwt message until found. This parameter is
        /// optional. In case not found or this field is not configured, load
        /// balancer searches the Bearer header by default in the http request
        /// "Authorization: Bearer &amp;lt;token&amp;gt;".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokens", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Tokens { get; set; }
    
        /// <summary>Specify whether to pass the JWT to backend server or remove it. By
        /// default, it is false which means will not pass the JWT to backend
        /// servers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pass_jwt_to_pool", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Pass_jwt_to_pool { get; set; } = false;
    
        /// <summary>A description of the protected area. If no realm is specified, clients
        /// often display a formatted hostname instead. The configured realm is
        /// returned when client request is rejected with 401 http status. In the
        /// response, it will be "WWW-Authentication: Bearer realm=&amp;lt;realm&amp;gt;".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("realm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Realm { get; set; }
    
        /// <summary>LBJwtKey used for verifying the signature of JWT token</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LBJwtKey Key { get; set; }
    
    
    }
    
    /// <summary>List of Directory Domain</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DirectoryDomainListResults : ListResult
    {
        /// <summary>List of Directory Domains</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(500)]
        public System.Collections.Generic.ICollection<DirectoryDomain> Results { get; set; } = new System.Collections.ObjectModel.Collection<DirectoryDomain>();
    
    
    }
    
    /// <summary>Child wrapper for ALBVsVip, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBVsVip : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBVsVip object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBVsVip", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBVsVip ALBVsVip { get; set; }
    
    
    }
    
    /// <summary>OSPF summary address configuration to summarize external routes</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OspfSummaryAddressConfig 
    {
        /// <summary>OSPF Summary address in CIDR format</summary>
        [Newtonsoft.Json.JsonProperty("prefix", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Prefix { get; set; }
    
        /// <summary>Used to filter the advertisement of external routes into the OSPF domain.
        /// Setting this field to "TRUE" will enable the summarization of external routes that are covered by
        /// ip_prefix configuration.
        /// Setting this field to "FALSE" will filter the advertisement of external routes that are covered by
        /// ip_prefix configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("advertise", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Advertise { get; set; } = true;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBVirtualServerStatus : LBVirtualServerStatusPerEP
    {
        /// <summary>UP means that all primary members in default pool are in UP status.
        /// For L7 virtual server, if there is no default pool, the virtual server
        /// would be treated as UP.
        /// PARTIALLY_UP means that some(not all) primary members in default pool
        /// are in UP status. The size of these active primary members should be
        /// larger than or equal to the certain number(min_active_members) which is
        /// defined in LBPool. When there are no backup members which are in the UP
        /// status, the number(min_active_members) would be ignored.
        /// PRIMARY_DOWN means that less than certain(min_active_members) primary
        /// members in default pool are in UP status but backup members are in UP
        /// status, the connections would be dispatched to backup members.
        /// DOWN means that all primary and backup members are in DOWN status.
        /// DETACHED means that the virtual server is not bound to any service.
        /// DISABLED means that the admin state of the virtual server is disabled.
        /// UNKOWN means that no status reported from transport-nodes. The
        /// associated load balancer service may be working(or not working).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LBVirtualServerStatusStatus? Status { get; set; }
    
        /// <summary>Timestamp when the data was last updated.</summary>
        [Newtonsoft.Json.JsonProperty("last_update_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update_timestamp { get; set; }
    
        /// <summary>load balancer virtual server object path.</summary>
        [Newtonsoft.Json.JsonProperty("virtual_server_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Virtual_server_path { get; set; }
    
    
    }
    
    /// <summary>A single request within a batch of operations</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BatchRequestItem 
    {
        [Newtonsoft.Json.JsonProperty("body", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Body { get; set; }
    
        /// <summary>relative uri (path and args), of the call including resource id (if this is a POST/DELETE), exclude hostname and port and prefix, exploded form of parameters</summary>
        [Newtonsoft.Json.JsonProperty("uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Uri { get; set; }
    
        /// <summary>http method type</summary>
        [Newtonsoft.Json.JsonProperty("method", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BatchRequestItemMethod Method { get; set; }
    
    
    }
    
    /// <summary>Policy Sub Attributes data holder</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicySubAttributes 
    {
        /// <summary>Datatype for sub attribute</summary>
        [Newtonsoft.Json.JsonProperty("datatype", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicySubAttributesDatatype Datatype { get; set; }
    
        /// <summary>Multiple sub attribute values can be specified as elements of array.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<string> Value { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Key for sub attribute</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicySubAttributesKey Key { get; set; }
    
    
    }
    
    /// <summary>Paged collection of Port QoS Profile Binding Maps</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PortQoSProfileBindingMapListResult : ListResult
    {
        /// <summary>Port QoS Profile Binding Map list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PortQoSProfileBindingMap> Results { get; set; } = new System.Collections.ObjectModel.Collection<PortQoSProfileBindingMap>();
    
    
    }
    
    /// <summary>Child wrapper object for IPFIXDFWProfile, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIPFIXDFWProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual IPFIXDFWProfile object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IPFIXDFWProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IPFIXDFWProfile IPFIXDFWProfile { get; set; }
    
    
    }
    
    /// <summary>This entity will be used to establish association between monitoring
    /// profile and Port. Using this entity, user can specify intent for applying
    /// monitoring profile to particular Port. Port here is Segment Port.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PortMonitoringProfileBindingMap : MonitoringProfileBindingMap
    {
        /// <summary>PolicyPath of associated IPFIX L2 Profile</summary>
        [Newtonsoft.Json.JsonProperty("ipfix_l2_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ipfix_l2_profile_path { get; set; }
    
        /// <summary>PolicyPath of associated Port Mirroring Profile</summary>
        [Newtonsoft.Json.JsonProperty("port_mirroring_profile_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Port_mirroring_profile_path { get; set; }
    
    
    }
    
    /// <summary>IPSec VPN tunnel traffic statistics.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IpSecVpnTunnelTrafficStatistics 
    {
        /// <summary>Total number of packets dropped while sending for any reason.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_sent_other_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_sent_other_error { get; set; }
    
        /// <summary>Total number of outgoing packets on outbound Security association.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_out { get; set; }
    
        /// <summary>Total number of outgoing packets dropped on outbound security association.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dropped_packets_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dropped_packets_out { get; set; }
    
        /// <summary>Total number of packets dropped due to integrity failures.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("integrity_failures", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Integrity_failures { get; set; }
    
        /// <summary>Number of packets dropped because of no matching policy is available.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nomatching_policy_errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Nomatching_policy_errors { get; set; }
    
        /// <summary>Totoal number of security association mismatch errors on incoming packets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sa_mismatch_errors_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Sa_mismatch_errors_in { get; set; }
    
        /// <summary>Tunnel peer subnet in IPv4 CIDR Block format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("peer_subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Peer_subnet { get; set; }
    
        /// <summary>Total number of packets dropped due to replay check on that Security association.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("replay_errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Replay_errors { get; set; }
    
        /// <summary>Total number of outgoing bytes on outbound Security association.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bytes_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_out { get; set; }
    
        /// <summary>Total number of incoming packets dropped on inbound Security association.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_received_other_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_received_other_error { get; set; }
    
        /// <summary>Total number of incoming packets dropped on inbound security association.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dropped_packets_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dropped_packets_in { get; set; }
    
        /// <summary>Total number of packets dropped because of failure in encryption.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("encryption_failures", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Encryption_failures { get; set; }
    
        /// <summary>Totoal number of security association mismatch errors on outgoing packets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sa_mismatch_errors_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Sa_mismatch_errors_out { get; set; }
    
        /// <summary>Gives the detailed reason about the tunnel when it is down. If tunnel
        /// is UP tunnel down reason will be empty.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tunnel_down_reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tunnel_down_reason { get; set; }
    
        /// <summary>Tunnel local subnet in IPv4 CIDR Block format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("local_subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Local_subnet { get; set; }
    
        /// <summary>Total number of incoming bytes on inbound Security association.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bytes_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bytes_in { get; set; }
    
        /// <summary>Total number of packets dropped due to decryption failures.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("decryption_failures", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Decryption_failures { get; set; }
    
        /// <summary>Total number of packets dropped while sending due to overflow in sequence number.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("seq_number_overflow_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Seq_number_overflow_error { get; set; }
    
        /// <summary>Total number of incoming packets on inbound Security association.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packets_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Packets_in { get; set; }
    
        /// <summary>Specifies the status of tunnel, if it is UP/DOWN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tunnel_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IpSecVpnTunnelTrafficStatisticsTunnel_status? Tunnel_status { get; set; }
    
        /// <summary>Policy UUID of IPSec Tunnel.</summary>
        [Newtonsoft.Json.JsonProperty("policy_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Policy_id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SIPacketsDroppedBySecurity 
    {
        /// <summary>The packets dropped by "Spoof Guard"; supported packet types are IPv4, IPv6, ARP, ND, non-IP.</summary>
        [Newtonsoft.Json.JsonProperty("spoof_guard_dropped", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SIPacketTypeAndCounter> Spoof_guard_dropped { get; set; }
    
        /// <summary>The number of IPv4 packets dropped by "DHCP server block".</summary>
        [Newtonsoft.Json.JsonProperty("dhcp_server_dropped_ipv4", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dhcp_server_dropped_ipv4 { get; set; }
    
        /// <summary>The number of IPv6 packets dropped by "DHCP server block".</summary>
        [Newtonsoft.Json.JsonProperty("dhcp_server_dropped_ipv6", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dhcp_server_dropped_ipv6 { get; set; }
    
        /// <summary>The number of IPv4 packets dropped by "DHCP client block".</summary>
        [Newtonsoft.Json.JsonProperty("dhcp_client_dropped_ipv4", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dhcp_client_dropped_ipv4 { get; set; }
    
        /// <summary>The number of packets dropped by "BPDU filter".</summary>
        [Newtonsoft.Json.JsonProperty("bpdu_filter_dropped", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Bpdu_filter_dropped { get; set; }
    
        /// <summary>The number of IPv6 packets dropped by "DHCP client block".</summary>
        [Newtonsoft.Json.JsonProperty("dhcp_client_dropped_ipv6", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Dhcp_client_dropped_ipv6 { get; set; }
    
    
    }
    
    /// <summary>Collection of Evpn Tunnel Endpoint Configuration.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EvpnTunnelEndpointConfigListResult : ListResult
    {
        /// <summary>Evpn Tunnel Endpoint Configuration list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<EvpnTunnelEndpointConfig> Results { get; set; } = new System.Collections.ObjectModel.Collection<EvpnTunnelEndpointConfig>();
    
    
    }
    
    /// <summary>IPFIX data from source logical segment, port, group will be forwarded to IPFIX
    /// collector.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IPFIXL2Profile : PolicyConfigResource
    {
        /// <summary>This priority field is used to resolve conflicts in Segment
        /// Ports which are covered by more than one IPFIX profiles. The IPFIX
        /// exporter will send records to Collectors in highest priority
        /// profile (lowest number) only.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 32000D)]
        public long? Priority { get; set; } = 0L;
    
        /// <summary>The time in seconds after a flow is expired if
        /// no more packets matching this flow are received by the cache.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("idle_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(60D, 3600D)]
        public long? Idle_timeout { get; set; } = 300L;
    
        /// <summary>Policy path for IPFIX collector profile. User can specify only one IPFIX collector.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipfix_collector_profile_path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Ipfix_collector_profile_path { get; set; }
    
        /// <summary>The maximum number of flow entries in
        /// each exporter flow cache.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_flows", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? Max_flows { get; set; } = 16384L;
    
        /// <summary>An identifier that is unique to the exporting process and used to
        /// meter the flows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("observation_domain_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? Observation_domain_id { get; set; } = 0L;
    
        /// <summary>The time in seconds after a flow is expired even if
        /// more packets matching this flow are received by the cache.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("active_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(60D, 3600D)]
        public long? Active_timeout { get; set; } = 300L;
    
        /// <summary>This property controls whether overlay flow info is included in the
        /// sample result.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("export_overlay_flow", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Export_overlay_flow { get; set; } = true;
    
        /// <summary>The probability in percentage that a packet is sampled,
        /// in range 0-100. The probability is equal for every packet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packet_sample_probability", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 100)]
        public double Packet_sample_probability { get; set; } = 0.1D;
    
    
    }
    
    /// <summary>Fast TCP profile.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBFastTcpProfile : LBAppProfile
    {
        /// <summary>It is used to specify how long a closing TCP connection (both FINs
        /// received or a RST is received) should be kept for this application
        /// before cleaning up the connection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("close_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 60D)]
        public long? Close_timeout { get; set; } = 8L;
    
        /// <summary>It is used to configure how long an idle TCP connection in ESTABLISHED
        /// state should be kept for this application before cleaning up.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("idle_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, 2147483647D)]
        public long? Idle_timeout { get; set; } = 1800L;
    
        /// <summary>If flow mirroring is enabled, all the flows to the bounded virtual
        /// server are mirrored to the standby node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ha_flow_mirroring_enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Ha_flow_mirroring_enabled { get; set; } = false;
    
    
    }
    
    /// <summary>Paged Collection of Policy Firewall Session timeout profiles</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyFirewallSessionTimerProfileListResult : ListResult
    {
        /// <summary>Policy Firewall Session timeout profile list results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PolicyFirewallSessionTimerProfile> Results { get; set; } = new System.Collections.ObjectModel.Collection<PolicyFirewallSessionTimerProfile>();
    
    
    }
    
    /// <summary>IDS RSecurity Policy Statistics.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdsSecurityPolicyStatistics : SecurityPolicyStatistics
    {
    
    }
    
    /// <summary>Tier-0 interface configuration for external connectivity.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BaseTier0Interface : PolicyConfigResource
    {
        /// <summary>Specify IP address and network prefix for interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnets", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.ICollection<InterfaceSubnet> Subnets { get; set; } = new System.Collections.ObjectModel.Collection<InterfaceSubnet>();
    
        /// <summary>Policy path of dhcp-relay-config to be attached to this Interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dhcp_relay_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dhcp_relay_path { get; set; }
    
    
    }
    
    /// <summary>Livetrace action configuration</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PolicyLiveTraceActionConfig 
    {
        /// <summary>Configuration of trace action</summary>
        [Newtonsoft.Json.JsonProperty("trace_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LiveTracePacketGranularActionConfig Trace_config { get; set; }
    
        /// <summary>Configuration of packet capture action</summary>
        [Newtonsoft.Json.JsonProperty("pktcap_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LiveTracePacketGranularActionConfig Pktcap_config { get; set; }
    
        /// <summary>Configuration of count action</summary>
        [Newtonsoft.Json.JsonProperty("count_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CountActionConfig Count_config { get; set; }
    
    
    }
    
    /// <summary>Child wrapper for ALBPKIProfile, used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildALBPKIProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual ALBPKIProfile object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ALBPKIProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ALBPKIProfile ALBPKIProfile { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for IPSecVpnService, used in hierarchical API.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildIPSecVpnService : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual IPSecVpnService object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("IPSecVpnService", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IPSecVpnService IPSecVpnService { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OspfDatabaseListResultInCsvFormat : CsvListResult
    {
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OspfDabtabaseCsvRecord> Results { get; set; }
    
    
    }
    
    /// <summary>A shaper that specifies ingress rate properties in Mb/s</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IngressRateLimiter : QoSBaseRateLimiter
    {
        /// <summary>The peak bandwidth rate is used to support burst traffic.</summary>
        [Newtonsoft.Json.JsonProperty("peak_bandwidth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, int.MaxValue)]
        public long? Peak_bandwidth { get; set; } = 0L;
    
        /// <summary>You can use the average bandwidth to reduce network congestion.</summary>
        [Newtonsoft.Json.JsonProperty("average_bandwidth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, int.MaxValue)]
        public long? Average_bandwidth { get; set; } = 0L;
    
        /// <summary>The burst duration is set in the burst size setting.</summary>
        [Newtonsoft.Json.JsonProperty("burst_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, int.MaxValue)]
        public long? Burst_size { get; set; } = 0L;
    
    
    }
    
    /// <summary>Identity (Directory) group</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class IdentityGroupInfo 
    {
        /// <summary>Each LDAP object is uniquely identified by its distinguished name (DN).
        /// A DN is a sequence of relative distinguished names (RDN) connected by commas.
        /// e.g. CN=Larry Cole,CN=admin,DC=corp,DC=acme,DC=com.
        /// A valid fully qualified distinguished name should be provided to include specific groups else
        /// the create / update realization of the Group containing an invalid/ partial DN will fail.
        /// This value is valid only if it matches to exactly 1 LDAP object on the LDAP server.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("distinguished_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Distinguished_name { get; set; }
    
        /// <summary>This is the base distinguished name for the domain where this particular group
        /// resides. (e.g. dc=example,dc=com)
        /// Each active directory domain has a domain naming context
        /// (NC), which contains domain-specific data. The root of
        /// this naming context is represented by a domain's
        /// distinguished name (DN) and is typically referred to as
        /// the NC head.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("domain_base_distinguished_name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Domain_base_distinguished_name { get; set; }
    
        /// <summary>A security identifier (SID) is a unique value of variable length
        /// used to identify a trustee. A SID consists of the following components:
        /// The revision level of the SID structure;
        /// A 48-bit identifier authority value that identifies the
        /// authority that issued the SID;
        /// A variable number of subauthority or relative identifier
        /// (RID) values that uniquely identify the trustee relative
        /// to the authority that issued the SID.
        /// This field is only populated for Microsoft Active Directory identity store.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sid { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for PolicyPimProfile used in hierarchical API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildPolicyPimProfile : ChildPolicyConfigResource
    {
        /// <summary>Contains actual PolicyPimProfile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("PolicyPimProfile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PolicyPimProfile PolicyPimProfile { get; set; }
    
    
    }
    
    /// <summary>A profile holding general security settings.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "resource_type")]
    [JsonInheritanceAttribute("GatewayGeneralSecurityProfile", typeof(GatewayGeneralSecurityProfile))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GeneralSecurityProfile : PolicyConfigResource
    {
    
    }
    
    /// <summary>This condition is used to match IP header fields of HTTP messages.
    /// Either source_address or group_id should be specified.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LBIpHeaderCondition : LBRuleCondition
    {
        /// <summary>Source IP address of HTTP message should match IP addresses which are
        /// configured in Group in order to perform actions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("group_path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group_path { get; set; }
    
        /// <summary>Source IP address of HTTP message. IP Address can be expressed as a
        /// single IP address like 10.1.1.1, or a range of IP addresses like
        /// 10.1.1.101-10.1.1.160. Both IPv4 and IPv6 addresses are supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source_address { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DhcpServerState : ConfigurationState
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ActionableResourceListResult : ListResult
    {
        /// <summary>List results</summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ActionableResource> Results { get; set; } = new System.Collections.ObjectModel.Collection<ActionableResource>();
    
    
    }
    
    /// <summary>Base type for CSV result.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CsvListResult 
    {
        /// <summary>File name set by HTTP server if API  returns CSV result as a file.</summary>
        [Newtonsoft.Json.JsonProperty("file_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string File_name { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer MicroServiceMatch object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBMicroServiceMatch 
    {
        /// <summary>Criterion to use for Micro Service matching the HTTP
        /// request.
        /// Enum options - IS_IN, IS_NOT_IN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("match_criteria", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ALBMicroServiceMatchMatch_criteria Match_criteria { get; set; }
    
    
    }
    
    /// <summary>Stores the information about cloud native service instance.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CloudNativeServiceInstance : DiscoveredResource
    {
        /// <summary>Type of cloud native service.</summary>
        [Newtonsoft.Json.JsonProperty("service_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Service_type { get; set; }
    
        /// <summary>Reference of the public cloud gateway that reported the service instance.</summary>
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceReference Source { get; set; }
    
        /// <summary>Id of service instance fetched from public cloud.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("external_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string External_id { get; set; }
    
    
    }
    
    /// <summary>Advanced load balancer ConnPoolProperties object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ALBConnPoolProperties 
    {
        /// <summary>Connection life timeout.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 600000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("upstream_connpool_conn_life_tmo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Upstream_connpool_conn_life_tmo { get; set; } = 600000L;
    
        /// <summary>Maximum number of connections a server can cache.
        /// Special values are 0- 'unlimited'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("upstream_connpool_server_max_cache", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Upstream_connpool_server_max_cache { get; set; } = 0L;
    
        /// <summary>Maximum number of times a connection can be reused.
        /// Special values are 0- 'unlimited'.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("upstream_connpool_conn_max_reuse", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Upstream_connpool_conn_max_reuse { get; set; } = 0L;
    
        /// <summary>Connection idle timeout.
        /// Default value when not specified in API or module is
        /// interpreted by ALB Controller as 60000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("upstream_connpool_conn_idle_tmo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Upstream_connpool_conn_idle_tmo { get; set; } = 60000L;
    
    
    }
    
    /// <summary>Site represents an NSX deployment having its own set of NSX clusters and
    /// transport nodes. It may correspond to a Data Center, VMC deployment, or
    /// NSX-Cloud deployment managed via CSM.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Site : PolicyConfigResource
    {
        /// <summary>System managed federation config.</summary>
        [Newtonsoft.Json.JsonProperty("federation_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GmFederationSiteConfig Federation_config { get; set; }
    
        /// <summary>Fail onboarding if maximum RTT exceeded.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fail_if_rtt_exceeded", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Fail_if_rtt_exceeded { get; set; } = true;
    
        /// <summary>12-bit system generated site number</summary>
        [Newtonsoft.Json.JsonProperty("site_number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Site_number { get; set; }
    
        /// <summary>If provided and fail_if_rtt_exceeded is true, onboarding of the site will
        /// fail if measured RTT is greater than this value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maximum_rtt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 1000D)]
        public long? Maximum_rtt { get; set; } = 250L;
    
        /// <summary>Both the local site and the remote site must have edge clusters correctly
        /// configured and remote tunnel endpoint (RTEP) interfaces must be defined,
        /// or onboarding will fail.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fail_if_rtep_misconfigured", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Fail_if_rtep_misconfigured { get; set; } = true;
    
        /// <summary>To onboard a site, the connection information (username, password,
        /// and API thumbprint) for at least one NSX manager node in the remote
        /// site must be provided. Once the site has been successfully onboarded,
        /// the site_connection_info is discarded and authentication to the
        /// remote site occurs using an X.509 client certificate.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("site_connection_info", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(3)]
        public System.Collections.Generic.ICollection<SiteNodeConnectionInfo> Site_connection_info { get; set; }
    
    
    }
    
    /// <summary>QoS profile contains configuration of rate limiting properties which can be
    /// applied in ingress and egress directions at Tier1 gateways
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GatewayQosProfile : PolicyConfigResource
    {
        /// <summary>Burst size in bytes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("burst_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, int.MaxValue)]
        public long? Burst_size { get; set; } = 1L;
    
        /// <summary>Action on traffic exceeding bandwidth.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("excess_action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public GatewayQosProfileExcess_action? Excess_action { get; set; }
    
        /// <summary>Committed bandwidth in both directions specified in Mbps.
        /// Bandwidth is limited to line rate when the value configured is greater
        /// than line rate.
        /// This property is deprecated, use committed_bandwidth instead.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("committed_bandwitdth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, int.MaxValue)]
        public long? Committed_bandwitdth { get; set; } = 1L;
    
        /// <summary>Committed bandwidth in both directions specified in Mbps.
        /// Bandwidth is limited to line rate when the value configured is greater
        /// than line rate.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("committed_bandwidth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1D, int.MaxValue)]
        public long? Committed_bandwidth { get; set; } = 1L;
    
    
    }
    
    /// <summary>Child wrapper object for FqdnAnalysisConfig, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildFqdnAnalysisConfig : ChildPolicyConfigResource
    {
        /// <summary>Contains the actual FqdnAnalysisConfig object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("FqdnAnalysisConfig", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public FqdnAnalysisConfig FqdnAnalysisConfig { get; set; }
    
    
    }
    
    /// <summary>Child wrapper object for SecurityZoneBinding, used in hierarchical API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildSecurityZoneBinding : ChildPolicyConfigResource
    {
        /// <summary>Security zone binding for a tier.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("SecurityZoneBinding", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SecurityZoneBinding SecurityZoneBinding { get; set; }
    
    
    }
    
    /// <summary>Schedule to specify day of the week and time to take automated backup</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class WeeklyBackupSchedule : BackupSchedule
    {
        /// <summary>Days of week when backup is taken. 0 - Sunday, 1 - Monday, 2 - Tuesday, 3 - Wednesday ...</summary>
        [Newtonsoft.Json.JsonProperty("days_of_week", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(7)]
        public System.Collections.Generic.ICollection<long> Days_of_week { get; set; } = new System.Collections.ObjectModel.Collection<long>();
    
        /// <summary>Time of day when backup is taken</summary>
        [Newtonsoft.Json.JsonProperty("minute_of_day", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0D, 59D)]
        public long Minute_of_day { get; set; }
    
        /// <summary>Time of day when backup is taken</summary>
        [Newtonsoft.Json.JsonProperty("hour_of_day", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0D, 23D)]
        public long Hour_of_day { get; set; }
    
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Aggregation statistic category</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Category
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IDPSDFW")]
        IDPSDFW = 0,
    
    }
    
    /// <summary>Type of certificate to return</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"cluster_api_certificate")]
        Cluster_api_certificate = 0,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source4
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source5
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source6
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>LDAP server test requested</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTIVITY")]
        CONNECTIVITY = 0,
    
    }
    
    /// <summary>Operation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Operation
    {
        [System.Runtime.Serialization.EnumMember(Value = @"insert_top")]
        Insert_top = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_bottom")]
        Insert_bottom = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_after")]
        Insert_after = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_before")]
        Insert_before = 3,
    
    }
    
    /// <summary>Type of certificate to return</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Type2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"cluster_api_certificate")]
        Cluster_api_certificate = 0,
    
    }
    
    /// <summary>Operation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Operation2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"insert_top")]
        Insert_top = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_bottom")]
        Insert_bottom = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_after")]
        Insert_after = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_before")]
        Insert_before = 3,
    
    }
    
    /// <summary>Aggregation statistic category</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Category2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IDPSDFW")]
        IDPSDFW = 0,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source7
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source8
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source9
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Action on statistics</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"reset")]
        Reset = 0,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source10
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source11
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source12
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source13
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>An action to be performed for DNS forwarder on EP</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action4
    {
        [System.Runtime.Serialization.EnumMember(Value = @"clear_cache")]
        Clear_cache = 0,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source14
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source15
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source16
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Filter routes based on the source from which route is learned</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Route_source
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BGP")]
        BGP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STATIC")]
        STATIC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTED")]
        CONNECTED = 2,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source17
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source18
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source19
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Source of the attribute, System Defined or custom</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Attribute_source
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALL")]
        ALL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CUSTOM")]
        CUSTOM = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SYSTEM")]
        SYSTEM = 2,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source20
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Frame type</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Frame_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GLOBAL_MANAGER")]
        GLOBAL_MANAGER = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOCAL_MANAGER")]
        LOCAL_MANAGER = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOCAL_LOCAL_MANAGER")]
        LOCAL_LOCAL_MANAGER = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NSX_INTELLIGENCE")]
        NSX_INTELLIGENCE = 3,
    
    }
    
    /// <summary>Operation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Operation3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"insert_top")]
        Insert_top = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_bottom")]
        Insert_bottom = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_after")]
        Insert_after = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_before")]
        Insert_before = 3,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source21
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source22
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>LDAP server test requested</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action5
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTIVITY")]
        CONNECTIVITY = 0,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source23
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Source from which tags are synced.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source24
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Amazon")]
        Amazon = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Azure")]
        Azure = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NSX")]
        NSX = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ANY")]
        ANY = 3,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source25
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Add or Remove Custom Context Profile Attribute values.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action6
    {
        [System.Runtime.Serialization.EnumMember(Value = @"add")]
        Add = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"remove")]
        Remove = 1,
    
    }
    
    /// <summary>Filter routes based on the source from which route is learned</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Route_source2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BGP")]
        BGP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STATIC")]
        STATIC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTED")]
        CONNECTED = 2,
    
    }
    
    /// <summary>Add or Remove group members.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action7
    {
        [System.Runtime.Serialization.EnumMember(Value = @"add")]
        Add = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"remove")]
        Remove = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source26
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Add or Remove group members.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action8
    {
        [System.Runtime.Serialization.EnumMember(Value = @"add")]
        Add = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"remove")]
        Remove = 1,
    
    }
    
    /// <summary>Filter routes based on the source from which route is learned</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Route_source3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BGP")]
        BGP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STATIC")]
        STATIC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTED")]
        CONNECTED = 2,
    
    }
    
    /// <summary>Operation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Operation4
    {
        [System.Runtime.Serialization.EnumMember(Value = @"insert_top")]
        Insert_top = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_bottom")]
        Insert_bottom = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_after")]
        Insert_after = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_before")]
        Insert_before = 3,
    
    }
    
    /// <summary>Frame type</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Frame_type2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GLOBAL_MANAGER")]
        GLOBAL_MANAGER = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOCAL_MANAGER")]
        LOCAL_MANAGER = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOCAL_LOCAL_MANAGER")]
        LOCAL_LOCAL_MANAGER = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NSX_INTELLIGENCE")]
        NSX_INTELLIGENCE = 3,
    
    }
    
    /// <summary>Aggregation statistic category</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Category3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DFW")]
        DFW = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE")]
        EDGE = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source27
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Filter routes based on the source from which route is learned</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Route_source4
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BGP")]
        BGP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STATIC")]
        STATIC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTED")]
        CONNECTED = 2,
    
    }
    
    /// <summary>Type of certificate to return</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Type3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"cluster_api_certificate")]
        Cluster_api_certificate = 0,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source28
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Filter routes based on the source from which route is learned</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Route_source5
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BGP")]
        BGP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STATIC")]
        STATIC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTED")]
        CONNECTED = 2,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source29
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Type of certificate to return</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Type4
    {
        [System.Runtime.Serialization.EnumMember(Value = @"cluster_api_certificate")]
        Cluster_api_certificate = 0,
    
    }
    
    /// <summary>Operation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Operation5
    {
        [System.Runtime.Serialization.EnumMember(Value = @"insert_top")]
        Insert_top = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_bottom")]
        Insert_bottom = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_after")]
        Insert_after = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_before")]
        Insert_before = 3,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source30
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Add or Remove group members.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action9
    {
        [System.Runtime.Serialization.EnumMember(Value = @"add")]
        Add = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"remove")]
        Remove = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source31
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Configuration state of the segment on enforcement point</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Configuration_state
    {
        [System.Runtime.Serialization.EnumMember(Value = @"pending")]
        Pending = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"in_progress")]
        In_progress = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"success")]
        Success = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"failed")]
        Failed = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"partial_success")]
        Partial_success = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"orphaned")]
        Orphaned = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"unknown")]
        Unknown = 6,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source32
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Configuration state of the segment on enforcement point</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Configuration_state2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"pending")]
        Pending = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"in_progress")]
        In_progress = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"success")]
        Success = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"failed")]
        Failed = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"partial_success")]
        Partial_success = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"orphaned")]
        Orphaned = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"unknown")]
        Unknown = 6,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source33
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Operation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Operation6
    {
        [System.Runtime.Serialization.EnumMember(Value = @"insert_top")]
        Insert_top = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_bottom")]
        Insert_bottom = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_after")]
        Insert_after = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_before")]
        Insert_before = 3,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source34
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source35
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Frame type</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Frame_type3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GLOBAL_MANAGER")]
        GLOBAL_MANAGER = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOCAL_MANAGER")]
        LOCAL_MANAGER = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOCAL_LOCAL_MANAGER")]
        LOCAL_LOCAL_MANAGER = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NSX_INTELLIGENCE")]
        NSX_INTELLIGENCE = 3,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source36
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Operation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Operation7
    {
        [System.Runtime.Serialization.EnumMember(Value = @"insert_top")]
        Insert_top = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_bottom")]
        Insert_bottom = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_after")]
        Insert_after = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_before")]
        Insert_before = 3,
    
    }
    
    /// <summary>Operation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Operation8
    {
        [System.Runtime.Serialization.EnumMember(Value = @"insert_top")]
        Insert_top = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_bottom")]
        Insert_bottom = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_after")]
        Insert_after = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_before")]
        Insert_before = 3,
    
    }
    
    /// <summary>Filter routes based on the source from which route is learned</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Route_source6
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BGP")]
        BGP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STATIC")]
        STATIC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTED")]
        CONNECTED = 2,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source37
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Action on statistics</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action10
    {
        [System.Runtime.Serialization.EnumMember(Value = @"reset")]
        Reset = 0,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source38
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Operation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Operation9
    {
        [System.Runtime.Serialization.EnumMember(Value = @"insert_top")]
        Insert_top = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_bottom")]
        Insert_bottom = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_after")]
        Insert_after = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_before")]
        Insert_before = 3,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source39
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Filter routes based on the source from which route is learned</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Route_source7
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BGP")]
        BGP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STATIC")]
        STATIC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTED")]
        CONNECTED = 2,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source40
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Add or Remove group members.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action11
    {
        [System.Runtime.Serialization.EnumMember(Value = @"add")]
        Add = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"remove")]
        Remove = 1,
    
    }
    
    /// <summary>Identity source type</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Identity_source_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"VIDM")]
        VIDM = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LDAP")]
        LDAP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OIDC")]
        OIDC = 2,
    
    }
    
    /// <summary>Type</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Type5
    {
        [System.Runtime.Serialization.EnumMember(Value = @"remote_user")]
        Remote_user = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"remote_group")]
        Remote_group = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"local_user")]
        Local_user = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"principal_identity")]
        Principal_identity = 3,
    
    }
    
    /// <summary>Filter routes based on the source from which route is learned</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Route_source8
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BGP")]
        BGP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STATIC")]
        STATIC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTED")]
        CONNECTED = 2,
    
    }
    
    /// <summary>Source of the attribute, System Defined or custom</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Attribute_source2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALL")]
        ALL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CUSTOM")]
        CUSTOM = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SYSTEM")]
        SYSTEM = 2,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source41
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source42
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Resource type of L3Vpn Session</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum L3vpn_session
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PolicyBasedL3VpnSession")]
        PolicyBasedL3VpnSession = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RouteBasedL3VpnSession")]
        RouteBasedL3VpnSession = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source43
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source44
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source45
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source46
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Sync type requested</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action12
    {
        [System.Runtime.Serialization.EnumMember(Value = @"FULL_SYNC")]
        FULL_SYNC = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DELTA_SYNC")]
        DELTA_SYNC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STOP_SYNC")]
        STOP_SYNC = 2,
    
    }
    
    /// <summary>An action to be performed for DNS forwarder on EP</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action13
    {
        [System.Runtime.Serialization.EnumMember(Value = @"clear_cache")]
        Clear_cache = 0,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source47
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source48
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Filter routes based on the source from which route is learned</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Route_source9
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BGP")]
        BGP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STATIC")]
        STATIC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTED")]
        CONNECTED = 2,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source49
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source50
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Filter routes based on the source from which route is learned</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Route_source10
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BGP")]
        BGP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STATIC")]
        STATIC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTED")]
        CONNECTED = 2,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source51
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source52
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Add or Remove group members.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action14
    {
        [System.Runtime.Serialization.EnumMember(Value = @"add")]
        Add = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"remove")]
        Remove = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source53
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source54
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Add or Remove group members.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action15
    {
        [System.Runtime.Serialization.EnumMember(Value = @"add")]
        Add = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"remove")]
        Remove = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source55
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source56
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source57
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source58
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source59
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Resource type of L3Vpn Session</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum L3vpn_session2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PolicyBasedL3VpnSession")]
        PolicyBasedL3VpnSession = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RouteBasedL3VpnSession")]
        RouteBasedL3VpnSession = 1,
    
    }
    
    /// <summary>Source from which tags are synced.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source60
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Amazon")]
        Amazon = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Azure")]
        Azure = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NSX")]
        NSX = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ANY")]
        ANY = 3,
    
    }
    
    /// <summary>Operation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Operation10
    {
        [System.Runtime.Serialization.EnumMember(Value = @"insert_top")]
        Insert_top = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_bottom")]
        Insert_bottom = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_after")]
        Insert_after = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_before")]
        Insert_before = 3,
    
    }
    
    /// <summary>Operation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Operation11
    {
        [System.Runtime.Serialization.EnumMember(Value = @"insert_top")]
        Insert_top = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_bottom")]
        Insert_bottom = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_after")]
        Insert_after = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_before")]
        Insert_before = 3,
    
    }
    
    /// <summary>Operation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Operation12
    {
        [System.Runtime.Serialization.EnumMember(Value = @"insert_top")]
        Insert_top = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_bottom")]
        Insert_bottom = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_after")]
        Insert_after = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_before")]
        Insert_before = 3,
    
    }
    
    /// <summary>Action on statistics</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action16
    {
        [System.Runtime.Serialization.EnumMember(Value = @"reset")]
        Reset = 0,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source61
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Sync type requested</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action17
    {
        [System.Runtime.Serialization.EnumMember(Value = @"FULL_SYNC")]
        FULL_SYNC = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DELTA_SYNC")]
        DELTA_SYNC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STOP_SYNC")]
        STOP_SYNC = 2,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source62
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Operation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Operation13
    {
        [System.Runtime.Serialization.EnumMember(Value = @"insert_top")]
        Insert_top = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_bottom")]
        Insert_bottom = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_after")]
        Insert_after = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_before")]
        Insert_before = 3,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source63
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source64
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source65
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source66
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Filter routes based on the source from which route is learned</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Route_source11
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BGP")]
        BGP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STATIC")]
        STATIC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTED")]
        CONNECTED = 2,
    
    }
    
    /// <summary>Configuration state of the segment on enforcement point</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Configuration_state3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"pending")]
        Pending = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"in_progress")]
        In_progress = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"success")]
        Success = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"failed")]
        Failed = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"partial_success")]
        Partial_success = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"orphaned")]
        Orphaned = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"unknown")]
        Unknown = 6,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source67
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source68
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Configuration state of the segment on enforcement point</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Configuration_state4
    {
        [System.Runtime.Serialization.EnumMember(Value = @"pending")]
        Pending = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"in_progress")]
        In_progress = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"success")]
        Success = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"failed")]
        Failed = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"partial_success")]
        Partial_success = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"orphaned")]
        Orphaned = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"unknown")]
        Unknown = 6,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source69
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source70
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source71
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source72
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source73
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Operation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Operation14
    {
        [System.Runtime.Serialization.EnumMember(Value = @"insert_top")]
        Insert_top = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_bottom")]
        Insert_bottom = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_after")]
        Insert_after = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_before")]
        Insert_before = 3,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source74
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Add or Remove group members.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action18
    {
        [System.Runtime.Serialization.EnumMember(Value = @"add")]
        Add = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"remove")]
        Remove = 1,
    
    }
    
    /// <summary>Operation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Operation15
    {
        [System.Runtime.Serialization.EnumMember(Value = @"insert_top")]
        Insert_top = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_bottom")]
        Insert_bottom = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_after")]
        Insert_after = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_before")]
        Insert_before = 3,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source75
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source76
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source77
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source78
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source79
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source80
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>An action to be performed for DNS forwarder on EP</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action19
    {
        [System.Runtime.Serialization.EnumMember(Value = @"clear_cache")]
        Clear_cache = 0,
    
    }
    
    /// <summary>An action to be performed for DNS forwarder on EP</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action20
    {
        [System.Runtime.Serialization.EnumMember(Value = @"clear_cache")]
        Clear_cache = 0,
    
    }
    
    /// <summary>Operation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Operation16
    {
        [System.Runtime.Serialization.EnumMember(Value = @"insert_top")]
        Insert_top = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_bottom")]
        Insert_bottom = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_after")]
        Insert_after = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_before")]
        Insert_before = 3,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source81
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>LDAP server test requested</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action21
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTIVITY")]
        CONNECTIVITY = 0,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source82
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source83
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source84
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Action on statistics</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action22
    {
        [System.Runtime.Serialization.EnumMember(Value = @"reset")]
        Reset = 0,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source85
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>LDAP server test requested</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action23
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTIVITY")]
        CONNECTIVITY = 0,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source86
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Add or Remove group members.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action24
    {
        [System.Runtime.Serialization.EnumMember(Value = @"add")]
        Add = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"remove")]
        Remove = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source87
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Filter routes based on the source from which route is learned</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Route_source12
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BGP")]
        BGP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STATIC")]
        STATIC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTED")]
        CONNECTED = 2,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source88
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source89
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source90
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Aggregation statistic category</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Category4
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DFW")]
        DFW = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE")]
        EDGE = 1,
    
    }
    
    /// <summary>Data source type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Source91
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    /// <summary>Add or Remove Custom Context Profile Attribute values.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action25
    {
        [System.Runtime.Serialization.EnumMember(Value = @"add")]
        Add = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"remove")]
        Remove = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyBgpNeighborStatusConnection_state
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INVALID")]
        INVALID = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IDLE")]
        IDLE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECT")]
        CONNECT = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACTIVE")]
        ACTIVE = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OPEN_SENT")]
        OPEN_SENT = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OPEN_CONFIRM")]
        OPEN_CONFIRM = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ESTABLISHED")]
        ESTABLISHED = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyBgpNeighborStatusType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INTER_SR")]
        INTER_SR = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"USER")]
        USER = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBWafPolicyPSMGroupMiss_action
    {
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_ACTION_NO_OP")]
        WAF_ACTION_NO_OP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_ACTION_BLOCK")]
        WAF_ACTION_BLOCK = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_ACTION_ALLOW_PARAMETER")]
        WAF_ACTION_ALLOW_PARAMETER = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBWafPolicyPSMGroupHit_action
    {
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_ACTION_NO_OP")]
        WAF_ACTION_NO_OP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_ACTION_BLOCK")]
        WAF_ACTION_BLOCK = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_ACTION_ALLOW_PARAMETER")]
        WAF_ACTION_ALLOW_PARAMETER = 2,
    
    }
    
    /// <summary>Type of Services available for applications defined under VHC.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Capabilities
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LoadBalancer")]
        LoadBalancer = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBPoolAlgorithm
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ROUND_ROBIN")]
        ROUND_ROBIN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WEIGHTED_ROUND_ROBIN")]
        WEIGHTED_ROUND_ROBIN = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LEAST_CONNECTION")]
        LEAST_CONNECTION = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WEIGHTED_LEAST_CONNECTION")]
        WEIGHTED_LEAST_CONNECTION = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IP_HASH")]
        IP_HASH = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum BaseRuleDirection
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IN")]
        IN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OUT")]
        OUT = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IN_OUT")]
        IN_OUT = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum BaseRuleIp_protocol
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IPV4")]
        IPV4 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IPV6")]
        IPV6 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IPV4_IPV6")]
        IPV4_IPV6 = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum VidmInfoType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"remote_user")]
        Remote_user = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"remote_group")]
        Remote_group = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBPoolLb_algorithm
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LB_ALGORITHM_LEAST_CONNECTIONS")]
        LB_ALGORITHM_LEAST_CONNECTIONS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LB_ALGORITHM_ROUND_ROBIN")]
        LB_ALGORITHM_ROUND_ROBIN = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LB_ALGORITHM_FASTEST_RESPONSE")]
        LB_ALGORITHM_FASTEST_RESPONSE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LB_ALGORITHM_CONSISTENT_HASH")]
        LB_ALGORITHM_CONSISTENT_HASH = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LB_ALGORITHM_LEAST_LOAD")]
        LB_ALGORITHM_LEAST_LOAD = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LB_ALGORITHM_FEWEST_SERVERS")]
        LB_ALGORITHM_FEWEST_SERVERS = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LB_ALGORITHM_RANDOM")]
        LB_ALGORITHM_RANDOM = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LB_ALGORITHM_FEWEST_TASKS")]
        LB_ALGORITHM_FEWEST_TASKS = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LB_ALGORITHM_NEAREST_SERVER")]
        LB_ALGORITHM_NEAREST_SERVER = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LB_ALGORITHM_CORE_AFFINITY")]
        LB_ALGORITHM_CORE_AFFINITY = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LB_ALGORITHM_TOPOLOGY")]
        LB_ALGORITHM_TOPOLOGY = 10,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBPoolLb_algorithm_hash
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LB_ALGORITHM_CONSISTENT_HASH_SOURCE_IP_ADDRESS")]
        LB_ALGORITHM_CONSISTENT_HASH_SOURCE_IP_ADDRESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LB_ALGORITHM_CONSISTENT_HASH_SOURCE_IP_ADDRESS_AND_PORT")]
        LB_ALGORITHM_CONSISTENT_HASH_SOURCE_IP_ADDRESS_AND_PORT = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LB_ALGORITHM_CONSISTENT_HASH_URI")]
        LB_ALGORITHM_CONSISTENT_HASH_URI = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LB_ALGORITHM_CONSISTENT_HASH_CUSTOM_HEADER")]
        LB_ALGORITHM_CONSISTENT_HASH_CUSTOM_HEADER = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LB_ALGORITHM_CONSISTENT_HASH_CUSTOM_STRING")]
        LB_ALGORITHM_CONSISTENT_HASH_CUSTOM_STRING = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LB_ALGORITHM_CONSISTENT_HASH_CALLID")]
        LB_ALGORITHM_CONSISTENT_HASH_CALLID = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ContainerIngressPolicyNetwork_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HEALTHY")]
        HEALTHY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNHEALTHY")]
        UNHEALTHY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TraceflowObservationReplicationLogicalReplication_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TX_VTEP")]
        TX_VTEP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TX_MTEP")]
        TX_MTEP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RX")]
        RX = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBServerSslProfileBindingServer_auth
    {
        [System.Runtime.Serialization.EnumMember(Value = @"REQUIRED")]
        REQUIRED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IGNORE")]
        IGNORE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTO_APPLY")]
        AUTO_APPLY = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum DirectoryDomainSyncStatsPrev_sync_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESS")]
        SUCCESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILURE")]
        FAILURE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum DirectoryDomainSyncStatsPrev_sync_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IDLE")]
        IDLE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FULL_SYNC")]
        FULL_SYNC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DELTA_SYNC")]
        DELTA_SYNC = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SELECTIVE_FULL_SYNC")]
        SELECTIVE_FULL_SYNC = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SELECTIVE_DELTA_SYNC")]
        SELECTIVE_DELTA_SYNC = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum DirectoryDomainSyncStatsCurrent_state
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IDLE")]
        IDLE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FULL_SYNC")]
        FULL_SYNC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DELTA_SYNC")]
        DELTA_SYNC = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SELECTIVE_FULL_SYNC")]
        SELECTIVE_FULL_SYNC = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SELECTIVE_DELTA_SYNC")]
        SELECTIVE_DELTA_SYNC = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ConsolidatedStatusConsolidated_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESS")]
        SUCCESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IN_PROGRESS")]
        IN_PROGRESS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNINITIALIZED")]
        UNINITIALIZED = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum GroupState
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IN_PROGRESS")]
        IN_PROGRESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESS")]
        SUCCESS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILURE")]
        FAILURE = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBAccessListControlAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALLOW")]
        ALLOW = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DROP")]
        DROP = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBSSLRatingPerformance_rating
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_SCORE_NOT_SECURE")]
        SSL_SCORE_NOT_SECURE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_SCORE_VERY_BAD")]
        SSL_SCORE_VERY_BAD = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_SCORE_BAD")]
        SSL_SCORE_BAD = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_SCORE_AVERAGE")]
        SSL_SCORE_AVERAGE = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_SCORE_GOOD")]
        SSL_SCORE_GOOD = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_SCORE_EXCELLENT")]
        SSL_SCORE_EXCELLENT = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBSSLRatingCompatibility_rating
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_SCORE_NOT_SECURE")]
        SSL_SCORE_NOT_SECURE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_SCORE_VERY_BAD")]
        SSL_SCORE_VERY_BAD = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_SCORE_BAD")]
        SSL_SCORE_BAD = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_SCORE_AVERAGE")]
        SSL_SCORE_AVERAGE = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_SCORE_GOOD")]
        SSL_SCORE_GOOD = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_SCORE_EXCELLENT")]
        SSL_SCORE_EXCELLENT = 5,
    
    }
    
    /// <summary>The IPSecDigestAlgorithms are used to verify message
    /// integrity during IPSec VPN tunnel establishment.
    /// SHA1 produces 160 bits hash and SHA2_XXX produces
    /// XXX bit hash.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Digest_algorithms
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SHA1")]
        SHA1 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SHA2_256")]
        SHA2_256 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SHA2_384")]
        SHA2_384 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SHA2_512")]
        SHA2_512 = 3,
    
    }
    
    /// <summary>IPSecEncryptionAlgorithms are used to ensure confidentiality
    /// of the messages exchanged during Tunnel negotiations. AES
    /// stands for Advanced Encryption Standards. AES_128 uses 128-bit
    /// keys whereas AES_256 uses 256-bit keys for encryption and
    /// decryption. AES_GCM stands for Advanced Encryption Standard(AES)
    /// in Galois/Counter Mode (GCM) and is used to provide both
    /// confidentiality and data origin authentication.
    /// NO_ENCRYPTION_AUTH_AES_GMAC_* enables authentication on input
    /// data without encyption. Digest algorithm should be empty for this
    /// option.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Encryption_algorithms
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AES_128")]
        AES_128 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AES_256")]
        AES_256 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AES_GCM_128")]
        AES_GCM_128 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AES_GCM_192")]
        AES_GCM_192 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AES_GCM_256")]
        AES_GCM_256 = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_ENCRYPTION_AUTH_AES_GMAC_128")]
        NO_ENCRYPTION_AUTH_AES_GMAC_128 = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_ENCRYPTION_AUTH_AES_GMAC_192")]
        NO_ENCRYPTION_AUTH_AES_GMAC_192 = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_ENCRYPTION_AUTH_AES_GMAC_256")]
        NO_ENCRYPTION_AUTH_AES_GMAC_256 = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_ENCRYPTION")]
        NO_ENCRYPTION = 8,
    
    }
    
    /// <summary>Diffie-Hellman groups represent algorithm used to derive shared
    /// keys between IPSec VPN initiator and responder over an
    /// unsecured network.
    /// GROUP2 uses 1048-bit Modular Exponentiation (MODP) group.
    /// GROUP5 uses 1536-bit MODP group.
    /// GROUP14 uses 2048-bit MODP group.
    /// GROUP15 uses 3072-bit MODP group.
    /// GROUP16 uses 4096-bit MODP group.
    /// GROUP19 uses 256-bit Random Elliptic Curve (ECP) group.
    /// GROUP20 uses 384-bit Random ECP group.
    /// GROUP21 uses 521-bit Random ECP group.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Dh_groups
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP2")]
        GROUP2 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP5")]
        GROUP5 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP14")]
        GROUP14 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP15")]
        GROUP15 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP16")]
        GROUP16 = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP19")]
        GROUP19 = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP20")]
        GROUP20 = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP21")]
        GROUP21 = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IPSecVpnTunnelProfileDf_policy
    {
        [System.Runtime.Serialization.EnumMember(Value = @"COPY")]
        COPY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLEAR")]
        CLEAR = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PropertyItemType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"String")]
        String = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Number")]
        Number = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Date")]
        Date = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Url")]
        Url = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum RenderConfigurationColor
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GREY")]
        GREY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DARK_GREY")]
        DARK_GREY = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LIGHT_GREY")]
        LIGHT_GREY = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SKY_BLUE")]
        SKY_BLUE = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BLUE")]
        BLUE = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GREEN")]
        GREEN = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"YELLOW")]
        YELLOW = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RED")]
        RED = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DARK_RED")]
        DARK_RED = 8,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum RuleAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALLOW")]
        ALLOW = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DROP")]
        DROP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REJECT")]
        REJECT = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"JUMP_TO_APPLICATION")]
        JUMP_TO_APPLICATION = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBCompressionFilterLevel
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AGGRESSIVE_COMPRESSION")]
        AGGRESSIVE_COMPRESSION = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NORMAL_COMPRESSION")]
        NORMAL_COMPRESSION = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_COMPRESSION")]
        NO_COMPRESSION = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBCompressionFilterMatch
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IS_IN")]
        IS_IN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IS_NOT_IN")]
        IS_NOT_IN = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum HeaderContent_alignment
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LEFT")]
        LEFT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RIGHT")]
        RIGHT = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Ipv6NdraProfileRa_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DISABLED")]
        DISABLED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SLAAC_DNS_THROUGH_RA")]
        SLAAC_DNS_THROUGH_RA = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SLAAC_DNS_THROUGH_DHCP")]
        SLAAC_DNS_THROUGH_DHCP = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DHCP_ADDRESS_AND_DNS_THROUGH_DHCP")]
        DHCP_ADDRESS_AND_DNS_THROUGH_DHCP = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SLAAC_AND_ADDRESS_DNS_THROUGH_DHCP")]
        SLAAC_AND_ADDRESS_DNS_THROUGH_DHCP = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum RealizedNSServiceService_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SERVICE")]
        SERVICE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SERVICE_GROUP")]
        SERVICE_GROUP = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SegmentAdmin_state
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SegmentType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ROUTED")]
        ROUTED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXTENDED")]
        EXTENDED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ROUTED_AND_EXTENDED")]
        ROUTED_AND_EXTENDED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DISCONNECTED")]
        DISCONNECTED = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SegmentReplication_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"MTEP")]
        MTEP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SOURCE")]
        SOURCE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ConsolidatedRealizedStatusPublish_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNAVAILABLE")]
        UNAVAILABLE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNREALIZED")]
        UNREALIZED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REALIZED")]
        REALIZED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ForwardingRuleAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ROUTE_TO_UNDERLAY")]
        ROUTE_TO_UNDERLAY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ROUTE_TO_OVERLAY")]
        ROUTE_TO_OVERLAY = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ROUTE_FROM_UNDERLAY")]
        ROUTE_FROM_UNDERLAY = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ROUTE_FROM_OVERLAY")]
        ROUTE_FROM_OVERLAY = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NAT_FROM_UNDERLAY")]
        NAT_FROM_UNDERLAY = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NAT_TO_UNDERLAY")]
        NAT_TO_UNDERLAY = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBHttpRequestUriArgumentsConditionMatch_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"STARTS_WITH")]
        STARTS_WITH = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ENDS_WITH")]
        ENDS_WITH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EQUALS")]
        EQUALS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONTAINS")]
        CONTAINS = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGEX")]
        REGEX = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TlsListenerCertificateResult
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESS")]
        SUCCESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTION_TIMEOUT")]
        CONNECTION_TIMEOUT = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_ROUTE_TO_HOST")]
        NO_ROUTE_TO_HOST = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTION_REFUSED")]
        CONNECTION_REFUSED = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBDnsServiceApplicationProfileError_response
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_ERROR_RESPONSE_ERROR")]
        DNS_ERROR_RESPONSE_ERROR = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_ERROR_RESPONSE_NONE")]
        DNS_ERROR_RESPONSE_NONE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBSSLCertificateExpiry_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_CERTIFICATE_GOOD")]
        SSL_CERTIFICATE_GOOD = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_CERTIFICATE_EXPIRY_WARNING")]
        SSL_CERTIFICATE_EXPIRY_WARNING = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_CERTIFICATE_EXPIRED")]
        SSL_CERTIFICATE_EXPIRED = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyLbPoolAccessSource_nat
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ENABLED")]
        ENABLED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DISABLED")]
        DISABLED = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyLbPoolAccessAlgorithm
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ROUND_ROBIN")]
        ROUND_ROBIN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LEAST_CONNECTION")]
        LEAST_CONNECTION = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBURIParamTokenType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"URI_TOKEN_TYPE_HOST")]
        URI_TOKEN_TYPE_HOST = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"URI_TOKEN_TYPE_PATH")]
        URI_TOKEN_TYPE_PATH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"URI_TOKEN_TYPE_STRING")]
        URI_TOKEN_TYPE_STRING = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"URI_TOKEN_TYPE_STRING_GROUP")]
        URI_TOKEN_TYPE_STRING_GROUP = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"URI_TOKEN_TYPE_REGEX")]
        URI_TOKEN_TYPE_REGEX = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBClientCertificateSubjectDnConditionMatch_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"STARTS_WITH")]
        STARTS_WITH = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ENDS_WITH")]
        ENDS_WITH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EQUALS")]
        EQUALS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONTAINS")]
        CONTAINS = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGEX")]
        REGEX = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum MacDiscoveryProfileMac_limit_policy
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALLOW")]
        ALLOW = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DROP")]
        DROP = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LbSslProtocolInfoProtocol
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_V2")]
        SSL_V2 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_V3")]
        SSL_V3 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_V1")]
        TLS_V1 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_V1_1")]
        TLS_V1_1 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_V1_2")]
        TLS_V1_2 = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IdfwVirtualMachineConditionStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_TOOLS_NOT_INSTALLED")]
        VM_TOOLS_NOT_INSTALLED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IDFW_NOT_SUPPORTED")]
        IDFW_NOT_SUPPORTED = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DFW_DISABLED")]
        DFW_DISABLED = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IDFW_DISABLED")]
        IDFW_DISABLED = 6,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LdapIdentitySourceSearchResultItemType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"USER")]
        USER = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP")]
        GROUP = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyInsertParametersOperation
    {
        [System.Runtime.Serialization.EnumMember(Value = @"insert_top")]
        Insert_top = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_bottom")]
        Insert_bottom = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_after")]
        Insert_after = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_before")]
        Insert_before = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBStringGroupType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SG_TYPE_STRING")]
        SG_TYPE_STRING = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SG_TYPE_KEYVAL")]
        SG_TYPE_KEYVAL = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum RealizedVirtualMachinePower_state
    {
        [System.Runtime.Serialization.EnumMember(Value = @"VM_RUNNING")]
        VM_RUNNING = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_STOPPED")]
        VM_STOPPED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_SUSPENDED")]
        VM_SUSPENDED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum DirectoryLdapServerProtocol
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LDAP")]
        LDAP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LDAPS")]
        LDAPS = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Dhcpv6HeaderMsg_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SOLICIT")]
        SOLICIT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ADVERTISE")]
        ADVERTISE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REQUEST")]
        REQUEST = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REPLY")]
        REPLY = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum L2VPNServiceMode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SERVER")]
        SERVER = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLIENT")]
        CLIENT = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IPSecVpnTunnelTrafficStatisticsTunnel_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 1,
    
    }
    
    /// <summary>Valid ENUM values for ALBDnsRecordType</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Query_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_OTHER")]
        DNS_RECORD_OTHER = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_A")]
        DNS_RECORD_A = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_NS")]
        DNS_RECORD_NS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_CNAME")]
        DNS_RECORD_CNAME = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_SOA")]
        DNS_RECORD_SOA = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_PTR")]
        DNS_RECORD_PTR = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_HINFO")]
        DNS_RECORD_HINFO = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_MX")]
        DNS_RECORD_MX = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_TXT")]
        DNS_RECORD_TXT = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_RP")]
        DNS_RECORD_RP = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_DNSKEY")]
        DNS_RECORD_DNSKEY = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_AAAA")]
        DNS_RECORD_AAAA = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_SRV")]
        DNS_RECORD_SRV = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_OPT")]
        DNS_RECORD_OPT = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_RRSIG")]
        DNS_RECORD_RRSIG = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_AXFR")]
        DNS_RECORD_AXFR = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_ANY")]
        DNS_RECORD_ANY = 16,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBDnsQueryTypeMatchMatch_criteria
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IS_IN")]
        IS_IN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IS_NOT_IN")]
        IS_NOT_IN = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBLdapAuthSettingsSecurity_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_LDAP_SECURE_NONE")]
        AUTH_LDAP_SECURE_NONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_LDAP_SECURE_USE_LDAPS")]
        AUTH_LDAP_SECURE_USE_LDAPS = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum WidgetItemAlignment
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LEFT")]
        LEFT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RIGHT")]
        RIGHT = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TraceActionArgumentTrace_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNI_DIRECTIONAL")]
        UNI_DIRECTIONAL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BI_DIRECTIONAL")]
        BI_DIRECTIONAL = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBSSLKeyECParamsCurve
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_KEY_EC_CURVE_SECP256R1")]
        SSL_KEY_EC_CURVE_SECP256R1 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_KEY_EC_CURVE_SECP384R1")]
        SSL_KEY_EC_CURVE_SECP384R1 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_KEY_EC_CURVE_SECP521R1")]
        SSL_KEY_EC_CURVE_SECP521R1 = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBHttpRequestVersionConditionVersion
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_VERSION_1_0")]
        HTTP_VERSION_1_0 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_VERSION_1_1")]
        HTTP_VERSION_1_1 = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TraceflowObservationDroppedReason
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ARP_FAIL")]
        ARP_FAIL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BFD")]
        BFD = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BROADCAST")]
        BROADCAST = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DHCP")]
        DHCP = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DLB")]
        DLB = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FW_RULE")]
        FW_RULE = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GENEVE")]
        GENEVE = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GRE")]
        GRE = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IFACE")]
        IFACE = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IP")]
        IP = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IP_REASS")]
        IP_REASS = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IPSEC")]
        IPSEC = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IPSEC_VTI")]
        IPSEC_VTI = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"L2VPN")]
        L2VPN = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"L4PORT")]
        L4PORT = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LB")]
        LB = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LROUTER")]
        LROUTER = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LSERVICE")]
        LSERVICE = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LSWITCH")]
        LSWITCH = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MANAGEMENT")]
        MANAGEMENT = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MD_PROXY")]
        MD_PROXY = 20,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NAT")]
        NAT = 21,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ND_NS_FAIL")]
        ND_NS_FAIL = 22,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NEIGH")]
        NEIGH = 23,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_EIP_FOUND")]
        NO_EIP_FOUND = 24,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_EIP_ASSOCIATION")]
        NO_EIP_ASSOCIATION = 25,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_ENI_FOR_IP")]
        NO_ENI_FOR_IP = 26,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_ENI_FOR_LIF")]
        NO_ENI_FOR_LIF = 27,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_ROUTE")]
        NO_ROUTE = 28,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_ROUTE_TABLE_FOUND")]
        NO_ROUTE_TABLE_FOUND = 29,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_UNDERLAY_ROUTE_FOUND")]
        NO_UNDERLAY_ROUTE_FOUND = 30,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOT_VDR_DOWNLINK")]
        NOT_VDR_DOWNLINK = 31,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_VDR_FOUND")]
        NO_VDR_FOUND = 32,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_VDR_ON_HOST")]
        NO_VDR_ON_HOST = 33,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOT_VDR_UPLINK")]
        NOT_VDR_UPLINK = 34,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SERVICE_INSERT")]
        SERVICE_INSERT = 35,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SPOOFGUARD")]
        SPOOFGUARD = 36,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TTL_ZERO")]
        TTL_ZERO = 37,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TUNNEL")]
        TUNNEL = 38,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VXLAN")]
        VXLAN = 39,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VXSTT")]
        VXSTT = 40,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VMC_NO_RESPONSE")]
        VMC_NO_RESPONSE = 41,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WRONG_UPLINK")]
        WRONG_UPLINK = 42,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 43,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TraceflowObservationDroppedArp_fail_reason
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ARP_UNKNOWN")]
        ARP_UNKNOWN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ARP_TIMEOUT")]
        ARP_TIMEOUT = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ARP_CPFAIL")]
        ARP_CPFAIL = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ARP_FROMCP")]
        ARP_FROMCP = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ARP_PORTDESTROY")]
        ARP_PORTDESTROY = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ARP_TABLEDESTROY")]
        ARP_TABLEDESTROY = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ARP_NETDESTROY")]
        ARP_NETDESTROY = 6,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IpAddressInfoSource
    {
        [System.Runtime.Serialization.EnumMember(Value = @"VM_TOOLS")]
        VM_TOOLS = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum UnaryOperationOperator
    {
        [System.Runtime.Serialization.EnumMember(Value = @"APPEND")]
        APPEND = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUBTRACT")]
        SUBTRACT = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ObjectRolePermissionGroupOperation
    {
        [System.Runtime.Serialization.EnumMember(Value = @"crud")]
        Crud = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"read")]
        Read = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"execute")]
        Execute = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"none")]
        None = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ResourceTagStatusTag_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Success")]
        Success = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Error")]
        Error = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum RedirectionRuleAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"REDIRECT")]
        REDIRECT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DO_NOT_REDIRECT")]
        DO_NOT_REDIRECT = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TraceflowOperation_state
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IN_PROGRESS")]
        IN_PROGRESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FINISHED")]
        FINISHED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILED")]
        FAILED = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TraceflowRequest_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESS")]
        SUCCESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIMEOUT")]
        TIMEOUT = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SOURCE_PORT_NOT_FOUND")]
        SOURCE_PORT_NOT_FOUND = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DATA_PATH_NOT_READY")]
        DATA_PATH_NOT_READY = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTION_ERROR")]
        CONNECTION_ERROR = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBServiceCountPerSeveritySeverity
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GREEN")]
        GREEN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ORANGE")]
        ORANGE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RED")]
        RED = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBDnsGeoLocationMatchMatch_criteria
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IS_IN")]
        IS_IN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IS_NOT_IN")]
        IS_NOT_IN = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBServiceError_log_level
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DEBUG")]
        DEBUG = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INFO")]
        INFO = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNING")]
        WARNING = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CRITICAL")]
        CRITICAL = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ALERT")]
        ALERT = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EMERGENCY")]
        EMERGENCY = 6,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBServiceSize
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SMALL")]
        SMALL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MEDIUM")]
        MEDIUM = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LARGE")]
        LARGE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XLARGE")]
        XLARGE = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DLB")]
        DLB = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IPv6DADStatusStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DUPLICATED")]
        DUPLICATED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TENTATIVE")]
        TENTATIVE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ASSIGNED")]
        ASSIGNED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOT_APPLICABLE")]
        NOT_APPLICABLE = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBSslSniConditionMatch_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"STARTS_WITH")]
        STARTS_WITH = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ENDS_WITH")]
        ENDS_WITH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EQUALS")]
        EQUALS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONTAINS")]
        CONTAINS = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGEX")]
        REGEX = 4,
    
    }
    
    /// <summary>The TunnelDigestAlgorithms are used to verify message integrity during tunnel establishment.
    /// SHA1 produces 160 bits hash and SHA2_256 produces 256 bit hash.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Tunnel_digest_algorithms
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SHA1")]
        SHA1 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SHA2_256")]
        SHA2_256 = 1,
    
    }
    
    /// <summary>The IKEDigestAlgorithms are used to verify message integrity during IKE negotiation.
    /// SHA1 produces 160 bits hash and SHA2_256 produces 256 bit hash.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Ike_digest_algorithms
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SHA1")]
        SHA1 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SHA2_256")]
        SHA2_256 = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum L3VpnIke_version
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IKE_V1")]
        IKE_V1 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IKE_V2")]
        IKE_V2 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IKE_FLEX")]
        IKE_FLEX = 2,
    
    }
    
    /// <summary>IKEEncryption algorithms are used to ensure confidentiality of the messages
    /// exchanged during IKE negotiations. AES stands for Advanced Encryption Standards.
    /// AES_128 uses 128-bit keys whereas AES_256 uses 256-bit keys for encryption and
    /// decryption. AES_GCM stands for Advanced Encryption Standard(AES) in Galois/Counter
    /// Mode(GCM) and is used to provide both confidentiality and data origin authentication.
    /// AES_GCM composed of two separate functions one for encryption(AES) and one for
    /// authentication(GMAC). AES_GCM algorithms will be available with IKE_V2 version only.
    /// AES_GMAC_128 uses 128-bit keys.
    /// AES_GMAC_192 uses 192-bit keys.
    /// AES_GMAC_256 uses 256-bit keys.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Ike_encryption_algorithms
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AES_128")]
        AES_128 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AES_256")]
        AES_256 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AES_GCM_128")]
        AES_GCM_128 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AES_GCM_192")]
        AES_GCM_192 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AES_GCM_256")]
        AES_GCM_256 = 4,
    
    }
    
    /// <summary>Diffie-Hellman groups represent algorithm used to derive shared keys between
    /// IPSec VPN initiator and responder over an unsecured network.
    /// GROUP2 uses 1024-bit Modular Exponentiation (MODP) group.
    /// GROUP5 uses 1536-bit MODP group.
    /// GROUP14 uses 2048-bit MODP group.
    /// GROUP15 uses 3072-bit MODP group.
    /// GROUP16 uses 4096-bit MODP group.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Dh_groups2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP2")]
        GROUP2 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP5")]
        GROUP5 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP14")]
        GROUP14 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP15")]
        GROUP15 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP16")]
        GROUP16 = 4,
    
    }
    
    /// <summary>TunnelEncryption algorithms are used to ensure confidentiality of the messages exchanged
    /// during Tunnel negotiations. AES stands for Advanced Encryption Standards. AES_128 uses
    /// 128-bit keys whereas AES_256 uses 256-bit keys for encryption and decryption. AES_GCM
    /// stands for Advanced Encryption Standard(AES) in Galois/Counter Mode (GCM) and is used to
    /// provide both confidentiality and data origin authentication.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Tunnel_encryption_algorithms
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AES_128")]
        AES_128 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AES_256")]
        AES_256 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AES_GCM_128")]
        AES_GCM_128 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AES_GCM_192")]
        AES_GCM_192 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AES_GCM_256")]
        AES_GCM_256 = 4,
    
    }
    
    /// <summary>The IkeDigestAlgorithms are used to verify message
    /// integrity during Ike negotiation. SHA1 produces 160
    /// bits hash and SHA2_XXX produces XXX bit hash.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Digest_algorithms2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SHA1")]
        SHA1 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SHA2_256")]
        SHA2_256 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SHA2_384")]
        SHA2_384 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SHA2_512")]
        SHA2_512 = 3,
    
    }
    
    /// <summary>IKEEncryption algorithms are used to ensure confidentiality of
    /// the messages exchanged during IKE negotiations. AES stands for
    /// Advanced Encryption Standards. AES_128 uses 128-bit keys whereas
    /// AES_256 uses 256-bit keys for encryption and decryption.
    /// AES_GCM stands for Advanced Encryption Standard(AES) in
    /// Galois/Counter Mode(GCM) and is used to provide both
    /// confidentiality and data origin authentication. AES_GCM composed
    /// of two separate functions one for encryption(AES) and one for
    /// authentication(GMAC). AES_GCM algorithms will be available with
    /// IKE_V2 version only.
    /// AES_GCM_128 uses 128-bit keys.
    /// AES_GCM_192 uses 192-bit keys.
    /// AES_GCM_256 uses 256-bit keys.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Encryption_algorithms2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AES_128")]
        AES_128 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AES_256")]
        AES_256 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AES_GCM_128")]
        AES_GCM_128 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AES_GCM_192")]
        AES_GCM_192 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AES_GCM_256")]
        AES_GCM_256 = 4,
    
    }
    
    /// <summary>Diffie-Hellman groups represent algorithm used to derive shared
    /// keys between IPSec VPN initiator and responder over an
    /// unsecured network.
    /// GROUP2 uses 1048-bit Modular Exponentiation (MODP) group.
    /// GROUP5 uses 1536-bit MODP group.
    /// GROUP14 uses 2048-bit MODP group.
    /// GROUP15 uses 3072-bit MODP group.
    /// GROUP16 uses 4096-bit MODP group.
    /// GROUP19 uses 256-bit Random Elliptic Curve (ECP) group.
    /// GROUP20 uses 384-bit Random ECP group.
    /// GROUP21 uses 521-bit Random ECP group.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Dh_groups3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP2")]
        GROUP2 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP5")]
        GROUP5 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP14")]
        GROUP14 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP15")]
        GROUP15 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP16")]
        GROUP16 = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP19")]
        GROUP19 = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP20")]
        GROUP20 = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP21")]
        GROUP21 = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IPSecVpnIkeProfileIke_version
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IKE_V1")]
        IKE_V1 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IKE_V2")]
        IKE_V2 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IKE_FLEX")]
        IKE_FLEX = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBServicePoolSelectorService_protocol
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PROTOCOL_TYPE_TCP_PROXY")]
        PROTOCOL_TYPE_TCP_PROXY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PROTOCOL_TYPE_TCP_FAST_PATH")]
        PROTOCOL_TYPE_TCP_FAST_PATH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PROTOCOL_TYPE_UDP_FAST_PATH")]
        PROTOCOL_TYPE_UDP_FAST_PATH = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PROTOCOL_TYPE_UDP_PROXY")]
        PROTOCOL_TYPE_UDP_PROXY = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ICMPTypeServiceEntryProtocol
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ICMPv4")]
        ICMPv4 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ICMPv6")]
        ICMPv6 = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBL4RuleActionSelectPoolAction_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"L4_RULE_ACTION_SELECT_POOL")]
        L4_RULE_ACTION_SELECT_POOL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"L4_RULE_ACTION_SELECT_POOLGROUP")]
        L4_RULE_ACTION_SELECT_POOLGROUP = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBHttpRequestBodyConditionMatch_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"STARTS_WITH")]
        STARTS_WITH = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ENDS_WITH")]
        ENDS_WITH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EQUALS")]
        EQUALS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONTAINS")]
        CONTAINS = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGEX")]
        REGEX = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum X509CertificatePublic_key_algo
    {
        [System.Runtime.Serialization.EnumMember(Value = @"RSA")]
        RSA = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DSA")]
        DSA = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ECDSA")]
        ECDSA = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum X509CertificateEcdsa_ec_field
    {
        [System.Runtime.Serialization.EnumMember(Value = @"F2M")]
        F2M = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FP")]
        FP = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SecurityPolicyConnectivity_strategy
    {
        [System.Runtime.Serialization.EnumMember(Value = @"WHITELIST")]
        WHITELIST = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BLACKLIST")]
        BLACKLIST = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WHITELIST_ENABLE_LOGGING")]
        WHITELIST_ENABLE_LOGGING = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BLACKLIST_ENABLE_LOGGING")]
        BLACKLIST_ENABLE_LOGGING = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NONE")]
        NONE = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ApplicationConnectivityStrategyApplication_connectivity_strategy
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALLOW_INTRA")]
        ALLOW_INTRA = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ALLOW_EGRESS")]
        ALLOW_EGRESS = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PktcapActionArgumentPktcap_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNI_DIRECTIONAL")]
        UNI_DIRECTIONAL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BI_DIRECTIONAL")]
        BI_DIRECTIONAL = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBAuthenticationActionType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SKIP_AUTHENTICATION")]
        SKIP_AUTHENTICATION = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"USE_DEFAULT_AUTHENTICATION")]
        USE_DEFAULT_AUTHENTICATION = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SecurityZoneRuleAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALLOW")]
        ALLOW = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DROP")]
        DROP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REJECT")]
        REJECT = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SKIP")]
        SKIP = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBAuthProfileType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_PROFILE_LDAP")]
        AUTH_PROFILE_LDAP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_PROFILE_TACACS_PLUS")]
        AUTH_PROFILE_TACACS_PLUS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_PROFILE_SAML")]
        AUTH_PROFILE_SAML = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_PROFILE_PINGACCESS")]
        AUTH_PROFILE_PINGACCESS = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_PROFILE_JWT")]
        AUTH_PROFILE_JWT = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBPoolStatusStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PARTIALLY_UP")]
        PARTIALLY_UP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PRIMARY_DOWN")]
        PRIMARY_DOWN = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DETACHED")]
        DETACHED = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBIpAddrMatchMatch_criteria
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IS_IN")]
        IS_IN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IS_NOT_IN")]
        IS_NOT_IN = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHTTPRewriteLocHdrActionProtocol
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP")]
        HTTP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTPS")]
        HTTPS = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CommunicationEntryDirection
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IN")]
        IN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OUT")]
        OUT = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IN_OUT")]
        IN_OUT = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CommunicationEntryAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALLOW")]
        ALLOW = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DROP")]
        DROP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REJECT")]
        REJECT = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBNetworkProfileUnionType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PROTOCOL_TYPE_TCP_PROXY")]
        PROTOCOL_TYPE_TCP_PROXY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PROTOCOL_TYPE_TCP_FAST_PATH")]
        PROTOCOL_TYPE_TCP_FAST_PATH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PROTOCOL_TYPE_UDP_FAST_PATH")]
        PROTOCOL_TYPE_UDP_FAST_PATH = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PROTOCOL_TYPE_UDP_PROXY")]
        PROTOCOL_TYPE_UDP_PROXY = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OspfRoutingConfigGraceful_restart_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DISABLE")]
        DISABLE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HELPER_ONLY")]
        HELPER_ONLY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBAnalyticsPolicyClient_insights
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NO_INSIGHTS")]
        NO_INSIGHTS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PASSIVE")]
        PASSIVE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACTIVE")]
        ACTIVE = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBCookiePersistenceProfileCookie_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INSERT")]
        INSERT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PREFIX")]
        PREFIX = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REWRITE")]
        REWRITE = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum AddressBindingEntrySource
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INVALID")]
        INVALID = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"USER_DEFINED")]
        USER_DEFINED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ARP_SNOOPING")]
        ARP_SNOOPING = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DHCP_SNOOPING")]
        DHCP_SNOOPING = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_TOOLS")]
        VM_TOOLS = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ND_SNOOPING")]
        ND_SNOOPING = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DHCPV6_SNOOPING")]
        DHCPV6_SNOOPING = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_TOOLS_V6")]
        VM_TOOLS_V6 = 8,
    
    }
    
    /// <summary>SSL cipher group</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Cipher_group_labels
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BALANCED")]
        BALANCED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HIGH_SECURITY")]
        HIGH_SECURITY = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HIGH_COMPATIBILITY")]
        HIGH_COMPATIBILITY = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CUSTOM")]
        CUSTOM = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LbSslCipherInfoCipher
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_256_CBC_SHA")]
        TLS_RSA_WITH_AES_256_CBC_SHA = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_128_CBC_SHA")]
        TLS_RSA_WITH_AES_128_CBC_SHA = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_3DES_EDE_CBC_SHA")]
        TLS_RSA_WITH_3DES_EDE_CBC_SHA = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_128_CBC_SHA256")]
        TLS_RSA_WITH_AES_128_CBC_SHA256 = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_128_GCM_SHA256")]
        TLS_RSA_WITH_AES_128_GCM_SHA256 = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_256_CBC_SHA256")]
        TLS_RSA_WITH_AES_256_CBC_SHA256 = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_256_GCM_SHA384")]
        TLS_RSA_WITH_AES_256_GCM_SHA384 = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = 20,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = 21,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = 22,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = 23,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = 24,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = 25,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = 26,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = 27,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = 28,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = 29,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = 30,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PortMirroringInstanceDirection
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INGRESS")]
        INGRESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EGRESS")]
        EGRESS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BIDIRECTIONAL")]
        BIDIRECTIONAL = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBClientLogStreamingFormatFormat
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LOG_STREAMING_FORMAT_JSON_FULL")]
        LOG_STREAMING_FORMAT_JSON_FULL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOG_STREAMING_FORMAT_JSON_SELECTED")]
        LOG_STREAMING_FORMAT_JSON_SELECTED = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum GlobalIdsSignatureAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALERT")]
        ALERT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DROP")]
        DROP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REJECT")]
        REJECT = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ConfigurationStateState
    {
        [System.Runtime.Serialization.EnumMember(Value = @"pending")]
        Pending = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"in_progress")]
        In_progress = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"success")]
        Success = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"failed")]
        Failed = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"partial_success")]
        Partial_success = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"orphaned")]
        Orphaned = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"unknown")]
        Unknown = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"error")]
        Error = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"in_sync")]
        In_sync = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOT_AVAILABLE")]
        NOT_AVAILABLE = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_DEPLOYMENT_QUEUED")]
        VM_DEPLOYMENT_QUEUED = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_DEPLOYMENT_IN_PROGRESS")]
        VM_DEPLOYMENT_IN_PROGRESS = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_DEPLOYMENT_FAILED")]
        VM_DEPLOYMENT_FAILED = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_POWER_ON_IN_PROGRESS")]
        VM_POWER_ON_IN_PROGRESS = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_POWER_ON_FAILED")]
        VM_POWER_ON_FAILED = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGISTRATION_PENDING")]
        REGISTRATION_PENDING = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NODE_NOT_READY")]
        NODE_NOT_READY = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NODE_READY")]
        NODE_READY = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_POWER_OFF_IN_PROGRESS")]
        VM_POWER_OFF_IN_PROGRESS = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_POWER_OFF_FAILED")]
        VM_POWER_OFF_FAILED = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_UNDEPLOY_IN_PROGRESS")]
        VM_UNDEPLOY_IN_PROGRESS = 20,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_UNDEPLOY_FAILED")]
        VM_UNDEPLOY_FAILED = 21,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_UNDEPLOY_SUCCESSFUL")]
        VM_UNDEPLOY_SUCCESSFUL = 22,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE_CONFIG_ERROR")]
        EDGE_CONFIG_ERROR = 23,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_DEPLOYMENT_RESTARTED")]
        VM_DEPLOYMENT_RESTARTED = 24,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGISTRATION_FAILED")]
        REGISTRATION_FAILED = 25,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TRANSPORT_NODE_SYNC_PENDING")]
        TRANSPORT_NODE_SYNC_PENDING = 26,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TRANSPORT_NODE_CONFIGURATION_MISSING")]
        TRANSPORT_NODE_CONFIGURATION_MISSING = 27,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE_HARDWARE_NOT_SUPPORTED")]
        EDGE_HARDWARE_NOT_SUPPORTED = 28,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MULTIPLE_OVERLAY_TZS_NOT_SUPPORTED")]
        MULTIPLE_OVERLAY_TZS_NOT_SUPPORTED = 29,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TN_OVERLAY_TZ_IN_USE_BY_EDGE_CLUSTER")]
        TN_OVERLAY_TZ_IN_USE_BY_EDGE_CLUSTER = 30,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TZ_ENDPOINTS_NOT_SPECIFIED")]
        TZ_ENDPOINTS_NOT_SPECIFIED = 31,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_PNIC_PREPARED_IN_EDGE")]
        NO_PNIC_PREPARED_IN_EDGE = 32,
    
        [System.Runtime.Serialization.EnumMember(Value = @"APPLIANCE_INTERNAL_ERROR")]
        APPLIANCE_INTERNAL_ERROR = 33,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VTEP_DHCP_NOT_SUPPORTED")]
        VTEP_DHCP_NOT_SUPPORTED = 34,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNSUPPORTED_HOST_SWITCH_PROFILE")]
        UNSUPPORTED_HOST_SWITCH_PROFILE = 35,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UPLINK_HOST_SWITCH_PROFILE_NOT_SPECIFIED")]
        UPLINK_HOST_SWITCH_PROFILE_NOT_SPECIFIED = 36,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HOSTSWITCH_PROFILE_NOT_FOUND")]
        HOSTSWITCH_PROFILE_NOT_FOUND = 37,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LLDP_SEND_ENABLED_NOT_SUPPORTED")]
        LLDP_SEND_ENABLED_NOT_SUPPORTED = 38,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNSUPPORTED_NAMED_TEAMING_POLICY")]
        UNSUPPORTED_NAMED_TEAMING_POLICY = 39,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LBSRCID_NOT_SUPPORTED_FOR_EDGE_VM")]
        LBSRCID_NOT_SUPPORTED_FOR_EDGE_VM = 40,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LACP_NOT_SUPPORTED_FOR_EDGE_VM")]
        LACP_NOT_SUPPORTED_FOR_EDGE_VM = 41,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STANDBY_UPLINKS_NOT_SUPPORTED_FOR_EDGE_VM")]
        STANDBY_UPLINKS_NOT_SUPPORTED_FOR_EDGE_VM = 42,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MULTIPLE_ACTIVE_UPLINKS_NOT_SUPPORTED_FOR_EDGE")]
        MULTIPLE_ACTIVE_UPLINKS_NOT_SUPPORTED_FOR_EDGE = 43,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNSUPPORTED_LACP_LB_ALGO_FOR_NODE")]
        UNSUPPORTED_LACP_LB_ALGO_FOR_NODE = 44,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE_NODE_VERSION_NOT_SUPPORTED")]
        EDGE_NODE_VERSION_NOT_SUPPORTED = 45,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_PNIC_SPECIFIED_IN_TN")]
        NO_PNIC_SPECIFIED_IN_TN = 46,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_PNIC_DEVICE_NAME")]
        INVALID_PNIC_DEVICE_NAME = 47,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TRANSPORT_NODE_READY")]
        TRANSPORT_NODE_READY = 48,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_NETWORK_EDIT_PENDING")]
        VM_NETWORK_EDIT_PENDING = 49,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNSUPPORTED_DEFAULT_TEAMING_POLICY")]
        UNSUPPORTED_DEFAULT_TEAMING_POLICY = 50,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MPA_DISCONNECTED")]
        MPA_DISCONNECTED = 51,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_RENAME_PENDING")]
        VM_RENAME_PENDING = 52,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_CONFIG_EDIT_PENDING")]
        VM_CONFIG_EDIT_PENDING = 53,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_NETWORK_EDIT_FAILED")]
        VM_NETWORK_EDIT_FAILED = 54,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_RENAME_FAILED")]
        VM_RENAME_FAILED = 55,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_CONFIG_EDIT_FAILED")]
        VM_CONFIG_EDIT_FAILED = 56,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_CONFIG_DISCREPANCY")]
        VM_CONFIG_DISCREPANCY = 57,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_NODE_REFRESH_FAILED")]
        VM_NODE_REFRESH_FAILED = 58,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_PLACEMENT_REFRESH_FAILED")]
        VM_PLACEMENT_REFRESH_FAILED = 59,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGISTRATION_TIMEDOUT")]
        REGISTRATION_TIMEDOUT = 60,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REPLACE_FAILED")]
        REPLACE_FAILED = 61,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UPLINK_FROM_TEAMING_POLICY_NOT_MAPPED")]
        UPLINK_FROM_TEAMING_POLICY_NOT_MAPPED = 62,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOGICAL_SWITCH_NAMED_TEAMING_HAS_NO_PNIC_BACKING")]
        LOGICAL_SWITCH_NAMED_TEAMING_HAS_NO_PNIC_BACKING = 63,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DELETE_VM_IN_REDEPLOY_FAILED")]
        DELETE_VM_IN_REDEPLOY_FAILED = 64,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DEPLOY_VM_IN_REDEPLOY_FAILED")]
        DEPLOY_VM_IN_REDEPLOY_FAILED = 65,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INSUFFICIENT_RESOURCES_IN_EDGE_NODE_FOR_SERVICE")]
        INSUFFICIENT_RESOURCES_IN_EDGE_NODE_FOR_SERVICE = 66,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LiveTracePacketGranularActionConfigTrace_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNI_DIRECTIONAL")]
        UNI_DIRECTIONAL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BI_DIRECTIONAL")]
        BI_DIRECTIONAL = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBSecurityPolicyOper_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DETECTION")]
        DETECTION = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MITIGATION")]
        MITIGATION = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBQueryMatchMatch_case
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SENSITIVE")]
        SENSITIVE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INSENSITIVE")]
        INSENSITIVE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBQueryMatchMatch_criteria
    {
        [System.Runtime.Serialization.EnumMember(Value = @"QUERY_MATCH_CONTAINS")]
        QUERY_MATCH_CONTAINS = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyDnsForwarderLog_level
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DEBUG")]
        DEBUG = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INFO")]
        INFO = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNING")]
        WARNING = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FATAL")]
        FATAL = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBNetworkSecurityRuleAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NETWORK_SECURITY_POLICY_ACTION_TYPE_ALLOW")]
        NETWORK_SECURITY_POLICY_ACTION_TYPE_ALLOW = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NETWORK_SECURITY_POLICY_ACTION_TYPE_DENY")]
        NETWORK_SECURITY_POLICY_ACTION_TYPE_DENY = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NETWORK_SECURITY_POLICY_ACTION_TYPE_RATE_LIMIT")]
        NETWORK_SECURITY_POLICY_ACTION_TYPE_RATE_LIMIT = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBEdgeNodeUsageSeverity
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GREEN")]
        GREEN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ORANGE")]
        ORANGE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RED")]
        RED = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBEdgeNodeUsageForm_factor
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SMALL_VIRTUAL_MACHINE")]
        SMALL_VIRTUAL_MACHINE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MEDIUM_VIRTUAL_MACHINE")]
        MEDIUM_VIRTUAL_MACHINE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LARGE_VIRTUAL_MACHINE")]
        LARGE_VIRTUAL_MACHINE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XLARGE_VIRTUAL_MACHINE")]
        XLARGE_VIRTUAL_MACHINE = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PHYSICAL_MACHINE")]
        PHYSICAL_MACHINE = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum L7PolicyLbPersistenceProfilePersistence
    {
        [System.Runtime.Serialization.EnumMember(Value = @"COOKIE")]
        COOKIE = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBServiceUsageService_size
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SMALL")]
        SMALL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MEDIUM")]
        MEDIUM = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LARGE")]
        LARGE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XLARGE")]
        XLARGE = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DLB")]
        DLB = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBServiceUsageSeverity
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GREEN")]
        GREEN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ORANGE")]
        ORANGE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RED")]
        RED = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHardwareSecurityModuleType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HSM_TYPE_THALES_NETHSM")]
        HSM_TYPE_THALES_NETHSM = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HSM_TYPE_SAFENET_LUNA")]
        HSM_TYPE_SAFENET_LUNA = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HSM_TYPE_AWS_CLOUDHSM")]
        HSM_TYPE_AWS_CLOUDHSM = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBSslModeSelectionActionSsl_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_PASSTHROUGH")]
        SSL_PASSTHROUGH = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_END_TO_END")]
        SSL_END_TO_END = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_OFFLOAD")]
        SSL_OFFLOAD = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ContainerNetworkPolicyNetwork_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HEALTHY")]
        HEALTHY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNHEALTHY")]
        UNHEALTHY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ContainerNetworkPolicyPolicy_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NETWORK_POLICY")]
        NETWORK_POLICY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ASG")]
        ASG = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyAttributesAttribute_source
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SYSTEM")]
        SYSTEM = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CUSTOM")]
        CUSTOM = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyAttributesKey
    {
        [System.Runtime.Serialization.EnumMember(Value = @"APP_ID")]
        APP_ID = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOMAIN_NAME")]
        DOMAIN_NAME = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"URL_CATEGORY")]
        URL_CATEGORY = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"URL_REPUTATION")]
        URL_REPUTATION = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyAttributesDatatype
    {
        [System.Runtime.Serialization.EnumMember(Value = @"STRING")]
        STRING = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBDnsRuleRLActionType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RL_ACTION_NONE")]
        DNS_RL_ACTION_NONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RL_ACTION_DROP_REQ")]
        DNS_RL_ACTION_DROP_REQ = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHostHdrMatchMatch_case
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SENSITIVE")]
        SENSITIVE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INSENSITIVE")]
        INSENSITIVE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHostHdrMatchMatch_criteria
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_EXISTS")]
        HDR_EXISTS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_DOES_NOT_EXIST")]
        HDR_DOES_NOT_EXIST = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_BEGINS_WITH")]
        HDR_BEGINS_WITH = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_DOES_NOT_BEGIN_WITH")]
        HDR_DOES_NOT_BEGIN_WITH = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_CONTAINS")]
        HDR_CONTAINS = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_DOES_NOT_CONTAIN")]
        HDR_DOES_NOT_CONTAIN = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_ENDS_WITH")]
        HDR_ENDS_WITH = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_DOES_NOT_END_WITH")]
        HDR_DOES_NOT_END_WITH = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_EQUALS")]
        HDR_EQUALS = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_DOES_NOT_EQUAL")]
        HDR_DOES_NOT_EQUAL = 9,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TransportInfoProtocol
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TCP")]
        TCP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UDP")]
        UDP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ICMPv4")]
        ICMPv4 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ICMPv6")]
        ICMPv6 = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SourceFieldEvaluationOperator
    {
        [System.Runtime.Serialization.EnumMember(Value = @"EQ")]
        EQ = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOT_EQ")]
        NOT_EQ = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TraceflowObservationRelayedLogicalMessage_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"REQUEST")]
        REQUEST = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REPLY")]
        REPLY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBSamlServiceProviderSettingsSaml_entity_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_SAML_CLUSTER_VIP")]
        AUTH_SAML_CLUSTER_VIP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_SAML_DNS_FQDN")]
        AUTH_SAML_DNS_FQDN = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_SAML_APP_VS")]
        AUTH_SAML_APP_VS = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBDnsRrSetType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_OTHER")]
        DNS_RECORD_OTHER = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_A")]
        DNS_RECORD_A = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_NS")]
        DNS_RECORD_NS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_CNAME")]
        DNS_RECORD_CNAME = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_SOA")]
        DNS_RECORD_SOA = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_PTR")]
        DNS_RECORD_PTR = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_HINFO")]
        DNS_RECORD_HINFO = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_MX")]
        DNS_RECORD_MX = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_TXT")]
        DNS_RECORD_TXT = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_RP")]
        DNS_RECORD_RP = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_DNSKEY")]
        DNS_RECORD_DNSKEY = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_AAAA")]
        DNS_RECORD_AAAA = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_SRV")]
        DNS_RECORD_SRV = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_OPT")]
        DNS_RECORD_OPT = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_RRSIG")]
        DNS_RECORD_RRSIG = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_AXFR")]
        DNS_RECORD_AXFR = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_ANY")]
        DNS_RECORD_ANY = 16,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum DhcpServerStatusService_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_STANDBY")]
        NO_STANDBY = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeaturePermissionPermission
    {
        [System.Runtime.Serialization.EnumMember(Value = @"crud")]
        Crud = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"read")]
        Read = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"execute")]
        Execute = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"none")]
        None = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBDnsInfoAlgorithm
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_RESPONSE_ROUND_ROBIN")]
        DNS_RECORD_RESPONSE_ROUND_ROBIN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_RESPONSE_CONSISTENT_HASH")]
        DNS_RECORD_RESPONSE_CONSISTENT_HASH = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBDnsInfoType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_OTHER")]
        DNS_RECORD_OTHER = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_A")]
        DNS_RECORD_A = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_NS")]
        DNS_RECORD_NS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_CNAME")]
        DNS_RECORD_CNAME = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_SOA")]
        DNS_RECORD_SOA = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_PTR")]
        DNS_RECORD_PTR = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_HINFO")]
        DNS_RECORD_HINFO = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_MX")]
        DNS_RECORD_MX = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_TXT")]
        DNS_RECORD_TXT = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_RP")]
        DNS_RECORD_RP = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_DNSKEY")]
        DNS_RECORD_DNSKEY = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_AAAA")]
        DNS_RECORD_AAAA = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_SRV")]
        DNS_RECORD_SRV = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_OPT")]
        DNS_RECORD_OPT = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_RRSIG")]
        DNS_RECORD_RRSIG = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_AXFR")]
        DNS_RECORD_AXFR = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_ANY")]
        DNS_RECORD_ANY = 16,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBTCPApplicationProfileProxy_protocol_version
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PROXY_PROTOCOL_VERSION_1")]
        PROXY_PROTOCOL_VERSION_1 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PROXY_PROTOCOL_VERSION_2")]
        PROXY_PROTOCOL_VERSION_2 = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBTCPApplicationProfileSsl_client_certificate_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_CLIENT_CERTIFICATE_NONE")]
        SSL_CLIENT_CERTIFICATE_NONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_CLIENT_CERTIFICATE_REQUEST")]
        SSL_CLIENT_CERTIFICATE_REQUEST = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_CLIENT_CERTIFICATE_REQUIRE")]
        SSL_CLIENT_CERTIFICATE_REQUIRE = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyTransportZoneTz_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"OVERLAY_STANDARD")]
        OVERLAY_STANDARD = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OVERLAY_ENS")]
        OVERLAY_ENS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VLAN_BACKED")]
        VLAN_BACKED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 3,
    
    }
    
    /// <summary>SSL cipher</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Client_supported_ssl_ciphers
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_256_CBC_SHA")]
        TLS_RSA_WITH_AES_256_CBC_SHA = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_128_CBC_SHA")]
        TLS_RSA_WITH_AES_128_CBC_SHA = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_3DES_EDE_CBC_SHA")]
        TLS_RSA_WITH_3DES_EDE_CBC_SHA = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_128_CBC_SHA256")]
        TLS_RSA_WITH_AES_128_CBC_SHA256 = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_128_GCM_SHA256")]
        TLS_RSA_WITH_AES_128_GCM_SHA256 = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_256_CBC_SHA256")]
        TLS_RSA_WITH_AES_256_CBC_SHA256 = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_256_GCM_SHA384")]
        TLS_RSA_WITH_AES_256_GCM_SHA384 = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = 20,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = 21,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = 22,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = 23,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = 24,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = 25,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = 26,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = 27,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = 28,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = 29,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = 30,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBHttpSslConditionUsed_ssl_cipher
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_256_CBC_SHA")]
        TLS_RSA_WITH_AES_256_CBC_SHA = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_128_CBC_SHA")]
        TLS_RSA_WITH_AES_128_CBC_SHA = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_3DES_EDE_CBC_SHA")]
        TLS_RSA_WITH_3DES_EDE_CBC_SHA = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_128_CBC_SHA256")]
        TLS_RSA_WITH_AES_128_CBC_SHA256 = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_128_GCM_SHA256")]
        TLS_RSA_WITH_AES_128_GCM_SHA256 = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_256_CBC_SHA256")]
        TLS_RSA_WITH_AES_256_CBC_SHA256 = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_256_GCM_SHA384")]
        TLS_RSA_WITH_AES_256_GCM_SHA384 = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = 20,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = 21,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = 22,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = 23,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = 24,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = 25,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = 26,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = 27,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = 28,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = 29,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = 30,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBHttpSslConditionSession_reused
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IGNORE")]
        IGNORE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REUSED")]
        REUSED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NEW")]
        NEW = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBHttpSslConditionUsed_protocol
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_V2")]
        SSL_V2 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_V3")]
        SSL_V3 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_V1")]
        TLS_V1 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_V1_1")]
        TLS_V1_1 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_V1_2")]
        TLS_V1_2 = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyNatRuleAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SNAT")]
        SNAT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNAT")]
        DNAT = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REFLEXIVE")]
        REFLEXIVE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_SNAT")]
        NO_SNAT = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_DNAT")]
        NO_DNAT = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NAT64")]
        NAT64 = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyNatRuleFirewall_match
    {
        [System.Runtime.Serialization.EnumMember(Value = @"MATCH_EXTERNAL_ADDRESS")]
        MATCH_EXTERNAL_ADDRESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MATCH_INTERNAL_ADDRESS")]
        MATCH_INTERNAL_ADDRESS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BYPASS")]
        BYPASS = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum L2ForwarderStatusPerNodeHigh_availability_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ACTIVE")]
        ACTIVE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STANDBY")]
        STANDBY = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SYNC")]
        SYNC = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBSSLKeyRSAParamsKey_size
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_KEY_1024_BITS")]
        SSL_KEY_1024_BITS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_KEY_2048_BITS")]
        SSL_KEY_2048_BITS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_KEY_3072_BITS")]
        SSL_KEY_3072_BITS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_KEY_4096_BITS")]
        SSL_KEY_4096_BITS = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBClientLogStreamingConfigProtocol
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LOG_STREAMING_PROTOCOL_UDP")]
        LOG_STREAMING_PROTOCOL_UDP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOG_STREAMING_PROTOCOL_SYSLOG_OVER_UDP")]
        LOG_STREAMING_PROTOCOL_SYSLOG_OVER_UDP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOG_STREAMING_PROTOCOL_TCP")]
        LOG_STREAMING_PROTOCOL_TCP = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOG_STREAMING_PROTOCOL_SYSLOG_OVER_TCP")]
        LOG_STREAMING_PROTOCOL_SYSLOG_OVER_TCP = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOG_STREAMING_PROTOCOL_RAW_OVER_UDP")]
        LOG_STREAMING_PROTOCOL_RAW_OVER_UDP = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBClientLogStreamingConfigLog_types_to_send
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LOGS_SIGNIFICANT_ONLY")]
        LOGS_SIGNIFICANT_ONLY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOGS_UDF_ONLY")]
        LOGS_UDF_ONLY = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOGS_UDF_SIGNIFICANT")]
        LOGS_UDF_SIGNIFICANT = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOGS_ALL")]
        LOGS_ALL = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LabelValueConfigurationSub_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"VERTICALLY_ALIGNED")]
        VERTICALLY_ALIGNED = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBVSDataScriptEvt
    {
        [System.Runtime.Serialization.EnumMember(Value = @"VS_DATASCRIPT_EVT_HTTP_REQ")]
        VS_DATASCRIPT_EVT_HTTP_REQ = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VS_DATASCRIPT_EVT_HTTP_RESP")]
        VS_DATASCRIPT_EVT_HTTP_RESP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VS_DATASCRIPT_EVT_HTTP_RESP_DATA")]
        VS_DATASCRIPT_EVT_HTTP_RESP_DATA = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VS_DATASCRIPT_EVT_HTTP_LB_FAILED")]
        VS_DATASCRIPT_EVT_HTTP_LB_FAILED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VS_DATASCRIPT_EVT_HTTP_REQ_DATA")]
        VS_DATASCRIPT_EVT_HTTP_REQ_DATA = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VS_DATASCRIPT_EVT_HTTP_RESP_FAILED")]
        VS_DATASCRIPT_EVT_HTTP_RESP_FAILED = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VS_DATASCRIPT_EVT_HTTP_LB_DONE")]
        VS_DATASCRIPT_EVT_HTTP_LB_DONE = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VS_DATASCRIPT_EVT_HTTP_AUTH")]
        VS_DATASCRIPT_EVT_HTTP_AUTH = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VS_DATASCRIPT_EVT_HTTP_POST_AUTH")]
        VS_DATASCRIPT_EVT_HTTP_POST_AUTH = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VS_DATASCRIPT_EVT_TCP_CLIENT_ACCEPT")]
        VS_DATASCRIPT_EVT_TCP_CLIENT_ACCEPT = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VS_DATASCRIPT_EVT_SSL_HANDSHAKE_DONE")]
        VS_DATASCRIPT_EVT_SSL_HANDSHAKE_DONE = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VS_DATASCRIPT_EVT_DNS_REQ")]
        VS_DATASCRIPT_EVT_DNS_REQ = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VS_DATASCRIPT_EVT_DNS_RESP")]
        VS_DATASCRIPT_EVT_DNS_RESP = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VS_DATASCRIPT_EVT_L4_REQUEST")]
        VS_DATASCRIPT_EVT_L4_REQUEST = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VS_DATASCRIPT_EVT_L4_RESPONSE")]
        VS_DATASCRIPT_EVT_L4_RESPONSE = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VS_DATASCRIPT_EVT_MAX")]
        VS_DATASCRIPT_EVT_MAX = 15,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBPathMatchMatch_case
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SENSITIVE")]
        SENSITIVE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INSENSITIVE")]
        INSENSITIVE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBPathMatchMatch_criteria
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BEGINS_WITH")]
        BEGINS_WITH = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOES_NOT_BEGIN_WITH")]
        DOES_NOT_BEGIN_WITH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONTAINS")]
        CONTAINS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOES_NOT_CONTAIN")]
        DOES_NOT_CONTAIN = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ENDS_WITH")]
        ENDS_WITH = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOES_NOT_END_WITH")]
        DOES_NOT_END_WITH = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EQUALS")]
        EQUALS = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOES_NOT_EQUAL")]
        DOES_NOT_EQUAL = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGEX_MATCH")]
        REGEX_MATCH = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGEX_DOES_NOT_MATCH")]
        REGEX_DOES_NOT_MATCH = 9,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyInterfaceOspfConfigNetwork_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BROADCAST")]
        BROADCAST = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"P2P")]
        P2P = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyNatNat_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INTERNAL")]
        INTERNAL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"USER")]
        USER = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NAT64")]
        NAT64 = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum BgpRouteFilteringAddress_family
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IPV4")]
        IPV4 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IPV6")]
        IPV6 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"L2VPN_EVPN")]
        L2VPN_EVPN = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBHttpResponseHeaderConditionMatch_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"STARTS_WITH")]
        STARTS_WITH = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ENDS_WITH")]
        ENDS_WITH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EQUALS")]
        EQUALS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONTAINS")]
        CONTAINS = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGEX")]
        REGEX = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBCompressionProfileType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AUTO_COMPRESSION")]
        AUTO_COMPRESSION = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CUSTOM_COMPRESSION")]
        CUSTOM_COMPRESSION = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBReplaceStringVarType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DATASCRIPT_VAR")]
        DATASCRIPT_VAR = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_HEADER_VAR")]
        HTTP_HEADER_VAR = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LITERAL_STRING")]
        LITERAL_STRING = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBSSLKeyAndCertificateStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_CERTIFICATE_FINISHED")]
        SSL_CERTIFICATE_FINISHED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_CERTIFICATE_PENDING")]
        SSL_CERTIFICATE_PENDING = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBSSLKeyAndCertificateType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_CERTIFICATE_TYPE_VIRTUALSERVICE")]
        SSL_CERTIFICATE_TYPE_VIRTUALSERVICE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_CERTIFICATE_TYPE_SYSTEM")]
        SSL_CERTIFICATE_TYPE_SYSTEM = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_CERTIFICATE_TYPE_CA")]
        SSL_CERTIFICATE_TYPE_CA = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBSSLKeyAndCertificateFormat
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_PEM")]
        SSL_PEM = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_PKCS12")]
        SSL_PKCS12 = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBServiceInstanceDetailPerStatusStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"READY")]
        READY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONFLICT")]
        CONFLICT = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOT_READY")]
        NOT_READY = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBWafPolicyMin_confidence
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CONFIDENCE_VERY_HIGH")]
        CONFIDENCE_VERY_HIGH = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONFIDENCE_HIGH")]
        CONFIDENCE_HIGH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONFIDENCE_PROBABLE")]
        CONFIDENCE_PROBABLE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONFIDENCE_LOW")]
        CONFIDENCE_LOW = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONFIDENCE_NONE")]
        CONFIDENCE_NONE = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBWafPolicyParanoia_level
    {
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_PARANOIA_LEVEL_LOW")]
        WAF_PARANOIA_LEVEL_LOW = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_PARANOIA_LEVEL_MEDIUM")]
        WAF_PARANOIA_LEVEL_MEDIUM = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_PARANOIA_LEVEL_HIGH")]
        WAF_PARANOIA_LEVEL_HIGH = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_PARANOIA_LEVEL_EXTREME")]
        WAF_PARANOIA_LEVEL_EXTREME = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBWafPolicyMode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_MODE_DETECTION_ONLY")]
        WAF_MODE_DETECTION_ONLY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_MODE_ENFORCEMENT")]
        WAF_MODE_ENFORCEMENT = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBWafPolicyFailure_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_FAILURE_MODE_OPEN")]
        WAF_FAILURE_MODE_OPEN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_FAILURE_MODE_CLOSED")]
        WAF_FAILURE_MODE_CLOSED = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum RouteAdvertisementRuleAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PERMIT")]
        PERMIT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DENY")]
        DENY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum RouteAdvertisementRulePrefix_operator
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GE")]
        GE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EQ")]
        EQ = 1,
    
    }
    
    /// <summary>Control routes advertised by Tier-1 instance.
    ///   TIER1_STATIC_ROUTES: Advertise all STATIC routes.
    ///   TIER1_CONNECTED: Advertise all subnets configured on connected
    ///   Interfaces and Segments.
    ///   TIER1_NAT: Advertise all NAT IP addresses.
    ///   TIER1_LB_VIP: Advertise all Load-balancer VIPs.
    ///   TIER1_LB_SNAT: Advertise all Loadbalancer SNAT IP addresses.
    ///   TIER1_DNS_FORWARDER_IP: Advertise DNS forwarder source and listener IPs
    ///   TIER1_IPSEC_LOCAL_ENDPOINT: Redistribute IPSec VPN local-endpoint subnets.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Route_advertisement_types
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_STATIC_ROUTES")]
        TIER1_STATIC_ROUTES = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_CONNECTED")]
        TIER1_CONNECTED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_NAT")]
        TIER1_NAT = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_LB_VIP")]
        TIER1_LB_VIP = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_LB_SNAT")]
        TIER1_LB_SNAT = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_DNS_FORWARDER_IP")]
        TIER1_DNS_FORWARDER_IP = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_IPSEC_LOCAL_ENDPOINT")]
        TIER1_IPSEC_LOCAL_ENDPOINT = 6,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum EnforcedStatusNsxTStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNINITIALIZED")]
        UNINITIALIZED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DEGRADED")]
        DEGRADED = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESS")]
        SUCCESS = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILURE")]
        FAILURE = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IN_PROGRESS")]
        IN_PROGRESS = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CustomPolicyLbPersistenceProfilePersistence
    {
        [System.Runtime.Serialization.EnumMember(Value = @"COOKIE")]
        COOKIE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SOURCE_IP")]
        SOURCE_IP = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ExternalIDExpressionMember_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"VirtualMachine")]
        VirtualMachine = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VirtualNetworkInterface")]
        VirtualNetworkInterface = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CloudNativeServiceInstance")]
        CloudNativeServiceInstance = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PhysicalServer")]
        PhysicalServer = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBHttpRequestHeaderConditionMatch_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"STARTS_WITH")]
        STARTS_WITH = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ENDS_WITH")]
        ENDS_WITH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EQUALS")]
        EQUALS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONTAINS")]
        CONTAINS = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGEX")]
        REGEX = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBDnsAttacksOper_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DETECTION")]
        DETECTION = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MITIGATION")]
        MITIGATION = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum DataSourceParametersSource
    {
        [System.Runtime.Serialization.EnumMember(Value = @"realtime")]
        Realtime = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"cached")]
        Cached = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBWafPSMRuleMode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_MODE_DETECTION_ONLY")]
        WAF_MODE_DETECTION_ONLY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_MODE_ENFORCEMENT")]
        WAF_MODE_ENFORCEMENT = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBWafPSMRuleMatch_case
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SENSITIVE")]
        SENSITIVE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INSENSITIVE")]
        INSENSITIVE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBWafPSMRuleParanoia_level
    {
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_PARANOIA_LEVEL_LOW")]
        WAF_PARANOIA_LEVEL_LOW = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_PARANOIA_LEVEL_MEDIUM")]
        WAF_PARANOIA_LEVEL_MEDIUM = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_PARANOIA_LEVEL_HIGH")]
        WAF_PARANOIA_LEVEL_HIGH = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_PARANOIA_LEVEL_EXTREME")]
        WAF_PARANOIA_LEVEL_EXTREME = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBLocationHdrMatchMatch_case
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SENSITIVE")]
        SENSITIVE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INSENSITIVE")]
        INSENSITIVE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBLocationHdrMatchMatch_criteria
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_EXISTS")]
        HDR_EXISTS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_DOES_NOT_EXIST")]
        HDR_DOES_NOT_EXIST = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_BEGINS_WITH")]
        HDR_BEGINS_WITH = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_DOES_NOT_BEGIN_WITH")]
        HDR_DOES_NOT_BEGIN_WITH = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_CONTAINS")]
        HDR_CONTAINS = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_DOES_NOT_CONTAIN")]
        HDR_DOES_NOT_CONTAIN = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_ENDS_WITH")]
        HDR_ENDS_WITH = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_DOES_NOT_END_WITH")]
        HDR_DOES_NOT_END_WITH = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_EQUALS")]
        HDR_EQUALS = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_DOES_NOT_EQUAL")]
        HDR_DOES_NOT_EQUAL = 9,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IdsProfileConjunctionOperatorOperator
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AND")]
        AND = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBPoolGroupDeploymentPolicyScheme
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BLUE_GREEN")]
        BLUE_GREEN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CANARY")]
        CANARY = 1,
    
    }
    
    /// <summary>Valid Group member type</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Results
    {
        [System.Runtime.Serialization.EnumMember(Value = @"VirtualMachine")]
        VirtualMachine = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VirtualNetworkInterface")]
        VirtualNetworkInterface = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SegmentPort")]
        SegmentPort = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Segment")]
        Segment = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CloudNativeServiceInstance")]
        CloudNativeServiceInstance = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IPAddress")]
        IPAddress = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MACAddress")]
        MACAddress = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IPSet")]
        IPSet = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IdentityGroup")]
        IdentityGroup = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PhysicalServer")]
        PhysicalServer = 9,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBOCSPConfigUrl_action
    {
        [System.Runtime.Serialization.EnumMember(Value = @"OCSP_RESPONDER_URL_FAILOVER")]
        OCSP_RESPONDER_URL_FAILOVER = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OCSP_RESPONDER_URL_OVERRIDE")]
        OCSP_RESPONDER_URL_OVERRIDE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TcpMaximumSegmentSizeClampingDirection
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NONE")]
        NONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INBOUND_CONNECTION")]
        INBOUND_CONNECTION = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OUTBOUND_CONNECTION")]
        OUTBOUND_CONNECTION = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BOTH")]
        BOTH = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALGTypeServiceEntryAlg
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ORACLE_TNS")]
        ORACLE_TNS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FTP")]
        FTP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUN_RPC_TCP")]
        SUN_RPC_TCP = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUN_RPC_UDP")]
        SUN_RPC_UDP = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MS_RPC_TCP")]
        MS_RPC_TCP = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MS_RPC_UDP")]
        MS_RPC_UDP = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NBNS_BROADCAST")]
        NBNS_BROADCAST = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NBDG_BROADCAST")]
        NBDG_BROADCAST = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TFTP")]
        TFTP = 8,
    
    }
    
    /// <summary>Valid ENUM values for ALBHTTPMethod</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Allowed_methods
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_GET")]
        HTTP_METHOD_GET = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_HEAD")]
        HTTP_METHOD_HEAD = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_PUT")]
        HTTP_METHOD_PUT = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_DELETE")]
        HTTP_METHOD_DELETE = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_POST")]
        HTTP_METHOD_POST = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_OPTIONS")]
        HTTP_METHOD_OPTIONS = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_TRACE")]
        HTTP_METHOD_TRACE = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_CONNECT")]
        HTTP_METHOD_CONNECT = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_PATCH")]
        HTTP_METHOD_PATCH = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_PROPFIND")]
        HTTP_METHOD_PROPFIND = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_PROPPATCH")]
        HTTP_METHOD_PROPPATCH = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_MKCOL")]
        HTTP_METHOD_MKCOL = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_COPY")]
        HTTP_METHOD_COPY = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_MOVE")]
        HTTP_METHOD_MOVE = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_LOCK")]
        HTTP_METHOD_LOCK = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_UNLOCK")]
        HTTP_METHOD_UNLOCK = 15,
    
    }
    
    /// <summary>Valid ENUM values for ALBHTTPVersion</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Allowed_http_versions
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ZERO_NINE")]
        ZERO_NINE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ONE_ZERO")]
        ONE_ZERO = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ONE_ONE")]
        ONE_ONE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TWO_ZERO")]
        TWO_ZERO = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBWafConfigStatus_code_for_rejected_requests
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_0")]
        HTTP_RESPONSE_CODE_0 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_100")]
        HTTP_RESPONSE_CODE_100 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_101")]
        HTTP_RESPONSE_CODE_101 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_200")]
        HTTP_RESPONSE_CODE_200 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_201")]
        HTTP_RESPONSE_CODE_201 = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_202")]
        HTTP_RESPONSE_CODE_202 = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_203")]
        HTTP_RESPONSE_CODE_203 = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_204")]
        HTTP_RESPONSE_CODE_204 = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_205")]
        HTTP_RESPONSE_CODE_205 = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_206")]
        HTTP_RESPONSE_CODE_206 = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_300")]
        HTTP_RESPONSE_CODE_300 = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_301")]
        HTTP_RESPONSE_CODE_301 = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_302")]
        HTTP_RESPONSE_CODE_302 = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_303")]
        HTTP_RESPONSE_CODE_303 = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_304")]
        HTTP_RESPONSE_CODE_304 = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_305")]
        HTTP_RESPONSE_CODE_305 = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_307")]
        HTTP_RESPONSE_CODE_307 = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_400")]
        HTTP_RESPONSE_CODE_400 = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_401")]
        HTTP_RESPONSE_CODE_401 = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_402")]
        HTTP_RESPONSE_CODE_402 = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_403")]
        HTTP_RESPONSE_CODE_403 = 20,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_404")]
        HTTP_RESPONSE_CODE_404 = 21,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_405")]
        HTTP_RESPONSE_CODE_405 = 22,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_406")]
        HTTP_RESPONSE_CODE_406 = 23,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_407")]
        HTTP_RESPONSE_CODE_407 = 24,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_408")]
        HTTP_RESPONSE_CODE_408 = 25,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_409")]
        HTTP_RESPONSE_CODE_409 = 26,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_410")]
        HTTP_RESPONSE_CODE_410 = 27,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_411")]
        HTTP_RESPONSE_CODE_411 = 28,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_412")]
        HTTP_RESPONSE_CODE_412 = 29,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_413")]
        HTTP_RESPONSE_CODE_413 = 30,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_414")]
        HTTP_RESPONSE_CODE_414 = 31,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_415")]
        HTTP_RESPONSE_CODE_415 = 32,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_416")]
        HTTP_RESPONSE_CODE_416 = 33,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_417")]
        HTTP_RESPONSE_CODE_417 = 34,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_426")]
        HTTP_RESPONSE_CODE_426 = 35,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_470")]
        HTTP_RESPONSE_CODE_470 = 36,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_475")]
        HTTP_RESPONSE_CODE_475 = 37,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_500")]
        HTTP_RESPONSE_CODE_500 = 38,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_501")]
        HTTP_RESPONSE_CODE_501 = 39,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_502")]
        HTTP_RESPONSE_CODE_502 = 40,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_503")]
        HTTP_RESPONSE_CODE_503 = 41,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_504")]
        HTTP_RESPONSE_CODE_504 = 42,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_CODE_505")]
        HTTP_RESPONSE_CODE_505 = 43,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TraceResultDirection
    {
        [System.Runtime.Serialization.EnumMember(Value = @"FORWARD")]
        FORWARD = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BACKWARD")]
        BACKWARD = 1,
    
    }
    
    /// <summary>Represents the internal categories.
    /// APPLICATION : IDS signature having protocol comes under APPLICATION internal category.
    /// MALWARE: IDS signature having malware_family comes under this internal category.
    /// VULNERABILITY : IDS signature having cvssv3 score comes under this internal category.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Categories
    {
        [System.Runtime.Serialization.EnumMember(Value = @"APPLICATION")]
        APPLICATION = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MALWARE")]
        MALWARE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VULNERABILITY")]
        VULNERABILITY = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IdsSignatureCvss
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NONE")]
        NONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOW")]
        LOW = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MEDIUM")]
        MEDIUM = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HIGH")]
        HIGH = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CRITICAL")]
        CRITICAL = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PathPermissionGroupOperation
    {
        [System.Runtime.Serialization.EnumMember(Value = @"crud")]
        Crud = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"read")]
        Read = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"execute")]
        Execute = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"none")]
        None = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyRealizedResourceState
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNAVAILABLE")]
        UNAVAILABLE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNREALIZED")]
        UNREALIZED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REALIZED")]
        REALIZED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBProtocolMatchProtocols
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP")]
        HTTP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTPS")]
        HTTPS = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBProtocolMatchMatch_criteria
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IS_IN")]
        IS_IN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IS_NOT_IN")]
        IS_NOT_IN = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBDnsRecordAlgorithm
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_RESPONSE_ROUND_ROBIN")]
        DNS_RECORD_RESPONSE_ROUND_ROBIN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_RESPONSE_CONSISTENT_HASH")]
        DNS_RECORD_RESPONSE_CONSISTENT_HASH = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBDnsRecordType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_OTHER")]
        DNS_RECORD_OTHER = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_A")]
        DNS_RECORD_A = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_NS")]
        DNS_RECORD_NS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_CNAME")]
        DNS_RECORD_CNAME = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_SOA")]
        DNS_RECORD_SOA = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_PTR")]
        DNS_RECORD_PTR = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_HINFO")]
        DNS_RECORD_HINFO = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_MX")]
        DNS_RECORD_MX = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_TXT")]
        DNS_RECORD_TXT = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_RP")]
        DNS_RECORD_RP = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_DNSKEY")]
        DNS_RECORD_DNSKEY = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_AAAA")]
        DNS_RECORD_AAAA = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_SRV")]
        DNS_RECORD_SRV = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_OPT")]
        DNS_RECORD_OPT = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_RRSIG")]
        DNS_RECORD_RRSIG = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_AXFR")]
        DNS_RECORD_AXFR = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_ANY")]
        DNS_RECORD_ANY = 16,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBSSLClientRequestHeaderRequest_header_value
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_CLIENT_IP")]
        HTTP_POLICY_VAR_CLIENT_IP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_VS_PORT")]
        HTTP_POLICY_VAR_VS_PORT = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_VS_IP")]
        HTTP_POLICY_VAR_VS_IP = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_HTTP_HDR")]
        HTTP_POLICY_VAR_HTTP_HDR = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_SSL_CLIENT_FINGERPRINT")]
        HTTP_POLICY_VAR_SSL_CLIENT_FINGERPRINT = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_SSL_CLIENT_SERIAL")]
        HTTP_POLICY_VAR_SSL_CLIENT_SERIAL = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_SSL_CLIENT_ISSUER")]
        HTTP_POLICY_VAR_SSL_CLIENT_ISSUER = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_SSL_CLIENT_SUBJECT")]
        HTTP_POLICY_VAR_SSL_CLIENT_SUBJECT = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_SSL_CLIENT_RAW")]
        HTTP_POLICY_VAR_SSL_CLIENT_RAW = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_SSL_PROTOCOL")]
        HTTP_POLICY_VAR_SSL_PROTOCOL = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_SSL_SERVER_NAME")]
        HTTP_POLICY_VAR_SSL_SERVER_NAME = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_USER_NAME")]
        HTTP_POLICY_VAR_USER_NAME = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_SSL_CIPHER")]
        HTTP_POLICY_VAR_SSL_CIPHER = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_REQUEST_ID")]
        HTTP_POLICY_VAR_REQUEST_ID = 13,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBDosThresholdAttack
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LAND")]
        LAND = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SMURF")]
        SMURF = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ICMP_PING_FLOOD")]
        ICMP_PING_FLOOD = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKOWN_PROTOCOL")]
        UNKOWN_PROTOCOL = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TEARDROP")]
        TEARDROP = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IP_FRAG_OVERRUN")]
        IP_FRAG_OVERRUN = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IP_FRAG_TOOSMALL")]
        IP_FRAG_TOOSMALL = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IP_FRAG_FULL")]
        IP_FRAG_FULL = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IP_FRAG_INCOMPLETE")]
        IP_FRAG_INCOMPLETE = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PORT_SCAN")]
        PORT_SCAN = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TCP_NON_SYN_FLOOD_OLD")]
        TCP_NON_SYN_FLOOD_OLD = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SYN_FLOOD")]
        SYN_FLOOD = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BAD_RST_FLOOD")]
        BAD_RST_FLOOD = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MALFORMED_FLOOD")]
        MALFORMED_FLOOD = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAKE_SESSION")]
        FAKE_SESSION = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ZERO_WINDOW_STRESS")]
        ZERO_WINDOW_STRESS = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SMALL_WINDOW_STRESS")]
        SMALL_WINDOW_STRESS = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_HTTP_TIMEOUT")]
        DOS_HTTP_TIMEOUT = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_HTTP_ERROR")]
        DOS_HTTP_ERROR = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_HTTP_ABORT")]
        DOS_HTTP_ABORT = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_SSL_ERROR")]
        DOS_SSL_ERROR = 20,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_APP_ERROR")]
        DOS_APP_ERROR = 21,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_REQ_IP_RL_DROP")]
        DOS_REQ_IP_RL_DROP = 22,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_REQ_URI_RL_DROP")]
        DOS_REQ_URI_RL_DROP = 23,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_REQ_URI_SCAN_BAD_RL_DROP")]
        DOS_REQ_URI_SCAN_BAD_RL_DROP = 24,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_REQ_URI_SCAN_UNKNOWN_RL_DROP")]
        DOS_REQ_URI_SCAN_UNKNOWN_RL_DROP = 25,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_REQ_IP_URI_RL_DROP")]
        DOS_REQ_IP_URI_RL_DROP = 26,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_CONN_IP_RL_DROP")]
        DOS_CONN_IP_RL_DROP = 27,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_SLOW_URL")]
        DOS_SLOW_URL = 28,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TCP_NON_SYN_FLOOD")]
        TCP_NON_SYN_FLOOD = 29,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_REQ_CIP_SCAN_BAD_RL_DROP")]
        DOS_REQ_CIP_SCAN_BAD_RL_DROP = 30,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_REQ_CIP_SCAN_UNKNOWN_RL_DROP")]
        DOS_REQ_CIP_SCAN_UNKNOWN_RL_DROP = 31,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_REQ_IP_RL_DROP_BAD")]
        DOS_REQ_IP_RL_DROP_BAD = 32,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_REQ_URI_RL_DROP_BAD")]
        DOS_REQ_URI_RL_DROP_BAD = 33,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_REQ_IP_URI_RL_DROP_BAD")]
        DOS_REQ_IP_URI_RL_DROP_BAD = 34,
    
        [System.Runtime.Serialization.EnumMember(Value = @"POLICY_DROPS")]
        POLICY_DROPS = 35,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_CONN_RL_DROP")]
        DOS_CONN_RL_DROP = 36,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_REQ_RL_DROP")]
        DOS_REQ_RL_DROP = 37,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_REQ_HDR_RL_DROP")]
        DOS_REQ_HDR_RL_DROP = 38,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOS_REQ_CUSTOM_RL_DROP")]
        DOS_REQ_CUSTOM_RL_DROP = 39,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_ATTACK_REFLECTION")]
        DNS_ATTACK_REFLECTION = 40,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TraceflowObservationReceivedLogicalSrc_component_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PHYSICAL")]
        PHYSICAL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LR")]
        LR = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LS")]
        LS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DFW")]
        DFW = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BRIDGE")]
        BRIDGE = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE_TUNNEL")]
        EDGE_TUNNEL = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE_HOSTSWITCH")]
        EDGE_HOSTSWITCH = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FW_BRIDGE")]
        FW_BRIDGE = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOAD_BALANCER")]
        LOAD_BALANCER = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NAT")]
        NAT = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IPSEC")]
        IPSEC = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SERVICE_INSERTION")]
        SERVICE_INSERTION = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VMC")]
        VMC = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SPOOFGUARD")]
        SPOOFGUARD = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE_FW")]
        EDGE_FW = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DLB")]
        DLB = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 16,
    
    }
    
    /// <summary>Valid ENUM values for ALBHTTPMethod</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Methods
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_GET")]
        HTTP_METHOD_GET = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_HEAD")]
        HTTP_METHOD_HEAD = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_PUT")]
        HTTP_METHOD_PUT = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_DELETE")]
        HTTP_METHOD_DELETE = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_POST")]
        HTTP_METHOD_POST = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_OPTIONS")]
        HTTP_METHOD_OPTIONS = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_TRACE")]
        HTTP_METHOD_TRACE = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_CONNECT")]
        HTTP_METHOD_CONNECT = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_PATCH")]
        HTTP_METHOD_PATCH = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_PROPFIND")]
        HTTP_METHOD_PROPFIND = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_PROPPATCH")]
        HTTP_METHOD_PROPPATCH = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_MKCOL")]
        HTTP_METHOD_MKCOL = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_COPY")]
        HTTP_METHOD_COPY = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_MOVE")]
        HTTP_METHOD_MOVE = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_LOCK")]
        HTTP_METHOD_LOCK = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_METHOD_UNLOCK")]
        HTTP_METHOD_UNLOCK = 15,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBMethodMatchMatch_criteria
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IS_IN")]
        IS_IN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IS_NOT_IN")]
        IS_NOT_IN = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PortAttachmentAllocate_addresses
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IP_POOL")]
        IP_POOL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MAC_POOL")]
        MAC_POOL = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BOTH")]
        BOTH = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NONE")]
        NONE = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DHCP")]
        DHCP = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PortAttachmentHyperbus_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ENABLE")]
        ENABLE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DISABLE")]
        DISABLE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PortAttachmentContext_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PARENT")]
        PARENT = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PortAttachmentType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PARENT")]
        PARENT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CHILD")]
        CHILD = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INDEPENDENT")]
        INDEPENDENT = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STATIC")]
        STATIC = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBDnsRuleDnsRrSetSection
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_MESSAGE_SECTION_QUESTION")]
        DNS_MESSAGE_SECTION_QUESTION = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_MESSAGE_SECTION_ANSWER")]
        DNS_MESSAGE_SECTION_ANSWER = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_MESSAGE_SECTION_AUTHORITY")]
        DNS_MESSAGE_SECTION_AUTHORITY = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_MESSAGE_SECTION_ADDITIONAL")]
        DNS_MESSAGE_SECTION_ADDITIONAL = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PktCapResultTransport_node_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ESX")]
        ESX = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RHELKVM")]
        RHELKVM = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UBUNTUKVM")]
        UBUNTUKVM = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CENTOSKVM")]
        CENTOSKVM = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RHELCONTAINER")]
        RHELCONTAINER = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CENTOSCONTAINER")]
        CENTOSCONTAINER = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RHELSERVER")]
        RHELSERVER = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UBUNTUSERVER")]
        UBUNTUSERVER = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CENTOSSERVER")]
        CENTOSSERVER = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SLESKVM")]
        SLESKVM = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SLESSERVER")]
        SLESSERVER = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WINDOWSSERVER")]
        WINDOWSSERVER = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RHELSMARTNIC")]
        RHELSMARTNIC = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OELSERVER")]
        OELSERVER = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UBUNTUSMARTNIC")]
        UBUNTUSMARTNIC = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE")]
        EDGE = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PUBLIC_CLOUD_GATEWAY_NODE")]
        PUBLIC_CLOUD_GATEWAY_NODE = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OTHERS")]
        OTHERS = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HYPERV")]
        HYPERV = 18,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TraceflowObservationDeliveredResolution_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ARP_SUPPRESSION_PORT_CACHE")]
        ARP_SUPPRESSION_PORT_CACHE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ARP_SUPPRESSION_TABLE")]
        ARP_SUPPRESSION_TABLE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ARP_SUPPRESSION_CP_QUERY")]
        ARP_SUPPRESSION_CP_QUERY = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ARP_VM")]
        ARP_VM = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyMetadataProxyStatusProxy_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_BACKUP")]
        NO_BACKUP = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyServiceProfileRedirection_action
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PUNT")]
        PUNT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"COPY")]
        COPY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum L2TcpMaxSegmentSizeClampingDirection
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NONE")]
        NONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BOTH")]
        BOTH = 1,
    
    }
    
    /// <summary>Valid ENUM values for ALBAnalyticsProfileRespCodeBlock</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Resp_code_block
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AP_HTTP_RSP_4XX")]
        AP_HTTP_RSP_4XX = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AP_HTTP_RSP_5XX")]
        AP_HTTP_RSP_5XX = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBApplicationProfileType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"APPLICATION_PROFILE_TYPE_L4")]
        APPLICATION_PROFILE_TYPE_L4 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"APPLICATION_PROFILE_TYPE_HTTP")]
        APPLICATION_PROFILE_TYPE_HTTP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"APPLICATION_PROFILE_TYPE_SYSLOG")]
        APPLICATION_PROFILE_TYPE_SYSLOG = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"APPLICATION_PROFILE_TYPE_DNS")]
        APPLICATION_PROFILE_TYPE_DNS = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"APPLICATION_PROFILE_TYPE_SSL")]
        APPLICATION_PROFILE_TYPE_SSL = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"APPLICATION_PROFILE_TYPE_SIP")]
        APPLICATION_PROFILE_TYPE_SIP = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum L3VpnContextIke_log_level
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DEBUG")]
        DEBUG = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INFO")]
        INFO = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARN")]
        WARN = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EMERGENCY")]
        EMERGENCY = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ConditionalValueConstraintExpressionOperator
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INCLUDES")]
        INCLUDES = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXCLUDES")]
        EXCLUDES = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EQUALS")]
        EQUALS = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IdfwComputeCollectionConditionStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DFW_DISABLED")]
        DFW_DISABLED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IDFW_DISABLED")]
        IDFW_DISABLED = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CustomPolicyLbVirtualServerApp_protocol
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TCP")]
        TCP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UDP")]
        UDP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP")]
        HTTP = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTPS")]
        HTTPS = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CustomPolicyLbVirtualServerClient_ssl_settings
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BASE_SECURE_111317")]
        BASE_SECURE_111317 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MODERATE_SECURE_111317")]
        MODERATE_SECURE_111317 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HIGH_SECURE_111317")]
        HIGH_SECURE_111317 = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CustomPolicyLbVirtualServerServer_ssl_settings
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BASE_SECURE_111317")]
        BASE_SECURE_111317 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MODERATE_SECURE_111317")]
        MODERATE_SECURE_111317 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HIGH_SECURE_111317")]
        HIGH_SECURE_111317 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DISABLED")]
        DISABLED = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBSSLKeyParamsAlgorithm
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_KEY_ALGORITHM_RSA")]
        SSL_KEY_ALGORITHM_RSA = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_KEY_ALGORITHM_EC")]
        SSL_KEY_ALGORITHM_EC = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IdsProfileSeveritySeverity
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CRITICAL")]
        CRITICAL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HIGH")]
        HIGH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MEDIUM")]
        MEDIUM = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOW")]
        LOW = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum AbstractSpaceConnectivity_strategy
    {
        [System.Runtime.Serialization.EnumMember(Value = @"WHITELIST")]
        WHITELIST = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BLACKLIST")]
        BLACKLIST = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WHITELIST_ENABLE_LOGGING")]
        WHITELIST_ENABLE_LOGGING = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BLACKLIST_ENABLE_LOGGING")]
        BLACKLIST_ENABLE_LOGGING = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NONE")]
        NONE = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyServiceInstanceFailure_policy
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALLOW")]
        ALLOW = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BLOCK")]
        BLOCK = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBServerSslProfileCipher_group_label
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BALANCED")]
        BALANCED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HIGH_SECURITY")]
        HIGH_SECURITY = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HIGH_COMPATIBILITY")]
        HIGH_COMPATIBILITY = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CUSTOM")]
        CUSTOM = 3,
    
    }
    
    /// <summary>SSL cipher</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Ciphers
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_256_CBC_SHA")]
        TLS_RSA_WITH_AES_256_CBC_SHA = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_128_CBC_SHA")]
        TLS_RSA_WITH_AES_128_CBC_SHA = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_3DES_EDE_CBC_SHA")]
        TLS_RSA_WITH_3DES_EDE_CBC_SHA = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_128_CBC_SHA256")]
        TLS_RSA_WITH_AES_128_CBC_SHA256 = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_128_GCM_SHA256")]
        TLS_RSA_WITH_AES_128_GCM_SHA256 = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_256_CBC_SHA256")]
        TLS_RSA_WITH_AES_256_CBC_SHA256 = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_256_GCM_SHA384")]
        TLS_RSA_WITH_AES_256_GCM_SHA384 = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = 20,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = 21,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = 22,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = 23,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = 24,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = 25,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = 26,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = 27,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = 28,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = 29,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = 30,
    
    }
    
    /// <summary>SSL protocol</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Protocols
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_V2")]
        SSL_V2 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_V3")]
        SSL_V3 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_V1")]
        TLS_V1 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_V1_1")]
        TLS_V1_1 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_V1_2")]
        TLS_V1_2 = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SVMDeploymentSpecService_form_factor
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SMALL")]
        SMALL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MEDIUM")]
        MEDIUM = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LARGE")]
        LARGE = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SVMDeploymentSpecHost_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ESXI")]
        ESXI = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RHELKVM")]
        RHELKVM = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UBUNTUKVM")]
        UBUNTUKVM = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBSourceIpPersistenceProfilePurge
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NO_PURGE")]
        NO_PURGE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FULL")]
        FULL = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBNodeCountPerSeveritySeverity
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GREEN")]
        GREEN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ORANGE")]
        ORANGE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RED")]
        RED = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBL4RulePortMatchMatch_criteria
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IS_IN")]
        IS_IN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IS_NOT_IN")]
        IS_NOT_IN = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBErrorPageBodyFormat
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR_PAGE_FORMAT_HTML")]
        ERROR_PAGE_FORMAT_HTML = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR_PAGE_FORMAT_JSON")]
        ERROR_PAGE_FORMAT_JSON = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHTTPRedirectActionProtocol
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP")]
        HTTP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTPS")]
        HTTPS = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHTTPRedirectActionStatus_code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_REDIRECT_STATUS_CODE_301")]
        HTTP_REDIRECT_STATUS_CODE_301 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_REDIRECT_STATUS_CODE_302")]
        HTTP_REDIRECT_STATUS_CODE_302 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_REDIRECT_STATUS_CODE_307")]
        HTTP_REDIRECT_STATUS_CODE_307 = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBDnsRuleActionResponseRcode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RCODE_NOERROR")]
        DNS_RCODE_NOERROR = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RCODE_FORMERR")]
        DNS_RCODE_FORMERR = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RCODE_SERVFAIL")]
        DNS_RCODE_SERVFAIL = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RCODE_NXDOMAIN")]
        DNS_RCODE_NXDOMAIN = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RCODE_NOTIMP")]
        DNS_RCODE_NOTIMP = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RCODE_REFUSED")]
        DNS_RCODE_REFUSED = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RCODE_YXDOMAIN")]
        DNS_RCODE_YXDOMAIN = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RCODE_YXRRSET")]
        DNS_RCODE_YXRRSET = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RCODE_NXRRSET")]
        DNS_RCODE_NXRRSET = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RCODE_NOTAUTH")]
        DNS_RCODE_NOTAUTH = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RCODE_NOTZONE")]
        DNS_RCODE_NOTZONE = 10,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IPSecVpnSessionConnection_initiation_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INITIATOR")]
        INITIATOR = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RESPOND_ONLY")]
        RESPOND_ONLY = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ON_DEMAND")]
        ON_DEMAND = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IPSecVpnSessionCompliance_suite
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CNSA")]
        CNSA = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUITE_B_GCM_128")]
        SUITE_B_GCM_128 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUITE_B_GCM_256")]
        SUITE_B_GCM_256 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PRIME")]
        PRIME = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FOUNDATION")]
        FOUNDATION = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FIPS")]
        FIPS = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NONE")]
        NONE = 6,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IPSecVpnSessionAuthentication_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PSK")]
        PSK = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CERTIFICATE")]
        CERTIFICATE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OspfAuthenticationConfigMode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NONE")]
        NONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PASSWORD")]
        PASSWORD = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MD5")]
        MD5 = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FullSyncStateLast_completed_stage
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INITIAL")]
        INITIAL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PAUSE_DCNS")]
        PAUSE_DCNS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DELETED_STALE_ENTITIES")]
        DELETED_STALE_ENTITIES = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PROCESSED_FULLSYNC_DATA")]
        PROCESSED_FULLSYNC_DATA = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PROCESSED_DELTAS")]
        PROCESSED_DELTAS = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNPAUSE_DCNS")]
        UNPAUSE_DCNS = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"COMPLETED")]
        COMPLETED = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ABORTED")]
        ABORTED = 8,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHealthMonitorType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HEALTH_MONITOR_PING")]
        HEALTH_MONITOR_PING = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HEALTH_MONITOR_TCP")]
        HEALTH_MONITOR_TCP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HEALTH_MONITOR_HTTP")]
        HEALTH_MONITOR_HTTP = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HEALTH_MONITOR_HTTPS")]
        HEALTH_MONITOR_HTTPS = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HEALTH_MONITOR_EXTERNAL")]
        HEALTH_MONITOR_EXTERNAL = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HEALTH_MONITOR_UDP")]
        HEALTH_MONITOR_UDP = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HEALTH_MONITOR_DNS")]
        HEALTH_MONITOR_DNS = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HEALTH_MONITOR_GSLB")]
        HEALTH_MONITOR_GSLB = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HEALTH_MONITOR_SIP")]
        HEALTH_MONITOR_SIP = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HEALTH_MONITOR_RADIUS")]
        HEALTH_MONITOR_RADIUS = 9,
    
    }
    
    /// <summary>Valid ENUM values for ALBHTTPVersion</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Versions
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ZERO_NINE")]
        ZERO_NINE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ONE_ZERO")]
        ONE_ZERO = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ONE_ONE")]
        ONE_ONE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TWO_ZERO")]
        TWO_ZERO = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHTTPVersionMatchMatch_criteria
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IS_IN")]
        IS_IN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IS_NOT_IN")]
        IS_NOT_IN = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum InterfaceIPv6DADStatusStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DUPLICATED")]
        DUPLICATED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TENTATIVE")]
        TENTATIVE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ASSIGNED")]
        ASSIGNED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOT_APPLICABLE")]
        NOT_APPLICABLE = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum VmToolsInfoVm_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE")]
        EDGE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SERVICE")]
        SERVICE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGULAR")]
        REGULAR = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHealthMonitorDNSRcode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"RCODE_NO_ERROR")]
        RCODE_NO_ERROR = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RCODE_ANYTHING")]
        RCODE_ANYTHING = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHealthMonitorDNSQtype
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_QUERY_TYPE")]
        DNS_QUERY_TYPE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_ANY_TYPE")]
        DNS_ANY_TYPE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_ANY_THING")]
        DNS_ANY_THING = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHealthMonitorDNSRecord_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_OTHER")]
        DNS_RECORD_OTHER = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_A")]
        DNS_RECORD_A = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_NS")]
        DNS_RECORD_NS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_CNAME")]
        DNS_RECORD_CNAME = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_SOA")]
        DNS_RECORD_SOA = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_PTR")]
        DNS_RECORD_PTR = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_HINFO")]
        DNS_RECORD_HINFO = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_MX")]
        DNS_RECORD_MX = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_TXT")]
        DNS_RECORD_TXT = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_RP")]
        DNS_RECORD_RP = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_DNSKEY")]
        DNS_RECORD_DNSKEY = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_AAAA")]
        DNS_RECORD_AAAA = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_SRV")]
        DNS_RECORD_SRV = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_OPT")]
        DNS_RECORD_OPT = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_RRSIG")]
        DNS_RECORD_RRSIG = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_AXFR")]
        DNS_RECORD_AXFR = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_RECORD_ANY")]
        DNS_RECORD_ANY = 16,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LogicalRouterStatusPerNodeHigh_availability_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ACTIVE")]
        ACTIVE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STANDBY")]
        STANDBY = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SYNC")]
        SYNC = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ADMIN_DOWN")]
        ADMIN_DOWN = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LayoutType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HORIZONTAL")]
        HORIZONTAL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VERTICAL")]
        VERTICAL = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GRID")]
        GRID = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Destinations
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BGP")]
        BGP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OSPF")]
        OSPF = 1,
    
    }
    
    /// <summary>Tier-0 route redistribution types.
    /// 
    ///   TIER0_STATIC: Redistribute user added static routes.
    ///   TIER0_CONNECTED: Redistribute all subnets configured on Interfaces and
    ///   routes related to TIER0_ROUTER_LINK, TIER0_SEGMENT,
    ///   TIER0_DNS_FORWARDER_IP, TIER0_IPSEC_LOCAL_IP, TIER0_NAT types.
    ///   TIER1_STATIC: Redistribute all subnets and static routes advertised
    ///   by Tier-1s.
    ///   TIER0_EXTERNAL_INTERFACE: Redistribute external interface subnets
    ///   on Tier-0.
    ///   TIER0_LOOPBACK_INTERFACE: Redistribute loopback interface subnets
    ///   on Tier-0.
    ///   TIER0_SEGMENT: Redistribute subnets configured on Segments connected
    ///   to Tier-0.
    ///   TIER0_ROUTER_LINK: Redistribute router link port subnets on Tier-0
    ///   TIER0_SERVICE_INTERFACE: Redistribute Tier0 service interface subnets.
    ///   TIER0_DNS_FORWARDER_IP: Redistribute DNS forwarder subnets.
    ///   TIER0_IPSEC_LOCAL_IP: Redistribute IPSec subnets.
    ///   TIER0_NAT: Redistribute NAT IPs owned by Tier-0.
    ///   TIER0_EVPN_TEP_IP: Redistribute EVPN local endpoint subnets on Tier-0.
    ///   TIER1_NAT: Redistribute NAT IPs advertised by Tier-1 instances.
    ///   TIER1_LB_VIP: Redistribute LB VIP IPs advertised by Tier-1 instances.
    ///   TIER1_LB_SNAT: Redistribute LB SNAT IPs advertised by Tier-1 instances.
    ///   TIER1_DNS_FORWARDER_IP: Redistribute DNS forwarder subnets on Tier-1
    ///   instances.
    ///   TIER1_CONNECTED: Redistribute all subnets configured on Segments and
    ///   Service Interfaces.
    ///   TIER1_SERVICE_INTERFACE: Redistribute Tier1 service interface subnets.
    ///   TIER1_SEGMENT: Redistribute subnets configured on Segments connected
    ///   to Tier1.
    ///   TIER1_IPSEC_LOCAL_ENDPOINT: Redistribute IPSec VPN local-endpoint
    ///   subnets advertised by TIER1.
    /// 
    /// 
    ///   Route redistribution destination is BGP.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Route_redistribution_types
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_STATIC")]
        TIER0_STATIC = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_CONNECTED")]
        TIER0_CONNECTED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_EXTERNAL_INTERFACE")]
        TIER0_EXTERNAL_INTERFACE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_SEGMENT")]
        TIER0_SEGMENT = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_ROUTER_LINK")]
        TIER0_ROUTER_LINK = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_SERVICE_INTERFACE")]
        TIER0_SERVICE_INTERFACE = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_LOOPBACK_INTERFACE")]
        TIER0_LOOPBACK_INTERFACE = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_DNS_FORWARDER_IP")]
        TIER0_DNS_FORWARDER_IP = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_IPSEC_LOCAL_IP")]
        TIER0_IPSEC_LOCAL_IP = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_NAT")]
        TIER0_NAT = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_EVPN_TEP_IP")]
        TIER0_EVPN_TEP_IP = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_NAT")]
        TIER1_NAT = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_STATIC")]
        TIER1_STATIC = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_LB_VIP")]
        TIER1_LB_VIP = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_LB_SNAT")]
        TIER1_LB_SNAT = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_DNS_FORWARDER_IP")]
        TIER1_DNS_FORWARDER_IP = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_CONNECTED")]
        TIER1_CONNECTED = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_SERVICE_INTERFACE")]
        TIER1_SERVICE_INTERFACE = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_SEGMENT")]
        TIER1_SEGMENT = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_IPSEC_LOCAL_ENDPOINT")]
        TIER1_IPSEC_LOCAL_ENDPOINT = 19,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum L2VPNTunnelEncapsulationProtocol
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GRE")]
        GRE = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum GlobalRestoreStatusValue
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INITIAL")]
        INITIAL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESS")]
        SUCCESS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILED")]
        FAILED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RUNNING")]
        RUNNING = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUSPENDED_BY_USER")]
        SUSPENDED_BY_USER = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUSPENDED_FOR_USER_ACTION")]
        SUSPENDED_FOR_USER_ACTION = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUSPENDED")]
        SUSPENDED = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ABORTED")]
        ABORTED = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum RouteMapEntryAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PERMIT")]
        PERMIT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DENY")]
        DENY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OspfAreaConfigArea_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NORMAL")]
        NORMAL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NSSA")]
        NSSA = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBRateLimiterActionStatus_code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_LOCAL_RESPONSE_STATUS_CODE_200")]
        HTTP_LOCAL_RESPONSE_STATUS_CODE_200 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_LOCAL_RESPONSE_STATUS_CODE_204")]
        HTTP_LOCAL_RESPONSE_STATUS_CODE_204 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_LOCAL_RESPONSE_STATUS_CODE_403")]
        HTTP_LOCAL_RESPONSE_STATUS_CODE_403 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_LOCAL_RESPONSE_STATUS_CODE_404")]
        HTTP_LOCAL_RESPONSE_STATUS_CODE_404 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_LOCAL_RESPONSE_STATUS_CODE_429")]
        HTTP_LOCAL_RESPONSE_STATUS_CODE_429 = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_LOCAL_RESPONSE_STATUS_CODE_501")]
        HTTP_LOCAL_RESPONSE_STATUS_CODE_501 = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBRateLimiterActionType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"RL_ACTION_NONE")]
        RL_ACTION_NONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RL_ACTION_DROP_CONN")]
        RL_ACTION_DROP_CONN = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RL_ACTION_RESET_CONN")]
        RL_ACTION_RESET_CONN = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RL_ACTION_CLOSE_CONN")]
        RL_ACTION_CLOSE_CONN = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RL_ACTION_LOCAL_RSP")]
        RL_ACTION_LOCAL_RSP = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RL_ACTION_REDIRECT")]
        RL_ACTION_REDIRECT = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum DhcpHeaderOp_code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BOOTREQUEST")]
        BOOTREQUEST = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BOOTREPLY")]
        BOOTREPLY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBL4RuleProtocolMatchProtocol
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PROTOCOL_ICMP")]
        PROTOCOL_ICMP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PROTOCOL_TCP")]
        PROTOCOL_TCP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PROTOCOL_UDP")]
        PROTOCOL_UDP = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBL4RuleProtocolMatchMatch_criteria
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IS_IN")]
        IS_IN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IS_NOT_IN")]
        IS_NOT_IN = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHTTPStatusMatchMatch_criteria
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IS_IN")]
        IS_IN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IS_NOT_IN")]
        IS_NOT_IN = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SiteOffBoardingStateStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INITIALIZE_INPROGRESS")]
        INITIALIZE_INPROGRESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INITIALIZE_FAILED")]
        INITIALIZE_FAILED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INITIALIZE_SUCCESSFUL")]
        INITIALIZE_SUCCESSFUL = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLEANUP_INPROGRESS")]
        CLEANUP_INPROGRESS = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLEANUP_FAILED")]
        CLEANUP_FAILED = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLEANUP_SUCCESSFUL")]
        CLEANUP_SUCCESSFUL = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REALIZATION_INPROGRESS")]
        REALIZATION_INPROGRESS = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REALIZATION_FAILED")]
        REALIZATION_FAILED = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REALIZATION_SUCCESSFUL")]
        REALIZATION_SUCCESSFUL = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TERMINAL_INPROGRESS")]
        TERMINAL_INPROGRESS = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TERMINAL_FAILED")]
        TERMINAL_FAILED = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILED")]
        FAILED = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESSFUL")]
        SUCCESSFUL = 12,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SegmentAdvancedConfigUrpf_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NONE")]
        NONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STRICT")]
        STRICT = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum NicMetadataInterface_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"MANAGEMENT")]
        MANAGEMENT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DATA1")]
        DATA1 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DATA2")]
        DATA2 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HA1")]
        HA1 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HA2")]
        HA2 = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONTROL")]
        CONTROL = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Transports
    {
        [System.Runtime.Serialization.EnumMember(Value = @"L2_BRIDGE")]
        L2_BRIDGE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"L3_ROUTED")]
        L3_ROUTED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NSH")]
        NSH = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBHttpRequestMethodConditionMethod
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GET")]
        GET = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OPTIONS")]
        OPTIONS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"POST")]
        POST = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HEAD")]
        HEAD = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PUT")]
        PUT = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ContainerApplicationStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HEALTHY")]
        HEALTHY = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DEGRADED")]
        DEGRADED = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ContainerApplicationNetwork_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HEALTHY")]
        HEALTHY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNHEALTHY")]
        UNHEALTHY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum GraphConfigurationX_value_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"string")]
        String = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"number")]
        Number = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"date")]
        Date = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum GraphConfigurationSub_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LINE_GRAPH")]
        LINE_GRAPH = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BAR_GRAPH")]
        BAR_GRAPH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STACKED_BAR_GRAPH")]
        STACKED_BAR_GRAPH = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBTCPProxyProfileCc_algo
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CC_ALGO_NEW_RENO")]
        CC_ALGO_NEW_RENO = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CC_ALGO_CUBIC")]
        CC_ALGO_CUBIC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CC_ALGO_HTCP")]
        CC_ALGO_HTCP = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBTCPProxyProfileIdle_connection_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"KEEP_ALIVE")]
        KEEP_ALIVE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLOSE_IDLE")]
        CLOSE_IDLE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBTacacsPlusAuthSettingsService
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_TACACS_PLUS_SERVICE_NONE")]
        AUTH_TACACS_PLUS_SERVICE_NONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_TACACS_PLUS_SERVICE_LOGIN")]
        AUTH_TACACS_PLUS_SERVICE_LOGIN = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_TACACS_PLUS_SERVICE_ENABLE")]
        AUTH_TACACS_PLUS_SERVICE_ENABLE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_TACACS_PLUS_SERVICE_PPP")]
        AUTH_TACACS_PLUS_SERVICE_PPP = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_TACACS_PLUS_SERVICE_ARAP")]
        AUTH_TACACS_PLUS_SERVICE_ARAP = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_TACACS_PLUS_SERVICE_PT")]
        AUTH_TACACS_PLUS_SERVICE_PT = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_TACACS_PLUS_SERVICE_RCMD")]
        AUTH_TACACS_PLUS_SERVICE_RCMD = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_TACACS_PLUS_SERVICE_X25")]
        AUTH_TACACS_PLUS_SERVICE_X25 = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_TACACS_PLUS_SERVICE_NASI")]
        AUTH_TACACS_PLUS_SERVICE_NASI = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_TACACS_PLUS_SERVICE_FWPROXY")]
        AUTH_TACACS_PLUS_SERVICE_FWPROXY = 9,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SegmentPortAttachmentStateState
    {
        [System.Runtime.Serialization.EnumMember(Value = @"FREE")]
        FREE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ATTACHED")]
        ATTACHED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ATTACHED_PENDING_CONF")]
        ATTACHED_PENDING_CONF = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ATTACHED_IN_MOTION")]
        ATTACHED_IN_MOTION = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DETACHED")]
        DETACHED = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBHttpRequestCookieConditionMatch_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"STARTS_WITH")]
        STARTS_WITH = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ENDS_WITH")]
        ENDS_WITH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EQUALS")]
        EQUALS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONTAINS")]
        CONTAINS = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGEX")]
        REGEX = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ErrorResolverUserInputDataData_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TEXT")]
        TEXT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NUMBER")]
        NUMBER = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PASSWORD")]
        PASSWORD = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum DistributedVirtualPortgroupOverall_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"RED")]
        RED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"YELLOW")]
        YELLOW = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GREEN")]
        GREEN = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GRAY")]
        GRAY = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum BgpAddressFamilyType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IPV4_UNICAST")]
        IPV4_UNICAST = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VPNV4_UNICAST")]
        VPNV4_UNICAST = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IPV6_UNICAST")]
        IPV6_UNICAST = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"L2VPN_EVPN")]
        L2VPN_EVPN = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBPoolGroupMemberDeployment_state
    {
        [System.Runtime.Serialization.EnumMember(Value = @"EVALUATION_IN_PROGRESS")]
        EVALUATION_IN_PROGRESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IN_SERVICE")]
        IN_SERVICE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OUT_OF_SERVICE")]
        OUT_OF_SERVICE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EVALUATION_FAILED")]
        EVALUATION_FAILED = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TraceflowObservationForwardedLogicalResend_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ARP_UNKNOWN_FROM_CP")]
        ARP_UNKNOWN_FROM_CP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ND_NS_UNKNWON_FROM_CP")]
        ND_NS_UNKNWON_FROM_CP = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TraceflowObservationForwardedLogicalDst_component_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PHYSICAL")]
        PHYSICAL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LR")]
        LR = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LS")]
        LS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DFW")]
        DFW = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BRIDGE")]
        BRIDGE = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE_TUNNEL")]
        EDGE_TUNNEL = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE_HOSTSWITCH")]
        EDGE_HOSTSWITCH = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FW_BRIDGE")]
        FW_BRIDGE = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOAD_BALANCER")]
        LOAD_BALANCER = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NAT")]
        NAT = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IPSEC")]
        IPSEC = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SERVICE_INSERTION")]
        SERVICE_INSERTION = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VMC")]
        VMC = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SPOOFGUARD")]
        SPOOFGUARD = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE_FW")]
        EDGE_FW = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DLB")]
        DLB = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 16,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LacpGroupConfigInfoTimeout_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"FAST")]
        FAST = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SLOW")]
        SLOW = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LacpGroupConfigInfoMode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ACTIVE")]
        ACTIVE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PASSIVE")]
        PASSIVE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyFirewallSchedulerTimezone
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UTC")]
        UTC = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOCAL")]
        LOCAL = 1,
    
    }
    
    /// <summary>Day on which scheduled firewall rule will be enforced</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Days
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SUNDAY")]
        SUNDAY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MONDAY")]
        MONDAY = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TUESDAY")]
        TUESDAY = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WEDNESDAY")]
        WEDNESDAY = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"THURSDAY")]
        THURSDAY = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FRIDAY")]
        FRIDAY = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SATURDAY")]
        SATURDAY = 6,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Functionalities
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NG_FW")]
        NG_FW = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IDS_IPS")]
        IDS_IPS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NET_MON")]
        NET_MON = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HCX")]
        HCX = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BYOD")]
        BYOD = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EPP")]
        EPP = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLB")]
        TLB = 6,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Attachment_point
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_LR")]
        TIER0_LR = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_LR")]
        TIER1_LR = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SERVICE_PLANE")]
        SERVICE_PLANE = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ServiceDefinitionOn_failure_policy
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALLOW")]
        ALLOW = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BLOCK")]
        BLOCK = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Transports2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"L2_BRIDGE")]
        L2_BRIDGE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"L3_ROUTED")]
        L3_ROUTED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NSH")]
        NSH = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Implementations
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NORTH_SOUTH")]
        NORTH_SOUTH = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EAST_WEST")]
        EAST_WEST = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ContainerApplicationInstanceStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HEALTHY")]
        HEALTHY = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DEGRADED")]
        DEGRADED = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ContainerApplicationInstanceNetwork_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HEALTHY")]
        HEALTHY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNHEALTHY")]
        UNHEALTHY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum HttpsPolicyLbVirtualServerClient_ssl_settings
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BASE_SECURE_111317")]
        BASE_SECURE_111317 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MODERATE_SECURE_111317")]
        MODERATE_SECURE_111317 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HIGH_SECURE_111317")]
        HIGH_SECURE_111317 = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBDnsTransportProtocolMatchProtocol
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_OVER_UDP")]
        DNS_OVER_UDP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_OVER_TCP")]
        DNS_OVER_TCP = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBDnsTransportProtocolMatchMatch_criteria
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IS_IN")]
        IS_IN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IS_NOT_IN")]
        IS_NOT_IN = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SegmentPortInit_state
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNBLOCKED_VLAN")]
        UNBLOCKED_VLAN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RESTORE_VIF")]
        RESTORE_VIF = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SegmentPortAdmin_state
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBAuthorizationActionStatus_code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_STATUS_CODE_401")]
        HTTP_RESPONSE_STATUS_CODE_401 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_STATUS_CODE_403")]
        HTTP_RESPONSE_STATUS_CODE_403 = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBAuthorizationActionType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALLOW_ACCESS")]
        ALLOW_ACCESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLOSE_CONNECTION")]
        CLOSE_CONNECTION = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_LOCAL_RESPONSE")]
        HTTP_LOCAL_RESPONSE = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyServiceChainPath_selection_policy
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ANY")]
        ANY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOCAL")]
        LOCAL = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REMOTE")]
        REMOTE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ROUND_ROBIN")]
        ROUND_ROBIN = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyServiceChainFailure_policy
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALLOW")]
        ALLOW = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BLOCK")]
        BLOCK = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHTTPHdrActionAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_ADD_HDR")]
        HTTP_ADD_HDR = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_REMOVE_HDR")]
        HTTP_REMOVE_HDR = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_REPLACE_HDR")]
        HTTP_REPLACE_HDR = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IPSecVpnServiceIke_log_level
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DEBUG")]
        DEBUG = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INFO")]
        INFO = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARN")]
        WARN = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EMERGENCY")]
        EMERGENCY = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum RealizedFirewallRuleDirection
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IN")]
        IN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OUT")]
        OUT = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IN_OUT")]
        IN_OUT = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum RealizedFirewallRuleAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALLOW")]
        ALLOW = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DROP")]
        DROP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REJECT")]
        REJECT = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LogicalRouterStatusLocale_operation_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PRIMARY_LOCATION")]
        PRIMARY_LOCATION = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SECONDARY_LOCATION")]
        SECONDARY_LOCATION = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBWafRulePhase
    {
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_PHASE_CONNECTION")]
        WAF_PHASE_CONNECTION = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_PHASE_REQUEST_HEADER")]
        WAF_PHASE_REQUEST_HEADER = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_PHASE_REQUEST_BODY")]
        WAF_PHASE_REQUEST_BODY = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_PHASE_RESPONSE_HEADER")]
        WAF_PHASE_RESPONSE_HEADER = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_PHASE_RESPONSE_BODY")]
        WAF_PHASE_RESPONSE_BODY = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_PHASE_LOGGING")]
        WAF_PHASE_LOGGING = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBWafRuleMode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_MODE_DETECTION_ONLY")]
        WAF_MODE_DETECTION_ONLY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_MODE_ENFORCEMENT")]
        WAF_MODE_ENFORCEMENT = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum AcceptableComponentVersionComponent_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HOST")]
        HOST = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE")]
        EDGE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CCP")]
        CCP = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MP")]
        MP = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TraceflowObservationComponent_sub_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LR_TIER0")]
        LR_TIER0 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LR_TIER1")]
        LR_TIER1 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LR_VRF_TIER0")]
        LR_VRF_TIER0 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LS_TRANSIT")]
        LS_TRANSIT = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SI_CLASSIFIER")]
        SI_CLASSIFIER = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SI_PROXY")]
        SI_PROXY = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VDR")]
        VDR = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ENI")]
        ENI = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AWS_GATEWAY")]
        AWS_GATEWAY = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TGW_ROUTE")]
        TGW_ROUTE = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE_UPLINK")]
        EDGE_UPLINK = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DELL_GATEWAY")]
        DELL_GATEWAY = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LGW_ROUTE")]
        LGW_ROUTE = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 13,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TraceflowObservationComponent_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PHYSICAL")]
        PHYSICAL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LR")]
        LR = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LS")]
        LS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DFW")]
        DFW = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BRIDGE")]
        BRIDGE = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE_TUNNEL")]
        EDGE_TUNNEL = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE_HOSTSWITCH")]
        EDGE_HOSTSWITCH = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FW_BRIDGE")]
        FW_BRIDGE = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOAD_BALANCER")]
        LOAD_BALANCER = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NAT")]
        NAT = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IPSEC")]
        IPSEC = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SERVICE_INSERTION")]
        SERVICE_INSERTION = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VMC")]
        VMC = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SPOOFGUARD")]
        SPOOFGUARD = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE_FW")]
        EDGE_FW = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DLB")]
        DLB = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 16,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TraceflowObservationTransport_node_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ESX")]
        ESX = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RHELKVM")]
        RHELKVM = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UBUNTUKVM")]
        UBUNTUKVM = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CENTOSKVM")]
        CENTOSKVM = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RHELCONTAINER")]
        RHELCONTAINER = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CENTOSCONTAINER")]
        CENTOSCONTAINER = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RHELSERVER")]
        RHELSERVER = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UBUNTUSERVER")]
        UBUNTUSERVER = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CENTOSSERVER")]
        CENTOSSERVER = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SLESKVM")]
        SLESKVM = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SLESSERVER")]
        SLESSERVER = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WINDOWSSERVER")]
        WINDOWSSERVER = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RHELSMARTNIC")]
        RHELSMARTNIC = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OELSERVER")]
        OELSERVER = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UBUNTUSMARTNIC")]
        UBUNTUSMARTNIC = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE")]
        EDGE = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PUBLIC_CLOUD_GATEWAY_NODE")]
        PUBLIC_CLOUD_GATEWAY_NODE = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OTHERS")]
        OTHERS = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HYPERV")]
        HYPERV = 18,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBClientLogConfigurationSignificant_log_processing
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LOGS_PROCESSING_NONE")]
        LOGS_PROCESSING_NONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOGS_PROCESSING_SYNC_AND_INDEX_ON_DEMAND")]
        LOGS_PROCESSING_SYNC_AND_INDEX_ON_DEMAND = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOGS_PROCESSING_AUTO_SYNC_AND_INDEX")]
        LOGS_PROCESSING_AUTO_SYNC_AND_INDEX = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOGS_PROCESSING_AUTO_SYNC_BUT_INDEX_ON_DEMAND")]
        LOGS_PROCESSING_AUTO_SYNC_BUT_INDEX_ON_DEMAND = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBClientLogConfigurationNon_significant_log_processing
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LOGS_PROCESSING_NONE")]
        LOGS_PROCESSING_NONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOGS_PROCESSING_SYNC_AND_INDEX_ON_DEMAND")]
        LOGS_PROCESSING_SYNC_AND_INDEX_ON_DEMAND = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOGS_PROCESSING_AUTO_SYNC_AND_INDEX")]
        LOGS_PROCESSING_AUTO_SYNC_AND_INDEX = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOGS_PROCESSING_AUTO_SYNC_BUT_INDEX_ON_DEMAND")]
        LOGS_PROCESSING_AUTO_SYNC_BUT_INDEX_ON_DEMAND = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBClientLogConfigurationFiltered_log_processing
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LOGS_PROCESSING_NONE")]
        LOGS_PROCESSING_NONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOGS_PROCESSING_SYNC_AND_INDEX_ON_DEMAND")]
        LOGS_PROCESSING_SYNC_AND_INDEX_ON_DEMAND = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOGS_PROCESSING_AUTO_SYNC_AND_INDEX")]
        LOGS_PROCESSING_AUTO_SYNC_AND_INDEX = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOGS_PROCESSING_AUTO_SYNC_BUT_INDEX_ON_DEMAND")]
        LOGS_PROCESSING_AUTO_SYNC_BUT_INDEX_ON_DEMAND = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyLbRuleMatch_strategy
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALL")]
        ALL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ANY")]
        ANY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum AttributeValData_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"STRING")]
        STRING = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DATE")]
        DATE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INTEGER")]
        INTEGER = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BOOLEAN")]
        BOOLEAN = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ServiceChainMappingDirection
    {
        [System.Runtime.Serialization.EnumMember(Value = @"FORWARD")]
        FORWARD = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REVERSE")]
        REVERSE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBFailActionHTTPRedirectProtocol
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP")]
        HTTP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTPS")]
        HTTPS = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBFailActionHTTPRedirectStatus_code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_REDIRECT_STATUS_CODE_301")]
        HTTP_REDIRECT_STATUS_CODE_301 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_REDIRECT_STATUS_CODE_302")]
        HTTP_REDIRECT_STATUS_CODE_302 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_REDIRECT_STATUS_CODE_307")]
        HTTP_REDIRECT_STATUS_CODE_307 = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBServiceUsageSummaryPool_member_severity
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GREEN")]
        GREEN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ORANGE")]
        ORANGE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RED")]
        RED = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBServiceUsageSummaryPool_severity
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GREEN")]
        GREEN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ORANGE")]
        ORANGE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RED")]
        RED = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBServiceUsageSummaryVirtual_server_severity
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GREEN")]
        GREEN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ORANGE")]
        ORANGE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RED")]
        RED = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum RealizedFirewallSectionSection_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LAYER2")]
        LAYER2 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LAYER3")]
        LAYER3 = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum StatsConfigurationSub_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"COMPACT")]
        COMPACT = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBPoolMemberAdmin_state
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ENABLED")]
        ENABLED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DISABLED")]
        DISABLED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GRACEFUL_DISABLED")]
        GRACEFUL_DISABLED = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyEdgeClusterMemberInterSiteStatusStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DEGRADED")]
        DEGRADED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Tier1InterfaceUrpf_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NONE")]
        NONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STRICT")]
        STRICT = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum L4PolicyLbPersistenceProfilePersistence
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SOURCE_IP")]
        SOURCE_IP = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ColumnItemType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"String")]
        String = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Number")]
        Number = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Date")]
        Date = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FederationUpgradeSummarySite_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ACTIVE_GM_SITE")]
        ACTIVE_GM_SITE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STANDBY_GM_SITE")]
        STANDBY_GM_SITE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NON_GM_SITE")]
        NON_GM_SITE = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FederationUpgradeSummaryOverall_upgrade_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESS")]
        SUCCESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILED")]
        FAILED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IN_PROGRESS")]
        IN_PROGRESS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOT_STARTED")]
        NOT_STARTED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PAUSED")]
        PAUSED = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBClientSslProfileCipher_group_label
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BALANCED")]
        BALANCED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HIGH_SECURITY")]
        HIGH_SECURITY = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HIGH_COMPATIBILITY")]
        HIGH_COMPATIBILITY = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CUSTOM")]
        CUSTOM = 3,
    
    }
    
    /// <summary>SSL cipher</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Ciphers2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_256_CBC_SHA")]
        TLS_RSA_WITH_AES_256_CBC_SHA = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_128_CBC_SHA")]
        TLS_RSA_WITH_AES_128_CBC_SHA = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_3DES_EDE_CBC_SHA")]
        TLS_RSA_WITH_3DES_EDE_CBC_SHA = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_128_CBC_SHA256")]
        TLS_RSA_WITH_AES_128_CBC_SHA256 = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_128_GCM_SHA256")]
        TLS_RSA_WITH_AES_128_GCM_SHA256 = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_256_CBC_SHA256")]
        TLS_RSA_WITH_AES_256_CBC_SHA256 = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_256_GCM_SHA384")]
        TLS_RSA_WITH_AES_256_GCM_SHA384 = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = 20,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = 21,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = 22,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = 23,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = 24,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = 25,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = 26,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = 27,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = 28,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = 29,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = 30,
    
    }
    
    /// <summary>SSL protocol</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Protocols2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_V2")]
        SSL_V2 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_V3")]
        SSL_V3 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_V1")]
        TLS_V1 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_V1_1")]
        TLS_V1_1 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_V1_2")]
        TLS_V1_2 = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBURIParamType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"URI_PARAM_TYPE_TOKENIZED")]
        URI_PARAM_TYPE_TOKENIZED = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBApplicationPersistenceProfilePersistence_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PERSISTENCE_TYPE_CLIENT_IP_ADDRESS")]
        PERSISTENCE_TYPE_CLIENT_IP_ADDRESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PERSISTENCE_TYPE_HTTP_COOKIE")]
        PERSISTENCE_TYPE_HTTP_COOKIE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PERSISTENCE_TYPE_TLS")]
        PERSISTENCE_TYPE_TLS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PERSISTENCE_TYPE_CLIENT_IPV6_ADDRESS")]
        PERSISTENCE_TYPE_CLIENT_IPV6_ADDRESS = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PERSISTENCE_TYPE_CUSTOM_HTTP_HEADER")]
        PERSISTENCE_TYPE_CUSTOM_HTTP_HEADER = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PERSISTENCE_TYPE_APP_COOKIE")]
        PERSISTENCE_TYPE_APP_COOKIE = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PERSISTENCE_TYPE_GSLB_SITE")]
        PERSISTENCE_TYPE_GSLB_SITE = 6,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBApplicationPersistenceProfileServer_hm_down_recovery
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HM_DOWN_PICK_NEW_SERVER")]
        HM_DOWN_PICK_NEW_SERVER = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HM_DOWN_ABORT_CONNECTION")]
        HM_DOWN_ABORT_CONNECTION = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HM_DOWN_CONTINUE_PERSISTENT_SERVER")]
        HM_DOWN_CONTINUE_PERSISTENT_SERVER = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum BgpGracefulRestartConfigMode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DISABLE")]
        DISABLE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GR_AND_HELPER")]
        GR_AND_HELPER = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HELPER_ONLY")]
        HELPER_ONLY = 2,
    
    }
    
    /// <summary>Resource Operation Type represents a change in state of a resource with
    /// regard to the interaction with DAO layer:
    /// POST_CREATE: post-create change event.
    /// POST_UPDATE: post-update change event.
    /// PRE_DELETE: pre-delete change event.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Operation_types
    {
        [System.Runtime.Serialization.EnumMember(Value = @"POST_CREATE")]
        POST_CREATE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"POST_UPDATE")]
        POST_UPDATE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PRE_DELETE")]
        PRE_DELETE = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum RoleBindingIdentity_source_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"VIDM")]
        VIDM = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LDAP")]
        LDAP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OIDC")]
        OIDC = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum RoleBindingType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"remote_user")]
        Remote_user = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"remote_group")]
        Remote_group = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"local_user")]
        Local_user = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"principal_identity")]
        Principal_identity = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum RoleBindingStale
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TRUE")]
        TRUE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FALSE")]
        FALSE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IconPlacement
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PRE")]
        PRE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"POST")]
        POST = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IconType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNING")]
        WARNING = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INFO")]
        INFO = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INPROGRESS")]
        INPROGRESS = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESS")]
        SUCCESS = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DETAIL")]
        DETAIL = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOT_AVAILABLE")]
        NOT_AVAILABLE = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SECURITY")]
        SECURITY = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NETWORKING")]
        NETWORKING = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOAD_BALANCER")]
        LOAD_BALANCER = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VPN")]
        VPN = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOMAIN")]
        DOMAIN = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP")]
        GROUP = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DISTRIBUTED_FIREWALL")]
        DISTRIBUTED_FIREWALL = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NETWORKING_TIER0")]
        NETWORKING_TIER0 = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NETWORKING_TIER1")]
        NETWORKING_TIER1 = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SEGMENT")]
        SEGMENT = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SYSTEM")]
        SYSTEM = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SYSTEM_FABRIC")]
        SYSTEM_FABRIC = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SYSTEM_BACKUPRESTORE")]
        SYSTEM_BACKUPRESTORE = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INVENTORY_GROUPS")]
        INVENTORY_GROUPS = 20,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SECURITY_DFW")]
        SECURITY_DFW = 21,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum VirtualMachineType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE")]
        EDGE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SERVICE")]
        SERVICE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGULAR")]
        REGULAR = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum VirtualMachinePower_state
    {
        [System.Runtime.Serialization.EnumMember(Value = @"VM_RUNNING")]
        VM_RUNNING = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_STOPPED")]
        VM_STOPPED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_SUSPENDED")]
        VM_SUSPENDED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TaskPropertiesStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"running")]
        Running = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"error")]
        Error = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"success")]
        Success = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"canceling")]
        Canceling = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"canceled")]
        Canceled = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"killed")]
        Killed = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum VrfRouteTargetsAddress_family
    {
        [System.Runtime.Serialization.EnumMember(Value = @"L2VPN_EVPN")]
        L2VPN_EVPN = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ConfigurationStateElementState
    {
        [System.Runtime.Serialization.EnumMember(Value = @"in_progress")]
        In_progress = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"success")]
        Success = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"failed")]
        Failed = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"partial_success")]
        Partial_success = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"in_sync")]
        In_sync = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_DEPLOYMENT_FAILED")]
        VM_DEPLOYMENT_FAILED = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_POWER_ON_FAILED")]
        VM_POWER_ON_FAILED = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_POWER_OFF_FAILED")]
        VM_POWER_OFF_FAILED = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_UNDEPLOY_FAILED")]
        VM_UNDEPLOY_FAILED = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REPLACE_FAILED")]
        REPLACE_FAILED = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UPLINK_FROM_TEAMING_POLICY_NOT_MAPPED")]
        UPLINK_FROM_TEAMING_POLICY_NOT_MAPPED = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOGICAL_SWITCH_NAMED_TEAMING_HAS_NO_PNIC_BACKING")]
        LOGICAL_SWITCH_NAMED_TEAMING_HAS_NO_PNIC_BACKING = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DELETE_VM_IN_REDEPLOY_FAILED")]
        DELETE_VM_IN_REDEPLOY_FAILED = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DEPLOY_VM_IN_REDEPLOY_FAILED")]
        DEPLOY_VM_IN_REDEPLOY_FAILED = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INSUFFICIENT_RESOURCES_IN_EDGE_NODE_FOR_SERVICE")]
        INSUFFICIENT_RESOURCES_IN_EDGE_NODE_FOR_SERVICE = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE_CONFIG_ERROR")]
        EDGE_CONFIG_ERROR = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGISTRATION_FAILED")]
        REGISTRATION_FAILED = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TRANSPORT_NODE_CONFIGURATION_MISSING")]
        TRANSPORT_NODE_CONFIGURATION_MISSING = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE_HARDWARE_NOT_SUPPORTED")]
        EDGE_HARDWARE_NOT_SUPPORTED = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MULTIPLE_OVERLAY_TZS_NOT_SUPPORTED")]
        MULTIPLE_OVERLAY_TZS_NOT_SUPPORTED = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TN_OVERLAY_TZ_IN_USE_BY_EDGE_CLUSTER")]
        TN_OVERLAY_TZ_IN_USE_BY_EDGE_CLUSTER = 20,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TZ_ENDPOINTS_NOT_SPECIFIED")]
        TZ_ENDPOINTS_NOT_SPECIFIED = 21,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_PNIC_PREPARED_IN_EDGE")]
        NO_PNIC_PREPARED_IN_EDGE = 22,
    
        [System.Runtime.Serialization.EnumMember(Value = @"APPLIANCE_INTERNAL_ERROR")]
        APPLIANCE_INTERNAL_ERROR = 23,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VTEP_DHCP_NOT_SUPPORTED")]
        VTEP_DHCP_NOT_SUPPORTED = 24,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNSUPPORTED_HOST_SWITCH_PROFILE")]
        UNSUPPORTED_HOST_SWITCH_PROFILE = 25,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UPLINK_HOST_SWITCH_PROFILE_NOT_SPECIFIED")]
        UPLINK_HOST_SWITCH_PROFILE_NOT_SPECIFIED = 26,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HOSTSWITCH_PROFILE_NOT_FOUND")]
        HOSTSWITCH_PROFILE_NOT_FOUND = 27,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LLDP_SEND_ENABLED_NOT_SUPPORTED")]
        LLDP_SEND_ENABLED_NOT_SUPPORTED = 28,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNSUPPORTED_NAMED_TEAMING_POLICY")]
        UNSUPPORTED_NAMED_TEAMING_POLICY = 29,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LBSRCID_NOT_SUPPORTED_FOR_EDGE_VM")]
        LBSRCID_NOT_SUPPORTED_FOR_EDGE_VM = 30,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LACP_NOT_SUPPORTED_FOR_EDGE_VM")]
        LACP_NOT_SUPPORTED_FOR_EDGE_VM = 31,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STANDBY_UPLINKS_NOT_SUPPORTED_FOR_EDGE_VM")]
        STANDBY_UPLINKS_NOT_SUPPORTED_FOR_EDGE_VM = 32,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MULTIPLE_ACTIVE_UPLINKS_NOT_SUPPORTED_FOR_EDGE")]
        MULTIPLE_ACTIVE_UPLINKS_NOT_SUPPORTED_FOR_EDGE = 33,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNSUPPORTED_LACP_LB_ALGO_FOR_NODE")]
        UNSUPPORTED_LACP_LB_ALGO_FOR_NODE = 34,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE_NODE_VERSION_NOT_SUPPORTED")]
        EDGE_NODE_VERSION_NOT_SUPPORTED = 35,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_PNIC_SPECIFIED_IN_TN")]
        NO_PNIC_SPECIFIED_IN_TN = 36,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_PNIC_DEVICE_NAME")]
        INVALID_PNIC_DEVICE_NAME = 37,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNSUPPORTED_DEFAULT_TEAMING_POLICY")]
        UNSUPPORTED_DEFAULT_TEAMING_POLICY = 38,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MPA_DISCONNECTED")]
        MPA_DISCONNECTED = 39,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_NETWORK_EDIT_PENDING")]
        VM_NETWORK_EDIT_PENDING = 40,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_RENAME_PENDING")]
        VM_RENAME_PENDING = 41,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_CONFIG_EDIT_PENDING")]
        VM_CONFIG_EDIT_PENDING = 42,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_NETWORK_EDIT_FAILED")]
        VM_NETWORK_EDIT_FAILED = 43,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_RENAME_FAILED")]
        VM_RENAME_FAILED = 44,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_CONFIG_EDIT_FAILED")]
        VM_CONFIG_EDIT_FAILED = 45,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_CONFIG_DISCREPANCY")]
        VM_CONFIG_DISCREPANCY = 46,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_NODE_REFRESH_FAILED")]
        VM_NODE_REFRESH_FAILED = 47,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VM_PLACEMENT_REFRESH_FAILED")]
        VM_PLACEMENT_REFRESH_FAILED = 48,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOT_AVAILABLE")]
        NOT_AVAILABLE = 49,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGISTRATION_TIMEDOUT")]
        REGISTRATION_TIMEDOUT = 50,
    
        [System.Runtime.Serialization.EnumMember(Value = @"pending")]
        Pending = 51,
    
        [System.Runtime.Serialization.EnumMember(Value = @"orphaned")]
        Orphaned = 52,
    
        [System.Runtime.Serialization.EnumMember(Value = @"unknown")]
        Unknown = 53,
    
        [System.Runtime.Serialization.EnumMember(Value = @"error")]
        Error = 54,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Restore_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"REGULAR_RESTORE")]
        REGULAR_RESTORE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"POLICY_ONLY_RESTORE")]
        POLICY_ONLY_RESTORE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBCookieMatchMatch_case
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SENSITIVE")]
        SENSITIVE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INSENSITIVE")]
        INSENSITIVE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBCookieMatchMatch_criteria
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_EXISTS")]
        HDR_EXISTS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_DOES_NOT_EXIST")]
        HDR_DOES_NOT_EXIST = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_BEGINS_WITH")]
        HDR_BEGINS_WITH = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_DOES_NOT_BEGIN_WITH")]
        HDR_DOES_NOT_BEGIN_WITH = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_CONTAINS")]
        HDR_CONTAINS = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_DOES_NOT_CONTAIN")]
        HDR_DOES_NOT_CONTAIN = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_ENDS_WITH")]
        HDR_ENDS_WITH = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_DOES_NOT_END_WITH")]
        HDR_DOES_NOT_END_WITH = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_EQUALS")]
        HDR_EQUALS = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_DOES_NOT_EQUAL")]
        HDR_DOES_NOT_EQUAL = 9,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHTTPHdrValueVar
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_CLIENT_IP")]
        HTTP_POLICY_VAR_CLIENT_IP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_VS_PORT")]
        HTTP_POLICY_VAR_VS_PORT = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_VS_IP")]
        HTTP_POLICY_VAR_VS_IP = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_HTTP_HDR")]
        HTTP_POLICY_VAR_HTTP_HDR = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_SSL_CLIENT_FINGERPRINT")]
        HTTP_POLICY_VAR_SSL_CLIENT_FINGERPRINT = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_SSL_CLIENT_SERIAL")]
        HTTP_POLICY_VAR_SSL_CLIENT_SERIAL = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_SSL_CLIENT_ISSUER")]
        HTTP_POLICY_VAR_SSL_CLIENT_ISSUER = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_SSL_CLIENT_SUBJECT")]
        HTTP_POLICY_VAR_SSL_CLIENT_SUBJECT = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_SSL_CLIENT_RAW")]
        HTTP_POLICY_VAR_SSL_CLIENT_RAW = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_SSL_PROTOCOL")]
        HTTP_POLICY_VAR_SSL_PROTOCOL = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_SSL_SERVER_NAME")]
        HTTP_POLICY_VAR_SSL_SERVER_NAME = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_USER_NAME")]
        HTTP_POLICY_VAR_USER_NAME = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_SSL_CIPHER")]
        HTTP_POLICY_VAR_SSL_CIPHER = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_POLICY_VAR_REQUEST_ID")]
        HTTP_POLICY_VAR_REQUEST_ID = 13,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum GlobalManagerMode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ACTIVE")]
        ACTIVE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STANDBY")]
        STANDBY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PacketDataTransport_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BROADCAST")]
        BROADCAST = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNICAST")]
        UNICAST = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MULTICAST")]
        MULTICAST = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHTTPSecurityActionAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_SECURITY_ACTION_CLOSE_CONN")]
        HTTP_SECURITY_ACTION_CLOSE_CONN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_SECURITY_ACTION_SEND_RESPONSE")]
        HTTP_SECURITY_ACTION_SEND_RESPONSE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_SECURITY_ACTION_ALLOW")]
        HTTP_SECURITY_ACTION_ALLOW = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_SECURITY_ACTION_REDIRECT_TO_HTTPS")]
        HTTP_SECURITY_ACTION_REDIRECT_TO_HTTPS = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_SECURITY_ACTION_RATE_LIMIT")]
        HTTP_SECURITY_ACTION_RATE_LIMIT = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_SECURITY_ACTION_REQUEST_CHECK_ICAP")]
        HTTP_SECURITY_ACTION_REQUEST_CHECK_ICAP = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHTTPSecurityActionStatus_code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_LOCAL_RESPONSE_STATUS_CODE_200")]
        HTTP_LOCAL_RESPONSE_STATUS_CODE_200 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_LOCAL_RESPONSE_STATUS_CODE_204")]
        HTTP_LOCAL_RESPONSE_STATUS_CODE_204 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_LOCAL_RESPONSE_STATUS_CODE_403")]
        HTTP_LOCAL_RESPONSE_STATUS_CODE_403 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_LOCAL_RESPONSE_STATUS_CODE_404")]
        HTTP_LOCAL_RESPONSE_STATUS_CODE_404 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_LOCAL_RESPONSE_STATUS_CODE_429")]
        HTTP_LOCAL_RESPONSE_STATUS_CODE_429 = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_LOCAL_RESPONSE_STATUS_CODE_501")]
        HTTP_LOCAL_RESPONSE_STATUS_CODE_501 = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CommunicationInsertParametersOperation
    {
        [System.Runtime.Serialization.EnumMember(Value = @"insert_top")]
        Insert_top = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_bottom")]
        Insert_bottom = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_after")]
        Insert_after = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"insert_before")]
        Insert_before = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBSSOPolicyType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SSO_TYPE_SAML")]
        SSO_TYPE_SAML = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSO_TYPE_PINGACCESS")]
        SSO_TYPE_PINGACCESS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSO_TYPE_JWT")]
        SSO_TYPE_JWT = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Attribute_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IP_ADDRESS")]
        IP_ADDRESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PORT")]
        PORT = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PASSWORD")]
        PASSWORD = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STRING")]
        STRING = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LONG")]
        LONG = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BOOLEAN")]
        BOOLEAN = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IdsSignatureVersionStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"OUTDATED")]
        OUTDATED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LATEST")]
        LATEST = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IdsSignatureVersionState
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ACTIVE")]
        ACTIVE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOTACTIVE")]
        NOTACTIVE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHdrMatchMatch_case
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SENSITIVE")]
        SENSITIVE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INSENSITIVE")]
        INSENSITIVE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHdrMatchMatch_criteria
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_EXISTS")]
        HDR_EXISTS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_DOES_NOT_EXIST")]
        HDR_DOES_NOT_EXIST = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_BEGINS_WITH")]
        HDR_BEGINS_WITH = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_DOES_NOT_BEGIN_WITH")]
        HDR_DOES_NOT_BEGIN_WITH = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_CONTAINS")]
        HDR_CONTAINS = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_DOES_NOT_CONTAIN")]
        HDR_DOES_NOT_CONTAIN = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_ENDS_WITH")]
        HDR_ENDS_WITH = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_DOES_NOT_END_WITH")]
        HDR_DOES_NOT_END_WITH = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_EQUALS")]
        HDR_EQUALS = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HDR_DOES_NOT_EQUAL")]
        HDR_DOES_NOT_EQUAL = 9,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBDnsAttackAttack_vector
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_REFLECTION")]
        DNS_REFLECTION = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_NXDOMAIN")]
        DNS_NXDOMAIN = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS_AMPLIFICATION_EGRESS")]
        DNS_AMPLIFICATION_EGRESS = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum GlobalConfigL3_forwarding_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IPV4_ONLY")]
        IPV4_ONLY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IPV4_AND_IPV6")]
        IPV4_AND_IPV6 = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FileTransferAuthenticationSchemeScheme_name
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PASSWORD")]
        PASSWORD = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ArpHeaderOp_code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ARP_REQUEST")]
        ARP_REQUEST = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ARP_REPLY")]
        ARP_REPLY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum BasePolicyServiceInstanceTransport_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"L2_BRIDGE")]
        L2_BRIDGE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"L3_ROUTED")]
        L3_ROUTED = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum BasePolicyServiceInstanceDeployment_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"STAND_ALONE")]
        STAND_ALONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACTIVE_STANDBY")]
        ACTIVE_STANDBY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBHttpsMonitorProfileRequest_method
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GET")]
        GET = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OPTIONS")]
        OPTIONS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"POST")]
        POST = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HEAD")]
        HEAD = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PUT")]
        PUT = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBHttpsMonitorProfileRequest_version
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_VERSION_1_0")]
        HTTP_VERSION_1_0 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_VERSION_1_1")]
        HTTP_VERSION_1_1 = 1,
    
    }
    
    /// <summary>Metadata proxy supported cryptographic protocol</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Crypto_protocols
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_V1")]
        TLS_V1 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_V1_1")]
        TLS_V1_1 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_V1_2")]
        TLS_V1_2 = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBLdapDirectorySettingsUser_search_scope
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_LDAP_SCOPE_BASE")]
        AUTH_LDAP_SCOPE_BASE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_LDAP_SCOPE_ONE")]
        AUTH_LDAP_SCOPE_ONE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_LDAP_SCOPE_SUBTREE")]
        AUTH_LDAP_SCOPE_SUBTREE = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBLdapDirectorySettingsGroup_search_scope
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_LDAP_SCOPE_BASE")]
        AUTH_LDAP_SCOPE_BASE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_LDAP_SCOPE_ONE")]
        AUTH_LDAP_SCOPE_ONE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_LDAP_SCOPE_SUBTREE")]
        AUTH_LDAP_SCOPE_SUBTREE = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PoolMemberSettingAdmin_state
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ENABLED")]
        ENABLED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DISABLED")]
        DISABLED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GRACEFUL_DISABLED")]
        GRACEFUL_DISABLED = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Tier1Pool_allocation
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ROUTING")]
        ROUTING = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LB_SMALL")]
        LB_SMALL = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LB_MEDIUM")]
        LB_MEDIUM = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LB_LARGE")]
        LB_LARGE = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LB_XLARGE")]
        LB_XLARGE = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Tier1Failover_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PREEMPTIVE")]
        PREEMPTIVE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NON_PREEMPTIVE")]
        NON_PREEMPTIVE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Tier1Type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ROUTED")]
        ROUTED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ISOLATED")]
        ISOLATED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NATTED")]
        NATTED = 2,
    
    }
    
    /// <summary>Control routes advertised by Tier-1 instance.
    ///   TIER1_STATIC_ROUTES: Advertise all STATIC routes.
    ///   TIER1_CONNECTED: Advertise all subnets configured on connected
    ///   Interfaces and Segments.
    ///   TIER1_NAT: Advertise all NAT IP addresses.
    ///   TIER1_LB_VIP: Advertise all Load-balancer VIPs.
    ///   TIER1_LB_SNAT: Advertise all Loadbalancer SNAT IP addresses.
    ///   TIER1_DNS_FORWARDER_IP: Advertise DNS forwarder source and listener IPs
    ///   TIER1_IPSEC_LOCAL_ENDPOINT: Redistribute IPSec VPN local-endpoint subnets.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Route_advertisement_types2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_STATIC_ROUTES")]
        TIER1_STATIC_ROUTES = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_CONNECTED")]
        TIER1_CONNECTED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_NAT")]
        TIER1_NAT = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_LB_VIP")]
        TIER1_LB_VIP = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_LB_SNAT")]
        TIER1_LB_SNAT = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_DNS_FORWARDER_IP")]
        TIER1_DNS_FORWARDER_IP = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_IPSEC_LOCAL_ENDPOINT")]
        TIER1_IPSEC_LOCAL_ENDPOINT = 6,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Tier0Failover_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PREEMPTIVE")]
        PREEMPTIVE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NON_PREEMPTIVE")]
        NON_PREEMPTIVE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Tier0Ha_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ACTIVE_ACTIVE")]
        ACTIVE_ACTIVE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACTIVE_STANDBY")]
        ACTIVE_STANDBY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBVariableConditionMatch_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"STARTS_WITH")]
        STARTS_WITH = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ENDS_WITH")]
        ENDS_WITH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EQUALS")]
        EQUALS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONTAINS")]
        CONTAINS = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGEX")]
        REGEX = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBHttpRequestUriConditionMatch_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"STARTS_WITH")]
        STARTS_WITH = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ENDS_WITH")]
        ENDS_WITH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EQUALS")]
        EQUALS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONTAINS")]
        CONTAINS = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGEX")]
        REGEX = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LiveTraceStatusOperation_state
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IN_PROGRESS")]
        IN_PROGRESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FINISHED")]
        FINISHED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PARTIAL_FINISHED")]
        PARTIAL_FINISHED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CANCELED")]
        CANCELED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIMEOUT")]
        TIMEOUT = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LiveTraceStatusRequest_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESS_DELIVERED")]
        SUCCESS_DELIVERED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LCP_FAILURE")]
        LCP_FAILURE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_FILTER")]
        INVALID_FILTER = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DATAPATH_FAILURE")]
        DATAPATH_FAILURE = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTION_ERROR")]
        CONNECTION_ERROR = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIMEOUT")]
        TIMEOUT = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 6,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum NdpHeaderMsg_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NEIGHBOR_SOLICITATION")]
        NEIGHBOR_SOLICITATION = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NEIGHBOR_ADVERTISEMENT")]
        NEIGHBOR_ADVERTISEMENT = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ContainerInfrastructureInfoInfra_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"vSphere")]
        VSphere = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AWS")]
        AWS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Azure")]
        Azure = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VMC")]
        VMC = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"KVM")]
        KVM = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Baremetal")]
        Baremetal = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CapacityDashboardUsageSeverity
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INFO")]
        INFO = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WARNING")]
        WARNING = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CRITICAL")]
        CRITICAL = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBWafDataFileType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_DATAFILE_PM_FROM_FILE")]
        WAF_DATAFILE_PM_FROM_FILE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_DATAFILE_DTD")]
        WAF_DATAFILE_DTD = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_DATAFILE_XSD")]
        WAF_DATAFILE_XSD = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBPoolMemberStatusStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DISABLED")]
        DISABLED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GRACEFUL_DISABLED")]
        GRACEFUL_DISABLED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNUSED")]
        UNUSED = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum BackupOperationStatusError_code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BACKUP_NOT_RUN_ON_MASTER")]
        BACKUP_NOT_RUN_ON_MASTER = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BACKUP_SERVER_UNREACHABLE")]
        BACKUP_SERVER_UNREACHABLE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BACKUP_AUTHENTICATION_FAILURE")]
        BACKUP_AUTHENTICATION_FAILURE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BACKUP_PERMISSION_ERROR")]
        BACKUP_PERMISSION_ERROR = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BACKUP_TIMEOUT")]
        BACKUP_TIMEOUT = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BACKUP_BAD_FINGERPRINT")]
        BACKUP_BAD_FINGERPRINT = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BACKUP_GENERIC_ERROR")]
        BACKUP_GENERIC_ERROR = 6,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHTTPApplicationProfileSsl_client_certificate_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_CLIENT_CERTIFICATE_NONE")]
        SSL_CLIENT_CERTIFICATE_NONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_CLIENT_CERTIFICATE_REQUEST")]
        SSL_CLIENT_CERTIFICATE_REQUEST = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_CLIENT_CERTIFICATE_REQUIRE")]
        SSL_CLIENT_CERTIFICATE_REQUIRE = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBPoolMemberGroupIp_revision_filter
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IPV4")]
        IPV4 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IPV6")]
        IPV6 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IPV4_IPV6")]
        IPV4_IPV6 = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBHttpMonitorProfileRequest_method
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GET")]
        GET = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OPTIONS")]
        OPTIONS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"POST")]
        POST = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HEAD")]
        HEAD = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PUT")]
        PUT = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBHttpMonitorProfileRequest_version
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_VERSION_1_0")]
        HTTP_VERSION_1_0 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_VERSION_1_1")]
        HTTP_VERSION_1_1 = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ServicePathHopAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SERVICE_ACTION_INVALID")]
        SERVICE_ACTION_INVALID = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"COPY")]
        COPY = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REDIRECT")]
        REDIRECT = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBFailActionType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"FAIL_ACTION_HTTP_REDIRECT")]
        FAIL_ACTION_HTTP_REDIRECT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAIL_ACTION_HTTP_LOCAL_RSP")]
        FAIL_ACTION_HTTP_LOCAL_RSP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAIL_ACTION_CLOSE_CONN")]
        FAIL_ACTION_CLOSE_CONN = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAIL_ACTION_BACKUP_POOL")]
        FAIL_ACTION_BACKUP_POOL = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHealthMonitorHttpAuth_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_BASIC")]
        AUTH_BASIC = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AUTH_NTLM")]
        AUTH_NTLM = 1,
    
    }
    
    /// <summary>Valid ENUM values for ALBHttpResponseCode</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Http_response_code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_ANY")]
        HTTP_ANY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_1XX")]
        HTTP_1XX = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_2XX")]
        HTTP_2XX = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_3XX")]
        HTTP_3XX = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_4XX")]
        HTTP_4XX = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_5XX")]
        HTTP_5XX = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum VirtualNetworkInterfaceOwner_vm_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"EDGE")]
        EDGE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SERVICE")]
        SERVICE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGULAR")]
        REGULAR = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FederationComponentUpgradeStatusStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESS")]
        SUCCESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILED")]
        FAILED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IN_PROGRESS")]
        IN_PROGRESS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOT_STARTED")]
        NOT_STARTED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PAUSED")]
        PAUSED = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IdsSignatureStatusDownload_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"READY")]
        READY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PENDING")]
        PENDING = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DISABLED")]
        DISABLED = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IdsSignatureStatusSignature_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE")]
        AVAILABLE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNAVAILABLE")]
        UNAVAILABLE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IPSecVpnRuleAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PROTECT")]
        PROTECT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BYPASS")]
        BYPASS = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IPSecVpnDpdProfileDpd_probe_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PERIODIC")]
        PERIODIC = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ON_DEMAND")]
        ON_DEMAND = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TagBulkOperationStatusStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Success")]
        Success = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Running")]
        Running = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Error")]
        Error = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Pending")]
        Pending = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ValueConstraintExpressionOperator
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INCLUDES")]
        INCLUDES = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXCLUDES")]
        EXCLUDES = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EQUALS")]
        EQUALS = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TnNodeStackSpanStatusVmknic_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESS")]
        SUCCESS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILED")]
        FAILED = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TnNodeStackSpanStatusDedicated_stack_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESS")]
        SUCCESS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILED")]
        FAILED = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBPortMatchMatch_criteria
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IS_IN")]
        IS_IN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IS_NOT_IN")]
        IS_NOT_IN = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PrefixEntryAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PERMIT")]
        PERMIT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DENY")]
        DENY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBWafPSMMatchElementName
    {
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_VARIABLE_ARGS")]
        WAF_VARIABLE_ARGS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_VARIABLE_ARGS_GET")]
        WAF_VARIABLE_ARGS_GET = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_VARIABLE_ARGS_POST")]
        WAF_VARIABLE_ARGS_POST = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_VARIABLE_ARGS_NAMES")]
        WAF_VARIABLE_ARGS_NAMES = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_VARIABLE_REQUEST_COOKIES")]
        WAF_VARIABLE_REQUEST_COOKIES = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_VARIABLE_QUERY_STRING")]
        WAF_VARIABLE_QUERY_STRING = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_VARIABLE_REQUEST_BASENAME")]
        WAF_VARIABLE_REQUEST_BASENAME = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_VARIABLE_REQUEST_URI")]
        WAF_VARIABLE_REQUEST_URI = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAF_VARIABLE_PATH_INFO")]
        WAF_VARIABLE_PATH_INFO = 8,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IdfwTransportNodeConditionStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOT_PREPARED")]
        NOT_PREPARED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IDFW_COMPONENT_NOT_INSTALLED")]
        IDFW_COMPONENT_NOT_INSTALLED = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DFW_DISABLED")]
        DFW_DISABLED = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IDFW_DISABLED")]
        IDFW_DISABLED = 6,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CurrentBackupOperationStatusCurrent_step
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BACKUP_CREATING_CLUSTER_BACKUP")]
        BACKUP_CREATING_CLUSTER_BACKUP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BACKUP_CREATING_NODE_BACKUP")]
        BACKUP_CREATING_NODE_BACKUP = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CurrentBackupOperationStatusOperation_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NONE")]
        NONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BACKUP")]
        BACKUP = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LdapProbeErrorError_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BASE_DN_NOT_FOUND")]
        BASE_DN_NOT_FOUND = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BIND_DN_AND_PASSWORD_REQUIRED")]
        BIND_DN_AND_PASSWORD_REQUIRED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BIND_DN_INVALID")]
        BIND_DN_INVALID = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CERTIFICATE_HOSTNAME_MISMATCH_ERROR")]
        CERTIFICATE_HOSTNAME_MISMATCH_ERROR = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CERTIFICATE_MISMATCH_ERROR")]
        CERTIFICATE_MISMATCH_ERROR = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTION_REFUSED")]
        CONNECTION_REFUSED = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONNECTION_TIMEOUT")]
        CONNECTION_TIMEOUT = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ERROR")]
        GENERAL_ERROR = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_CONFIGURED_CERTIFICATE")]
        INVALID_CONFIGURED_CERTIFICATE = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_CREDENTIALS")]
        INVALID_CREDENTIALS = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_HANDSHAKE_ERROR")]
        SSL_HANDSHAKE_ERROR = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STARTTLS_FAILED")]
        STARTTLS_FAILED = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN_HOST")]
        UNKNOWN_HOST = 12,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyCapacityDashboardUsageUsage_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NUMBER_OF_VSPHERE_CLUSTERS")]
        NUMBER_OF_VSPHERE_CLUSTERS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NUMBER_OF_PREPARED_HOSTS")]
        NUMBER_OF_PREPARED_HOSTS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NUMBER_OF_GROUPS")]
        NUMBER_OF_GROUPS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NUMBER_OF_SEGMENT")]
        NUMBER_OF_SEGMENT = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NUMBER_OF_SEGMENT_PORT")]
        NUMBER_OF_SEGMENT_PORT = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NUMBER_OF_FIREWALL_RULES")]
        NUMBER_OF_FIREWALL_RULES = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NUMBER_OF_FIREWALL_SECTIONS")]
        NUMBER_OF_FIREWALL_SECTIONS = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NUMBER_OF_SECURITY_POLICY_RULES")]
        NUMBER_OF_SECURITY_POLICY_RULES = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NUMBER_OF_SECURITY_POLICY")]
        NUMBER_OF_SECURITY_POLICY = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NUMBER_OF_PROTECTION_ENABLED_HOST")]
        NUMBER_OF_PROTECTION_ENABLED_HOST = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NUMBER_OF_PROTECTION_ENABLED_VIRTUAL_MACHINES")]
        NUMBER_OF_PROTECTION_ENABLED_VIRTUAL_MACHINES = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NUMBER_OF_EDGE_CLUSTERS")]
        NUMBER_OF_EDGE_CLUSTERS = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NUMBER_OF_EDGE_NODES")]
        NUMBER_OF_EDGE_NODES = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NUMBER_OF_TIER0_ROUTERS")]
        NUMBER_OF_TIER0_ROUTERS = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NUMBER_OF_TIER1_ROUTERS")]
        NUMBER_OF_TIER1_ROUTERS = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NUMBER_OF_NAT_RULES")]
        NUMBER_OF_NAT_RULES = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NUMBER_OF_DHCP_IP_POOLS")]
        NUMBER_OF_DHCP_IP_POOLS = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NUMBER_OF_TIER1_WITH_NAT_RULE")]
        NUMBER_OF_TIER1_WITH_NAT_RULE = 17,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ContainerClusterNodeNetwork_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HEALTHY")]
        HEALTHY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNHEALTHY")]
        UNHEALTHY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHTTPSwitchingActionAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_SWITCHING_SELECT_POOL")]
        HTTP_SWITCHING_SELECT_POOL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_SWITCHING_SELECT_LOCAL")]
        HTTP_SWITCHING_SELECT_LOCAL = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_SWITCHING_SELECT_POOLGROUP")]
        HTTP_SWITCHING_SELECT_POOLGROUP = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHTTPSwitchingActionStatus_code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_LOCAL_RESPONSE_STATUS_CODE_200")]
        HTTP_LOCAL_RESPONSE_STATUS_CODE_200 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_LOCAL_RESPONSE_STATUS_CODE_204")]
        HTTP_LOCAL_RESPONSE_STATUS_CODE_204 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_LOCAL_RESPONSE_STATUS_CODE_403")]
        HTTP_LOCAL_RESPONSE_STATUS_CODE_403 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_LOCAL_RESPONSE_STATUS_CODE_404")]
        HTTP_LOCAL_RESPONSE_STATUS_CODE_404 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_LOCAL_RESPONSE_STATUS_CODE_429")]
        HTTP_LOCAL_RESPONSE_STATUS_CODE_429 = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_LOCAL_RESPONSE_STATUS_CODE_501")]
        HTTP_LOCAL_RESPONSE_STATUS_CODE_501 = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CommunityMatchCriteriaMatch_operator
    {
        [System.Runtime.Serialization.EnumMember(Value = @"MATCH_ANY")]
        MATCH_ANY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MATCH_ALL")]
        MATCH_ALL = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MATCH_EXACT")]
        MATCH_EXACT = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MATCH_COMMUNITY_REGEX")]
        MATCH_COMMUNITY_REGEX = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MATCH_LARGE_COMMUNITY_REGEX")]
        MATCH_LARGE_COMMUNITY_REGEX = 4,
    
    }
    
    /// <summary>Intrusion Detection System Profile severity</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Profile_severity
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CRITICAL")]
        CRITICAL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HIGH")]
        HIGH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MEDIUM")]
        MEDIUM = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOW")]
        LOW = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHealthMonitorSIPSip_monitor_transport
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SIP_UDP_PROTO")]
        SIP_UDP_PROTO = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SIP_TCP_PROTO")]
        SIP_TCP_PROTO = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHealthMonitorSIPSip_request_code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SIP_OPTIONS")]
        SIP_OPTIONS = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBWafExclusionTypeMatch_case
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SENSITIVE")]
        SENSITIVE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INSENSITIVE")]
        INSENSITIVE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBWafExclusionTypeMatch_op
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BEGINS_WITH")]
        BEGINS_WITH = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOES_NOT_BEGIN_WITH")]
        DOES_NOT_BEGIN_WITH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONTAINS")]
        CONTAINS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOES_NOT_CONTAIN")]
        DOES_NOT_CONTAIN = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ENDS_WITH")]
        ENDS_WITH = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOES_NOT_END_WITH")]
        DOES_NOT_END_WITH = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EQUALS")]
        EQUALS = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOES_NOT_EQUAL")]
        DOES_NOT_EQUAL = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGEX_MATCH")]
        REGEX_MATCH = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGEX_DOES_NOT_MATCH")]
        REGEX_DOES_NOT_MATCH = 9,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum BgpNeighborConfigGraceful_restart_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DISABLE")]
        DISABLE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GR_AND_HELPER")]
        GR_AND_HELPER = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HELPER_ONLY")]
        HELPER_ONLY = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FileTransferProtocolProtocol_name
    {
        [System.Runtime.Serialization.EnumMember(Value = @"sftp")]
        Sftp = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ConnectivityAdvancedConfigConnectivity
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ON")]
        ON = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OFF")]
        OFF = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LegendPosition
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TOP")]
        TOP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BOTTOM")]
        BOTTOM = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LEFT")]
        LEFT = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RIGHT")]
        RIGHT = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TOP_RIGHT")]
        TOP_RIGHT = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LegendType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CIRCLE")]
        CIRCLE = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LegendAlignment
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HORIZONTAL")]
        HORIZONTAL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VERTICAL")]
        VERTICAL = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum L4PortSetServiceEntryL4_protocol
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TCP")]
        TCP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UDP")]
        UDP = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum L2BridgeEndpointProfileFailover_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PREEMPTIVE")]
        PREEMPTIVE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NON_PREEMPTIVE")]
        NON_PREEMPTIVE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum L2BridgeEndpointProfileHa_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ACTIVE_STANDBY")]
        ACTIVE_STANDBY = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ContainerProjectNetwork_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HEALTHY")]
        HEALTHY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNHEALTHY")]
        UNHEALTHY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum EvpnConfigMode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INLINE")]
        INLINE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ROUTE_SERVER")]
        ROUTE_SERVER = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DISABLE")]
        DISABLE = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBNodeUsageSummarySeverity
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GREEN")]
        GREEN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ORANGE")]
        ORANGE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RED")]
        RED = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBClientCertificateIssuerDnConditionMatch_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"STARTS_WITH")]
        STARTS_WITH = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ENDS_WITH")]
        ENDS_WITH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EQUALS")]
        EQUALS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONTAINS")]
        CONTAINS = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGEX")]
        REGEX = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IdsProfileFilterCriteriaFilter_name
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CVSS")]
        CVSS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ATTACK_TARGET")]
        ATTACK_TARGET = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ATTACK_TYPE")]
        ATTACK_TYPE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PRODUCT_AFFECTED")]
        PRODUCT_AFFECTED = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBSSLVersionType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_VERSION_SSLV3")]
        SSL_VERSION_SSLV3 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_VERSION_TLS1")]
        SSL_VERSION_TLS1 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_VERSION_TLS1_1")]
        SSL_VERSION_TLS1_1 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_VERSION_TLS1_2")]
        SSL_VERSION_TLS1_2 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_VERSION_TLS1_3")]
        SSL_VERSION_TLS1_3 = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBVirtualServiceFlow_dist
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LOAD_AWARE")]
        LOAD_AWARE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONSISTENT_HASH_SOURCE_IP_ADDRESS")]
        CONSISTENT_HASH_SOURCE_IP_ADDRESS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONSISTENT_HASH_SOURCE_IP_ADDRESS_AND_PORT")]
        CONSISTENT_HASH_SOURCE_IP_ADDRESS_AND_PORT = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBVirtualServiceCloud_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CLOUD_NONE")]
        CLOUD_NONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLOUD_VCENTER")]
        CLOUD_VCENTER = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLOUD_OPENSTACK")]
        CLOUD_OPENSTACK = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLOUD_AWS")]
        CLOUD_AWS = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLOUD_VCA")]
        CLOUD_VCA = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLOUD_APIC")]
        CLOUD_APIC = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLOUD_MESOS")]
        CLOUD_MESOS = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLOUD_LINUXSERVER")]
        CLOUD_LINUXSERVER = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLOUD_DOCKER_UCP")]
        CLOUD_DOCKER_UCP = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLOUD_RANCHER")]
        CLOUD_RANCHER = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLOUD_OSHIFT_K8S")]
        CLOUD_OSHIFT_K8S = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLOUD_AZURE")]
        CLOUD_AZURE = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLOUD_GCP")]
        CLOUD_GCP = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLOUD_NSXT")]
        CLOUD_NSXT = 13,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBVirtualServiceActive_standby_se_tag
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ACTIVE_STANDBY_SE_1")]
        ACTIVE_STANDBY_SE_1 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACTIVE_STANDBY_SE_2")]
        ACTIVE_STANDBY_SE_2 = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBVirtualServiceType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"VS_TYPE_NORMAL")]
        VS_TYPE_NORMAL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VS_TYPE_VH_PARENT")]
        VS_TYPE_VH_PARENT = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VS_TYPE_VH_CHILD")]
        VS_TYPE_VH_CHILD = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBVirtualServiceFlow_label_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NO_LABEL")]
        NO_LABEL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"APPLICATION_LABEL")]
        APPLICATION_LABEL = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SERVICE_LABEL")]
        SERVICE_LABEL = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SegmentPortMacTableCsvEntryMac_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"STATIC")]
        STATIC = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LEARNED")]
        LEARNED = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Ipv6DadProfileDad_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LOOSE")]
        LOOSE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STRICT")]
        STRICT = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBIpAddrType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"V4")]
        V4 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DNS")]
        DNS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"V6")]
        V6 = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBHTTPClientAuthenticationParamsType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_BASIC_AUTH")]
        HTTP_BASIC_AUTH = 0,
    
    }
    
    /// <summary>Valid ENUM values for ALBHttpReselectRespCodeBlock</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Resp_code_block2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RSP_4XX")]
        HTTP_RSP_4XX = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RSP_5XX")]
        HTTP_RSP_5XX = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IPSecVpnIkeSessionStatusIke_session_state
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NEGOTIATING")]
        NEGOTIATING = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Permissions
    {
        [System.Runtime.Serialization.EnumMember(Value = @"read-api")]
        ReadApi = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"read-write-api")]
        ReadWriteApi = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"crud")]
        Crud = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"read")]
        Read = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"execute")]
        Execute = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"none")]
        None = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBDnsQueryNameMatchMatch_criteria
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BEGINS_WITH")]
        BEGINS_WITH = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOES_NOT_BEGIN_WITH")]
        DOES_NOT_BEGIN_WITH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONTAINS")]
        CONTAINS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOES_NOT_CONTAIN")]
        DOES_NOT_CONTAIN = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ENDS_WITH")]
        ENDS_WITH = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOES_NOT_END_WITH")]
        DOES_NOT_END_WITH = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EQUALS")]
        EQUALS = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOES_NOT_EQUAL")]
        DOES_NOT_EQUAL = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGEX_MATCH")]
        REGEX_MATCH = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGEX_DOES_NOT_MATCH")]
        REGEX_DOES_NOT_MATCH = 9,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBDsrProfileDsr_encap_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ENCAP_IPINIP")]
        ENCAP_IPINIP = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBDsrProfileDsr_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DSR_TYPE_L2")]
        DSR_TYPE_L2 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DSR_TYPE_L3")]
        DSR_TYPE_L3 = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBFailActionHTTPLocalResponseStatus_code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"FAIL_HTTP_STATUS_CODE_200")]
        FAIL_HTTP_STATUS_CODE_200 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAIL_HTTP_STATUS_CODE_503")]
        FAIL_HTTP_STATUS_CODE_503 = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IdsRuleAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DETECT")]
        DETECT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DETECT_PREVENT")]
        DETECT_PREVENT = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBSSLProfileType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_PROFILE_TYPE_APPLICATION")]
        SSL_PROFILE_TYPE_APPLICATION = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SSL_PROFILE_TYPE_SYSTEM")]
        SSL_PROFILE_TYPE_SYSTEM = 1,
    
    }
    
    /// <summary>Valid ENUM values for ALBAcceptedCipherEnums</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Cipher_enums
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256")]
        TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384")]
        TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256")]
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384")]
        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_128_GCM_SHA256")]
        TLS_RSA_WITH_AES_128_GCM_SHA256 = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_256_GCM_SHA384")]
        TLS_RSA_WITH_AES_256_GCM_SHA384 = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_128_CBC_SHA256")]
        TLS_RSA_WITH_AES_128_CBC_SHA256 = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_256_CBC_SHA256")]
        TLS_RSA_WITH_AES_256_CBC_SHA256 = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA")]
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA")]
        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_128_CBC_SHA")]
        TLS_RSA_WITH_AES_128_CBC_SHA = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_AES_256_CBC_SHA")]
        TLS_RSA_WITH_AES_256_CBC_SHA = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_RSA_WITH_3DES_EDE_CBC_SHA")]
        TLS_RSA_WITH_3DES_EDE_CBC_SHA = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_AES_256_GCM_SHA384")]
        TLS_AES_256_GCM_SHA384 = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_CHACHA20_POLY1305_SHA256")]
        TLS_CHACHA20_POLY1305_SHA256 = 20,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_AES_128_GCM_SHA256")]
        TLS_AES_128_GCM_SHA256 = 21,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBClientSslProfileBindingClient_auth
    {
        [System.Runtime.Serialization.EnumMember(Value = @"REQUIRED")]
        REQUIRED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IGNORE")]
        IGNORE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PerStepRestoreStatusValue
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INITIAL")]
        INITIAL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RUNNING")]
        RUNNING = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUSPENDED_BY_USER")]
        SUSPENDED_BY_USER = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUSPENDED_FOR_USER_ACTION")]
        SUSPENDED_FOR_USER_ACTION = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILED")]
        FAILED = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESS")]
        SUCCESS = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBServiceStatusService_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PARTIALLY_UP")]
        PARTIALLY_UP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_STANDBY")]
        NO_STANDBY = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DETACHED")]
        DETACHED = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DISABLED")]
        DISABLED = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBVipAuto_allocate_ip_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"V4_ONLY")]
        V4_ONLY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"V6_ONLY")]
        V6_ONLY = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"V4_V6")]
        V4_V6 = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IPSecVpnSessionStatusNsxTRuntime_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DEGRADED")]
        DEGRADED = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBRulePhase
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_REQUEST_REWRITE")]
        HTTP_REQUEST_REWRITE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_FORWARDING")]
        HTTP_FORWARDING = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_RESPONSE_REWRITE")]
        HTTP_RESPONSE_REWRITE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HTTP_ACCESS")]
        HTTP_ACCESS = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TRANSPORT")]
        TRANSPORT = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBRuleMatch_strategy
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALL")]
        ALL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ANY")]
        ANY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBStringMatchMatch_criteria
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BEGINS_WITH")]
        BEGINS_WITH = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOES_NOT_BEGIN_WITH")]
        DOES_NOT_BEGIN_WITH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONTAINS")]
        CONTAINS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOES_NOT_CONTAIN")]
        DOES_NOT_CONTAIN = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ENDS_WITH")]
        ENDS_WITH = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOES_NOT_END_WITH")]
        DOES_NOT_END_WITH = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EQUALS")]
        EQUALS = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOES_NOT_EQUAL")]
        DOES_NOT_EQUAL = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGEX_MATCH")]
        REGEX_MATCH = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REGEX_DOES_NOT_MATCH")]
        REGEX_DOES_NOT_MATCH = 9,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBTagType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AVI_DEFINED")]
        AVI_DEFINED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"USER_DEFINED")]
        USER_DEFINED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VCENTER_DEFINED")]
        VCENTER_DEFINED = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBPGDeploymentRuleOperator
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CO_EQ")]
        CO_EQ = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CO_GT")]
        CO_GT = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CO_GE")]
        CO_GE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CO_LT")]
        CO_LT = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CO_LE")]
        CO_LE = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CO_NE")]
        CO_NE = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBHttpProfileX_forwarded_for
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INSERT")]
        INSERT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REPLACE")]
        REPLACE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PortMirroringProfileDirection
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INGRESS")]
        INGRESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EGRESS")]
        EGRESS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BIDIRECTIONAL")]
        BIDIRECTIONAL = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PortMirroringProfileTcp_ip_stack
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Default")]
        Default = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Mirror")]
        Mirror = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PortMirroringProfileProfile_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"REMOTE_L3_SPAN")]
        REMOTE_L3_SPAN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOGICAL_SPAN")]
        LOGICAL_SPAN = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PortMirroringProfileEncapsulation_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GRE")]
        GRE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ERSPAN_TWO")]
        ERSPAN_TWO = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ERSPAN_THREE")]
        ERSPAN_THREE = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SegmentPortMacTableEntryMac_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"STATIC")]
        STATIC = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LEARNED")]
        LEARNED = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ConjunctionOperatorConjunction_operator
    {
        [System.Runtime.Serialization.EnumMember(Value = @"OR")]
        OR = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AND")]
        AND = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ApplicationTierAccess_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Public")]
        Public = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Private")]
        Private = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Shared")]
        Shared = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ApplicationTierSize
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ONE")]
        ONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XXS")]
        XXS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XS")]
        XS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"S")]
        S = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"M")]
        M = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"L")]
        L = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XL")]
        XL = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XXL")]
        XXL = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XXXL")]
        XXXL = 8,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum DnsHeaderAddress_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"V4")]
        V4 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"V6")]
        V6 = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum DnsHeaderMessage_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"QUERY")]
        QUERY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RESPONSE")]
        RESPONSE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ContainerClusterNetwork_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"HEALTHY")]
        HEALTHY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNHEALTHY")]
        UNHEALTHY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ContainerClusterCluster_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PAS")]
        PAS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PKS")]
        PKS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Kubernetes")]
        Kubernetes = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Openshift")]
        Openshift = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WCP")]
        WCP = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WCP_Guest")]
        WCP_Guest = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 6,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBSensitiveFieldRuleAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LOG_FIELD_REMOVE")]
        LOG_FIELD_REMOVE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOG_FIELD_MASKOFF")]
        LOG_FIELD_MASKOFF = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CountActionArgumentCount_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALL")]
        ALL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INTERFACE_ONLY")]
        INTERFACE_ONLY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum L3VpnRuleAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PROTECT")]
        PROTECT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BYPASS")]
        BYPASS = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum NsxTDNSForwarderStatusStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NO_BACKUP")]
        NO_BACKUP = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum L2VPNSessionStatusNsxTRuntime_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IdentitySourceLdapServerProbeResultResult
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESS")]
        SUCCESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILURE")]
        FAILURE = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum RealizedLogicalPortStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 2,
    
    }
    
    /// <summary>Tier-0 route redistribution types.
    /// 
    ///   TIER0_STATIC: Redistribute user added static routes.
    ///   TIER0_CONNECTED: Redistribute all subnets configured on Interfaces and
    ///   routes related to TIER0_ROUTER_LINK, TIER0_SEGMENT,
    ///   TIER0_DNS_FORWARDER_IP, TIER0_IPSEC_LOCAL_IP, TIER0_NAT types.
    ///   TIER1_STATIC: Redistribute all subnets and static routes advertised
    ///   by Tier-1s.
    ///   TIER0_EXTERNAL_INTERFACE: Redistribute external interface subnets
    ///   on Tier-0.
    ///   TIER0_LOOPBACK_INTERFACE: Redistribute loopback interface subnets
    ///   on Tier-0.
    ///   TIER0_SEGMENT: Redistribute subnets configured on Segments connected
    ///   to Tier-0.
    ///   TIER0_ROUTER_LINK: Redistribute router link port subnets on Tier-0
    ///   TIER0_SERVICE_INTERFACE: Redistribute Tier0 service interface subnets.
    ///   TIER0_DNS_FORWARDER_IP: Redistribute DNS forwarder subnets.
    ///   TIER0_IPSEC_LOCAL_IP: Redistribute IPSec subnets.
    ///   TIER0_NAT: Redistribute NAT IPs owned by Tier-0.
    ///   TIER0_EVPN_TEP_IP: Redistribute EVPN local endpoint subnets on Tier-0.
    ///   TIER1_NAT: Redistribute NAT IPs advertised by Tier-1 instances.
    ///   TIER1_LB_VIP: Redistribute LB VIP IPs advertised by Tier-1 instances.
    ///   TIER1_LB_SNAT: Redistribute LB SNAT IPs advertised by Tier-1 instances.
    ///   TIER1_DNS_FORWARDER_IP: Redistribute DNS forwarder subnets on Tier-1
    ///   instances.
    ///   TIER1_CONNECTED: Redistribute all subnets configured on Segments and
    ///   Service Interfaces.
    ///   TIER1_SERVICE_INTERFACE: Redistribute Tier1 service interface subnets.
    ///   TIER1_SEGMENT: Redistribute subnets configured on Segments connected
    ///   to Tier1.
    ///   TIER1_IPSEC_LOCAL_ENDPOINT: Redistribute IPSec VPN local-endpoint
    ///   subnets advertised by TIER1.
    /// 
    /// 
    ///   Route redistribution destination is BGP.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Route_redistribution_types2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_STATIC")]
        TIER0_STATIC = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_CONNECTED")]
        TIER0_CONNECTED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_EXTERNAL_INTERFACE")]
        TIER0_EXTERNAL_INTERFACE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_SEGMENT")]
        TIER0_SEGMENT = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_ROUTER_LINK")]
        TIER0_ROUTER_LINK = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_SERVICE_INTERFACE")]
        TIER0_SERVICE_INTERFACE = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_LOOPBACK_INTERFACE")]
        TIER0_LOOPBACK_INTERFACE = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_DNS_FORWARDER_IP")]
        TIER0_DNS_FORWARDER_IP = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_IPSEC_LOCAL_IP")]
        TIER0_IPSEC_LOCAL_IP = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_NAT")]
        TIER0_NAT = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER0_EVPN_TEP_IP")]
        TIER0_EVPN_TEP_IP = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_NAT")]
        TIER1_NAT = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_STATIC")]
        TIER1_STATIC = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_LB_VIP")]
        TIER1_LB_VIP = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_LB_SNAT")]
        TIER1_LB_SNAT = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_DNS_FORWARDER_IP")]
        TIER1_DNS_FORWARDER_IP = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_CONNECTED")]
        TIER1_CONNECTED = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_SERVICE_INTERFACE")]
        TIER1_SERVICE_INTERFACE = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_SEGMENT")]
        TIER1_SEGMENT = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TIER1_IPSEC_LOCAL_ENDPOINT")]
        TIER1_IPSEC_LOCAL_ENDPOINT = 19,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum MirrorStackStatusListResultOverall_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESS")]
        SUCCESS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILED")]
        FAILED = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicyEdgeClusterInterSiteStatusOverall_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DEGRADED")]
        DEGRADED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Tier0InterfaceUrpf_mode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NONE")]
        NONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STRICT")]
        STRICT = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Tier0InterfaceType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"EXTERNAL")]
        EXTERNAL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SERVICE")]
        SERVICE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOOPBACK")]
        LOOPBACK = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum QoSDscpMode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TRUSTED")]
        TRUSTED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNTRUSTED")]
        UNTRUSTED = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ConditionOperator
    {
        [System.Runtime.Serialization.EnumMember(Value = @"EQUALS")]
        EQUALS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CONTAINS")]
        CONTAINS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STARTSWITH")]
        STARTSWITH = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ENDSWITH")]
        ENDSWITH = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOTEQUALS")]
        NOTEQUALS = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ConditionKey
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Tag")]
        Tag = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Name")]
        Name = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OSName")]
        OSName = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ComputerName")]
        ComputerName = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ConditionMember_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IPSet")]
        IPSet = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VirtualMachine")]
        VirtualMachine = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LogicalPort")]
        LogicalPort = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LogicalSwitch")]
        LogicalSwitch = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Segment")]
        Segment = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SegmentPort")]
        SegmentPort = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FieldSanityConstraintExpressionOperator
    {
        [System.Runtime.Serialization.EnumMember(Value = @"OR")]
        OR = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AND")]
        AND = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Checks
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALL_PUBLIC_IPS")]
        ALL_PUBLIC_IPS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ALL_PRIVATE_IPS")]
        ALL_PRIVATE_IPS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ALL_IPV6_CIDRS")]
        ALL_IPV6_CIDRS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ALL_IPV6_IPS")]
        ALL_IPV6_IPS = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ALL_IPV4_CIDRS")]
        ALL_IPV4_CIDRS = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ALL_IPV4_IPS")]
        ALL_IPV4_IPS = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LBVirtualServerStatusStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PARTIALLY_UP")]
        PARTIALLY_UP = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PRIMARY_DOWN")]
        PRIMARY_DOWN = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DETACHED")]
        DETACHED = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DISABLED")]
        DISABLED = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 6,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum BatchRequestItemMethod
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GET")]
        GET = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"POST")]
        POST = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PUT")]
        PUT = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DELETE")]
        DELETE = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PATCH")]
        PATCH = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicySubAttributesDatatype
    {
        [System.Runtime.Serialization.EnumMember(Value = @"STRING")]
        STRING = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PolicySubAttributesKey
    {
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_CIPHER_SUITE")]
        TLS_CIPHER_SUITE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLS_VERSION")]
        TLS_VERSION = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CIFS_SMB_VERSION")]
        CIFS_SMB_VERSION = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum IpSecVpnTunnelTrafficStatisticsTunnel_status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ALBMicroServiceMatchMatch_criteria
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IS_IN")]
        IS_IN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IS_NOT_IN")]
        IS_NOT_IN = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum GatewayQosProfileExcess_action
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DROP")]
        DROP = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    [System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = true)]
    internal class JsonInheritanceAttribute : System.Attribute
    {
        public JsonInheritanceAttribute(string key, System.Type type)
        {
            Key = key;
            Type = type;
        }
    
        public string Key { get; }
    
        public System.Type Type { get; }
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.22.0 (Newtonsoft.Json v11.0.0.0)")]
    internal class JsonInheritanceConverter : Newtonsoft.Json.JsonConverter
    {
        internal static readonly string DefaultDiscriminatorName = "discriminator";
    
        private readonly string _discriminator;
    
        [System.ThreadStatic]
        private static bool _isReading;
    
        [System.ThreadStatic]
        private static bool _isWriting;
    
        public JsonInheritanceConverter()
        {
            _discriminator = DefaultDiscriminatorName;
        }
    
        public JsonInheritanceConverter(string discriminator)
        {
            _discriminator = discriminator;
        }
    
        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object value, Newtonsoft.Json.JsonSerializer serializer)
        {
            try
            {
                _isWriting = true;
    
                var jObject = Newtonsoft.Json.Linq.JObject.FromObject(value, serializer);
                jObject.AddFirst(new Newtonsoft.Json.Linq.JProperty(_discriminator, GetSubtypeDiscriminator(value.GetType())));
                writer.WriteToken(jObject.CreateReader());
            }
            finally
            {
                _isWriting = false;
            }
        }
    
        public override bool CanWrite
        {
            get
            {
                if (_isWriting)
                {
                    _isWriting = false;
                    return false;
                }
                return true;
            }
        }
    
        public override bool CanRead
        {
            get
            {
                if (_isReading)
                {
                    _isReading = false;
                    return false;
                }
                return true;
            }
        }
    
        public override bool CanConvert(System.Type objectType)
        {
            return true;
        }
    
        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, object existingValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            var jObject = serializer.Deserialize<Newtonsoft.Json.Linq.JObject>(reader);
            if (jObject == null)
                return null;
    
            var discriminator = Newtonsoft.Json.Linq.Extensions.Value<string>(jObject.GetValue(_discriminator));
            var subtype = GetObjectSubtype(objectType, discriminator);
           
            var objectContract = serializer.ContractResolver.ResolveContract(subtype) as Newtonsoft.Json.Serialization.JsonObjectContract;
            if (objectContract == null || System.Linq.Enumerable.All(objectContract.Properties, p => p.PropertyName != _discriminator))
            {
                jObject.Remove(_discriminator);
            }
    
            try
            {
                _isReading = true;
                return serializer.Deserialize(jObject.CreateReader(), subtype);
            }
            finally
            {
                _isReading = false;
            }
        }
    
        private System.Type GetObjectSubtype(System.Type objectType, string discriminator)
        {
            foreach (var attribute in System.Reflection.CustomAttributeExtensions.GetCustomAttributes<JsonInheritanceAttribute>(System.Reflection.IntrospectionExtensions.GetTypeInfo(objectType), true))
            {
                if (attribute.Key == discriminator)
                    return attribute.Type;
            }
    
            return objectType;
        }
    
        private string GetSubtypeDiscriminator(System.Type objectType)
        {
            foreach (var attribute in System.Reflection.CustomAttributeExtensions.GetCustomAttributes<JsonInheritanceAttribute>(System.Reflection.IntrospectionExtensions.GetTypeInfo(objectType), true))
            {
                if (attribute.Type == objectType)
                    return attribute.Key;
            }
    
            return objectType.Name;
        }
    }

    public partial class FileResponse : System.IDisposable
    {
        private System.IDisposable _client; 
        private System.IDisposable _response; 

        public int StatusCode { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public System.IO.Stream Stream { get; private set; }

        public bool IsPartial
        {
            get { return StatusCode == 206; }
        }

        public FileResponse(int statusCode, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.IO.Stream stream, System.IDisposable client, System.IDisposable response)
        {
            StatusCode = statusCode; 
            Headers = headers; 
            Stream = stream; 
            _client = client; 
            _response = response;
        }

        public void Dispose() 
        {
            if (Stream != null)
                Stream.Dispose();
            if (_response != null)
                _response.Dispose();
            if (_client != null)
                _client.Dispose();
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.0.5.0 (NJsonSchema v10.0.22.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException) 
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + response.Substring(0, response.Length >= 512 ? 512 : response.Length), innerException)
        {
            StatusCode = statusCode;
            Response = response; 
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.0.5.0 (NJsonSchema v10.0.22.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException) 
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108